import "./../box2d.wasm.js";
// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// file-map:scripts/c3runtime.js
var require_c3runtime = __commonJS({
  "file-map:scripts/c3runtime.js"(exports, module) {
    {
      let setMatrixArrayType2 = function(t) {
        ARRAY_TYPE = t;
      }, toRadian2 = function(t) {
        return t * degree;
      }, equals$92 = function(t, a2) {
        return Math.abs(t - a2) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a2));
      }, create$82 = function() {
        var t = new ARRAY_TYPE(4);
        return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;
      }, clone$82 = function(t) {
        var a2 = new ARRAY_TYPE(4);
        return a2[0] = t[0], a2[1] = t[1], a2[2] = t[2], a2[3] = t[3], a2;
      }, copy$82 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t[2] = a2[2], t[3] = a2[3], t;
      }, identity$52 = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;
      }, fromValues$82 = function(t, a2, r2, n) {
        var e = new ARRAY_TYPE(4);
        return e[0] = t, e[1] = a2, e[2] = r2, e[3] = n, e;
      }, set$82 = function(t, a2, r2, n, e) {
        return t[0] = a2, t[1] = r2, t[2] = n, t[3] = e, t;
      }, transpose$22 = function(t, a2) {
        if (t === a2) {
          var r2 = a2[1];
          t[1] = a2[2], t[2] = r2;
        } else t[0] = a2[0], t[1] = a2[2], t[2] = a2[1], t[3] = a2[3];
        return t;
      }, invert$52 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = r2 * o2 - e * n;
        return u ? (u = 1 / u, t[0] = o2 * u, t[1] = -n * u, t[2] = -e * u, t[3] = r2 * u, t) : null;
      }, adjoint$22 = function(t, a2) {
        var r2 = a2[0];
        return t[0] = a2[3], t[1] = -a2[1], t[2] = -a2[2], t[3] = r2, t;
      }, determinant$32 = function(t) {
        return t[0] * t[3] - t[2] * t[1];
      }, multiply$82 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = r2[0], i2 = r2[1], c2 = r2[2], l2 = r2[3];
        return t[0] = n * s2 + o2 * i2, t[1] = e * s2 + u * i2, t[2] = n * c2 + o2 * l2, t[3] = e * c2 + u * l2, t;
      }, rotate$42 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = Math.sin(r2), i2 = Math.cos(r2);
        return t[0] = n * i2 + o2 * s2, t[1] = e * i2 + u * s2, t[2] = n * -s2 + o2 * i2, t[3] = e * -s2 + u * i2, t;
      }, scale$82 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = r2[0], i2 = r2[1];
        return t[0] = n * s2, t[1] = e * s2, t[2] = o2 * i2, t[3] = u * i2, t;
      }, fromRotation$42 = function(t, a2) {
        var r2 = Math.sin(a2), n = Math.cos(a2);
        return t[0] = n, t[1] = r2, t[2] = -r2, t[3] = n, t;
      }, fromScaling$32 = function(t, a2) {
        return t[0] = a2[0], t[1] = 0, t[2] = 0, t[3] = a2[1], t;
      }, str$82 = function(t) {
        return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
      }, frob$32 = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3]);
      }, LDU2 = function(t, a2, r2, n) {
        return t[2] = n[2] / n[0], r2[0] = n[0], r2[1] = n[1], r2[3] = n[3] - t[2] * r2[1], [t, a2, r2];
      }, add$82 = function(t, a2, r2) {
        return t[0] = a2[0] + r2[0], t[1] = a2[1] + r2[1], t[2] = a2[2] + r2[2], t[3] = a2[3] + r2[3], t;
      }, subtract$62 = function(t, a2, r2) {
        return t[0] = a2[0] - r2[0], t[1] = a2[1] - r2[1], t[2] = a2[2] - r2[2], t[3] = a2[3] - r2[3], t;
      }, exactEquals$82 = function(t, a2) {
        return t[0] === a2[0] && t[1] === a2[1] && t[2] === a2[2] && t[3] === a2[3];
      }, equals$82 = function(t, a2) {
        var r2 = t[0], n = t[1], e = t[2], o2 = t[3], u = a2[0], s2 = a2[1], i2 = a2[2], c2 = a2[3];
        return Math.abs(r2 - u) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(u)) && Math.abs(n - s2) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(s2)) && Math.abs(e - i2) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(i2)) && Math.abs(o2 - c2) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs(c2));
      }, multiplyScalar$32 = function(t, a2, r2) {
        return t[0] = a2[0] * r2, t[1] = a2[1] * r2, t[2] = a2[2] * r2, t[3] = a2[3] * r2, t;
      }, multiplyScalarAndAdd$32 = function(t, a2, r2, n) {
        return t[0] = a2[0] + r2[0] * n, t[1] = a2[1] + r2[1] * n, t[2] = a2[2] + r2[2] * n, t[3] = a2[3] + r2[3] * n, t;
      }, create$72 = function() {
        var t = new ARRAY_TYPE(6);
        return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, t[3] = 1, t;
      }, clone$72 = function(t) {
        var a2 = new ARRAY_TYPE(6);
        return a2[0] = t[0], a2[1] = t[1], a2[2] = t[2], a2[3] = t[3], a2[4] = t[4], a2[5] = t[5], a2;
      }, copy$72 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t[2] = a2[2], t[3] = a2[3], t[4] = a2[4], t[5] = a2[5], t;
      }, identity$42 = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
      }, fromValues$72 = function(t, a2, r2, n, e, o2) {
        var u = new ARRAY_TYPE(6);
        return u[0] = t, u[1] = a2, u[2] = r2, u[3] = n, u[4] = e, u[5] = o2, u;
      }, set$72 = function(t, a2, r2, n, e, o2, u) {
        return t[0] = a2, t[1] = r2, t[2] = n, t[3] = e, t[4] = o2, t[5] = u, t;
      }, invert$42 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = a2[4], s2 = a2[5], i2 = r2 * o2 - n * e;
        return i2 ? (i2 = 1 / i2, t[0] = o2 * i2, t[1] = -n * i2, t[2] = -e * i2, t[3] = r2 * i2, t[4] = (e * s2 - o2 * u) * i2, t[5] = (n * u - r2 * s2) * i2, t) : null;
      }, determinant$22 = function(t) {
        return t[0] * t[3] - t[1] * t[2];
      }, multiply$72 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = r2[0], l2 = r2[1], $ = r2[2], h = r2[3], f2 = r2[4], M = r2[5];
        return t[0] = n * c2 + o2 * l2, t[1] = e * c2 + u * l2, t[2] = n * $ + o2 * h, t[3] = e * $ + u * h, t[4] = n * f2 + o2 * M + s2, t[5] = e * f2 + u * M + i2, t;
      }, rotate$32 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = Math.sin(r2), l2 = Math.cos(r2);
        return t[0] = n * l2 + o2 * c2, t[1] = e * l2 + u * c2, t[2] = n * -c2 + o2 * l2, t[3] = e * -c2 + u * l2, t[4] = s2, t[5] = i2, t;
      }, scale$72 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = r2[0], l2 = r2[1];
        return t[0] = n * c2, t[1] = e * c2, t[2] = o2 * l2, t[3] = u * l2, t[4] = s2, t[5] = i2, t;
      }, translate$32 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = r2[0], l2 = r2[1];
        return t[0] = n, t[1] = e, t[2] = o2, t[3] = u, t[4] = n * c2 + o2 * l2 + s2, t[5] = e * c2 + u * l2 + i2, t;
      }, fromRotation$32 = function(t, a2) {
        var r2 = Math.sin(a2), n = Math.cos(a2);
        return t[0] = n, t[1] = r2, t[2] = -r2, t[3] = n, t[4] = 0, t[5] = 0, t;
      }, fromScaling$22 = function(t, a2) {
        return t[0] = a2[0], t[1] = 0, t[2] = 0, t[3] = a2[1], t[4] = 0, t[5] = 0, t;
      }, fromTranslation$32 = function(t, a2) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = a2[0], t[5] = a2[1], t;
      }, str$72 = function(t) {
        return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")";
      }, frob$22 = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);
      }, add$72 = function(t, a2, r2) {
        return t[0] = a2[0] + r2[0], t[1] = a2[1] + r2[1], t[2] = a2[2] + r2[2], t[3] = a2[3] + r2[3], t[4] = a2[4] + r2[4], t[5] = a2[5] + r2[5], t;
      }, subtract$52 = function(t, a2, r2) {
        return t[0] = a2[0] - r2[0], t[1] = a2[1] - r2[1], t[2] = a2[2] - r2[2], t[3] = a2[3] - r2[3], t[4] = a2[4] - r2[4], t[5] = a2[5] - r2[5], t;
      }, multiplyScalar$22 = function(t, a2, r2) {
        return t[0] = a2[0] * r2, t[1] = a2[1] * r2, t[2] = a2[2] * r2, t[3] = a2[3] * r2, t[4] = a2[4] * r2, t[5] = a2[5] * r2, t;
      }, multiplyScalarAndAdd$22 = function(t, a2, r2, n) {
        return t[0] = a2[0] + r2[0] * n, t[1] = a2[1] + r2[1] * n, t[2] = a2[2] + r2[2] * n, t[3] = a2[3] + r2[3] * n, t[4] = a2[4] + r2[4] * n, t[5] = a2[5] + r2[5] * n, t;
      }, exactEquals$72 = function(t, a2) {
        return t[0] === a2[0] && t[1] === a2[1] && t[2] === a2[2] && t[3] === a2[3] && t[4] === a2[4] && t[5] === a2[5];
      }, equals$72 = function(t, a2) {
        var r2 = t[0], n = t[1], e = t[2], o2 = t[3], u = t[4], s2 = t[5], i2 = a2[0], c2 = a2[1], l2 = a2[2], $ = a2[3], h = a2[4], f2 = a2[5];
        return Math.abs(r2 - i2) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(i2)) && Math.abs(n - c2) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(c2)) && Math.abs(e - l2) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(l2)) && Math.abs(o2 - $) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs($)) && Math.abs(u - h) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(h)) && Math.abs(s2 - f2) <= EPSILON * Math.max(1, Math.abs(s2), Math.abs(f2));
      }, create$62 = function() {
        var t = new ARRAY_TYPE(9);
        return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
      }, fromMat4$12 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t[2] = a2[2], t[3] = a2[4], t[4] = a2[5], t[5] = a2[6], t[6] = a2[8], t[7] = a2[9], t[8] = a2[10], t;
      }, clone$62 = function(t) {
        var a2 = new ARRAY_TYPE(9);
        return a2[0] = t[0], a2[1] = t[1], a2[2] = t[2], a2[3] = t[3], a2[4] = t[4], a2[5] = t[5], a2[6] = t[6], a2[7] = t[7], a2[8] = t[8], a2;
      }, copy$62 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t[2] = a2[2], t[3] = a2[3], t[4] = a2[4], t[5] = a2[5], t[6] = a2[6], t[7] = a2[7], t[8] = a2[8], t;
      }, fromValues$62 = function(t, a2, r2, n, e, o2, u, s2, i2) {
        var c2 = new ARRAY_TYPE(9);
        return c2[0] = t, c2[1] = a2, c2[2] = r2, c2[3] = n, c2[4] = e, c2[5] = o2, c2[6] = u, c2[7] = s2, c2[8] = i2, c2;
      }, set$62 = function(t, a2, r2, n, e, o2, u, s2, i2, c2) {
        return t[0] = a2, t[1] = r2, t[2] = n, t[3] = e, t[4] = o2, t[5] = u, t[6] = s2, t[7] = i2, t[8] = c2, t;
      }, identity$32 = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
      }, transpose$12 = function(t, a2) {
        if (t === a2) {
          var r2 = a2[1], n = a2[2], e = a2[5];
          t[1] = a2[3], t[2] = a2[6], t[3] = r2, t[5] = a2[7], t[6] = n, t[7] = e;
        } else t[0] = a2[0], t[1] = a2[3], t[2] = a2[6], t[3] = a2[1], t[4] = a2[4], t[5] = a2[7], t[6] = a2[2], t[7] = a2[5], t[8] = a2[8];
        return t;
      }, invert$32 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = a2[4], s2 = a2[5], i2 = a2[6], c2 = a2[7], l2 = a2[8], $ = l2 * u - s2 * c2, h = -l2 * o2 + s2 * i2, f2 = c2 * o2 - u * i2, M = r2 * $ + n * h + e * f2;
        return M ? (M = 1 / M, t[0] = $ * M, t[1] = (-l2 * n + e * c2) * M, t[2] = (s2 * n - e * u) * M, t[3] = h * M, t[4] = (l2 * r2 - e * i2) * M, t[5] = (-s2 * r2 + e * o2) * M, t[6] = f2 * M, t[7] = (-c2 * r2 + n * i2) * M, t[8] = (u * r2 - n * o2) * M, t) : null;
      }, adjoint$12 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = a2[4], s2 = a2[5], i2 = a2[6], c2 = a2[7], l2 = a2[8];
        return t[0] = u * l2 - s2 * c2, t[1] = e * c2 - n * l2, t[2] = n * s2 - e * u, t[3] = s2 * i2 - o2 * l2, t[4] = r2 * l2 - e * i2, t[5] = e * o2 - r2 * s2, t[6] = o2 * c2 - u * i2, t[7] = n * i2 - r2 * c2, t[8] = r2 * u - n * o2, t;
      }, determinant$12 = function(t) {
        var a2 = t[0], r2 = t[1], n = t[2], e = t[3], o2 = t[4], u = t[5], s2 = t[6], i2 = t[7], c2 = t[8];
        return a2 * (c2 * o2 - u * i2) + r2 * (-c2 * e + u * s2) + n * (i2 * e - o2 * s2);
      }, multiply$62 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], $ = a2[8], h = r2[0], f2 = r2[1], M = r2[2], m = r2[3], d2 = r2[4], v = r2[5], b = r2[6], p = r2[7], A = r2[8];
        return t[0] = h * n + f2 * u + M * c2, t[1] = h * e + f2 * s2 + M * l2, t[2] = h * o2 + f2 * i2 + M * $, t[3] = m * n + d2 * u + v * c2, t[4] = m * e + d2 * s2 + v * l2, t[5] = m * o2 + d2 * i2 + v * $, t[6] = b * n + p * u + A * c2, t[7] = b * e + p * s2 + A * l2, t[8] = b * o2 + p * i2 + A * $, t;
      }, translate$22 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], $ = a2[8], h = r2[0], f2 = r2[1];
        return t[0] = n, t[1] = e, t[2] = o2, t[3] = u, t[4] = s2, t[5] = i2, t[6] = h * n + f2 * u + c2, t[7] = h * e + f2 * s2 + l2, t[8] = h * o2 + f2 * i2 + $, t;
      }, rotate$22 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], $ = a2[8], h = Math.sin(r2), f2 = Math.cos(r2);
        return t[0] = f2 * n + h * u, t[1] = f2 * e + h * s2, t[2] = f2 * o2 + h * i2, t[3] = f2 * u - h * n, t[4] = f2 * s2 - h * e, t[5] = f2 * i2 - h * o2, t[6] = c2, t[7] = l2, t[8] = $, t;
      }, scale$62 = function(t, a2, r2) {
        var n = r2[0], e = r2[1];
        return t[0] = n * a2[0], t[1] = n * a2[1], t[2] = n * a2[2], t[3] = e * a2[3], t[4] = e * a2[4], t[5] = e * a2[5], t[6] = a2[6], t[7] = a2[7], t[8] = a2[8], t;
      }, fromTranslation$22 = function(t, a2) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = a2[0], t[7] = a2[1], t[8] = 1, t;
      }, fromRotation$22 = function(t, a2) {
        var r2 = Math.sin(a2), n = Math.cos(a2);
        return t[0] = n, t[1] = r2, t[2] = 0, t[3] = -r2, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
      }, fromScaling$12 = function(t, a2) {
        return t[0] = a2[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = a2[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
      }, fromMat2d2 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t[2] = 0, t[3] = a2[2], t[4] = a2[3], t[5] = 0, t[6] = a2[4], t[7] = a2[5], t[8] = 1, t;
      }, fromQuat$12 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = r2 + r2, s2 = n + n, i2 = e + e, c2 = r2 * u, l2 = n * u, $ = n * s2, h = e * u, f2 = e * s2, M = e * i2, m = o2 * u, d2 = o2 * s2, v = o2 * i2;
        return t[0] = 1 - $ - M, t[3] = l2 - v, t[6] = h + d2, t[1] = l2 + v, t[4] = 1 - c2 - M, t[7] = f2 - m, t[2] = h - d2, t[5] = f2 + m, t[8] = 1 - c2 - $, t;
      }, normalFromMat42 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = a2[4], s2 = a2[5], i2 = a2[6], c2 = a2[7], l2 = a2[8], $ = a2[9], h = a2[10], f2 = a2[11], M = a2[12], m = a2[13], d2 = a2[14], v = a2[15], b = r2 * s2 - n * u, p = r2 * i2 - e * u, A = r2 * c2 - o2 * u, y = n * i2 - e * s2, g = n * c2 - o2 * s2, R = e * c2 - o2 * i2, E = l2 * m - $ * M, q = l2 * d2 - h * M, x = l2 * v - f2 * M, P = $ * d2 - h * m, L = $ * v - f2 * m, O = h * v - f2 * d2, S = b * O - p * L + A * P + y * x - g * q + R * E;
        return S ? (S = 1 / S, t[0] = (s2 * O - i2 * L + c2 * P) * S, t[1] = (i2 * x - u * O - c2 * q) * S, t[2] = (u * L - s2 * x + c2 * E) * S, t[3] = (e * L - n * O - o2 * P) * S, t[4] = (r2 * O - e * x + o2 * q) * S, t[5] = (n * x - r2 * L - o2 * E) * S, t[6] = (m * R - d2 * g + v * y) * S, t[7] = (d2 * A - M * R - v * p) * S, t[8] = (M * g - m * A + v * b) * S, t) : null;
      }, projection2 = function(t, a2, r2) {
        return t[0] = 2 / a2, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r2, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
      }, str$62 = function(t) {
        return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
      }, frob$12 = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
      }, add$62 = function(t, a2, r2) {
        return t[0] = a2[0] + r2[0], t[1] = a2[1] + r2[1], t[2] = a2[2] + r2[2], t[3] = a2[3] + r2[3], t[4] = a2[4] + r2[4], t[5] = a2[5] + r2[5], t[6] = a2[6] + r2[6], t[7] = a2[7] + r2[7], t[8] = a2[8] + r2[8], t;
      }, subtract$42 = function(t, a2, r2) {
        return t[0] = a2[0] - r2[0], t[1] = a2[1] - r2[1], t[2] = a2[2] - r2[2], t[3] = a2[3] - r2[3], t[4] = a2[4] - r2[4], t[5] = a2[5] - r2[5], t[6] = a2[6] - r2[6], t[7] = a2[7] - r2[7], t[8] = a2[8] - r2[8], t;
      }, multiplyScalar$12 = function(t, a2, r2) {
        return t[0] = a2[0] * r2, t[1] = a2[1] * r2, t[2] = a2[2] * r2, t[3] = a2[3] * r2, t[4] = a2[4] * r2, t[5] = a2[5] * r2, t[6] = a2[6] * r2, t[7] = a2[7] * r2, t[8] = a2[8] * r2, t;
      }, multiplyScalarAndAdd$12 = function(t, a2, r2, n) {
        return t[0] = a2[0] + r2[0] * n, t[1] = a2[1] + r2[1] * n, t[2] = a2[2] + r2[2] * n, t[3] = a2[3] + r2[3] * n, t[4] = a2[4] + r2[4] * n, t[5] = a2[5] + r2[5] * n, t[6] = a2[6] + r2[6] * n, t[7] = a2[7] + r2[7] * n, t[8] = a2[8] + r2[8] * n, t;
      }, exactEquals$62 = function(t, a2) {
        return t[0] === a2[0] && t[1] === a2[1] && t[2] === a2[2] && t[3] === a2[3] && t[4] === a2[4] && t[5] === a2[5] && t[6] === a2[6] && t[7] === a2[7] && t[8] === a2[8];
      }, equals$62 = function(t, a2) {
        var r2 = t[0], n = t[1], e = t[2], o2 = t[3], u = t[4], s2 = t[5], i2 = t[6], c2 = t[7], l2 = t[8], $ = a2[0], h = a2[1], f2 = a2[2], M = a2[3], m = a2[4], d2 = a2[5], v = a2[6], b = a2[7], p = a2[8];
        return Math.abs(r2 - $) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs($)) && Math.abs(n - h) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(e - f2) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(f2)) && Math.abs(o2 - M) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs(M)) && Math.abs(u - m) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(m)) && Math.abs(s2 - d2) <= EPSILON * Math.max(1, Math.abs(s2), Math.abs(d2)) && Math.abs(i2 - v) <= EPSILON * Math.max(1, Math.abs(i2), Math.abs(v)) && Math.abs(c2 - b) <= EPSILON * Math.max(1, Math.abs(c2), Math.abs(b)) && Math.abs(l2 - p) <= EPSILON * Math.max(1, Math.abs(l2), Math.abs(p));
      }, create$52 = function() {
        var t = new ARRAY_TYPE(16);
        return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
      }, clone$52 = function(t) {
        var a2 = new ARRAY_TYPE(16);
        return a2[0] = t[0], a2[1] = t[1], a2[2] = t[2], a2[3] = t[3], a2[4] = t[4], a2[5] = t[5], a2[6] = t[6], a2[7] = t[7], a2[8] = t[8], a2[9] = t[9], a2[10] = t[10], a2[11] = t[11], a2[12] = t[12], a2[13] = t[13], a2[14] = t[14], a2[15] = t[15], a2;
      }, copy$52 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t[2] = a2[2], t[3] = a2[3], t[4] = a2[4], t[5] = a2[5], t[6] = a2[6], t[7] = a2[7], t[8] = a2[8], t[9] = a2[9], t[10] = a2[10], t[11] = a2[11], t[12] = a2[12], t[13] = a2[13], t[14] = a2[14], t[15] = a2[15], t;
      }, fromValues$52 = function(t, a2, r2, n, e, o2, u, s2, i2, c2, l2, $, h, f2, M, m) {
        var d2 = new ARRAY_TYPE(16);
        return d2[0] = t, d2[1] = a2, d2[2] = r2, d2[3] = n, d2[4] = e, d2[5] = o2, d2[6] = u, d2[7] = s2, d2[8] = i2, d2[9] = c2, d2[10] = l2, d2[11] = $, d2[12] = h, d2[13] = f2, d2[14] = M, d2[15] = m, d2;
      }, set$52 = function(t, a2, r2, n, e, o2, u, s2, i2, c2, l2, $, h, f2, M, m, d2) {
        return t[0] = a2, t[1] = r2, t[2] = n, t[3] = e, t[4] = o2, t[5] = u, t[6] = s2, t[7] = i2, t[8] = c2, t[9] = l2, t[10] = $, t[11] = h, t[12] = f2, t[13] = M, t[14] = m, t[15] = d2, t;
      }, identity$22 = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, transpose2 = function(t, a2) {
        if (t === a2) {
          var r2 = a2[1], n = a2[2], e = a2[3], o2 = a2[6], u = a2[7], s2 = a2[11];
          t[1] = a2[4], t[2] = a2[8], t[3] = a2[12], t[4] = r2, t[6] = a2[9], t[7] = a2[13], t[8] = n, t[9] = o2, t[11] = a2[14], t[12] = e, t[13] = u, t[14] = s2;
        } else t[0] = a2[0], t[1] = a2[4], t[2] = a2[8], t[3] = a2[12], t[4] = a2[1], t[5] = a2[5], t[6] = a2[9], t[7] = a2[13], t[8] = a2[2], t[9] = a2[6], t[10] = a2[10], t[11] = a2[14], t[12] = a2[3], t[13] = a2[7], t[14] = a2[11], t[15] = a2[15];
        return t;
      }, invert$22 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = a2[4], s2 = a2[5], i2 = a2[6], c2 = a2[7], l2 = a2[8], $ = a2[9], h = a2[10], f2 = a2[11], M = a2[12], m = a2[13], d2 = a2[14], v = a2[15], b = r2 * s2 - n * u, p = r2 * i2 - e * u, A = r2 * c2 - o2 * u, y = n * i2 - e * s2, g = n * c2 - o2 * s2, R = e * c2 - o2 * i2, E = l2 * m - $ * M, q = l2 * d2 - h * M, x = l2 * v - f2 * M, P = $ * d2 - h * m, L = $ * v - f2 * m, O = h * v - f2 * d2, S = b * O - p * L + A * P + y * x - g * q + R * E;
        return S ? (S = 1 / S, t[0] = (s2 * O - i2 * L + c2 * P) * S, t[1] = (e * L - n * O - o2 * P) * S, t[2] = (m * R - d2 * g + v * y) * S, t[3] = (h * g - $ * R - f2 * y) * S, t[4] = (i2 * x - u * O - c2 * q) * S, t[5] = (r2 * O - e * x + o2 * q) * S, t[6] = (d2 * A - M * R - v * p) * S, t[7] = (l2 * R - h * A + f2 * p) * S, t[8] = (u * L - s2 * x + c2 * E) * S, t[9] = (n * x - r2 * L - o2 * E) * S, t[10] = (M * g - m * A + v * b) * S, t[11] = ($ * A - l2 * g - f2 * b) * S, t[12] = (s2 * q - u * P - i2 * E) * S, t[13] = (r2 * P - n * q + e * E) * S, t[14] = (m * p - M * y - d2 * b) * S, t[15] = (l2 * y - $ * p + h * b) * S, t) : null;
      }, adjoint2 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = a2[4], s2 = a2[5], i2 = a2[6], c2 = a2[7], l2 = a2[8], $ = a2[9], h = a2[10], f2 = a2[11], M = a2[12], m = a2[13], d2 = a2[14], v = a2[15], b = r2 * s2 - n * u, p = r2 * i2 - e * u, A = r2 * c2 - o2 * u, y = n * i2 - e * s2, g = n * c2 - o2 * s2, R = e * c2 - o2 * i2, E = l2 * m - $ * M, q = l2 * d2 - h * M, x = l2 * v - f2 * M, P = $ * d2 - h * m, L = $ * v - f2 * m, O = h * v - f2 * d2;
        return t[0] = s2 * O - i2 * L + c2 * P, t[1] = e * L - n * O - o2 * P, t[2] = m * R - d2 * g + v * y, t[3] = h * g - $ * R - f2 * y, t[4] = i2 * x - u * O - c2 * q, t[5] = r2 * O - e * x + o2 * q, t[6] = d2 * A - M * R - v * p, t[7] = l2 * R - h * A + f2 * p, t[8] = u * L - s2 * x + c2 * E, t[9] = n * x - r2 * L - o2 * E, t[10] = M * g - m * A + v * b, t[11] = $ * A - l2 * g - f2 * b, t[12] = s2 * q - u * P - i2 * E, t[13] = r2 * P - n * q + e * E, t[14] = m * p - M * y - d2 * b, t[15] = l2 * y - $ * p + h * b, t;
      }, determinant2 = function(t) {
        var a2 = t[0], r2 = t[1], n = t[2], e = t[3], o2 = t[4], u = t[5], s2 = t[6], i2 = t[7], c2 = t[8], l2 = t[9], $ = t[10], h = t[11], f2 = t[12], M = t[13], m = t[14], d2 = a2 * u - r2 * o2, v = a2 * s2 - n * o2, b = r2 * s2 - n * u, p = c2 * M - l2 * f2, A = c2 * m - $ * f2, y = l2 * m - $ * M;
        return i2 * (a2 * y - r2 * A + n * p) - e * (o2 * y - u * A + s2 * p) + t[15] * (c2 * b - l2 * v + $ * d2) - h * (f2 * b - M * v + m * d2);
      }, multiply$52 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], $ = a2[8], h = a2[9], f2 = a2[10], M = a2[11], m = a2[12], d2 = a2[13], v = a2[14], b = a2[15], p = r2[0], A = r2[1], y = r2[2], g = r2[3];
        return t[0] = p * n + A * s2 + y * $ + g * m, t[1] = p * e + A * i2 + y * h + g * d2, t[2] = p * o2 + A * c2 + y * f2 + g * v, t[3] = p * u + A * l2 + y * M + g * b, p = r2[4], A = r2[5], y = r2[6], g = r2[7], t[4] = p * n + A * s2 + y * $ + g * m, t[5] = p * e + A * i2 + y * h + g * d2, t[6] = p * o2 + A * c2 + y * f2 + g * v, t[7] = p * u + A * l2 + y * M + g * b, p = r2[8], A = r2[9], y = r2[10], g = r2[11], t[8] = p * n + A * s2 + y * $ + g * m, t[9] = p * e + A * i2 + y * h + g * d2, t[10] = p * o2 + A * c2 + y * f2 + g * v, t[11] = p * u + A * l2 + y * M + g * b, p = r2[12], A = r2[13], y = r2[14], g = r2[15], t[12] = p * n + A * s2 + y * $ + g * m, t[13] = p * e + A * i2 + y * h + g * d2, t[14] = p * o2 + A * c2 + y * f2 + g * v, t[15] = p * u + A * l2 + y * M + g * b, t;
      }, translate$12 = function(t, a2, r2) {
        var n, e, o2, u, s2, i2, c2, l2, $, h, f2, M, m = r2[0], d2 = r2[1], v = r2[2];
        return a2 === t ? (t[12] = a2[0] * m + a2[4] * d2 + a2[8] * v + a2[12], t[13] = a2[1] * m + a2[5] * d2 + a2[9] * v + a2[13], t[14] = a2[2] * m + a2[6] * d2 + a2[10] * v + a2[14], t[15] = a2[3] * m + a2[7] * d2 + a2[11] * v + a2[15]) : (n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], $ = a2[8], h = a2[9], f2 = a2[10], M = a2[11], t[0] = n, t[1] = e, t[2] = o2, t[3] = u, t[4] = s2, t[5] = i2, t[6] = c2, t[7] = l2, t[8] = $, t[9] = h, t[10] = f2, t[11] = M, t[12] = n * m + s2 * d2 + $ * v + a2[12], t[13] = e * m + i2 * d2 + h * v + a2[13], t[14] = o2 * m + c2 * d2 + f2 * v + a2[14], t[15] = u * m + l2 * d2 + M * v + a2[15]), t;
      }, scale$52 = function(t, a2, r2) {
        var n = r2[0], e = r2[1], o2 = r2[2];
        return t[0] = a2[0] * n, t[1] = a2[1] * n, t[2] = a2[2] * n, t[3] = a2[3] * n, t[4] = a2[4] * e, t[5] = a2[5] * e, t[6] = a2[6] * e, t[7] = a2[7] * e, t[8] = a2[8] * o2, t[9] = a2[9] * o2, t[10] = a2[10] * o2, t[11] = a2[11] * o2, t[12] = a2[12], t[13] = a2[13], t[14] = a2[14], t[15] = a2[15], t;
      }, rotate$12 = function(t, a2, r2, n) {
        var e, o2, u, s2, i2, c2, l2, $, h, f2, M, m, d2, v, b, p, A, y, g, R, E, q, x, P, L = n[0], O = n[1], S = n[2], Y = Math.hypot(L, O, S);
        return Y < EPSILON ? null : (L *= Y = 1 / Y, O *= Y, S *= Y, e = Math.sin(r2), u = 1 - (o2 = Math.cos(r2)), s2 = a2[0], i2 = a2[1], c2 = a2[2], l2 = a2[3], $ = a2[4], h = a2[5], f2 = a2[6], M = a2[7], m = a2[8], d2 = a2[9], v = a2[10], b = a2[11], p = L * L * u + o2, A = O * L * u + S * e, y = S * L * u - O * e, g = L * O * u - S * e, R = O * O * u + o2, E = S * O * u + L * e, q = L * S * u + O * e, x = O * S * u - L * e, P = S * S * u + o2, t[0] = s2 * p + $ * A + m * y, t[1] = i2 * p + h * A + d2 * y, t[2] = c2 * p + f2 * A + v * y, t[3] = l2 * p + M * A + b * y, t[4] = s2 * g + $ * R + m * E, t[5] = i2 * g + h * R + d2 * E, t[6] = c2 * g + f2 * R + v * E, t[7] = l2 * g + M * R + b * E, t[8] = s2 * q + $ * x + m * P, t[9] = i2 * q + h * x + d2 * P, t[10] = c2 * q + f2 * x + v * P, t[11] = l2 * q + M * x + b * P, a2 !== t && (t[12] = a2[12], t[13] = a2[13], t[14] = a2[14], t[15] = a2[15]), t);
      }, rotateX$32 = function(t, a2, r2) {
        var n = Math.sin(r2), e = Math.cos(r2), o2 = a2[4], u = a2[5], s2 = a2[6], i2 = a2[7], c2 = a2[8], l2 = a2[9], $ = a2[10], h = a2[11];
        return a2 !== t && (t[0] = a2[0], t[1] = a2[1], t[2] = a2[2], t[3] = a2[3], t[12] = a2[12], t[13] = a2[13], t[14] = a2[14], t[15] = a2[15]), t[4] = o2 * e + c2 * n, t[5] = u * e + l2 * n, t[6] = s2 * e + $ * n, t[7] = i2 * e + h * n, t[8] = c2 * e - o2 * n, t[9] = l2 * e - u * n, t[10] = $ * e - s2 * n, t[11] = h * e - i2 * n, t;
      }, rotateY$32 = function(t, a2, r2) {
        var n = Math.sin(r2), e = Math.cos(r2), o2 = a2[0], u = a2[1], s2 = a2[2], i2 = a2[3], c2 = a2[8], l2 = a2[9], $ = a2[10], h = a2[11];
        return a2 !== t && (t[4] = a2[4], t[5] = a2[5], t[6] = a2[6], t[7] = a2[7], t[12] = a2[12], t[13] = a2[13], t[14] = a2[14], t[15] = a2[15]), t[0] = o2 * e - c2 * n, t[1] = u * e - l2 * n, t[2] = s2 * e - $ * n, t[3] = i2 * e - h * n, t[8] = o2 * n + c2 * e, t[9] = u * n + l2 * e, t[10] = s2 * n + $ * e, t[11] = i2 * n + h * e, t;
      }, rotateZ$32 = function(t, a2, r2) {
        var n = Math.sin(r2), e = Math.cos(r2), o2 = a2[0], u = a2[1], s2 = a2[2], i2 = a2[3], c2 = a2[4], l2 = a2[5], $ = a2[6], h = a2[7];
        return a2 !== t && (t[8] = a2[8], t[9] = a2[9], t[10] = a2[10], t[11] = a2[11], t[12] = a2[12], t[13] = a2[13], t[14] = a2[14], t[15] = a2[15]), t[0] = o2 * e + c2 * n, t[1] = u * e + l2 * n, t[2] = s2 * e + $ * n, t[3] = i2 * e + h * n, t[4] = c2 * e - o2 * n, t[5] = l2 * e - u * n, t[6] = $ * e - s2 * n, t[7] = h * e - i2 * n, t;
      }, fromTranslation$12 = function(t, a2) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = a2[0], t[13] = a2[1], t[14] = a2[2], t[15] = 1, t;
      }, fromScaling2 = function(t, a2) {
        return t[0] = a2[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a2[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = a2[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, fromRotation$12 = function(t, a2, r2) {
        var n, e, o2, u = r2[0], s2 = r2[1], i2 = r2[2], c2 = Math.hypot(u, s2, i2);
        return c2 < EPSILON ? null : (u *= c2 = 1 / c2, s2 *= c2, i2 *= c2, n = Math.sin(a2), o2 = 1 - (e = Math.cos(a2)), t[0] = u * u * o2 + e, t[1] = s2 * u * o2 + i2 * n, t[2] = i2 * u * o2 - s2 * n, t[3] = 0, t[4] = u * s2 * o2 - i2 * n, t[5] = s2 * s2 * o2 + e, t[6] = i2 * s2 * o2 + u * n, t[7] = 0, t[8] = u * i2 * o2 + s2 * n, t[9] = s2 * i2 * o2 - u * n, t[10] = i2 * i2 * o2 + e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
      }, fromXRotation2 = function(t, a2) {
        var r2 = Math.sin(a2), n = Math.cos(a2);
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n, t[6] = r2, t[7] = 0, t[8] = 0, t[9] = -r2, t[10] = n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, fromYRotation2 = function(t, a2) {
        var r2 = Math.sin(a2), n = Math.cos(a2);
        return t[0] = n, t[1] = 0, t[2] = -r2, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = r2, t[9] = 0, t[10] = n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, fromZRotation2 = function(t, a2) {
        var r2 = Math.sin(a2), n = Math.cos(a2);
        return t[0] = n, t[1] = r2, t[2] = 0, t[3] = 0, t[4] = -r2, t[5] = n, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, fromRotationTranslation$12 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = n + n, i2 = e + e, c2 = o2 + o2, l2 = n * s2, $ = n * i2, h = n * c2, f2 = e * i2, M = e * c2, m = o2 * c2, d2 = u * s2, v = u * i2, b = u * c2;
        return t[0] = 1 - (f2 + m), t[1] = $ + b, t[2] = h - v, t[3] = 0, t[4] = $ - b, t[5] = 1 - (l2 + m), t[6] = M + d2, t[7] = 0, t[8] = h + v, t[9] = M - d2, t[10] = 1 - (l2 + f2), t[11] = 0, t[12] = r2[0], t[13] = r2[1], t[14] = r2[2], t[15] = 1, t;
      }, fromQuat22 = function(t, a2) {
        var r2 = new ARRAY_TYPE(3), n = -a2[0], e = -a2[1], o2 = -a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], $ = n * n + e * e + o2 * o2 + u * u;
        return $ > 0 ? (r2[0] = 2 * (s2 * u + l2 * n + i2 * o2 - c2 * e) / $, r2[1] = 2 * (i2 * u + l2 * e + c2 * n - s2 * o2) / $, r2[2] = 2 * (c2 * u + l2 * o2 + s2 * e - i2 * n) / $) : (r2[0] = 2 * (s2 * u + l2 * n + i2 * o2 - c2 * e), r2[1] = 2 * (i2 * u + l2 * e + c2 * n - s2 * o2), r2[2] = 2 * (c2 * u + l2 * o2 + s2 * e - i2 * n)), fromRotationTranslation$12(t, a2, r2), t;
      }, getTranslation$12 = function(t, a2) {
        return t[0] = a2[12], t[1] = a2[13], t[2] = a2[14], t;
      }, getScaling2 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[4], u = a2[5], s2 = a2[6], i2 = a2[8], c2 = a2[9], l2 = a2[10];
        return t[0] = Math.hypot(r2, n, e), t[1] = Math.hypot(o2, u, s2), t[2] = Math.hypot(i2, c2, l2), t;
      }, getRotation2 = function(t, a2) {
        var r2 = new ARRAY_TYPE(3);
        getScaling2(r2, a2);
        var n = 1 / r2[0], e = 1 / r2[1], o2 = 1 / r2[2], u = a2[0] * n, s2 = a2[1] * e, i2 = a2[2] * o2, c2 = a2[4] * n, l2 = a2[5] * e, $ = a2[6] * o2, h = a2[8] * n, f2 = a2[9] * e, M = a2[10] * o2, m = u + l2 + M, d2 = 0;
        return m > 0 ? (d2 = 2 * Math.sqrt(m + 1), t[3] = 0.25 * d2, t[0] = ($ - f2) / d2, t[1] = (h - i2) / d2, t[2] = (s2 - c2) / d2) : u > l2 && u > M ? (d2 = 2 * Math.sqrt(1 + u - l2 - M), t[3] = ($ - f2) / d2, t[0] = 0.25 * d2, t[1] = (s2 + c2) / d2, t[2] = (h + i2) / d2) : l2 > M ? (d2 = 2 * Math.sqrt(1 + l2 - u - M), t[3] = (h - i2) / d2, t[0] = (s2 + c2) / d2, t[1] = 0.25 * d2, t[2] = ($ + f2) / d2) : (d2 = 2 * Math.sqrt(1 + M - u - l2), t[3] = (s2 - c2) / d2, t[0] = (h + i2) / d2, t[1] = ($ + f2) / d2, t[2] = 0.25 * d2), t;
      }, decompose2 = function(t, a2, r2, n) {
        a2[0] = n[12], a2[1] = n[13], a2[2] = n[14];
        var e = n[0], o2 = n[1], u = n[2], s2 = n[4], i2 = n[5], c2 = n[6], l2 = n[8], $ = n[9], h = n[10];
        r2[0] = Math.hypot(e, o2, u), r2[1] = Math.hypot(s2, i2, c2), r2[2] = Math.hypot(l2, $, h);
        var f2 = 1 / r2[0], M = 1 / r2[1], m = 1 / r2[2], d2 = e * f2, v = o2 * M, b = u * m, p = s2 * f2, A = i2 * M, y = c2 * m, g = l2 * f2, R = $ * M, E = h * m, q = d2 + A + E, x = 0;
        return q > 0 ? (x = 2 * Math.sqrt(q + 1), t[3] = 0.25 * x, t[0] = (y - R) / x, t[1] = (g - b) / x, t[2] = (v - p) / x) : d2 > A && d2 > E ? (x = 2 * Math.sqrt(1 + d2 - A - E), t[3] = (y - R) / x, t[0] = 0.25 * x, t[1] = (v + p) / x, t[2] = (g + b) / x) : A > E ? (x = 2 * Math.sqrt(1 + A - d2 - E), t[3] = (g - b) / x, t[0] = (v + p) / x, t[1] = 0.25 * x, t[2] = (y + R) / x) : (x = 2 * Math.sqrt(1 + E - d2 - A), t[3] = (v - p) / x, t[0] = (g + b) / x, t[1] = (y + R) / x, t[2] = 0.25 * x), t;
      }, fromRotationTranslationScale2 = function(t, a2, r2, n) {
        var e = a2[0], o2 = a2[1], u = a2[2], s2 = a2[3], i2 = e + e, c2 = o2 + o2, l2 = u + u, $ = e * i2, h = e * c2, f2 = e * l2, M = o2 * c2, m = o2 * l2, d2 = u * l2, v = s2 * i2, b = s2 * c2, p = s2 * l2, A = n[0], y = n[1], g = n[2];
        return t[0] = (1 - (M + d2)) * A, t[1] = (h + p) * A, t[2] = (f2 - b) * A, t[3] = 0, t[4] = (h - p) * y, t[5] = (1 - ($ + d2)) * y, t[6] = (m + v) * y, t[7] = 0, t[8] = (f2 + b) * g, t[9] = (m - v) * g, t[10] = (1 - ($ + M)) * g, t[11] = 0, t[12] = r2[0], t[13] = r2[1], t[14] = r2[2], t[15] = 1, t;
      }, fromRotationTranslationScaleOrigin2 = function(t, a2, r2, n, e) {
        var o2 = a2[0], u = a2[1], s2 = a2[2], i2 = a2[3], c2 = o2 + o2, l2 = u + u, $ = s2 + s2, h = o2 * c2, f2 = o2 * l2, M = o2 * $, m = u * l2, d2 = u * $, v = s2 * $, b = i2 * c2, p = i2 * l2, A = i2 * $, y = n[0], g = n[1], R = n[2], E = e[0], q = e[1], x = e[2], P = (1 - (m + v)) * y, L = (f2 + A) * y, O = (M - p) * y, S = (f2 - A) * g, Y = (1 - (h + v)) * g, T = (d2 + b) * g, N = (M + p) * R, _ = (d2 - b) * R, I = (1 - (h + m)) * R;
        return t[0] = P, t[1] = L, t[2] = O, t[3] = 0, t[4] = S, t[5] = Y, t[6] = T, t[7] = 0, t[8] = N, t[9] = _, t[10] = I, t[11] = 0, t[12] = r2[0] + E - (P * E + S * q + N * x), t[13] = r2[1] + q - (L * E + Y * q + _ * x), t[14] = r2[2] + x - (O * E + T * q + I * x), t[15] = 1, t;
      }, fromQuat3 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = r2 + r2, s2 = n + n, i2 = e + e, c2 = r2 * u, l2 = n * u, $ = n * s2, h = e * u, f2 = e * s2, M = e * i2, m = o2 * u, d2 = o2 * s2, v = o2 * i2;
        return t[0] = 1 - $ - M, t[1] = l2 + v, t[2] = h - d2, t[3] = 0, t[4] = l2 - v, t[5] = 1 - c2 - M, t[6] = f2 + m, t[7] = 0, t[8] = h + d2, t[9] = f2 - m, t[10] = 1 - c2 - $, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, frustum2 = function(t, a2, r2, n, e, o2, u) {
        var s2 = 1 / (r2 - a2), i2 = 1 / (e - n), c2 = 1 / (o2 - u);
        return t[0] = 2 * o2 * s2, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * o2 * i2, t[6] = 0, t[7] = 0, t[8] = (r2 + a2) * s2, t[9] = (e + n) * i2, t[10] = (u + o2) * c2, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = u * o2 * 2 * c2, t[15] = 0, t;
      }, perspectiveNO2 = function(t, a2, r2, n, e) {
        var o2 = 1 / Math.tan(a2 / 2);
        if (t[0] = o2 / r2, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o2, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0) {
          var u = 1 / (n - e);
          t[10] = (e + n) * u, t[14] = 2 * e * n * u;
        } else t[10] = -1, t[14] = -2 * n;
        return t;
      }, perspectiveZO2 = function(t, a2, r2, n, e) {
        var o2 = 1 / Math.tan(a2 / 2);
        if (t[0] = o2 / r2, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o2, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0) {
          var u = 1 / (n - e);
          t[10] = e * u, t[14] = e * n * u;
        } else t[10] = -1, t[14] = -n;
        return t;
      }, perspectiveFromFieldOfView2 = function(t, a2, r2, n) {
        var e = Math.tan(a2.upDegrees * Math.PI / 180), o2 = Math.tan(a2.downDegrees * Math.PI / 180), u = Math.tan(a2.leftDegrees * Math.PI / 180), s2 = Math.tan(a2.rightDegrees * Math.PI / 180), i2 = 2 / (u + s2), c2 = 2 / (e + o2);
        return t[0] = i2, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = c2, t[6] = 0, t[7] = 0, t[8] = -(u - s2) * i2 * 0.5, t[9] = (e - o2) * c2 * 0.5, t[10] = n / (r2 - n), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = n * r2 / (r2 - n), t[15] = 0, t;
      }, orthoNO2 = function(t, a2, r2, n, e, o2, u) {
        var s2 = 1 / (a2 - r2), i2 = 1 / (n - e), c2 = 1 / (o2 - u);
        return t[0] = -2 * s2, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * i2, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * c2, t[11] = 0, t[12] = (a2 + r2) * s2, t[13] = (e + n) * i2, t[14] = (u + o2) * c2, t[15] = 1, t;
      }, orthoZO2 = function(t, a2, r2, n, e, o2, u) {
        var s2 = 1 / (a2 - r2), i2 = 1 / (n - e), c2 = 1 / (o2 - u);
        return t[0] = -2 * s2, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * i2, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = c2, t[11] = 0, t[12] = (a2 + r2) * s2, t[13] = (e + n) * i2, t[14] = o2 * c2, t[15] = 1, t;
      }, lookAt2 = function(t, a2, r2, n) {
        var e, o2, u, s2, i2, c2, l2, $, h, f2, M = a2[0], m = a2[1], d2 = a2[2], v = n[0], b = n[1], p = n[2], A = r2[0], y = r2[1], g = r2[2];
        return Math.abs(M - A) < EPSILON && Math.abs(m - y) < EPSILON && Math.abs(d2 - g) < EPSILON ? identity$22(t) : (l2 = M - A, $ = m - y, h = d2 - g, e = b * (h *= f2 = 1 / Math.hypot(l2, $, h)) - p * ($ *= f2), o2 = p * (l2 *= f2) - v * h, u = v * $ - b * l2, (f2 = Math.hypot(e, o2, u)) ? (e *= f2 = 1 / f2, o2 *= f2, u *= f2) : (e = 0, o2 = 0, u = 0), s2 = $ * u - h * o2, i2 = h * e - l2 * u, c2 = l2 * o2 - $ * e, (f2 = Math.hypot(s2, i2, c2)) ? (s2 *= f2 = 1 / f2, i2 *= f2, c2 *= f2) : (s2 = 0, i2 = 0, c2 = 0), t[0] = e, t[1] = s2, t[2] = l2, t[3] = 0, t[4] = o2, t[5] = i2, t[6] = $, t[7] = 0, t[8] = u, t[9] = c2, t[10] = h, t[11] = 0, t[12] = -(e * M + o2 * m + u * d2), t[13] = -(s2 * M + i2 * m + c2 * d2), t[14] = -(l2 * M + $ * m + h * d2), t[15] = 1, t);
      }, targetTo2 = function(t, a2, r2, n) {
        var e = a2[0], o2 = a2[1], u = a2[2], s2 = n[0], i2 = n[1], c2 = n[2], l2 = e - r2[0], $ = o2 - r2[1], h = u - r2[2], f2 = l2 * l2 + $ * $ + h * h;
        f2 > 0 && (l2 *= f2 = 1 / Math.sqrt(f2), $ *= f2, h *= f2);
        var M = i2 * h - c2 * $, m = c2 * l2 - s2 * h, d2 = s2 * $ - i2 * l2;
        return (f2 = M * M + m * m + d2 * d2) > 0 && (M *= f2 = 1 / Math.sqrt(f2), m *= f2, d2 *= f2), t[0] = M, t[1] = m, t[2] = d2, t[3] = 0, t[4] = $ * d2 - h * m, t[5] = h * M - l2 * d2, t[6] = l2 * m - $ * M, t[7] = 0, t[8] = l2, t[9] = $, t[10] = h, t[11] = 0, t[12] = e, t[13] = o2, t[14] = u, t[15] = 1, t;
      }, str$52 = function(t) {
        return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")";
      }, frob2 = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
      }, add$52 = function(t, a2, r2) {
        return t[0] = a2[0] + r2[0], t[1] = a2[1] + r2[1], t[2] = a2[2] + r2[2], t[3] = a2[3] + r2[3], t[4] = a2[4] + r2[4], t[5] = a2[5] + r2[5], t[6] = a2[6] + r2[6], t[7] = a2[7] + r2[7], t[8] = a2[8] + r2[8], t[9] = a2[9] + r2[9], t[10] = a2[10] + r2[10], t[11] = a2[11] + r2[11], t[12] = a2[12] + r2[12], t[13] = a2[13] + r2[13], t[14] = a2[14] + r2[14], t[15] = a2[15] + r2[15], t;
      }, subtract$32 = function(t, a2, r2) {
        return t[0] = a2[0] - r2[0], t[1] = a2[1] - r2[1], t[2] = a2[2] - r2[2], t[3] = a2[3] - r2[3], t[4] = a2[4] - r2[4], t[5] = a2[5] - r2[5], t[6] = a2[6] - r2[6], t[7] = a2[7] - r2[7], t[8] = a2[8] - r2[8], t[9] = a2[9] - r2[9], t[10] = a2[10] - r2[10], t[11] = a2[11] - r2[11], t[12] = a2[12] - r2[12], t[13] = a2[13] - r2[13], t[14] = a2[14] - r2[14], t[15] = a2[15] - r2[15], t;
      }, multiplyScalar2 = function(t, a2, r2) {
        return t[0] = a2[0] * r2, t[1] = a2[1] * r2, t[2] = a2[2] * r2, t[3] = a2[3] * r2, t[4] = a2[4] * r2, t[5] = a2[5] * r2, t[6] = a2[6] * r2, t[7] = a2[7] * r2, t[8] = a2[8] * r2, t[9] = a2[9] * r2, t[10] = a2[10] * r2, t[11] = a2[11] * r2, t[12] = a2[12] * r2, t[13] = a2[13] * r2, t[14] = a2[14] * r2, t[15] = a2[15] * r2, t;
      }, multiplyScalarAndAdd2 = function(t, a2, r2, n) {
        return t[0] = a2[0] + r2[0] * n, t[1] = a2[1] + r2[1] * n, t[2] = a2[2] + r2[2] * n, t[3] = a2[3] + r2[3] * n, t[4] = a2[4] + r2[4] * n, t[5] = a2[5] + r2[5] * n, t[6] = a2[6] + r2[6] * n, t[7] = a2[7] + r2[7] * n, t[8] = a2[8] + r2[8] * n, t[9] = a2[9] + r2[9] * n, t[10] = a2[10] + r2[10] * n, t[11] = a2[11] + r2[11] * n, t[12] = a2[12] + r2[12] * n, t[13] = a2[13] + r2[13] * n, t[14] = a2[14] + r2[14] * n, t[15] = a2[15] + r2[15] * n, t;
      }, exactEquals$52 = function(t, a2) {
        return t[0] === a2[0] && t[1] === a2[1] && t[2] === a2[2] && t[3] === a2[3] && t[4] === a2[4] && t[5] === a2[5] && t[6] === a2[6] && t[7] === a2[7] && t[8] === a2[8] && t[9] === a2[9] && t[10] === a2[10] && t[11] === a2[11] && t[12] === a2[12] && t[13] === a2[13] && t[14] === a2[14] && t[15] === a2[15];
      }, equals$52 = function(t, a2) {
        var r2 = t[0], n = t[1], e = t[2], o2 = t[3], u = t[4], s2 = t[5], i2 = t[6], c2 = t[7], l2 = t[8], $ = t[9], h = t[10], f2 = t[11], M = t[12], m = t[13], d2 = t[14], v = t[15], b = a2[0], p = a2[1], A = a2[2], y = a2[3], g = a2[4], R = a2[5], E = a2[6], q = a2[7], x = a2[8], P = a2[9], L = a2[10], O = a2[11], S = a2[12], Y = a2[13], T = a2[14], N = a2[15];
        return Math.abs(r2 - b) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(b)) && Math.abs(n - p) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(p)) && Math.abs(e - A) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(A)) && Math.abs(o2 - y) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs(y)) && Math.abs(u - g) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(g)) && Math.abs(s2 - R) <= EPSILON * Math.max(1, Math.abs(s2), Math.abs(R)) && Math.abs(i2 - E) <= EPSILON * Math.max(1, Math.abs(i2), Math.abs(E)) && Math.abs(c2 - q) <= EPSILON * Math.max(1, Math.abs(c2), Math.abs(q)) && Math.abs(l2 - x) <= EPSILON * Math.max(1, Math.abs(l2), Math.abs(x)) && Math.abs($ - P) <= EPSILON * Math.max(1, Math.abs($), Math.abs(P)) && Math.abs(h - L) <= EPSILON * Math.max(1, Math.abs(h), Math.abs(L)) && Math.abs(f2 - O) <= EPSILON * Math.max(1, Math.abs(f2), Math.abs(O)) && Math.abs(M - S) <= EPSILON * Math.max(1, Math.abs(M), Math.abs(S)) && Math.abs(m - Y) <= EPSILON * Math.max(1, Math.abs(m), Math.abs(Y)) && Math.abs(d2 - T) <= EPSILON * Math.max(1, Math.abs(d2), Math.abs(T)) && Math.abs(v - N) <= EPSILON * Math.max(1, Math.abs(v), Math.abs(N));
      }, create$42 = function() {
        var t = new ARRAY_TYPE(3);
        return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
      }, clone$42 = function(t) {
        var a2 = new ARRAY_TYPE(3);
        return a2[0] = t[0], a2[1] = t[1], a2[2] = t[2], a2;
      }, length$42 = function(t) {
        var a2 = t[0], r2 = t[1], n = t[2];
        return Math.hypot(a2, r2, n);
      }, fromValues$42 = function(t, a2, r2) {
        var n = new ARRAY_TYPE(3);
        return n[0] = t, n[1] = a2, n[2] = r2, n;
      }, copy$42 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t[2] = a2[2], t;
      }, set$42 = function(t, a2, r2, n) {
        return t[0] = a2, t[1] = r2, t[2] = n, t;
      }, add$42 = function(t, a2, r2) {
        return t[0] = a2[0] + r2[0], t[1] = a2[1] + r2[1], t[2] = a2[2] + r2[2], t;
      }, subtract$22 = function(t, a2, r2) {
        return t[0] = a2[0] - r2[0], t[1] = a2[1] - r2[1], t[2] = a2[2] - r2[2], t;
      }, multiply$42 = function(t, a2, r2) {
        return t[0] = a2[0] * r2[0], t[1] = a2[1] * r2[1], t[2] = a2[2] * r2[2], t;
      }, divide$22 = function(t, a2, r2) {
        return t[0] = a2[0] / r2[0], t[1] = a2[1] / r2[1], t[2] = a2[2] / r2[2], t;
      }, ceil$22 = function(t, a2) {
        return t[0] = Math.ceil(a2[0]), t[1] = Math.ceil(a2[1]), t[2] = Math.ceil(a2[2]), t;
      }, floor$22 = function(t, a2) {
        return t[0] = Math.floor(a2[0]), t[1] = Math.floor(a2[1]), t[2] = Math.floor(a2[2]), t;
      }, min$22 = function(t, a2, r2) {
        return t[0] = Math.min(a2[0], r2[0]), t[1] = Math.min(a2[1], r2[1]), t[2] = Math.min(a2[2], r2[2]), t;
      }, max$22 = function(t, a2, r2) {
        return t[0] = Math.max(a2[0], r2[0]), t[1] = Math.max(a2[1], r2[1]), t[2] = Math.max(a2[2], r2[2]), t;
      }, round$22 = function(t, a2) {
        return t[0] = Math.round(a2[0]), t[1] = Math.round(a2[1]), t[2] = Math.round(a2[2]), t;
      }, scale$42 = function(t, a2, r2) {
        return t[0] = a2[0] * r2, t[1] = a2[1] * r2, t[2] = a2[2] * r2, t;
      }, scaleAndAdd$22 = function(t, a2, r2, n) {
        return t[0] = a2[0] + r2[0] * n, t[1] = a2[1] + r2[1] * n, t[2] = a2[2] + r2[2] * n, t;
      }, distance$22 = function(t, a2) {
        var r2 = a2[0] - t[0], n = a2[1] - t[1], e = a2[2] - t[2];
        return Math.hypot(r2, n, e);
      }, squaredDistance$22 = function(t, a2) {
        var r2 = a2[0] - t[0], n = a2[1] - t[1], e = a2[2] - t[2];
        return r2 * r2 + n * n + e * e;
      }, squaredLength$42 = function(t) {
        var a2 = t[0], r2 = t[1], n = t[2];
        return a2 * a2 + r2 * r2 + n * n;
      }, negate$22 = function(t, a2) {
        return t[0] = -a2[0], t[1] = -a2[1], t[2] = -a2[2], t;
      }, inverse$22 = function(t, a2) {
        return t[0] = 1 / a2[0], t[1] = 1 / a2[1], t[2] = 1 / a2[2], t;
      }, normalize$42 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = r2 * r2 + n * n + e * e;
        return o2 > 0 && (o2 = 1 / Math.sqrt(o2)), t[0] = a2[0] * o2, t[1] = a2[1] * o2, t[2] = a2[2] * o2, t;
      }, dot$42 = function(t, a2) {
        return t[0] * a2[0] + t[1] * a2[1] + t[2] * a2[2];
      }, cross$22 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = r2[0], s2 = r2[1], i2 = r2[2];
        return t[0] = e * i2 - o2 * s2, t[1] = o2 * u - n * i2, t[2] = n * s2 - e * u, t;
      }, lerp$42 = function(t, a2, r2, n) {
        var e = a2[0], o2 = a2[1], u = a2[2];
        return t[0] = e + n * (r2[0] - e), t[1] = o2 + n * (r2[1] - o2), t[2] = u + n * (r2[2] - u), t;
      }, slerp$12 = function(t, a2, r2, n) {
        var e = Math.acos(Math.min(Math.max(dot$42(a2, r2), -1), 1)), o2 = Math.sin(e), u = Math.sin((1 - n) * e) / o2, s2 = Math.sin(n * e) / o2;
        return t[0] = u * a2[0] + s2 * r2[0], t[1] = u * a2[1] + s2 * r2[1], t[2] = u * a2[2] + s2 * r2[2], t;
      }, hermite2 = function(t, a2, r2, n, e, o2) {
        var u = o2 * o2, s2 = u * (2 * o2 - 3) + 1, i2 = u * (o2 - 2) + o2, c2 = u * (o2 - 1), l2 = u * (3 - 2 * o2);
        return t[0] = a2[0] * s2 + r2[0] * i2 + n[0] * c2 + e[0] * l2, t[1] = a2[1] * s2 + r2[1] * i2 + n[1] * c2 + e[1] * l2, t[2] = a2[2] * s2 + r2[2] * i2 + n[2] * c2 + e[2] * l2, t;
      }, bezier2 = function(t, a2, r2, n, e, o2) {
        var u = 1 - o2, s2 = u * u, i2 = o2 * o2, c2 = s2 * u, l2 = 3 * o2 * s2, $ = 3 * i2 * u, h = i2 * o2;
        return t[0] = a2[0] * c2 + r2[0] * l2 + n[0] * $ + e[0] * h, t[1] = a2[1] * c2 + r2[1] * l2 + n[1] * $ + e[1] * h, t[2] = a2[2] * c2 + r2[2] * l2 + n[2] * $ + e[2] * h, t;
      }, random$32 = function(t, a2) {
        a2 = a2 || 1;
        var r2 = 2 * RANDOM() * Math.PI, n = 2 * RANDOM() - 1, e = Math.sqrt(1 - n * n) * a2;
        return t[0] = Math.cos(r2) * e, t[1] = Math.sin(r2) * e, t[2] = n * a2, t;
      }, transformMat4$22 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = r2[3] * n + r2[7] * e + r2[11] * o2 + r2[15];
        return u = u || 1, t[0] = (r2[0] * n + r2[4] * e + r2[8] * o2 + r2[12]) / u, t[1] = (r2[1] * n + r2[5] * e + r2[9] * o2 + r2[13]) / u, t[2] = (r2[2] * n + r2[6] * e + r2[10] * o2 + r2[14]) / u, t;
      }, transformMat3$12 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2];
        return t[0] = n * r2[0] + e * r2[3] + o2 * r2[6], t[1] = n * r2[1] + e * r2[4] + o2 * r2[7], t[2] = n * r2[2] + e * r2[5] + o2 * r2[8], t;
      }, transformQuat$12 = function(t, a2, r2) {
        var n = r2[0], e = r2[1], o2 = r2[2], u = r2[3], s2 = a2[0], i2 = a2[1], c2 = a2[2], l2 = e * c2 - o2 * i2, $ = o2 * s2 - n * c2, h = n * i2 - e * s2, f2 = e * h - o2 * $, M = o2 * l2 - n * h, m = n * $ - e * l2, d2 = 2 * u;
        return l2 *= d2, $ *= d2, h *= d2, f2 *= 2, M *= 2, m *= 2, t[0] = s2 + l2 + f2, t[1] = i2 + $ + M, t[2] = c2 + h + m, t;
      }, rotateX$22 = function(t, a2, r2, n) {
        var e = [], o2 = [];
        return e[0] = a2[0] - r2[0], e[1] = a2[1] - r2[1], e[2] = a2[2] - r2[2], o2[0] = e[0], o2[1] = e[1] * Math.cos(n) - e[2] * Math.sin(n), o2[2] = e[1] * Math.sin(n) + e[2] * Math.cos(n), t[0] = o2[0] + r2[0], t[1] = o2[1] + r2[1], t[2] = o2[2] + r2[2], t;
      }, rotateY$22 = function(t, a2, r2, n) {
        var e = [], o2 = [];
        return e[0] = a2[0] - r2[0], e[1] = a2[1] - r2[1], e[2] = a2[2] - r2[2], o2[0] = e[2] * Math.sin(n) + e[0] * Math.cos(n), o2[1] = e[1], o2[2] = e[2] * Math.cos(n) - e[0] * Math.sin(n), t[0] = o2[0] + r2[0], t[1] = o2[1] + r2[1], t[2] = o2[2] + r2[2], t;
      }, rotateZ$22 = function(t, a2, r2, n) {
        var e = [], o2 = [];
        return e[0] = a2[0] - r2[0], e[1] = a2[1] - r2[1], e[2] = a2[2] - r2[2], o2[0] = e[0] * Math.cos(n) - e[1] * Math.sin(n), o2[1] = e[0] * Math.sin(n) + e[1] * Math.cos(n), o2[2] = e[2], t[0] = o2[0] + r2[0], t[1] = o2[1] + r2[1], t[2] = o2[2] + r2[2], t;
      }, angle$12 = function(t, a2) {
        var r2 = t[0], n = t[1], e = t[2], o2 = a2[0], u = a2[1], s2 = a2[2], i2 = Math.sqrt((r2 * r2 + n * n + e * e) * (o2 * o2 + u * u + s2 * s2)), c2 = i2 && dot$42(t, a2) / i2;
        return Math.acos(Math.min(Math.max(c2, -1), 1));
      }, zero$22 = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t;
      }, str$42 = function(t) {
        return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
      }, exactEquals$42 = function(t, a2) {
        return t[0] === a2[0] && t[1] === a2[1] && t[2] === a2[2];
      }, equals$42 = function(t, a2) {
        var r2 = t[0], n = t[1], e = t[2], o2 = a2[0], u = a2[1], s2 = a2[2];
        return Math.abs(r2 - o2) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(o2)) && Math.abs(n - u) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(e - s2) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(s2));
      }, create$32 = function() {
        var t = new ARRAY_TYPE(4);
        return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
      }, clone$32 = function(t) {
        var a2 = new ARRAY_TYPE(4);
        return a2[0] = t[0], a2[1] = t[1], a2[2] = t[2], a2[3] = t[3], a2;
      }, fromValues$32 = function(t, a2, r2, n) {
        var e = new ARRAY_TYPE(4);
        return e[0] = t, e[1] = a2, e[2] = r2, e[3] = n, e;
      }, copy$32 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t[2] = a2[2], t[3] = a2[3], t;
      }, set$32 = function(t, a2, r2, n, e) {
        return t[0] = a2, t[1] = r2, t[2] = n, t[3] = e, t;
      }, add$32 = function(t, a2, r2) {
        return t[0] = a2[0] + r2[0], t[1] = a2[1] + r2[1], t[2] = a2[2] + r2[2], t[3] = a2[3] + r2[3], t;
      }, subtract$12 = function(t, a2, r2) {
        return t[0] = a2[0] - r2[0], t[1] = a2[1] - r2[1], t[2] = a2[2] - r2[2], t[3] = a2[3] - r2[3], t;
      }, multiply$32 = function(t, a2, r2) {
        return t[0] = a2[0] * r2[0], t[1] = a2[1] * r2[1], t[2] = a2[2] * r2[2], t[3] = a2[3] * r2[3], t;
      }, divide$12 = function(t, a2, r2) {
        return t[0] = a2[0] / r2[0], t[1] = a2[1] / r2[1], t[2] = a2[2] / r2[2], t[3] = a2[3] / r2[3], t;
      }, ceil$12 = function(t, a2) {
        return t[0] = Math.ceil(a2[0]), t[1] = Math.ceil(a2[1]), t[2] = Math.ceil(a2[2]), t[3] = Math.ceil(a2[3]), t;
      }, floor$12 = function(t, a2) {
        return t[0] = Math.floor(a2[0]), t[1] = Math.floor(a2[1]), t[2] = Math.floor(a2[2]), t[3] = Math.floor(a2[3]), t;
      }, min$12 = function(t, a2, r2) {
        return t[0] = Math.min(a2[0], r2[0]), t[1] = Math.min(a2[1], r2[1]), t[2] = Math.min(a2[2], r2[2]), t[3] = Math.min(a2[3], r2[3]), t;
      }, max$12 = function(t, a2, r2) {
        return t[0] = Math.max(a2[0], r2[0]), t[1] = Math.max(a2[1], r2[1]), t[2] = Math.max(a2[2], r2[2]), t[3] = Math.max(a2[3], r2[3]), t;
      }, round$12 = function(t, a2) {
        return t[0] = Math.round(a2[0]), t[1] = Math.round(a2[1]), t[2] = Math.round(a2[2]), t[3] = Math.round(a2[3]), t;
      }, scale$32 = function(t, a2, r2) {
        return t[0] = a2[0] * r2, t[1] = a2[1] * r2, t[2] = a2[2] * r2, t[3] = a2[3] * r2, t;
      }, scaleAndAdd$12 = function(t, a2, r2, n) {
        return t[0] = a2[0] + r2[0] * n, t[1] = a2[1] + r2[1] * n, t[2] = a2[2] + r2[2] * n, t[3] = a2[3] + r2[3] * n, t;
      }, distance$12 = function(t, a2) {
        var r2 = a2[0] - t[0], n = a2[1] - t[1], e = a2[2] - t[2], o2 = a2[3] - t[3];
        return Math.hypot(r2, n, e, o2);
      }, squaredDistance$12 = function(t, a2) {
        var r2 = a2[0] - t[0], n = a2[1] - t[1], e = a2[2] - t[2], o2 = a2[3] - t[3];
        return r2 * r2 + n * n + e * e + o2 * o2;
      }, length$32 = function(t) {
        var a2 = t[0], r2 = t[1], n = t[2], e = t[3];
        return Math.hypot(a2, r2, n, e);
      }, squaredLength$32 = function(t) {
        var a2 = t[0], r2 = t[1], n = t[2], e = t[3];
        return a2 * a2 + r2 * r2 + n * n + e * e;
      }, negate$12 = function(t, a2) {
        return t[0] = -a2[0], t[1] = -a2[1], t[2] = -a2[2], t[3] = -a2[3], t;
      }, inverse$12 = function(t, a2) {
        return t[0] = 1 / a2[0], t[1] = 1 / a2[1], t[2] = 1 / a2[2], t[3] = 1 / a2[3], t;
      }, normalize$32 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = r2 * r2 + n * n + e * e + o2 * o2;
        return u > 0 && (u = 1 / Math.sqrt(u)), t[0] = r2 * u, t[1] = n * u, t[2] = e * u, t[3] = o2 * u, t;
      }, dot$32 = function(t, a2) {
        return t[0] * a2[0] + t[1] * a2[1] + t[2] * a2[2] + t[3] * a2[3];
      }, cross$12 = function(t, a2, r2, n) {
        var e = r2[0] * n[1] - r2[1] * n[0], o2 = r2[0] * n[2] - r2[2] * n[0], u = r2[0] * n[3] - r2[3] * n[0], s2 = r2[1] * n[2] - r2[2] * n[1], i2 = r2[1] * n[3] - r2[3] * n[1], c2 = r2[2] * n[3] - r2[3] * n[2], l2 = a2[0], $ = a2[1], h = a2[2], f2 = a2[3];
        return t[0] = $ * c2 - h * i2 + f2 * s2, t[1] = -l2 * c2 + h * u - f2 * o2, t[2] = l2 * i2 - $ * u + f2 * e, t[3] = -l2 * s2 + $ * o2 - h * e, t;
      }, lerp$32 = function(t, a2, r2, n) {
        var e = a2[0], o2 = a2[1], u = a2[2], s2 = a2[3];
        return t[0] = e + n * (r2[0] - e), t[1] = o2 + n * (r2[1] - o2), t[2] = u + n * (r2[2] - u), t[3] = s2 + n * (r2[3] - s2), t;
      }, random$22 = function(t, a2) {
        var r2, n, e, o2, u, s2;
        a2 = a2 || 1;
        do {
          u = (r2 = 2 * RANDOM() - 1) * r2 + (n = 2 * RANDOM() - 1) * n;
        } while (u >= 1);
        do {
          s2 = (e = 2 * RANDOM() - 1) * e + (o2 = 2 * RANDOM() - 1) * o2;
        } while (s2 >= 1);
        var i2 = Math.sqrt((1 - u) / s2);
        return t[0] = a2 * r2, t[1] = a2 * n, t[2] = a2 * e * i2, t[3] = a2 * o2 * i2, t;
      }, transformMat4$12 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3];
        return t[0] = r2[0] * n + r2[4] * e + r2[8] * o2 + r2[12] * u, t[1] = r2[1] * n + r2[5] * e + r2[9] * o2 + r2[13] * u, t[2] = r2[2] * n + r2[6] * e + r2[10] * o2 + r2[14] * u, t[3] = r2[3] * n + r2[7] * e + r2[11] * o2 + r2[15] * u, t;
      }, transformQuat2 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = r2[0], s2 = r2[1], i2 = r2[2], c2 = r2[3], l2 = c2 * n + s2 * o2 - i2 * e, $ = c2 * e + i2 * n - u * o2, h = c2 * o2 + u * e - s2 * n, f2 = -u * n - s2 * e - i2 * o2;
        return t[0] = l2 * c2 + f2 * -u + $ * -i2 - h * -s2, t[1] = $ * c2 + f2 * -s2 + h * -u - l2 * -i2, t[2] = h * c2 + f2 * -i2 + l2 * -s2 - $ * -u, t[3] = a2[3], t;
      }, zero$12 = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t;
      }, str$32 = function(t) {
        return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
      }, exactEquals$32 = function(t, a2) {
        return t[0] === a2[0] && t[1] === a2[1] && t[2] === a2[2] && t[3] === a2[3];
      }, equals$32 = function(t, a2) {
        var r2 = t[0], n = t[1], e = t[2], o2 = t[3], u = a2[0], s2 = a2[1], i2 = a2[2], c2 = a2[3];
        return Math.abs(r2 - u) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(u)) && Math.abs(n - s2) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(s2)) && Math.abs(e - i2) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(i2)) && Math.abs(o2 - c2) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs(c2));
      }, create$22 = function() {
        var t = new ARRAY_TYPE(4);
        return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
      }, identity$12 = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
      }, setAxisAngle2 = function(t, a2, r2) {
        r2 *= 0.5;
        var n = Math.sin(r2);
        return t[0] = n * a2[0], t[1] = n * a2[1], t[2] = n * a2[2], t[3] = Math.cos(r2), t;
      }, getAxisAngle2 = function(t, a2) {
        var r2 = 2 * Math.acos(a2[3]), n = Math.sin(r2 / 2);
        return n > EPSILON ? (t[0] = a2[0] / n, t[1] = a2[1] / n, t[2] = a2[2] / n) : (t[0] = 1, t[1] = 0, t[2] = 0), r2;
      }, getAngle2 = function(t, a2) {
        var r2 = dot$2(t, a2);
        return Math.acos(2 * r2 * r2 - 1);
      }, multiply$22 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = r2[0], i2 = r2[1], c2 = r2[2], l2 = r2[3];
        return t[0] = n * l2 + u * s2 + e * c2 - o2 * i2, t[1] = e * l2 + u * i2 + o2 * s2 - n * c2, t[2] = o2 * l2 + u * c2 + n * i2 - e * s2, t[3] = u * l2 - n * s2 - e * i2 - o2 * c2, t;
      }, rotateX$12 = function(t, a2, r2) {
        r2 *= 0.5;
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = Math.sin(r2), i2 = Math.cos(r2);
        return t[0] = n * i2 + u * s2, t[1] = e * i2 + o2 * s2, t[2] = o2 * i2 - e * s2, t[3] = u * i2 - n * s2, t;
      }, rotateY$12 = function(t, a2, r2) {
        r2 *= 0.5;
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = Math.sin(r2), i2 = Math.cos(r2);
        return t[0] = n * i2 - o2 * s2, t[1] = e * i2 + u * s2, t[2] = o2 * i2 + n * s2, t[3] = u * i2 - e * s2, t;
      }, rotateZ$12 = function(t, a2, r2) {
        r2 *= 0.5;
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = Math.sin(r2), i2 = Math.cos(r2);
        return t[0] = n * i2 + e * s2, t[1] = e * i2 - n * s2, t[2] = o2 * i2 + u * s2, t[3] = u * i2 - o2 * s2, t;
      }, calculateW2 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2];
        return t[0] = r2, t[1] = n, t[2] = e, t[3] = Math.sqrt(Math.abs(1 - r2 * r2 - n * n - e * e)), t;
      }, exp2 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = Math.sqrt(r2 * r2 + n * n + e * e), s2 = Math.exp(o2), i2 = u > 0 ? s2 * Math.sin(u) / u : 0;
        return t[0] = r2 * i2, t[1] = n * i2, t[2] = e * i2, t[3] = s2 * Math.cos(u), t;
      }, ln2 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = Math.sqrt(r2 * r2 + n * n + e * e), s2 = u > 0 ? Math.atan2(u, o2) / u : 0;
        return t[0] = r2 * s2, t[1] = n * s2, t[2] = e * s2, t[3] = 0.5 * Math.log(r2 * r2 + n * n + e * e + o2 * o2), t;
      }, pow2 = function(t, a2, r2) {
        return ln2(t, a2), scale$2(t, t, r2), exp2(t, t), t;
      }, slerp2 = function(t, a2, r2, n) {
        var e, o2, u, s2, i2, c2 = a2[0], l2 = a2[1], $ = a2[2], h = a2[3], f2 = r2[0], M = r2[1], m = r2[2], d2 = r2[3];
        return (o2 = c2 * f2 + l2 * M + $ * m + h * d2) < 0 && (o2 = -o2, f2 = -f2, M = -M, m = -m, d2 = -d2), 1 - o2 > EPSILON ? (e = Math.acos(o2), u = Math.sin(e), s2 = Math.sin((1 - n) * e) / u, i2 = Math.sin(n * e) / u) : (s2 = 1 - n, i2 = n), t[0] = s2 * c2 + i2 * f2, t[1] = s2 * l2 + i2 * M, t[2] = s2 * $ + i2 * m, t[3] = s2 * h + i2 * d2, t;
      }, random$12 = function(t) {
        var a2 = RANDOM(), r2 = RANDOM(), n = RANDOM(), e = Math.sqrt(1 - a2), o2 = Math.sqrt(a2);
        return t[0] = e * Math.sin(2 * Math.PI * r2), t[1] = e * Math.cos(2 * Math.PI * r2), t[2] = o2 * Math.sin(2 * Math.PI * n), t[3] = o2 * Math.cos(2 * Math.PI * n), t;
      }, invert$12 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u = r2 * r2 + n * n + e * e + o2 * o2, s2 = u ? 1 / u : 0;
        return t[0] = -r2 * s2, t[1] = -n * s2, t[2] = -e * s2, t[3] = o2 * s2, t;
      }, conjugate$12 = function(t, a2) {
        return t[0] = -a2[0], t[1] = -a2[1], t[2] = -a2[2], t[3] = a2[3], t;
      }, fromMat32 = function(t, a2) {
        var r2, n = a2[0] + a2[4] + a2[8];
        if (n > 0) r2 = Math.sqrt(n + 1), t[3] = 0.5 * r2, r2 = 0.5 / r2, t[0] = (a2[5] - a2[7]) * r2, t[1] = (a2[6] - a2[2]) * r2, t[2] = (a2[1] - a2[3]) * r2;
        else {
          var e = 0;
          a2[4] > a2[0] && (e = 1), a2[8] > a2[3 * e + e] && (e = 2);
          var o2 = (e + 1) % 3, u = (e + 2) % 3;
          r2 = Math.sqrt(a2[3 * e + e] - a2[3 * o2 + o2] - a2[3 * u + u] + 1), t[e] = 0.5 * r2, r2 = 0.5 / r2, t[3] = (a2[3 * o2 + u] - a2[3 * u + o2]) * r2, t[o2] = (a2[3 * o2 + e] + a2[3 * e + o2]) * r2, t[u] = (a2[3 * u + e] + a2[3 * e + u]) * r2;
        }
        return t;
      }, fromEuler2 = function(t, a2, r2, n) {
        var e = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : ANGLE_ORDER, o2 = Math.PI / 360;
        a2 *= o2, n *= o2, r2 *= o2;
        var u = Math.sin(a2), s2 = Math.cos(a2), i2 = Math.sin(r2), c2 = Math.cos(r2), l2 = Math.sin(n), $ = Math.cos(n);
        switch (e) {
          case "xyz":
            t[0] = u * c2 * $ + s2 * i2 * l2, t[1] = s2 * i2 * $ - u * c2 * l2, t[2] = s2 * c2 * l2 + u * i2 * $, t[3] = s2 * c2 * $ - u * i2 * l2;
            break;
          case "xzy":
            t[0] = u * c2 * $ - s2 * i2 * l2, t[1] = s2 * i2 * $ - u * c2 * l2, t[2] = s2 * c2 * l2 + u * i2 * $, t[3] = s2 * c2 * $ + u * i2 * l2;
            break;
          case "yxz":
            t[0] = u * c2 * $ + s2 * i2 * l2, t[1] = s2 * i2 * $ - u * c2 * l2, t[2] = s2 * c2 * l2 - u * i2 * $, t[3] = s2 * c2 * $ + u * i2 * l2;
            break;
          case "yzx":
            t[0] = u * c2 * $ + s2 * i2 * l2, t[1] = s2 * i2 * $ + u * c2 * l2, t[2] = s2 * c2 * l2 - u * i2 * $, t[3] = s2 * c2 * $ - u * i2 * l2;
            break;
          case "zxy":
            t[0] = u * c2 * $ - s2 * i2 * l2, t[1] = s2 * i2 * $ + u * c2 * l2, t[2] = s2 * c2 * l2 + u * i2 * $, t[3] = s2 * c2 * $ - u * i2 * l2;
            break;
          case "zyx":
            t[0] = u * c2 * $ - s2 * i2 * l2, t[1] = s2 * i2 * $ + u * c2 * l2, t[2] = s2 * c2 * l2 - u * i2 * $, t[3] = s2 * c2 * $ + u * i2 * l2;
            break;
          default:
            throw new Error("Unknown angle order " + e);
        }
        return t;
      }, str$22 = function(t) {
        return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
      }, equals$22 = function(t, a2) {
        return Math.abs(dot$32(t, a2)) >= 1 - EPSILON;
      }, create$12 = function() {
        var t = new ARRAY_TYPE(8);
        return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[3] = 1, t;
      }, clone$12 = function(t) {
        var a2 = new ARRAY_TYPE(8);
        return a2[0] = t[0], a2[1] = t[1], a2[2] = t[2], a2[3] = t[3], a2[4] = t[4], a2[5] = t[5], a2[6] = t[6], a2[7] = t[7], a2;
      }, fromValues$12 = function(t, a2, r2, n, e, o2, u, s2) {
        var i2 = new ARRAY_TYPE(8);
        return i2[0] = t, i2[1] = a2, i2[2] = r2, i2[3] = n, i2[4] = e, i2[5] = o2, i2[6] = u, i2[7] = s2, i2;
      }, fromRotationTranslationValues2 = function(t, a2, r2, n, e, o2, u) {
        var s2 = new ARRAY_TYPE(8);
        s2[0] = t, s2[1] = a2, s2[2] = r2, s2[3] = n;
        var i2 = 0.5 * e, c2 = 0.5 * o2, l2 = 0.5 * u;
        return s2[4] = i2 * n + c2 * r2 - l2 * a2, s2[5] = c2 * n + l2 * t - i2 * r2, s2[6] = l2 * n + i2 * a2 - c2 * t, s2[7] = -i2 * t - c2 * a2 - l2 * r2, s2;
      }, fromRotationTranslation2 = function(t, a2, r2) {
        var n = 0.5 * r2[0], e = 0.5 * r2[1], o2 = 0.5 * r2[2], u = a2[0], s2 = a2[1], i2 = a2[2], c2 = a2[3];
        return t[0] = u, t[1] = s2, t[2] = i2, t[3] = c2, t[4] = n * c2 + e * i2 - o2 * s2, t[5] = e * c2 + o2 * u - n * i2, t[6] = o2 * c2 + n * s2 - e * u, t[7] = -n * u - e * s2 - o2 * i2, t;
      }, fromTranslation2 = function(t, a2) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0.5 * a2[0], t[5] = 0.5 * a2[1], t[6] = 0.5 * a2[2], t[7] = 0, t;
      }, fromRotation2 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t[2] = a2[2], t[3] = a2[3], t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;
      }, fromMat42 = function(t, a2) {
        var r2 = create$22();
        getRotation2(r2, a2);
        var n = new ARRAY_TYPE(3);
        return getTranslation$12(n, a2), fromRotationTranslation2(t, r2, n), t;
      }, copy$12 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t[2] = a2[2], t[3] = a2[3], t[4] = a2[4], t[5] = a2[5], t[6] = a2[6], t[7] = a2[7], t;
      }, identity2 = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;
      }, set$12 = function(t, a2, r2, n, e, o2, u, s2, i2) {
        return t[0] = a2, t[1] = r2, t[2] = n, t[3] = e, t[4] = o2, t[5] = u, t[6] = s2, t[7] = i2, t;
      }, getDual2 = function(t, a2) {
        return t[0] = a2[4], t[1] = a2[5], t[2] = a2[6], t[3] = a2[7], t;
      }, setDual2 = function(t, a2) {
        return t[4] = a2[0], t[5] = a2[1], t[6] = a2[2], t[7] = a2[3], t;
      }, getTranslation2 = function(t, a2) {
        var r2 = a2[4], n = a2[5], e = a2[6], o2 = a2[7], u = -a2[0], s2 = -a2[1], i2 = -a2[2], c2 = a2[3];
        return t[0] = 2 * (r2 * c2 + o2 * u + n * i2 - e * s2), t[1] = 2 * (n * c2 + o2 * s2 + e * u - r2 * i2), t[2] = 2 * (e * c2 + o2 * i2 + r2 * s2 - n * u), t;
      }, translate2 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = 0.5 * r2[0], i2 = 0.5 * r2[1], c2 = 0.5 * r2[2], l2 = a2[4], $ = a2[5], h = a2[6], f2 = a2[7];
        return t[0] = n, t[1] = e, t[2] = o2, t[3] = u, t[4] = u * s2 + e * c2 - o2 * i2 + l2, t[5] = u * i2 + o2 * s2 - n * c2 + $, t[6] = u * c2 + n * i2 - e * s2 + h, t[7] = -n * s2 - e * i2 - o2 * c2 + f2, t;
      }, rotateX2 = function(t, a2, r2) {
        var n = -a2[0], e = -a2[1], o2 = -a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], $ = s2 * u + l2 * n + i2 * o2 - c2 * e, h = i2 * u + l2 * e + c2 * n - s2 * o2, f2 = c2 * u + l2 * o2 + s2 * e - i2 * n, M = l2 * u - s2 * n - i2 * e - c2 * o2;
        return rotateX$12(t, a2, r2), n = t[0], e = t[1], o2 = t[2], u = t[3], t[4] = $ * u + M * n + h * o2 - f2 * e, t[5] = h * u + M * e + f2 * n - $ * o2, t[6] = f2 * u + M * o2 + $ * e - h * n, t[7] = M * u - $ * n - h * e - f2 * o2, t;
      }, rotateY2 = function(t, a2, r2) {
        var n = -a2[0], e = -a2[1], o2 = -a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], $ = s2 * u + l2 * n + i2 * o2 - c2 * e, h = i2 * u + l2 * e + c2 * n - s2 * o2, f2 = c2 * u + l2 * o2 + s2 * e - i2 * n, M = l2 * u - s2 * n - i2 * e - c2 * o2;
        return rotateY$12(t, a2, r2), n = t[0], e = t[1], o2 = t[2], u = t[3], t[4] = $ * u + M * n + h * o2 - f2 * e, t[5] = h * u + M * e + f2 * n - $ * o2, t[6] = f2 * u + M * o2 + $ * e - h * n, t[7] = M * u - $ * n - h * e - f2 * o2, t;
      }, rotateZ2 = function(t, a2, r2) {
        var n = -a2[0], e = -a2[1], o2 = -a2[2], u = a2[3], s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], $ = s2 * u + l2 * n + i2 * o2 - c2 * e, h = i2 * u + l2 * e + c2 * n - s2 * o2, f2 = c2 * u + l2 * o2 + s2 * e - i2 * n, M = l2 * u - s2 * n - i2 * e - c2 * o2;
        return rotateZ$12(t, a2, r2), n = t[0], e = t[1], o2 = t[2], u = t[3], t[4] = $ * u + M * n + h * o2 - f2 * e, t[5] = h * u + M * e + f2 * n - $ * o2, t[6] = f2 * u + M * o2 + $ * e - h * n, t[7] = M * u - $ * n - h * e - f2 * o2, t;
      }, rotateByQuatAppend2 = function(t, a2, r2) {
        var n = r2[0], e = r2[1], o2 = r2[2], u = r2[3], s2 = a2[0], i2 = a2[1], c2 = a2[2], l2 = a2[3];
        return t[0] = s2 * u + l2 * n + i2 * o2 - c2 * e, t[1] = i2 * u + l2 * e + c2 * n - s2 * o2, t[2] = c2 * u + l2 * o2 + s2 * e - i2 * n, t[3] = l2 * u - s2 * n - i2 * e - c2 * o2, s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], t[4] = s2 * u + l2 * n + i2 * o2 - c2 * e, t[5] = i2 * u + l2 * e + c2 * n - s2 * o2, t[6] = c2 * u + l2 * o2 + s2 * e - i2 * n, t[7] = l2 * u - s2 * n - i2 * e - c2 * o2, t;
      }, rotateByQuatPrepend2 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = r2[0], i2 = r2[1], c2 = r2[2], l2 = r2[3];
        return t[0] = n * l2 + u * s2 + e * c2 - o2 * i2, t[1] = e * l2 + u * i2 + o2 * s2 - n * c2, t[2] = o2 * l2 + u * c2 + n * i2 - e * s2, t[3] = u * l2 - n * s2 - e * i2 - o2 * c2, s2 = r2[4], i2 = r2[5], c2 = r2[6], l2 = r2[7], t[4] = n * l2 + u * s2 + e * c2 - o2 * i2, t[5] = e * l2 + u * i2 + o2 * s2 - n * c2, t[6] = o2 * l2 + u * c2 + n * i2 - e * s2, t[7] = u * l2 - n * s2 - e * i2 - o2 * c2, t;
      }, rotateAroundAxis2 = function(t, a2, r2, n) {
        if (Math.abs(n) < EPSILON) return copy$12(t, a2);
        var e = Math.hypot(r2[0], r2[1], r2[2]);
        n *= 0.5;
        var o2 = Math.sin(n), u = o2 * r2[0] / e, s2 = o2 * r2[1] / e, i2 = o2 * r2[2] / e, c2 = Math.cos(n), l2 = a2[0], $ = a2[1], h = a2[2], f2 = a2[3];
        t[0] = l2 * c2 + f2 * u + $ * i2 - h * s2, t[1] = $ * c2 + f2 * s2 + h * u - l2 * i2, t[2] = h * c2 + f2 * i2 + l2 * s2 - $ * u, t[3] = f2 * c2 - l2 * u - $ * s2 - h * i2;
        var M = a2[4], m = a2[5], d2 = a2[6], v = a2[7];
        return t[4] = M * c2 + v * u + m * i2 - d2 * s2, t[5] = m * c2 + v * s2 + d2 * u - M * i2, t[6] = d2 * c2 + v * i2 + M * s2 - m * u, t[7] = v * c2 - M * u - m * s2 - d2 * i2, t;
      }, add$12 = function(t, a2, r2) {
        return t[0] = a2[0] + r2[0], t[1] = a2[1] + r2[1], t[2] = a2[2] + r2[2], t[3] = a2[3] + r2[3], t[4] = a2[4] + r2[4], t[5] = a2[5] + r2[5], t[6] = a2[6] + r2[6], t[7] = a2[7] + r2[7], t;
      }, multiply$12 = function(t, a2, r2) {
        var n = a2[0], e = a2[1], o2 = a2[2], u = a2[3], s2 = r2[4], i2 = r2[5], c2 = r2[6], l2 = r2[7], $ = a2[4], h = a2[5], f2 = a2[6], M = a2[7], m = r2[0], d2 = r2[1], v = r2[2], b = r2[3];
        return t[0] = n * b + u * m + e * v - o2 * d2, t[1] = e * b + u * d2 + o2 * m - n * v, t[2] = o2 * b + u * v + n * d2 - e * m, t[3] = u * b - n * m - e * d2 - o2 * v, t[4] = n * l2 + u * s2 + e * c2 - o2 * i2 + $ * b + M * m + h * v - f2 * d2, t[5] = e * l2 + u * i2 + o2 * s2 - n * c2 + h * b + M * d2 + f2 * m - $ * v, t[6] = o2 * l2 + u * c2 + n * i2 - e * s2 + f2 * b + M * v + $ * d2 - h * m, t[7] = u * l2 - n * s2 - e * i2 - o2 * c2 + M * b - $ * m - h * d2 - f2 * v, t;
      }, scale$12 = function(t, a2, r2) {
        return t[0] = a2[0] * r2, t[1] = a2[1] * r2, t[2] = a2[2] * r2, t[3] = a2[3] * r2, t[4] = a2[4] * r2, t[5] = a2[5] * r2, t[6] = a2[6] * r2, t[7] = a2[7] * r2, t;
      }, lerp$12 = function(t, a2, r2, n) {
        var e = 1 - n;
        return dot$1(a2, r2) < 0 && (n = -n), t[0] = a2[0] * e + r2[0] * n, t[1] = a2[1] * e + r2[1] * n, t[2] = a2[2] * e + r2[2] * n, t[3] = a2[3] * e + r2[3] * n, t[4] = a2[4] * e + r2[4] * n, t[5] = a2[5] * e + r2[5] * n, t[6] = a2[6] * e + r2[6] * n, t[7] = a2[7] * e + r2[7] * n, t;
      }, invert2 = function(t, a2) {
        var r2 = squaredLength$1(a2);
        return t[0] = -a2[0] / r2, t[1] = -a2[1] / r2, t[2] = -a2[2] / r2, t[3] = a2[3] / r2, t[4] = -a2[4] / r2, t[5] = -a2[5] / r2, t[6] = -a2[6] / r2, t[7] = a2[7] / r2, t;
      }, conjugate2 = function(t, a2) {
        return t[0] = -a2[0], t[1] = -a2[1], t[2] = -a2[2], t[3] = a2[3], t[4] = -a2[4], t[5] = -a2[5], t[6] = -a2[6], t[7] = a2[7], t;
      }, normalize$12 = function(t, a2) {
        var r2 = squaredLength$1(a2);
        if (r2 > 0) {
          r2 = Math.sqrt(r2);
          var n = a2[0] / r2, e = a2[1] / r2, o2 = a2[2] / r2, u = a2[3] / r2, s2 = a2[4], i2 = a2[5], c2 = a2[6], l2 = a2[7], $ = n * s2 + e * i2 + o2 * c2 + u * l2;
          t[0] = n, t[1] = e, t[2] = o2, t[3] = u, t[4] = (s2 - n * $) / r2, t[5] = (i2 - e * $) / r2, t[6] = (c2 - o2 * $) / r2, t[7] = (l2 - u * $) / r2;
        }
        return t;
      }, str$12 = function(t) {
        return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")";
      }, exactEquals$12 = function(t, a2) {
        return t[0] === a2[0] && t[1] === a2[1] && t[2] === a2[2] && t[3] === a2[3] && t[4] === a2[4] && t[5] === a2[5] && t[6] === a2[6] && t[7] === a2[7];
      }, equals$12 = function(t, a2) {
        var r2 = t[0], n = t[1], e = t[2], o2 = t[3], u = t[4], s2 = t[5], i2 = t[6], c2 = t[7], l2 = a2[0], $ = a2[1], h = a2[2], f2 = a2[3], M = a2[4], m = a2[5], d2 = a2[6], v = a2[7];
        return Math.abs(r2 - l2) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(l2)) && Math.abs(n - $) <= EPSILON * Math.max(1, Math.abs(n), Math.abs($)) && Math.abs(e - h) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(h)) && Math.abs(o2 - f2) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs(f2)) && Math.abs(u - M) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(M)) && Math.abs(s2 - m) <= EPSILON * Math.max(1, Math.abs(s2), Math.abs(m)) && Math.abs(i2 - d2) <= EPSILON * Math.max(1, Math.abs(i2), Math.abs(d2)) && Math.abs(c2 - v) <= EPSILON * Math.max(1, Math.abs(c2), Math.abs(v));
      }, create2 = function() {
        var t = new ARRAY_TYPE(2);
        return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0), t;
      }, clone2 = function(t) {
        var a2 = new ARRAY_TYPE(2);
        return a2[0] = t[0], a2[1] = t[1], a2;
      }, fromValues2 = function(t, a2) {
        var r2 = new ARRAY_TYPE(2);
        return r2[0] = t, r2[1] = a2, r2;
      }, copy2 = function(t, a2) {
        return t[0] = a2[0], t[1] = a2[1], t;
      }, set2 = function(t, a2, r2) {
        return t[0] = a2, t[1] = r2, t;
      }, add2 = function(t, a2, r2) {
        return t[0] = a2[0] + r2[0], t[1] = a2[1] + r2[1], t;
      }, subtract2 = function(t, a2, r2) {
        return t[0] = a2[0] - r2[0], t[1] = a2[1] - r2[1], t;
      }, multiply2 = function(t, a2, r2) {
        return t[0] = a2[0] * r2[0], t[1] = a2[1] * r2[1], t;
      }, divide2 = function(t, a2, r2) {
        return t[0] = a2[0] / r2[0], t[1] = a2[1] / r2[1], t;
      }, ceil2 = function(t, a2) {
        return t[0] = Math.ceil(a2[0]), t[1] = Math.ceil(a2[1]), t;
      }, floor2 = function(t, a2) {
        return t[0] = Math.floor(a2[0]), t[1] = Math.floor(a2[1]), t;
      }, min2 = function(t, a2, r2) {
        return t[0] = Math.min(a2[0], r2[0]), t[1] = Math.min(a2[1], r2[1]), t;
      }, max2 = function(t, a2, r2) {
        return t[0] = Math.max(a2[0], r2[0]), t[1] = Math.max(a2[1], r2[1]), t;
      }, round2 = function(t, a2) {
        return t[0] = Math.round(a2[0]), t[1] = Math.round(a2[1]), t;
      }, scale2 = function(t, a2, r2) {
        return t[0] = a2[0] * r2, t[1] = a2[1] * r2, t;
      }, scaleAndAdd2 = function(t, a2, r2, n) {
        return t[0] = a2[0] + r2[0] * n, t[1] = a2[1] + r2[1] * n, t;
      }, distance2 = function(t, a2) {
        var r2 = a2[0] - t[0], n = a2[1] - t[1];
        return Math.hypot(r2, n);
      }, squaredDistance2 = function(t, a2) {
        var r2 = a2[0] - t[0], n = a2[1] - t[1];
        return r2 * r2 + n * n;
      }, length2 = function(t) {
        var a2 = t[0], r2 = t[1];
        return Math.hypot(a2, r2);
      }, squaredLength2 = function(t) {
        var a2 = t[0], r2 = t[1];
        return a2 * a2 + r2 * r2;
      }, negate2 = function(t, a2) {
        return t[0] = -a2[0], t[1] = -a2[1], t;
      }, inverse2 = function(t, a2) {
        return t[0] = 1 / a2[0], t[1] = 1 / a2[1], t;
      }, normalize2 = function(t, a2) {
        var r2 = a2[0], n = a2[1], e = r2 * r2 + n * n;
        return e > 0 && (e = 1 / Math.sqrt(e)), t[0] = a2[0] * e, t[1] = a2[1] * e, t;
      }, dot4 = function(t, a2) {
        return t[0] * a2[0] + t[1] * a2[1];
      }, cross2 = function(t, a2, r2) {
        var n = a2[0] * r2[1] - a2[1] * r2[0];
        return t[0] = t[1] = 0, t[2] = n, t;
      }, lerp2 = function(t, a2, r2, n) {
        var e = a2[0], o2 = a2[1];
        return t[0] = e + n * (r2[0] - e), t[1] = o2 + n * (r2[1] - o2), t;
      }, random2 = function(t, a2) {
        a2 = a2 || 1;
        var r2 = 2 * RANDOM() * Math.PI;
        return t[0] = Math.cos(r2) * a2, t[1] = Math.sin(r2) * a2, t;
      }, transformMat22 = function(t, a2, r2) {
        var n = a2[0], e = a2[1];
        return t[0] = r2[0] * n + r2[2] * e, t[1] = r2[1] * n + r2[3] * e, t;
      }, transformMat2d2 = function(t, a2, r2) {
        var n = a2[0], e = a2[1];
        return t[0] = r2[0] * n + r2[2] * e + r2[4], t[1] = r2[1] * n + r2[3] * e + r2[5], t;
      }, transformMat32 = function(t, a2, r2) {
        var n = a2[0], e = a2[1];
        return t[0] = r2[0] * n + r2[3] * e + r2[6], t[1] = r2[1] * n + r2[4] * e + r2[7], t;
      }, transformMat42 = function(t, a2, r2) {
        var n = a2[0], e = a2[1];
        return t[0] = r2[0] * n + r2[4] * e + r2[12], t[1] = r2[1] * n + r2[5] * e + r2[13], t;
      }, rotate2 = function(t, a2, r2, n) {
        var e = a2[0] - r2[0], o2 = a2[1] - r2[1], u = Math.sin(n), s2 = Math.cos(n);
        return t[0] = e * s2 - o2 * u + r2[0], t[1] = e * u + o2 * s2 + r2[1], t;
      }, angle2 = function(t, a2) {
        var r2 = t[0], n = t[1], e = a2[0], o2 = a2[1], u = Math.sqrt((r2 * r2 + n * n) * (e * e + o2 * o2)), s2 = u && (r2 * e + n * o2) / u;
        return Math.acos(Math.min(Math.max(s2, -1), 1));
      }, zero2 = function(t) {
        return t[0] = 0, t[1] = 0, t;
      }, str2 = function(t) {
        return "vec2(" + t[0] + ", " + t[1] + ")";
      }, exactEquals2 = function(t, a2) {
        return t[0] === a2[0] && t[1] === a2[1];
      }, equals2 = function(t, a2) {
        var r2 = t[0], n = t[1], e = a2[0], o2 = a2[1];
        return Math.abs(r2 - e) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(e)) && Math.abs(n - o2) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(o2));
      };
      setMatrixArrayType = setMatrixArrayType2, toRadian = toRadian2, equals$9 = equals$92, create$8 = create$82, clone$8 = clone$82, copy$8 = copy$82, identity$5 = identity$52, fromValues$8 = fromValues$82, set$8 = set$82, transpose$2 = transpose$22, invert$5 = invert$52, adjoint$2 = adjoint$22, determinant$3 = determinant$32, multiply$8 = multiply$82, rotate$4 = rotate$42, scale$8 = scale$82, fromRotation$4 = fromRotation$42, fromScaling$3 = fromScaling$32, str$8 = str$82, frob$3 = frob$32, LDU = LDU2, add$8 = add$82, subtract$6 = subtract$62, exactEquals$8 = exactEquals$82, equals$8 = equals$82, multiplyScalar$3 = multiplyScalar$32, multiplyScalarAndAdd$3 = multiplyScalarAndAdd$32, create$7 = create$72, clone$7 = clone$72, copy$7 = copy$72, identity$4 = identity$42, fromValues$7 = fromValues$72, set$7 = set$72, invert$4 = invert$42, determinant$2 = determinant$22, multiply$7 = multiply$72, rotate$3 = rotate$32, scale$7 = scale$72, translate$3 = translate$32, fromRotation$3 = fromRotation$32, fromScaling$2 = fromScaling$22, fromTranslation$3 = fromTranslation$32, str$7 = str$72, frob$2 = frob$22, add$7 = add$72, subtract$5 = subtract$52, multiplyScalar$2 = multiplyScalar$22, multiplyScalarAndAdd$2 = multiplyScalarAndAdd$22, exactEquals$7 = exactEquals$72, equals$7 = equals$72, create$6 = create$62, fromMat4$1 = fromMat4$12, clone$6 = clone$62, copy$6 = copy$62, fromValues$6 = fromValues$62, set$6 = set$62, identity$3 = identity$32, transpose$1 = transpose$12, invert$3 = invert$32, adjoint$1 = adjoint$12, determinant$1 = determinant$12, multiply$6 = multiply$62, translate$2 = translate$22, rotate$2 = rotate$22, scale$6 = scale$62, fromTranslation$2 = fromTranslation$22, fromRotation$2 = fromRotation$22, fromScaling$1 = fromScaling$12, fromMat2d = fromMat2d2, fromQuat$1 = fromQuat$12, normalFromMat4 = normalFromMat42, projection = projection2, str$6 = str$62, frob$1 = frob$12, add$6 = add$62, subtract$4 = subtract$42, multiplyScalar$1 = multiplyScalar$12, multiplyScalarAndAdd$1 = multiplyScalarAndAdd$12, exactEquals$6 = exactEquals$62, equals$6 = equals$62, create$5 = create$52, clone$5 = clone$52, copy$5 = copy$52, fromValues$5 = fromValues$52, set$5 = set$52, identity$2 = identity$22, transpose = transpose2, invert$2 = invert$22, adjoint = adjoint2, determinant = determinant2, multiply$5 = multiply$52, translate$1 = translate$12, scale$5 = scale$52, rotate$1 = rotate$12, rotateX$3 = rotateX$32, rotateY$3 = rotateY$32, rotateZ$3 = rotateZ$32, fromTranslation$1 = fromTranslation$12, fromScaling = fromScaling2, fromRotation$1 = fromRotation$12, fromXRotation = fromXRotation2, fromYRotation = fromYRotation2, fromZRotation = fromZRotation2, fromRotationTranslation$1 = fromRotationTranslation$12, fromQuat2 = fromQuat22, getTranslation$1 = getTranslation$12, getScaling = getScaling2, getRotation = getRotation2, decompose = decompose2, fromRotationTranslationScale = fromRotationTranslationScale2, fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin2, fromQuat = fromQuat3, frustum = frustum2, perspectiveNO = perspectiveNO2, perspectiveZO = perspectiveZO2, perspectiveFromFieldOfView = perspectiveFromFieldOfView2, orthoNO = orthoNO2, orthoZO = orthoZO2, lookAt = lookAt2, targetTo = targetTo2, str$5 = str$52, frob = frob2, add$5 = add$52, subtract$3 = subtract$32, multiplyScalar = multiplyScalar2, multiplyScalarAndAdd = multiplyScalarAndAdd2, exactEquals$5 = exactEquals$52, equals$5 = equals$52, create$4 = create$42, clone$4 = clone$42, length$4 = length$42, fromValues$4 = fromValues$42, copy$4 = copy$42, set$4 = set$42, add$4 = add$42, subtract$2 = subtract$22, multiply$4 = multiply$42, divide$2 = divide$22, ceil$2 = ceil$22, floor$2 = floor$22, min$2 = min$22, max$2 = max$22, round$2 = round$22, scale$4 = scale$42, scaleAndAdd$2 = scaleAndAdd$22, distance$2 = distance$22, squaredDistance$2 = squaredDistance$22, squaredLength$4 = squaredLength$42, negate$2 = negate$22, inverse$2 = inverse$22, normalize$4 = normalize$42, dot$4 = dot$42, cross$2 = cross$22, lerp$4 = lerp$42, slerp$1 = slerp$12, hermite = hermite2, bezier = bezier2, random$3 = random$32, transformMat4$2 = transformMat4$22, transformMat3$1 = transformMat3$12, transformQuat$1 = transformQuat$12, rotateX$2 = rotateX$22, rotateY$2 = rotateY$22, rotateZ$2 = rotateZ$22, angle$1 = angle$12, zero$2 = zero$22, str$4 = str$42, exactEquals$4 = exactEquals$42, equals$4 = equals$42, create$3 = create$32, clone$3 = clone$32, fromValues$3 = fromValues$32, copy$3 = copy$32, set$3 = set$32, add$3 = add$32, subtract$1 = subtract$12, multiply$3 = multiply$32, divide$1 = divide$12, ceil$1 = ceil$12, floor$1 = floor$12, min$1 = min$12, max$1 = max$12, round$1 = round$12, scale$3 = scale$32, scaleAndAdd$1 = scaleAndAdd$12, distance$1 = distance$12, squaredDistance$1 = squaredDistance$12, length$3 = length$32, squaredLength$3 = squaredLength$32, negate$1 = negate$12, inverse$1 = inverse$12, normalize$3 = normalize$32, dot$3 = dot$32, cross$1 = cross$12, lerp$3 = lerp$32, random$2 = random$22, transformMat4$1 = transformMat4$12, transformQuat = transformQuat2, zero$1 = zero$12, str$3 = str$32, exactEquals$3 = exactEquals$32, equals$3 = equals$32, create$2 = create$22, identity$1 = identity$12, setAxisAngle = setAxisAngle2, getAxisAngle = getAxisAngle2, getAngle = getAngle2, multiply$2 = multiply$22, rotateX$1 = rotateX$12, rotateY$1 = rotateY$12, rotateZ$1 = rotateZ$12, calculateW = calculateW2, exp = exp2, ln = ln2, pow = pow2, slerp = slerp2, random$1 = random$12, invert$1 = invert$12, conjugate$1 = conjugate$12, fromMat3 = fromMat32, fromEuler = fromEuler2, str$2 = str$22, equals$2 = equals$22, create$1 = create$12, clone$1 = clone$12, fromValues$1 = fromValues$12, fromRotationTranslationValues = fromRotationTranslationValues2, fromRotationTranslation = fromRotationTranslation2, fromTranslation = fromTranslation2, fromRotation = fromRotation2, fromMat4 = fromMat42, copy$1 = copy$12, identity = identity2, set$1 = set$12, getDual = getDual2, setDual = setDual2, getTranslation = getTranslation2, translate = translate2, rotateX = rotateX2, rotateY = rotateY2, rotateZ = rotateZ2, rotateByQuatAppend = rotateByQuatAppend2, rotateByQuatPrepend = rotateByQuatPrepend2, rotateAroundAxis = rotateAroundAxis2, add$1 = add$12, multiply$1 = multiply$12, scale$1 = scale$12, lerp$1 = lerp$12, invert = invert2, conjugate = conjugate2, normalize$1 = normalize$12, str$1 = str$12, exactEquals$1 = exactEquals$12, equals$1 = equals$12, create = create2, clone = clone2, fromValues = fromValues2, copy = copy2, set = set2, add = add2, subtract = subtract2, multiply = multiply2, divide = divide2, ceil = ceil2, floor = floor2, min = min2, max = max2, round = round2, scale = scale2, scaleAndAdd = scaleAndAdd2, distance = distance2, squaredDistance = squaredDistance2, length = length2, squaredLength = squaredLength2, negate = negate2, inverse = inverse2, normalize = normalize2, dot = dot4, cross = cross2, lerp = lerp2, random = random2, transformMat2 = transformMat22, transformMat2d = transformMat2d2, transformMat3 = transformMat32, transformMat4 = transformMat42, rotate = rotate2, angle = angle2, zero = zero2, str = str2, exactEquals = exactEquals2, equals = equals2;
      EPSILON = 1e-6, ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, RANDOM = Math.random, ANGLE_ORDER = "zyx";
      degree = Math.PI / 180;
      Math.hypot || (Math.hypot = function() {
        for (var t = 0, a2 = arguments.length; a2--; ) t += arguments[a2] * arguments[a2];
        return Math.sqrt(t);
      });
      common = { __proto__: null, EPSILON, get ARRAY_TYPE() {
        return ARRAY_TYPE;
      }, RANDOM, ANGLE_ORDER, setMatrixArrayType: setMatrixArrayType2, toRadian: toRadian2, equals: equals$92 };
      mul$8 = multiply$82, sub$6 = subtract$62, mat2 = Object.freeze({ __proto__: null, create: create$82, clone: clone$82, copy: copy$82, identity: identity$52, fromValues: fromValues$82, set: set$82, transpose: transpose$22, invert: invert$52, adjoint: adjoint$22, determinant: determinant$32, multiply: multiply$82, rotate: rotate$42, scale: scale$82, fromRotation: fromRotation$42, fromScaling: fromScaling$32, str: str$82, frob: frob$32, LDU: LDU2, add: add$82, subtract: subtract$62, exactEquals: exactEquals$82, equals: equals$82, multiplyScalar: multiplyScalar$32, multiplyScalarAndAdd: multiplyScalarAndAdd$32, mul: mul$8, sub: sub$6 });
      mul$7 = multiply$72, sub$5 = subtract$52, mat2d = Object.freeze({ __proto__: null, create: create$72, clone: clone$72, copy: copy$72, identity: identity$42, fromValues: fromValues$72, set: set$72, invert: invert$42, determinant: determinant$22, multiply: multiply$72, rotate: rotate$32, scale: scale$72, translate: translate$32, fromRotation: fromRotation$32, fromScaling: fromScaling$22, fromTranslation: fromTranslation$32, str: str$72, frob: frob$22, add: add$72, subtract: subtract$52, multiplyScalar: multiplyScalar$22, multiplyScalarAndAdd: multiplyScalarAndAdd$22, exactEquals: exactEquals$72, equals: equals$72, mul: mul$7, sub: sub$5 });
      mul$6 = multiply$62, sub$4 = subtract$42, mat3 = Object.freeze({ __proto__: null, create: create$62, fromMat4: fromMat4$12, clone: clone$62, copy: copy$62, fromValues: fromValues$62, set: set$62, identity: identity$32, transpose: transpose$12, invert: invert$32, adjoint: adjoint$12, determinant: determinant$12, multiply: multiply$62, translate: translate$22, rotate: rotate$22, scale: scale$62, fromTranslation: fromTranslation$22, fromRotation: fromRotation$22, fromScaling: fromScaling$12, fromMat2d: fromMat2d2, fromQuat: fromQuat$12, normalFromMat4: normalFromMat42, projection: projection2, str: str$62, frob: frob$12, add: add$62, subtract: subtract$42, multiplyScalar: multiplyScalar$12, multiplyScalarAndAdd: multiplyScalarAndAdd$12, exactEquals: exactEquals$62, equals: equals$62, mul: mul$6, sub: sub$4 });
      perspective = perspectiveNO2;
      ortho = orthoNO2;
      mul$5 = multiply$52, sub$3 = subtract$32, mat4 = Object.freeze({ __proto__: null, create: create$52, clone: clone$52, copy: copy$52, fromValues: fromValues$52, set: set$52, identity: identity$22, transpose: transpose2, invert: invert$22, adjoint: adjoint2, determinant: determinant2, multiply: multiply$52, translate: translate$12, scale: scale$52, rotate: rotate$12, rotateX: rotateX$32, rotateY: rotateY$32, rotateZ: rotateZ$32, fromTranslation: fromTranslation$12, fromScaling: fromScaling2, fromRotation: fromRotation$12, fromXRotation: fromXRotation2, fromYRotation: fromYRotation2, fromZRotation: fromZRotation2, fromRotationTranslation: fromRotationTranslation$12, fromQuat2: fromQuat22, getTranslation: getTranslation$12, getScaling: getScaling2, getRotation: getRotation2, decompose: decompose2, fromRotationTranslationScale: fromRotationTranslationScale2, fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin2, fromQuat: fromQuat3, frustum: frustum2, perspectiveNO: perspectiveNO2, perspective, perspectiveZO: perspectiveZO2, perspectiveFromFieldOfView: perspectiveFromFieldOfView2, orthoNO: orthoNO2, ortho, orthoZO: orthoZO2, lookAt: lookAt2, targetTo: targetTo2, str: str$52, frob: frob2, add: add$52, subtract: subtract$32, multiplyScalar: multiplyScalar2, multiplyScalarAndAdd: multiplyScalarAndAdd2, exactEquals: exactEquals$52, equals: equals$52, mul: mul$5, sub: sub$3 });
      sub$2 = subtract$22, mul$4 = multiply$42, div$2 = divide$22, dist$2 = distance$22, sqrDist$2 = squaredDistance$22, len$4 = length$42, sqrLen$4 = squaredLength$42, forEach$2 = function() {
        var t = create$42();
        return function(a2, r2, n, e, o2, u) {
          var s2, i2;
          for (r2 || (r2 = 3), n || (n = 0), i2 = e ? Math.min(e * r2 + n, a2.length) : a2.length, s2 = n; s2 < i2; s2 += r2) t[0] = a2[s2], t[1] = a2[s2 + 1], t[2] = a2[s2 + 2], o2(t, t, u), a2[s2] = t[0], a2[s2 + 1] = t[1], a2[s2 + 2] = t[2];
          return a2;
        };
      }(), vec3 = Object.freeze({ __proto__: null, create: create$42, clone: clone$42, length: length$42, fromValues: fromValues$42, copy: copy$42, set: set$42, add: add$42, subtract: subtract$22, multiply: multiply$42, divide: divide$22, ceil: ceil$22, floor: floor$22, min: min$22, max: max$22, round: round$22, scale: scale$42, scaleAndAdd: scaleAndAdd$22, distance: distance$22, squaredDistance: squaredDistance$22, squaredLength: squaredLength$42, negate: negate$22, inverse: inverse$22, normalize: normalize$42, dot: dot$42, cross: cross$22, lerp: lerp$42, slerp: slerp$12, hermite: hermite2, bezier: bezier2, random: random$32, transformMat4: transformMat4$22, transformMat3: transformMat3$12, transformQuat: transformQuat$12, rotateX: rotateX$22, rotateY: rotateY$22, rotateZ: rotateZ$22, angle: angle$12, zero: zero$22, str: str$42, exactEquals: exactEquals$42, equals: equals$42, sub: sub$2, mul: mul$4, div: div$2, dist: dist$2, sqrDist: sqrDist$2, len: len$4, sqrLen: sqrLen$4, forEach: forEach$2 });
      sub$1 = subtract$12, mul$3 = multiply$32, div$1 = divide$12, dist$1 = distance$12, sqrDist$1 = squaredDistance$12, len$3 = length$32, sqrLen$3 = squaredLength$32, forEach$1 = function() {
        var t = create$32();
        return function(a2, r2, n, e, o2, u) {
          var s2, i2;
          for (r2 || (r2 = 4), n || (n = 0), i2 = e ? Math.min(e * r2 + n, a2.length) : a2.length, s2 = n; s2 < i2; s2 += r2) t[0] = a2[s2], t[1] = a2[s2 + 1], t[2] = a2[s2 + 2], t[3] = a2[s2 + 3], o2(t, t, u), a2[s2] = t[0], a2[s2 + 1] = t[1], a2[s2 + 2] = t[2], a2[s2 + 3] = t[3];
          return a2;
        };
      }(), vec4 = Object.freeze({ __proto__: null, create: create$32, clone: clone$32, fromValues: fromValues$32, copy: copy$32, set: set$32, add: add$32, subtract: subtract$12, multiply: multiply$32, divide: divide$12, ceil: ceil$12, floor: floor$12, min: min$12, max: max$12, round: round$12, scale: scale$32, scaleAndAdd: scaleAndAdd$12, distance: distance$12, squaredDistance: squaredDistance$12, length: length$32, squaredLength: squaredLength$32, negate: negate$12, inverse: inverse$12, normalize: normalize$32, dot: dot$32, cross: cross$12, lerp: lerp$32, random: random$22, transformMat4: transformMat4$12, transformQuat: transformQuat2, zero: zero$12, str: str$32, exactEquals: exactEquals$32, equals: equals$32, sub: sub$1, mul: mul$3, div: div$1, dist: dist$1, sqrDist: sqrDist$1, len: len$3, sqrLen: sqrLen$3, forEach: forEach$1 });
      clone$2 = clone$32, fromValues$2 = fromValues$32, copy$2 = copy$32, set$2 = set$32, add$2 = add$32, mul$2 = multiply$22, scale$2 = scale$32, dot$2 = dot$32, lerp$2 = lerp$32, length$2 = length$32, len$2 = length$2, squaredLength$2 = squaredLength$32, sqrLen$2 = squaredLength$2, normalize$2 = normalize$32, exactEquals$2 = exactEquals$32;
      rotationTo = function() {
        var t = create$42(), a2 = fromValues$42(1, 0, 0), r2 = fromValues$42(0, 1, 0);
        return function(n, e, o2) {
          var u = dot$42(e, o2);
          return u < -0.999999 ? (cross$22(t, a2, e), len$4(t) < 1e-6 && cross$22(t, r2, e), normalize$42(t, t), setAxisAngle2(n, t, Math.PI), n) : u > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (cross$22(t, e, o2), n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = 1 + u, normalize$2(n, n));
        };
      }(), sqlerp = function() {
        var t = create$22(), a2 = create$22();
        return function(r2, n, e, o2, u, s2) {
          return slerp2(t, n, u, s2), slerp2(a2, e, o2, s2), slerp2(r2, t, a2, 2 * s2 * (1 - s2)), r2;
        };
      }(), setAxes = function() {
        var t = create$62();
        return function(a2, r2, n, e) {
          return t[0] = n[0], t[3] = n[1], t[6] = n[2], t[1] = e[0], t[4] = e[1], t[7] = e[2], t[2] = -r2[0], t[5] = -r2[1], t[8] = -r2[2], normalize$2(a2, fromMat32(a2, t));
        };
      }(), quat = Object.freeze({ __proto__: null, create: create$22, identity: identity$12, setAxisAngle: setAxisAngle2, getAxisAngle: getAxisAngle2, getAngle: getAngle2, multiply: multiply$22, rotateX: rotateX$12, rotateY: rotateY$12, rotateZ: rotateZ$12, calculateW: calculateW2, exp: exp2, ln: ln2, pow: pow2, slerp: slerp2, random: random$12, invert: invert$12, conjugate: conjugate$12, fromMat3: fromMat32, fromEuler: fromEuler2, str: str$22, clone: clone$2, fromValues: fromValues$2, copy: copy$2, set: set$2, add: add$2, mul: mul$2, scale: scale$2, dot: dot$2, lerp: lerp$2, length: length$2, len: len$2, squaredLength: squaredLength$2, sqrLen: sqrLen$2, normalize: normalize$2, exactEquals: exactEquals$2, equals: equals$22, rotationTo, sqlerp, setAxes });
      getReal = copy$2;
      setReal = copy$2;
      mul$1 = multiply$12;
      dot$1 = dot$2;
      length$1 = length$2, len$1 = length$1, squaredLength$1 = squaredLength$2, sqrLen$1 = squaredLength$1;
      quat2 = Object.freeze({ __proto__: null, create: create$12, clone: clone$12, fromValues: fromValues$12, fromRotationTranslationValues: fromRotationTranslationValues2, fromRotationTranslation: fromRotationTranslation2, fromTranslation: fromTranslation2, fromRotation: fromRotation2, fromMat4: fromMat42, copy: copy$12, identity: identity2, set: set$12, getReal, getDual: getDual2, setReal, setDual: setDual2, getTranslation: getTranslation2, translate: translate2, rotateX: rotateX2, rotateY: rotateY2, rotateZ: rotateZ2, rotateByQuatAppend: rotateByQuatAppend2, rotateByQuatPrepend: rotateByQuatPrepend2, rotateAroundAxis: rotateAroundAxis2, add: add$12, multiply: multiply$12, mul: mul$1, scale: scale$12, dot: dot$1, lerp: lerp$12, invert: invert2, conjugate: conjugate2, length: length$1, len: len$1, squaredLength: squaredLength$1, sqrLen: sqrLen$1, normalize: normalize$12, str: str$12, exactEquals: exactEquals$12, equals: equals$12 });
      len = length2, sub = subtract2, mul = multiply2, div = divide2, dist = distance2, sqrDist = squaredDistance2, sqrLen = squaredLength2, forEach = function() {
        var t = create2();
        return function(a2, r2, n, e, o2, u) {
          var s2, i2;
          for (r2 || (r2 = 2), n || (n = 0), i2 = e ? Math.min(e * r2 + n, a2.length) : a2.length, s2 = n; s2 < i2; s2 += r2) t[0] = a2[s2], t[1] = a2[s2 + 1], o2(t, t, u), a2[s2] = t[0], a2[s2 + 1] = t[1];
          return a2;
        };
      }(), vec2 = Object.freeze({ __proto__: null, create: create2, clone: clone2, fromValues: fromValues2, copy: copy2, set: set2, add: add2, subtract: subtract2, multiply: multiply2, divide: divide2, ceil: ceil2, floor: floor2, min: min2, max: max2, round: round2, scale: scale2, scaleAndAdd: scaleAndAdd2, distance: distance2, squaredDistance: squaredDistance2, length: length2, squaredLength: squaredLength2, negate: negate2, inverse: inverse2, normalize: normalize2, dot: dot4, cross: cross2, lerp: lerp2, random: random2, transformMat2: transformMat22, transformMat2d: transformMat2d2, transformMat3: transformMat32, transformMat4: transformMat42, rotate: rotate2, angle: angle2, zero: zero2, str: str2, exactEquals: exactEquals2, equals: equals2, len, sub, mul, div, dist, sqrDist, sqrLen, forEach });
      globalThis.glMatrix = common, globalThis.glMatrix.mat2 = mat2, globalThis.glMatrix.mat2d = mat2d, globalThis.glMatrix.mat3 = mat3, globalThis.glMatrix.mat4 = mat4, globalThis.glMatrix.quat = quat, globalThis.glMatrix.quat2 = quat2, globalThis.glMatrix.vec2 = vec2, globalThis.glMatrix.vec3 = vec3, globalThis.glMatrix.vec4 = vec4;
    }
    var EPSILON;
    var ARRAY_TYPE;
    var RANDOM;
    var ANGLE_ORDER;
    var degree;
    var common;
    var mul$8;
    var sub$6;
    var mat2;
    var mul$7;
    var sub$5;
    var mat2d;
    var mul$6;
    var sub$4;
    var mat3;
    var perspective;
    var ortho;
    var mul$5;
    var sub$3;
    var mat4;
    var sub$2;
    var mul$4;
    var div$2;
    var dist$2;
    var sqrDist$2;
    var len$4;
    var sqrLen$4;
    var forEach$2;
    var vec3;
    var sub$1;
    var mul$3;
    var div$1;
    var dist$1;
    var sqrDist$1;
    var len$3;
    var sqrLen$3;
    var forEach$1;
    var vec4;
    var clone$2;
    var fromValues$2;
    var copy$2;
    var set$2;
    var add$2;
    var mul$2;
    var scale$2;
    var dot$2;
    var lerp$2;
    var length$2;
    var len$2;
    var squaredLength$2;
    var sqrLen$2;
    var normalize$2;
    var exactEquals$2;
    var rotationTo;
    var sqlerp;
    var setAxes;
    var quat;
    var getReal;
    var setReal;
    var mul$1;
    var dot$1;
    var length$1;
    var len$1;
    var squaredLength$1;
    var sqrLen$1;
    var quat2;
    var len;
    var sub;
    var mul;
    var div;
    var dist;
    var sqrDist;
    var sqrLen;
    var forEach;
    var vec2;
    var setMatrixArrayType;
    var toRadian;
    var equals$9;
    var create$8;
    var clone$8;
    var copy$8;
    var identity$5;
    var fromValues$8;
    var set$8;
    var transpose$2;
    var invert$5;
    var adjoint$2;
    var determinant$3;
    var multiply$8;
    var rotate$4;
    var scale$8;
    var fromRotation$4;
    var fromScaling$3;
    var str$8;
    var frob$3;
    var LDU;
    var add$8;
    var subtract$6;
    var exactEquals$8;
    var equals$8;
    var multiplyScalar$3;
    var multiplyScalarAndAdd$3;
    var create$7;
    var clone$7;
    var copy$7;
    var identity$4;
    var fromValues$7;
    var set$7;
    var invert$4;
    var determinant$2;
    var multiply$7;
    var rotate$3;
    var scale$7;
    var translate$3;
    var fromRotation$3;
    var fromScaling$2;
    var fromTranslation$3;
    var str$7;
    var frob$2;
    var add$7;
    var subtract$5;
    var multiplyScalar$2;
    var multiplyScalarAndAdd$2;
    var exactEquals$7;
    var equals$7;
    var create$6;
    var fromMat4$1;
    var clone$6;
    var copy$6;
    var fromValues$6;
    var set$6;
    var identity$3;
    var transpose$1;
    var invert$3;
    var adjoint$1;
    var determinant$1;
    var multiply$6;
    var translate$2;
    var rotate$2;
    var scale$6;
    var fromTranslation$2;
    var fromRotation$2;
    var fromScaling$1;
    var fromMat2d;
    var fromQuat$1;
    var normalFromMat4;
    var projection;
    var str$6;
    var frob$1;
    var add$6;
    var subtract$4;
    var multiplyScalar$1;
    var multiplyScalarAndAdd$1;
    var exactEquals$6;
    var equals$6;
    var create$5;
    var clone$5;
    var copy$5;
    var fromValues$5;
    var set$5;
    var identity$2;
    var transpose;
    var invert$2;
    var adjoint;
    var determinant;
    var multiply$5;
    var translate$1;
    var scale$5;
    var rotate$1;
    var rotateX$3;
    var rotateY$3;
    var rotateZ$3;
    var fromTranslation$1;
    var fromScaling;
    var fromRotation$1;
    var fromXRotation;
    var fromYRotation;
    var fromZRotation;
    var fromRotationTranslation$1;
    var fromQuat2;
    var getTranslation$1;
    var getScaling;
    var getRotation;
    var decompose;
    var fromRotationTranslationScale;
    var fromRotationTranslationScaleOrigin;
    var fromQuat;
    var frustum;
    var perspectiveNO;
    var perspectiveZO;
    var perspectiveFromFieldOfView;
    var orthoNO;
    var orthoZO;
    var lookAt;
    var targetTo;
    var str$5;
    var frob;
    var add$5;
    var subtract$3;
    var multiplyScalar;
    var multiplyScalarAndAdd;
    var exactEquals$5;
    var equals$5;
    var create$4;
    var clone$4;
    var length$4;
    var fromValues$4;
    var copy$4;
    var set$4;
    var add$4;
    var subtract$2;
    var multiply$4;
    var divide$2;
    var ceil$2;
    var floor$2;
    var min$2;
    var max$2;
    var round$2;
    var scale$4;
    var scaleAndAdd$2;
    var distance$2;
    var squaredDistance$2;
    var squaredLength$4;
    var negate$2;
    var inverse$2;
    var normalize$4;
    var dot$4;
    var cross$2;
    var lerp$4;
    var slerp$1;
    var hermite;
    var bezier;
    var random$3;
    var transformMat4$2;
    var transformMat3$1;
    var transformQuat$1;
    var rotateX$2;
    var rotateY$2;
    var rotateZ$2;
    var angle$1;
    var zero$2;
    var str$4;
    var exactEquals$4;
    var equals$4;
    var create$3;
    var clone$3;
    var fromValues$3;
    var copy$3;
    var set$3;
    var add$3;
    var subtract$1;
    var multiply$3;
    var divide$1;
    var ceil$1;
    var floor$1;
    var min$1;
    var max$1;
    var round$1;
    var scale$3;
    var scaleAndAdd$1;
    var distance$1;
    var squaredDistance$1;
    var length$3;
    var squaredLength$3;
    var negate$1;
    var inverse$1;
    var normalize$3;
    var dot$3;
    var cross$1;
    var lerp$3;
    var random$2;
    var transformMat4$1;
    var transformQuat;
    var zero$1;
    var str$3;
    var exactEquals$3;
    var equals$3;
    var create$2;
    var identity$1;
    var setAxisAngle;
    var getAxisAngle;
    var getAngle;
    var multiply$2;
    var rotateX$1;
    var rotateY$1;
    var rotateZ$1;
    var calculateW;
    var exp;
    var ln;
    var pow;
    var slerp;
    var random$1;
    var invert$1;
    var conjugate$1;
    var fromMat3;
    var fromEuler;
    var str$2;
    var equals$2;
    var create$1;
    var clone$1;
    var fromValues$1;
    var fromRotationTranslationValues;
    var fromRotationTranslation;
    var fromTranslation;
    var fromRotation;
    var fromMat4;
    var copy$1;
    var identity;
    var set$1;
    var getDual;
    var setDual;
    var getTranslation;
    var translate;
    var rotateX;
    var rotateY;
    var rotateZ;
    var rotateByQuatAppend;
    var rotateByQuatPrepend;
    var rotateAroundAxis;
    var add$1;
    var multiply$1;
    var scale$1;
    var lerp$1;
    var invert;
    var conjugate;
    var normalize$1;
    var str$1;
    var exactEquals$1;
    var equals$1;
    var create;
    var clone;
    var fromValues;
    var copy;
    var set;
    var add;
    var subtract;
    var multiply;
    var divide;
    var ceil;
    var floor;
    var min;
    var max;
    var round;
    var scale;
    var scaleAndAdd;
    var distance;
    var squaredDistance;
    var length;
    var squaredLength;
    var negate;
    var inverse;
    var normalize;
    var dot;
    var cross;
    var lerp;
    var random;
    var transformMat2;
    var transformMat2d;
    var transformMat3;
    var transformMat4;
    var rotate;
    var angle;
    var zero;
    var str;
    var exactEquals;
    var equals;
    {
      let lineInt2 = function(o2, n, t) {
        t = t || 0;
        var e, l2, p, g, r2, i2, y, u = [0, 0];
        return e = o2[1][1] - o2[0][1], l2 = o2[0][0] - o2[1][0], p = e * o2[0][0] + l2 * o2[0][1], g = n[1][1] - n[0][1], r2 = n[0][0] - n[1][0], i2 = g * n[0][0] + r2 * n[0][1], scalar_eq2(y = e * r2 - g * l2, 0, t) || (u[0] = (r2 * p - l2 * i2) / y, u[1] = (e * i2 - g * p) / y), u;
      }, lineSegmentsIntersect2 = function(o2, n, t, e) {
        var l2 = n[0] - o2[0], p = n[1] - o2[1], g = e[0] - t[0], r2 = e[1] - t[1];
        if (g * p - r2 * l2 === 0) return false;
        var i2 = (l2 * (t[1] - o2[1]) + p * (o2[0] - t[0])) / (g * p - r2 * l2), y = (g * (o2[1] - t[1]) + r2 * (t[0] - o2[0])) / (r2 * l2 - g * p);
        return i2 >= 0 && i2 <= 1 && y >= 0 && y <= 1;
      }, triangleArea2 = function(o2, n, t) {
        return (n[0] - o2[0]) * (t[1] - o2[1]) - (t[0] - o2[0]) * (n[1] - o2[1]);
      }, isLeft2 = function(o2, n, t) {
        return triangleArea2(o2, n, t) > 0;
      }, isLeftOn2 = function(o2, n, t) {
        return triangleArea2(o2, n, t) >= 0;
      }, isRight2 = function(o2, n, t) {
        return triangleArea2(o2, n, t) < 0;
      }, isRightOn2 = function(o2, n, t) {
        return triangleArea2(o2, n, t) <= 0;
      }, collinear2 = function(o2, n, t, e) {
        if (e) {
          var l2 = tmpPoint1, p = tmpPoint2;
          l2[0] = n[0] - o2[0], l2[1] = n[1] - o2[1], p[0] = t[0] - n[0], p[1] = t[1] - n[1];
          var g = l2[0] * p[0] + l2[1] * p[1], r2 = Math.sqrt(l2[0] * l2[0] + l2[1] * l2[1]), i2 = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
          return Math.acos(g / (r2 * i2)) < e;
        }
        return 0 === triangleArea2(o2, n, t);
      }, sqdist2 = function(o2, n) {
        var t = n[0] - o2[0], e = n[1] - o2[1];
        return t * t + e * e;
      }, polygonAt2 = function(o2, n) {
        var t = o2.length;
        return o2[n < 0 ? n % t + t : n % t];
      }, polygonClear2 = function(o2) {
        o2.length = 0;
      }, polygonAppend2 = function(o2, n, t, e) {
        for (var l2 = t; l2 < e; l2++) o2.push(n[l2]);
      }, polygonMakeCCW2 = function(o2) {
        for (var n = 0, t = o2, e = 1; e < o2.length; ++e) (t[e][1] < t[n][1] || t[e][1] === t[n][1] && t[e][0] > t[n][0]) && (n = e);
        return !isLeft2(polygonAt2(o2, n - 1), polygonAt2(o2, n), polygonAt2(o2, n + 1)) && (polygonReverse2(o2), true);
      }, polygonReverse2 = function(o2) {
        for (var n = [], t = o2.length, e = 0; e !== t; e++) n.push(o2.pop());
        for (e = 0; e !== t; e++) o2[e] = n[e];
      }, polygonIsReflex2 = function(o2, n) {
        return isRight2(polygonAt2(o2, n - 1), polygonAt2(o2, n), polygonAt2(o2, n + 1));
      }, polygonCanSee3 = function(o2, n, t) {
        var e, l2, p = tmpLine1, g = tmpLine2;
        if (isLeftOn2(polygonAt2(o2, n + 1), polygonAt2(o2, n), polygonAt2(o2, t)) && isRightOn2(polygonAt2(o2, n - 1), polygonAt2(o2, n), polygonAt2(o2, t))) return false;
        l2 = sqdist2(polygonAt2(o2, n), polygonAt2(o2, t));
        for (var r2 = 0; r2 !== o2.length; ++r2) if ((r2 + 1) % o2.length !== n && r2 !== n && isLeftOn2(polygonAt2(o2, n), polygonAt2(o2, t), polygonAt2(o2, r2 + 1)) && isRightOn2(polygonAt2(o2, n), polygonAt2(o2, t), polygonAt2(o2, r2)) && (p[0] = polygonAt2(o2, n), p[1] = polygonAt2(o2, t), g[0] = polygonAt2(o2, r2), g[1] = polygonAt2(o2, r2 + 1), e = lineInt2(p, g), sqdist2(polygonAt2(o2, n), e) < l2)) return false;
        return true;
      }, polygonCanSee22 = function(o2, n, t) {
        for (var e = 0; e !== o2.length; ++e) if (e !== n && e !== t && (e + 1) % o2.length !== n && (e + 1) % o2.length !== t && lineSegmentsIntersect2(polygonAt2(o2, n), polygonAt2(o2, t), polygonAt2(o2, e), polygonAt2(o2, e + 1))) return false;
        return true;
      }, polygonCopy2 = function(o2, n, t, e) {
        var l2 = e || [];
        if (polygonClear2(l2), n < t) for (var p = n; p <= t; p++) l2.push(o2[p]);
        else {
          for (p = 0; p <= t; p++) l2.push(o2[p]);
          for (p = n; p < o2.length; p++) l2.push(o2[p]);
        }
        return l2;
      }, polygonGetCutEdges2 = function(o2) {
        for (var n = [], t = [], e = [], l2 = [], p = Number.MAX_VALUE, g = 0; g < o2.length; ++g) if (polygonIsReflex2(o2, g)) {
          for (var r2 = 0; r2 < o2.length; ++r2) if (polygonCanSee3(o2, g, r2)) {
            t = polygonGetCutEdges2(polygonCopy2(o2, g, r2, l2)), e = polygonGetCutEdges2(polygonCopy2(o2, r2, g, l2));
            for (var i2 = 0; i2 < e.length; i2++) t.push(e[i2]);
            t.length < p && (n = t, p = t.length, n.push([polygonAt2(o2, g), polygonAt2(o2, r2)]));
          }
        }
        return n;
      }, polygonDecomp2 = function(o2) {
        var n = polygonGetCutEdges2(o2);
        return n.length > 0 ? polygonSlice2(o2, n) : [o2];
      }, polygonSlice2 = function(o2, n) {
        if (0 === n.length) return [o2];
        if (n instanceof Array && n.length && n[0] instanceof Array && 2 === n[0].length && n[0][0] instanceof Array) {
          for (var t = [o2], e = 0; e < n.length; e++) for (var l2 = n[e], p = 0; p < t.length; p++) {
            var g = polygonSlice2(t[p], l2);
            if (g) {
              t.splice(p, 1), t.push(g[0], g[1]);
              break;
            }
          }
          return t;
        }
        l2 = n, e = o2.indexOf(l2[0]), p = o2.indexOf(l2[1]);
        return -1 !== e && -1 !== p && [polygonCopy2(o2, e, p), polygonCopy2(o2, p, e)];
      }, polygonIsSimple2 = function(o2) {
        var n, t = o2;
        for (n = 0; n < t.length - 1; n++) for (var e = 0; e < n - 1; e++) if (lineSegmentsIntersect2(t[n], t[n + 1], t[e], t[e + 1])) return false;
        for (n = 1; n < t.length - 2; n++) if (lineSegmentsIntersect2(t[0], t[t.length - 1], t[n], t[n + 1])) return false;
        return true;
      }, getIntersectionPoint2 = function(o2, n, t, e, l2) {
        l2 = l2 || 0;
        var p = n[1] - o2[1], g = o2[0] - n[0], r2 = p * o2[0] + g * o2[1], i2 = e[1] - t[1], y = t[0] - e[0], u = i2 * t[0] + y * t[1], s2 = p * y - i2 * g;
        return scalar_eq2(s2, 0, l2) ? [0, 0] : [(y * r2 - g * u) / s2, (p * u - i2 * r2) / s2];
      }, polygonQuickDecomp2 = function(o2, n, t, e, l2, p, g) {
        p = p || 100, g = g || 0, l2 = l2 || 25, n = void 0 !== n ? n : [], t = t || [], e = e || [];
        var r2 = [0, 0], i2 = [0, 0], y = [0, 0], u = 0, s2 = 0, A = 0, a2 = 0, f2 = 0, c2 = 0, h = 0, v = [], m = [], d2 = o2, C = o2;
        if (C.length < 3) return n;
        if (++g > p) return console.warn("quickDecomp: max level (" + p + ") reached."), n;
        for (var R = 0; R < o2.length; ++R) if (polygonIsReflex2(d2, R)) {
          t.push(d2[R]), u = s2 = Number.MAX_VALUE;
          for (var q = 0; q < o2.length; ++q) isLeft2(polygonAt2(d2, R - 1), polygonAt2(d2, R), polygonAt2(d2, q)) && isRightOn2(polygonAt2(d2, R - 1), polygonAt2(d2, R), polygonAt2(d2, q - 1)) && (y = getIntersectionPoint2(polygonAt2(d2, R - 1), polygonAt2(d2, R), polygonAt2(d2, q), polygonAt2(d2, q - 1)), isRight2(polygonAt2(d2, R + 1), polygonAt2(d2, R), y) && (A = sqdist2(d2[R], y)) < s2 && (s2 = A, i2 = y, c2 = q)), isLeft2(polygonAt2(d2, R + 1), polygonAt2(d2, R), polygonAt2(d2, q + 1)) && isRightOn2(polygonAt2(d2, R + 1), polygonAt2(d2, R), polygonAt2(d2, q)) && (y = getIntersectionPoint2(polygonAt2(d2, R + 1), polygonAt2(d2, R), polygonAt2(d2, q), polygonAt2(d2, q + 1)), isLeft2(polygonAt2(d2, R - 1), polygonAt2(d2, R), y) && (A = sqdist2(d2[R], y)) < u && (u = A, r2 = y, f2 = q));
          if (c2 === (f2 + 1) % o2.length) y[0] = (i2[0] + r2[0]) / 2, y[1] = (i2[1] + r2[1]) / 2, e.push(y), R < f2 ? (polygonAppend2(v, d2, R, f2 + 1), v.push(y), m.push(y), 0 !== c2 && polygonAppend2(m, d2, c2, d2.length), polygonAppend2(m, d2, 0, R + 1)) : (0 !== R && polygonAppend2(v, d2, R, d2.length), polygonAppend2(v, d2, 0, f2 + 1), v.push(y), m.push(y), polygonAppend2(m, d2, c2, R + 1));
          else {
            if (c2 > f2 && (f2 += o2.length), a2 = Number.MAX_VALUE, f2 < c2) return n;
            for (q = c2; q <= f2; ++q) isLeftOn2(polygonAt2(d2, R - 1), polygonAt2(d2, R), polygonAt2(d2, q)) && isRightOn2(polygonAt2(d2, R + 1), polygonAt2(d2, R), polygonAt2(d2, q)) && (A = sqdist2(polygonAt2(d2, R), polygonAt2(d2, q))) < a2 && polygonCanSee22(d2, R, q) && (a2 = A, h = q % o2.length);
            R < h ? (polygonAppend2(v, d2, R, h + 1), 0 !== h && polygonAppend2(m, d2, h, C.length), polygonAppend2(m, d2, 0, R + 1)) : (0 !== R && polygonAppend2(v, d2, R, C.length), polygonAppend2(v, d2, 0, h + 1), polygonAppend2(m, d2, h, R + 1));
          }
          return v.length < m.length ? (polygonQuickDecomp2(v, n, t, e, l2, p, g), polygonQuickDecomp2(m, n, t, e, l2, p, g)) : (polygonQuickDecomp2(m, n, t, e, l2, p, g), polygonQuickDecomp2(v, n, t, e, l2, p, g)), n;
        }
        return n.push(o2), n;
      }, polygonRemoveCollinearPoints2 = function(o2, n) {
        for (var t = 0, e = o2.length - 1; o2.length > 3 && e >= 0; --e) collinear2(polygonAt2(o2, e - 1), polygonAt2(o2, e), polygonAt2(o2, e + 1), n) && (o2.splice(e % o2.length, 1), t++);
        return t;
      }, polygonRemoveDuplicatePoints2 = function(o2, n) {
        for (var t = o2.length - 1; t >= 1; --t) for (var e = o2[t], l2 = t - 1; l2 >= 0; --l2) points_eq2(e, o2[l2], n) && o2.splice(t, 1);
      }, scalar_eq2 = function(o2, n, t) {
        return t = t || 0, Math.abs(o2 - n) <= t;
      }, points_eq2 = function(o2, n, t) {
        return scalar_eq2(o2[0], n[0], t) && scalar_eq2(o2[1], n[1], t);
      };
      lineInt = lineInt2, lineSegmentsIntersect = lineSegmentsIntersect2, triangleArea = triangleArea2, isLeft = isLeft2, isLeftOn = isLeftOn2, isRight = isRight2, isRightOn = isRightOn2, collinear = collinear2, sqdist = sqdist2, polygonAt = polygonAt2, polygonClear = polygonClear2, polygonAppend = polygonAppend2, polygonMakeCCW = polygonMakeCCW2, polygonReverse = polygonReverse2, polygonIsReflex = polygonIsReflex2, polygonCanSee = polygonCanSee3, polygonCanSee2 = polygonCanSee22, polygonCopy = polygonCopy2, polygonGetCutEdges = polygonGetCutEdges2, polygonDecomp = polygonDecomp2, polygonSlice = polygonSlice2, polygonIsSimple = polygonIsSimple2, getIntersectionPoint = getIntersectionPoint2, polygonQuickDecomp = polygonQuickDecomp2, polygonRemoveCollinearPoints = polygonRemoveCollinearPoints2, polygonRemoveDuplicatePoints = polygonRemoveDuplicatePoints2, scalar_eq = scalar_eq2, points_eq = points_eq2;
      tmpPoint1 = [], tmpPoint2 = [];
      tmpLine1 = [], tmpLine2 = [];
      self.polyDecomp = { decomp: polygonDecomp2, quickDecomp: polygonQuickDecomp2, isSimple: polygonIsSimple2, removeCollinearPoints: polygonRemoveCollinearPoints2, removeDuplicatePoints: polygonRemoveDuplicatePoints2, makeCCW: polygonMakeCCW2 };
    }
    var tmpPoint1;
    var tmpPoint2;
    var tmpLine1;
    var tmpLine2;
    var lineInt;
    var lineSegmentsIntersect;
    var triangleArea;
    var isLeft;
    var isLeftOn;
    var isRight;
    var isRightOn;
    var collinear;
    var sqdist;
    var polygonAt;
    var polygonClear;
    var polygonAppend;
    var polygonMakeCCW;
    var polygonReverse;
    var polygonIsReflex;
    var polygonCanSee;
    var polygonCanSee2;
    var polygonCopy;
    var polygonGetCutEdges;
    var polygonDecomp;
    var polygonSlice;
    var polygonIsSimple;
    var getIntersectionPoint;
    var polygonQuickDecomp;
    var polygonRemoveCollinearPoints;
    var polygonRemoveDuplicatePoints;
    var scalar_eq;
    var points_eq;
    {
      let isReady = false, hasAppStarted = false, buildMode = "dev";
      const internalApiToken = Symbol("Construct internal API token");
      let internalApiTokenAccessesRemaining = 16;
      const C33 = self.C3 = class {
        constructor() {
          throw TypeError("static class can't be instantiated");
        }
        static _GetInternalAPIToken() {
          if (internalApiTokenAccessesRemaining <= 0) throw new Error("cannot obtain internal API token");
          return --internalApiTokenAccessesRemaining, internalApiToken;
        }
        static SetReady() {
          isReady = true;
        }
        static IsReady() {
          return isReady;
        }
        static SetAppStarted() {
          hasAppStarted = true;
        }
        static HasAppStarted() {
          return hasAppStarted;
        }
        static SetBuildMode(e) {
          buildMode = e;
        }
        static GetBuildMode() {
          return buildMode;
        }
        static IsReleaseBuild() {
          return "final" === buildMode;
        }
      };
      C33.isDebug = false, C33.isDebugDefend = false, C33.hardwareConcurrency = navigator.hardwareConcurrency || 2, self.C3X = {};
    }
    {
      const C33 = self.C3;
      C33.QueryParser = class {
        constructor(e) {
          this._queryString = e, this._parameters = /* @__PURE__ */ new Map(), this._Parse();
        }
        _Parse() {
          let e = this._queryString;
          (e.startsWith("?") || e.startsWith("#")) && (e = e.substr(1));
          const r2 = e.split("&");
          for (const e2 of r2) this._ParseParameter(e2);
        }
        _ParseParameter(e) {
          if (!e) return;
          if (!e.includes("=")) return void this._parameters.set(e, null);
          const r2 = e.indexOf("="), t = decodeURIComponent(e.substring(0, r2)), s2 = decodeURIComponent(e.substring(r2 + 1));
          this._parameters.set(t, s2);
        }
        LogAll() {
          for (const e of this._parameters) console.log("[QueryParser] Parameter '" + e[0] + "' = " + (null === e[1] ? "null" : "'" + e[1] + "'"));
        }
        Has(e) {
          return this._parameters.has(e);
        }
        Get(e) {
          const r2 = this._parameters.get(e);
          return void 0 === r2 ? null : r2;
        }
        ClearHash() {
          history.replaceState("", document.title, location.pathname + location.search);
        }
        Reparse(e) {
          this._queryString = e, this._parameters.clear(), this._Parse();
        }
      }, C33.QueryString = new C33.QueryParser(location.search), C33.LocationHashString = new C33.QueryParser(location.hash), C33.QueryString.Has("perf") && (C33.isPerformanceProfiling = true), "dev" !== C33.QueryString.Get("mode") && C33.SetBuildMode("final");
    }
    {
      let GetWindowsNTVersionName2 = function(r2) {
        const o2 = parseFloat(r2), e = windowsNTVerMap.get(o2);
        return e || (o2 >= 13 ? "11" : "NT " + r2);
      };
      GetWindowsNTVersionName = GetWindowsNTVersionName2;
      const C33 = self.C3, UNKNOWN = "(unknown)";
      C33.Platform = { OS: UNKNOWN, OSVersion: UNKNOWN, Browser: UNKNOWN, BrowserVersion: UNKNOWN, BrowserVersionNumber: NaN, BrowserEngine: UNKNOWN, Context: "browser", IsDesktop: true, IsMobile: false, IsAppleOS: false, IsIpadOS: false, GetDetailedInfo: async () => {
      } };
      const windowsNTVerMap = /* @__PURE__ */ new Map([[5, "2000"], [5.1, "XP"], [5.2, "XP"], [6, "Vista"], [6.1, "7"], [6.2, "8"], [6.3, "8.1"], [10, "10"]]);
      const uaStr = navigator.userAgent, uaData = navigator["userAgentData"];
      if (uaData && uaData["brands"].length > 0) {
        let ReadBrandList2 = function(e2) {
          let t = "", a2 = "", s2 = "", n = "";
          for (const i2 of e2) {
            const e3 = r2.get(i2["brand"]);
            !t && e3 && (t = e3, a2 = i2["version"]);
            const m = o2.get(i2["brand"]);
            !s2 && m && (s2 = m, n = i2["version"]);
          }
          t || "Chromium" !== s2 || (C33.Platform.Browser = "Chromium", C33.Platform.BrowserVersion = n), C33.Platform.Browser = t || UNKNOWN, C33.Platform.BrowserVersion = a2 || UNKNOWN, C33.Platform.BrowserEngine = s2 || UNKNOWN;
        };
        ReadBrandList = ReadBrandList2;
        C33.Platform.OS = uaData["platform"], C33.Platform.IsMobile = uaData["mobile"], C33.Platform.IsDesktop = !C33.Platform.IsMobile;
        const r2 = /* @__PURE__ */ new Map([["Google Chrome", "Chrome"], ["Microsoft Edge", "Edge"], ["Opera", "Opera"], ["Opera GX", "Opera GX"], ["Mozilla Firefox", "Firefox"], ["Apple Safari", "Safari"], ["NW.js", "NW.js"]]), o2 = /* @__PURE__ */ new Map([["Chromium", "Chromium"], ["Gecko", "Gecko"], ["WebKit", "WebKit"]]);
        ReadBrandList2(uaData["brands"]);
        let e = false;
        C33.Platform.GetDetailedInfo = async () => {
          if (!e) try {
            const r3 = await navigator["userAgentData"]["getHighEntropyValues"](["platformVersion", "fullVersionList"]);
            ReadBrandList2(r3["fullVersionList"]), "Windows" === C33.Platform.OS ? C33.Platform.OSVersion = GetWindowsNTVersionName2(r3["platformVersion"]) : C33.Platform.OSVersion = r3["platformVersion"], e = true;
          } catch (r3) {
            console.warn("Failed to get detailed user agent information: ", r3);
          }
        };
      } else {
        let RunTest2 = function(r2, o2) {
          const e = Array.isArray(r2) ? r2 : [r2];
          for (const r3 of e) {
            const e2 = r3.exec(uaStr);
            if (e2) {
              o2(e2);
              break;
            }
          }
        };
        RunTest = RunTest2;
        RunTest2(/windows\s+nt\s+([\d\.]+)/i, (r2) => {
          C33.Platform.OS = "Windows";
          const o2 = r2[1];
          C33.Platform.OSVersion = GetWindowsNTVersionName2(o2);
        }), RunTest2(/mac\s+os\s+x\s+([\d\._]+)/i, (r2) => {
          C33.Platform.OS = "macOS", C33.Platform.OSVersion = r2[1].replace(/_/g, ".");
        }), RunTest2(/CrOS/, () => {
          C33.Platform.OS = "Chrome OS";
        }), RunTest2(/linux|openbsd|freebsd|netbsd/i, () => {
          C33.Platform.OS = "Linux";
        }), RunTest2(/android/i, () => {
          C33.Platform.OS = "Android";
        }), RunTest2(/android\s+([\d\.]+)/i, (r2) => {
          C33.Platform.OS = "Android", C33.Platform.OSVersion = r2[1];
        }), C33.Platform.OS === UNKNOWN && (RunTest2(/(iphone|ipod|ipad)/i, (r2) => {
          C33.Platform.OS = "iOS";
        }), RunTest2([/iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i], (r2) => {
          C33.Platform.OS = "iOS", C33.Platform.OSVersion = r2[1].replace(/_/g, ".");
        }));
        const t = /chrome\//i.test(uaStr), a2 = /chromium\//i.test(uaStr), s2 = /edg\//i.test(uaStr), n = /OPR\//.test(uaStr), i2 = /nwjs/i.test(uaStr), m = /safari\//i.test(uaStr), l2 = /webkit/i.test(uaStr);
        s2 || n || RunTest2(/chrome\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Chrome", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Chromium";
        }), RunTest2(/edg\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Edge", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Chromium";
        }), RunTest2(/OPR\/([\d\.]+)/, (r2) => {
          C33.Platform.Browser = "Opera", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Chromium";
        }), RunTest2(/chromium\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Chromium", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Chromium";
        }), RunTest2(/nwjs\/[0-9.]+/i, (r2) => {
          C33.Platform.Browser = "NW.js", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Chromium", C33.Platform.Context = "nwjs";
        }), RunTest2(/firefox\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Firefox", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Gecko";
        }), !m || t || a2 || s2 || n || i2 || (C33.Platform.Browser = "Safari", C33.Platform.BrowserEngine = "WebKit", RunTest2(/version\/([\d\.]+)/i, (r2) => {
          C33.Platform.BrowserVersion = r2[1];
        }), RunTest2(/crios\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Chrome for iOS", C33.Platform.BrowserVersion = r2[1];
        }), RunTest2(/fxios\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Firefox for iOS", C33.Platform.BrowserVersion = r2[1];
        }), RunTest2(/edgios\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Edge for iOS", C33.Platform.BrowserVersion = r2[1];
        })), C33.Platform.BrowserEngine === UNKNOWN && l2 && (C33.Platform.BrowserEngine = "WebKit"), "Android" === C33.Platform.OS && "Safari" === C33.Platform.Browser && (C33.Platform.Browser = "Stock");
        const f2 = (/* @__PURE__ */ new Set(["Windows", "macOS", "Linux", "Chrome OS"])).has(C33.Platform.OS) || "nwjs" === C33.Platform.Context;
        C33.Platform.IsDesktop = f2, C33.Platform.IsMobile = !f2;
      }
      "Chrome" === C33.Platform.Browser && "browser" === C33.Platform.Context && /wv\)/.test(uaStr) && (C33.Platform.Context = "webview"), "nwjs" !== C33.Platform.Context && "undefined" != typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator["standalone"]) && (C33.Platform.Context = "webapp"), C33.Platform.BrowserVersionNumber = parseFloat(C33.Platform.BrowserVersion);
      const looksLikeIPadOS = "macOS" === C33.Platform.OS && navigator["maxTouchPoints"] && navigator["maxTouchPoints"] > 2;
      looksLikeIPadOS && (C33.Platform.OS = "iOS", C33.Platform.OSVersion = C33.Platform.BrowserVersion, C33.Platform.IsDesktop = false, C33.Platform.IsMobile = true, C33.Platform.IsIpadOS = true), C33.Platform.IsAppleOS = "macOS" === C33.Platform.OS || "iOS" === C33.Platform.OS;
    }
    var ReadBrandList;
    var RunTest;
    var GetWindowsNTVersionName;
    {
      "use strict";
      {
        let s2 = function(e2) {
          return new Promise((t2, r3) => {
            e2.onsuccess = () => t2(e2.result), e2.onerror = () => r3(e2.error);
          });
        }, a2 = function(e2) {
          return new Promise((t2, r3) => {
            e2.oncomplete = () => t2(), e2.onerror = () => r3(e2.error), e2.onabort = () => r3(e2.error);
          });
        }, c2 = function(e2, t2) {
          return u(e2, t2);
        }, i2 = function(e2, t2) {
          return u(e2, t2, true);
        }, l2 = function(e2) {
          f2(e2);
          let t2 = r2.get(e2);
          return t2 instanceof Promise || (t2 = y(e2), r2.set(e2, t2), t2.catch((t3) => r2.delete(e2))), t2;
        }, f2 = function(e2) {
          if ("string" != typeof e2) throw new TypeError("expected string");
        }, d2 = function(e2, r3) {
          const n2 = e2.objectStore(t).openCursor();
          return new Promise((e3) => {
            const t2 = [];
            n2.onsuccess = (n3) => {
              const o3 = n3.target.result;
              if (o3) {
                switch (r3) {
                  case "entries":
                    t2.push([o3.key, o3.value]);
                    break;
                  case "keys":
                    t2.push(o3.key);
                    break;
                  case "values":
                    t2.push(o3.value);
                }
                o3.continue();
              } else e3(t2);
            };
          });
        };
        s = s2, a = a2, c = c2, i = i2, l = l2, f = f2, d = d2;
        const e = 2, t = "keyvaluepairs", r2 = /* @__PURE__ */ new Map(), n = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAll, o2 = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAllKeys;
        async function u(e2, n2, o3 = false, s3 = true) {
          const a3 = await l2(e2);
          try {
            return n2(a3.transaction([t], o3 ? "readwrite" : "readonly"));
          } catch (t2) {
            if (s3 && "InvalidStateError" === t2["name"]) return r2.delete(e2), u(e2, n2, o3, false);
            throw t2;
          }
        }
        async function y(r3) {
          f2(r3);
          const n2 = indexedDB.open(r3, e);
          return n2.addEventListener("upgradeneeded", (e2) => {
            try {
              e2.target.result.createObjectStore(t);
            } catch (e3) {
              console.error(`Failed to create objectstore for database ${r3}`, e3);
            }
          }), s2(n2);
        }
        class m {
          constructor(e2) {
            f2(e2), this.name = e2;
          }
          async ready() {
            await l2(this.name);
          }
          set(e2, r3) {
            return f2(e2), i2(this.name, async (n2) => {
              const o3 = s2(n2.objectStore(t).put(r3, e2)), c3 = a2(n2);
              await Promise.all([c3, o3]);
            });
          }
          get(e2) {
            return f2(e2), c2(this.name, async (r3) => {
              const n2 = s2(r3.objectStore(t).get(e2)), o3 = a2(r3), [c3, i3] = await Promise.all([o3, n2]);
              return i3;
            });
          }
          delete(e2) {
            return f2(e2), i2(this.name, async (r3) => {
              const n2 = s2(r3.objectStore(t).delete(e2)), o3 = a2(r3);
              await Promise.all([o3, n2]);
            });
          }
          clear() {
            return i2(this.name, async (e2) => {
              const r3 = s2(e2.objectStore(t).clear()), n2 = a2(e2);
              await Promise.all([n2, r3]);
            });
          }
          keys() {
            return c2(this.name, async (e2) => {
              let r3;
              if (o2) {
                r3 = s2(e2.objectStore(t).getAllKeys());
              } else r3 = d2(e2, "keys");
              const n2 = a2(e2), [c3, i3] = await Promise.all([n2, r3]);
              return i3;
            });
          }
          values() {
            return c2(this.name, async (e2) => {
              let r3;
              if (n) {
                r3 = s2(e2.objectStore(t).getAll());
              } else r3 = d2(e2, "values");
              const o3 = a2(e2), [c3, i3] = await Promise.all([o3, r3]);
              return i3;
            });
          }
          entries() {
            return c2(this.name, async (e2) => {
              const t2 = d2(e2, "entries"), r3 = a2(e2), [n2, o3] = await Promise.all([r3, t2]);
              return o3;
            });
          }
        }
        self.KVStorageContainer = m;
      }
    }
    var s;
    var a;
    var c;
    var i;
    var l;
    var f;
    var d;
    {
      "use strict";
      {
        let r2 = function(e2) {
          throw new Error(`"${e2}" is not implemented`);
        }, a2 = function(e2) {
          if ("function" == typeof e2) throw new Error("localforage callback API is not implemented; please use the promise API instead");
        }, o2 = function(e2) {
          return "object" == typeof e2 ? new Promise((t2) => {
            const { port1: r3, port2: a3 } = new MessageChannel();
            a3.onmessage = (e3) => t2(e3.data), r3.postMessage(e2);
          }) : Promise.resolve(e2);
        };
        r = r2, a = a2, o = o2;
        const e = self.KVStorageContainer, t = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i];
        /* @__PURE__ */ new WeakMap();
        class s2 {
          constructor(e2) {
            this._inst = e2, this._isInMemory = !this._inst, this._isInMemory || "undefined" != typeof indexedDB || (this._isInMemory = true, console.warn("Unable to use local storage because IndexedDB API is not available")), this._memoryStorage = /* @__PURE__ */ new Map();
          }
          _MaybeSwitchToMemoryFallback(e2) {
            if (!this._isInMemory) {
              for (const r3 of t) if (e2 && r3.test(e2.message)) {
                console.error("Unable to use local storage, reverting to in-memory store: ", e2, e2.message), this._isInMemory = true;
                break;
              }
            }
          }
          async _getItemFallback(e2) {
            const t2 = this._memoryStorage.get(e2), r3 = await o2(t2);
            return void 0 === r3 ? null : r3;
          }
          async _setItemFallback(e2, t2) {
            t2 = await o2(t2), this._memoryStorage.set(e2, t2);
          }
          _removeItemFallback(e2) {
            this._memoryStorage.delete(e2);
          }
          _clearFallback() {
            this._memoryStorage.clear();
          }
          _keysFallback() {
            return Array.from(this._memoryStorage.keys());
          }
          IsInMemory() {
            return this._isInMemory;
          }
          GetMemoryStorage() {
            return this._memoryStorage;
          }
          SetMemoryStorage(e2) {
            this._memoryStorage = e2;
          }
          async getItem(e2, t2) {
            if (a2(t2), this._isInMemory) return await this._getItemFallback(e2);
            let r3;
            try {
              r3 = await this._inst.get(e2);
            } catch (t3) {
              return this._MaybeSwitchToMemoryFallback(t3), this._isInMemory ? await this._getItemFallback(e2) : (console.error(`Error reading '${e2}' from storage, returning null: `, t3), null);
            }
            return void 0 === r3 ? null : r3;
          }
          async setItem(e2, t2, r3) {
            if (a2(r3), void 0 === t2 && (t2 = null), this._isInMemory) await this._setItemFallback(e2, t2);
            else try {
              await this._inst.set(e2, t2);
            } catch (r4) {
              if (this._MaybeSwitchToMemoryFallback(r4), !this._isInMemory) throw r4;
              await this._setItemFallback(e2, t2);
            }
          }
          async removeItem(e2, t2) {
            if (a2(t2), this._isInMemory) this._removeItemFallback(e2);
            else try {
              await this._inst.delete(e2);
            } catch (t3) {
              this._MaybeSwitchToMemoryFallback(t3), this._isInMemory ? this._removeItemFallback(e2) : console.error(`Error removing '${e2}' from storage: `, t3);
            }
          }
          async clear(e2) {
            if (a2(e2), this._isInMemory) this._clearFallback();
            else try {
              await this._inst.clear();
            } catch (e3) {
              this._MaybeSwitchToMemoryFallback(e3), this._isInMemory ? this._clearFallback() : console.error("Error clearing storage: ", e3);
            }
          }
          async keys(e2) {
            if (a2(e2), this._isInMemory) return this._keysFallback();
            let t2 = [];
            try {
              t2 = await this._inst.keys();
            } catch (e3) {
              if (this._MaybeSwitchToMemoryFallback(e3), this._isInMemory) return this._keysFallback();
              console.error("Error getting storage keys: ", e3);
            }
            return t2;
          }
          ready(e2) {
            return a2(e2), this._isInMemory ? Promise.resolve(true) : this._inst.ready();
          }
          createInstance(t2) {
            if (t2.forceInMemoryFallback) return new s2(null);
            {
              const r3 = t2.name;
              if ("string" != typeof r3) throw new TypeError("invalid store name");
              const a3 = new e(r3);
              return new s2(a3);
            }
          }
          length(e2) {
            r2("localforage.length()");
          }
          key(e2, t2) {
            r2("localforage.key()");
          }
          iterate(e2, t2) {
            r2("localforage.iterate()");
          }
          setDriver(e2) {
            r2("localforage.setDriver()");
          }
          config(e2) {
            r2("localforage.config()");
          }
          defineDriver(e2) {
            r2("localforage.defineDriver()");
          }
          driver() {
            r2("localforage.driver()");
          }
          supports(e2) {
            r2("localforage.supports()");
          }
          dropInstance() {
            r2("localforage.dropInstance()");
          }
        }
        self["localforage"] = new s2(new e("localforage"));
      }
    }
    var r;
    var a;
    var o;
    {
      const C33 = self.C3;
      if (C33.Supports = {}, C33.Supports.WebAnimations = (() => {
        try {
          if ("undefined" == typeof document) return false;
          const e = document.createElement("div");
          if (void 0 === e.animate) return false;
          return void 0 !== e.animate([{ opacity: "0" }, { opacity: "1" }], 1e3).reverse;
        } catch (e) {
          return false;
        }
      })(), C33.Supports.DialogElement = "undefined" != typeof HTMLDialogElement, C33.Supports.RequestIdleCallback = !!self.requestIdleCallback, C33.Supports.ImageBitmap = !!self.createImageBitmap, C33.Supports.ImageBitmapOptions = false, C33.Supports.ImageBitmapOptionsResize = false, C33.Supports.ImageBitmap) {
        try {
          self.createImageBitmap(new ImageData(32, 32), { "premultiplyAlpha": "none" }).then(() => {
            C33.Supports.ImageBitmapOptions = true;
          }).catch(() => {
            C33.Supports.ImageBitmapOptions = false;
          });
        } catch (e) {
          C33.Supports.ImageBitmapOptions = false;
        }
        try {
          self.createImageBitmap(new ImageData(32, 32), { "resizeWidth": 10, "resizeHeight": 10 }).then((e) => {
            C33.Supports.ImageBitmapOptionsResize = 10 === e.width && 10 === e.height;
          }).catch(() => {
            C33.Supports.ImageBitmapOptionsResize = false;
          });
        } catch (e) {
          C33.Supports.ImageBitmapOptionsResize = false;
        }
      }
      if (C33.Supports.ClipboardReadText = !(!navigator["clipboard"] || !navigator["clipboard"]["readText"]), C33.Supports.PermissionsQuery = !(!navigator["permissions"] || !navigator["permissions"]["query"]), C33.Supports.ClipboardPermissionsQuery = false, C33.Supports.PermissionsQuery) {
        const e = { "name": "clipboard-read" };
        navigator["permissions"]["query"](e).then(() => {
          C33.Supports.ClipboardPermissionsQuery = true;
        }).catch(() => {
          C33.Supports.ClipboardPermissionsQuery = false;
        });
      }
      C33.Supports.AsyncClipboardApi = !!(navigator["permissions"] && navigator["clipboard"] && self["ClipboardItem"]), C33.Supports.Proxies = "undefined" != typeof Proxy, C33.Supports.DownloadAttribute = (() => {
        if ("undefined" == typeof document) return false;
        return void 0 !== document.createElement("a").download;
      })(), C33.Supports.Fetch = "function" == typeof fetch, C33.Supports.PersistentStorage = !!(self.isSecureContext && "Opera" !== C33.Platform.Browser && navigator["storage"] && navigator["storage"]["persist"]), C33.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator["storage"] && navigator["storage"]["estimate"]), C33.Supports.Fullscreen = (() => {
        if ("undefined" == typeof document) return false;
        if ("iOS" === C33.Platform.OS) return false;
        const e = document.documentElement;
        return !!(e.requestFullscreen || e.msRequestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullscreen);
      })(), C33.Supports.ImageDecoder = void 0 !== self["ImageDecoder"], C33.Supports.WebCodecs = !!self["VideoEncoder"], C33.Supports.NativeFileSystemAPI = !!self["showOpenFilePicker"], C33.Supports.QueryLocalFonts = !!self["queryLocalFonts"], C33.Supports.UserActivation = !!navigator["userActivation"], C33.Supports.CanvasToBlobWebP = false, (async () => {
        let e;
        "undefined" == typeof document ? e = new OffscreenCanvas(32, 32) : (e = document.createElement("canvas"), e.width = 32, e.height = 32);
        const t = e.getContext("2d");
        t.fillStyle = "blue", t.fillRect(0, 0, 32, 32);
        let o2 = null;
        try {
          e["convertToBlob"] ? o2 = await e["convertToBlob"]({ "type": "image/webp", "quality": 1 }) : e.toBlob && (o2 = await new Promise((t2) => e.toBlob(t2, "image/webp", 1))), C33.Supports.CanvasToBlobWebP = o2 && "image/webp" === o2.type;
        } catch (e2) {
          C33.Supports.CanvasToBlobWebP = false;
        }
      })();
    }
    {
      const C33 = self.C3;
      if (!String.prototype.trimStart) {
        const t = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
        String.prototype.trimStart = function() {
          return this.replace(t, "");
        };
      }
      if (!String.prototype.trimEnd) {
        const r2 = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
        String.prototype.trimEnd = function() {
          return this.replace(r2, "");
        };
      }
      if (String.prototype.replaceAll || (String.prototype.replaceAll = function(t, r2) {
        return this.replace(new RegExp(C33.EscapeRegex(t), "g"), r2);
      }), Array.prototype.values || (Array.prototype.values = function* () {
        for (const t of this) yield t;
      }), !Array.prototype.flat) {
        let arrayFlat2 = function(t, r2) {
          return t.reduce((t2, e) => r2 > 0 && Array.isArray(e) ? (Array.prototype.push.apply(t2, arrayFlat2(e, r2 - 1)), t2) : (t2.push(e), t2), []);
        };
        arrayFlat = arrayFlat2;
        Array.prototype.flat = function(t = 1) {
          return arrayFlat2(this, t);
        };
      }
      Array.prototype.at || (Array.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
      }), String.prototype.at || (String.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
      }), RegExp.escape || (RegExp.escape = function(t) {
        return String(t).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
      }), Set.prototype.isSubsetOf || (Set.prototype.isSubsetOf = function(t) {
        if (!(t instanceof Set)) throw new TypeError("argument must be a Set");
        for (const r2 of this) if (!t.has(r2)) return false;
        return true;
      }), navigator["storage"] && !navigator["storage"]["estimate"] && navigator["webkitTemporaryStorage"] && navigator["webkitTemporaryStorage"]["queryUsageAndQuota"] && (navigator["storage"]["estimate"] = function() {
        return new Promise((t, r2) => navigator["webkitTemporaryStorage"]["queryUsageAndQuota"]((r3, e) => t({ "usage": r3, "quota": e }), r2));
      }), void 0 === self.isSecureContext && (self.isSecureContext = "https:" === location.protocol), void 0 === self["globalThis"] && (self["globalThis"] = self);
    }
    var arrayFlat;
    {
      let assertFail2 = function(e) {
        let s2 = "Assertion failure: " + e + "\n\nStack trace:\n" + C33.GetCallStack();
        console.error(s2);
      };
      assertFail = assertFail2;
      const C33 = self.C3;
      self.assert = function(e, s2) {
        e || assertFail2(s2);
      };
    }
    var assertFail;
    {
      const C33 = self.C3, C3X = self.C3X;
      C33.IsNumber = function(e) {
        return "number" == typeof e;
      }, C33.IsFiniteNumber = function(e) {
        return C33.IsNumber(e) && isFinite(e);
      }, C33.RequireNumber = function(e) {
        if (!C33.IsNumber(e)) throw new TypeError("expected number");
      }, C33.RequireOptionalNumber = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireNumberInRange = function(e, n, r2) {
        if (!C33.IsNumber(e) || isNaN(e) || n > e || r2 < e) throw new RangeError("number outside of range");
      }, C33.RequireAllNumber = function(...e) {
        for (let n of e) ;
      }, C33.RequireFiniteNumber = function(e) {
        if (!C33.IsFiniteNumber(e)) throw new TypeError("expected finite number");
      }, C33.RequireOptionalFiniteNumber = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllFiniteNumber = function(...e) {
        for (let n of e) ;
      }, C33.IsString = function(e) {
        return "string" == typeof e;
      }, C33.RequireString = function(e) {
        if (!C33.IsString(e)) throw new TypeError("expected string");
      }, C33.RequireOptionalString = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllString = function(...e) {
        for (let n of e) ;
      }, C33.IsSimpleObject = function(e) {
        if ("object" != typeof e || null === e) return false;
        let n = Object.getPrototypeOf(e);
        return n ? n.constructor === Object : null === n;
      }, C33.RequireSimpleObject = function(e) {
        if (!C33.IsSimpleObject(e)) throw new TypeError("expected simple object");
      }, C33.RequireOptionalSimpleObject = function(e) {
        if (!C33.IsNullOrUndefined(e) && !C33.IsSimpleObject(e)) throw new TypeError("expected simple object");
      }, C33.IsObject = function(e) {
        return "object" == typeof e && null !== e && !Array.isArray(e);
      }, C33.RequireObject = function(e) {
        if (!C33.IsObject(e)) throw new TypeError("expected object");
      }, C33.RequireOptionalObject = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllObject = function(...e) {
        for (let n of e) ;
      }, C33.IsFileLike = function(e) {
        return C33.WeakIsInstanceOf(e, Blob) && "string" == typeof e["name"];
      }, C33.RequireFileLike = function(e) {
        if (!C33.IsFileLike(e)) throw new TypeError("expected file");
      }, C33.RequireOptionalFileLike = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.IsArray = function(e) {
        return Array.isArray(e);
      }, C33.RequireArray = function(e) {
        if (!C33.IsArray(e)) throw new TypeError("expected array");
      }, C33.RequireOptionalArray = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllArray = function(...e) {
        for (let n of e) ;
      }, C33.Is2DArray = function(e) {
        return !!C33.IsArray(e) && (!e.length || !!C33.IsArray(e[0]));
      }, C33.Require2DArray = function(e) {
        if (!C33.Is2DArray(e)) throw new TypeError("expected 2d array");
        for (let n of e) if (!C33.IsArray(n)) throw new TypeError("expected 2d array");
      }, C33.RequireOptional2DArray = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.IsFunction = function(e) {
        return "function" == typeof e;
      }, C33.RequireFunction = function(e, n) {
        if (!C33.IsFunction(e)) throw new TypeError("expected function");
        if (!C33.IsNullOrUndefined(n) && e !== n) throw new TypeError("expected same function reference");
      }, C33.RequireOptionalFunction = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllFunction = function(...e) {
        for (let n of e) ;
      }, C33.RequireAnyFunction = function(e, ...n) {
        if (!C33.IsFunction(e)) throw new TypeError("expected function");
        if (!n.length) throw new Error("missing comparison functions");
        for (let r2 of n) if (!C33.IsNullOrUndefined(r2) && e === r2) return;
        throw new TypeError("expected same function reference");
      }, C33.RequireOptionalAllFunction = function(...e) {
        if (!C33.IsNullOrUndefined(e)) for (let n of e) ;
      }, C33.IsInstanceOf = function(e, n) {
        return e instanceof n;
      }, C33.IsInstanceOfAny = function(e, ...n) {
        for (let r2 of n) if (C33.IsInstanceOf(e, r2)) return true;
        return false;
      }, C33.RequireInstanceOf = function(e, n) {
        if (!C33.IsInstanceOf(e, n)) throw new TypeError("unexpected type");
      }, C33.RequireOptionalInstanceOf = function(e, n) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllInstanceOf = function(e, ...n) {
        for (let e2 of n) ;
      }, C33.RequireAnyInstanceOf = function(e, ...n) {
        if (!C33.IsInstanceOfAny(e, ...n)) throw new TypeError("unexpected type");
      }, C33.RequireAnyOptionalInstanceOf = function(e, ...n) {
        if (!C33.IsNullOrUndefined(e) && !C33.IsInstanceOfAny(e, ...n)) throw new TypeError("unexpected type");
      }, C33.IsArrayOf = function(e, n) {
        for (let r2 of e) if (!C33.IsInstanceOf(r2, n)) return false;
        return true;
      }, C33.IsArrayOfFiniteNumbers = function(e) {
        for (let n of e) if (!C33.IsFiniteNumber(n)) return false;
        return true;
      }, C33.RequireArrayOf = function(e, n) {
        for (let n2 of e) ;
      }, C33.RequireOptionalArrayOf = function(e, n) {
        if (!C33.IsNullOrUndefined(e)) for (let n2 of e) ;
      }, C33.RequireOptionalArrayOfFunctions = function(e, n) {
        if (!C33.IsNullOrUndefined(e)) for (let n2 of e) ;
      }, C33.RequireArrayOfAny = function(e, ...n) {
        for (let n2 of e) ;
      }, C33.RequireOptionalArrayOfAny = function(e, ...n) {
        if (!C33.IsNullOrUndefined(e)) for (let n2 of e) ;
      }, C33.IsDOMNode = function(e, n) {
        return !(C33.IsNullOrUndefined(e) || !C33.IsString(e.nodeName)) && (!n || C33.equalsNoCase(e.nodeName, n));
      }, C33.RequireDOMNode = function(e, n) {
        if (C33.IsNullOrUndefined(e) || !C33.IsString(e.nodeName)) throw new TypeError("expected DOM node");
        if (n && !C33.equalsNoCase(e.nodeName, n)) throw new TypeError(`expected DOM '${n}' node`);
      }, C33.RequireOptionalDOMNode = function(e, n) {
        C33.IsNullOrUndefined(e);
      }, C33.IsHTMLElement = function(e, n) {
        return !(C33.IsNullOrUndefined(e) || !C33.IsString(e.tagName)) && (!n || C33.equalsNoCase(e.tagName, n));
      }, C33.RequireHTMLElement = function(e, n) {
        if (C33.IsNullOrUndefined(e) || !C33.IsString(e.tagName)) throw new TypeError("expected HTML element");
        if (n && !C33.equalsNoCase(e.tagName, n)) throw new TypeError(`expected HTML '${n}' element`);
      }, C33.RequireOptionalHTMLElement = function(e, n) {
        C33.IsNullOrUndefined(e);
      }, C33.IsDrawable = function(e) {
        return C33.IsHTMLElement(e, "img") || C33.IsHTMLElement(e, "canvas") || C33.IsHTMLElement(e, "video") || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap;
      }, C33.RequireDrawable = function(e) {
        if (!C33.IsDrawable(e)) throw new TypeError("expected drawable");
      }, C33.RequireOptionalDrawable = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.IsDrawableOrImageData = function(e) {
        return e instanceof ImageData || C33.IsDrawable(e);
      }, C33.RequireDrawableOrImageData = function(e) {
        if (!C33.IsDrawableOrImageData(e)) throw new TypeError("expected drawable or image data");
      }, C33.RequireOptionalDrawableOrImageData = function(e) {
        if (!C33.IsNullOrUndefined(e) && !C33.IsDrawableOrImageData(e)) throw new TypeError("expected drawable or image data");
      }, C33.IsStringLike = function(e) {
        return "string" == typeof e || C33.HtmlString && e instanceof C33.HtmlString || e instanceof C33.BBString;
      }, C33.RequireStringLike = function(e) {
        if (!C33.IsStringLike(e)) throw new TypeError("expected string-like");
      }, C33.RequireOptionalStringLike = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllStringLike = function(...e) {
        for (let n of e) ;
      }, C33.RequireOverride = function() {
        throw new Error("must be overridden");
      }, C33.NotYetImplemented = function() {
        throw new Error("not yet implemented");
      }, C33.IsGeneratorFunction = function(e) {
        return e.constructor === function* () {
        }.constructor;
      }, C33.RequireGeneratorFunction = function(e) {
        if (!C33.IsGeneratorFunction(e)) throw new Error("expected generator function");
      }, C33.IsIterable = function(e) {
        return "function" === e[Symbol.iterator];
      }, C33.RequireIterable = function(e) {
        if (!C33.IsIterable(e)) throw new Error("expected iterable");
      }, C33.IsDefined = function(e) {
        return !C33.IsNullOrUndefined(e);
      }, C33.IsNullOrUndefined = function(e) {
        return null == e;
      }, C33.AreArrayElementsOfSameType = function(e) {
        let n = e[0].constructor;
        for (let r2 of e) if (r2.constructor !== n) return false;
        return n;
      }, C33.AreArrayElementsOfType = function(e, n) {
        for (let r2 of e) if (!(r2 instanceof n)) return false;
        return true;
      };
      const TypedArray = Object.getPrototypeOf(Uint8Array);
      C33.IsTypedArray = function(e) {
        return C33.IsInstanceOf(e, TypedArray);
      }, C33.RequireTypedArray = function(e) {
      }, C33.WeakRequireTypedArray = function(e) {
        C33.WeakRequireInstanceOf(e, TypedArray);
      }, C33.WeakRequireAnyInstanceOf = function(e, ...n) {
        if (!C33.WeakIsAnyInstanceOf(e, ...n)) throw new TypeError("unexpected type");
      }, C33.WeakIsAnyInstanceOf = function(e, ...n) {
        for (const r2 of n) if (C33.WeakIsInstanceOf(e, r2)) return true;
        return false;
      }, C33.WeakRequireInstanceOf = function(e, n) {
        if (!C33.WeakIsInstanceOf(e, n)) throw new TypeError("unexpected type");
      }, C33.WeakIsInstanceOf = function(e, n) {
        for (; e = Object.getPrototypeOf(e); ) if (e.constructor.name === n.name) return true;
        return false;
      }, C3X.RequireNumber = C33.RequireNumber, C3X.RequireOptionalNumber = C33.RequireOptionalNumber, C3X.RequireFiniteNumber = C33.RequireFiniteNumber, C3X.RequireOptionalFiniteNumber = C33.RequireOptionalFiniteNumber, C3X.RequireString = C33.RequireString, C3X.RequireOptionalString = C33.RequireOptionalString, C3X.RequireObject = C33.RequireObject, C3X.RequireOptionalObject = C33.RequireOptionalObject, C3X.RequireArray = C33.RequireArray, C3X.RequireOptionalArray = C33.RequireOptionalArray, C3X.RequireFunction = C33.RequireFunction, C3X.RequireOptionalFunction = C33.RequireOptionalFunction, C3X.RequireInstanceOf = C33.RequireInstanceOf, C3X.RequireOptionalInstanceOf = C33.RequireOptionalInstanceOf, C3X.IsNullOrUndefined = C33.IsNullOrUndefined;
    }
    {
      let isValidTypeChange2 = function(e, t) {
        let r2 = C33.getType(e), n = C33.getType(t);
        return "null" === r2 || "null" === n || "undefined" !== r2 && "undefined" !== n && r2 === n;
      }, logDefendedObjectWarning2 = function(e) {
        console.warn("[Defence] " + e + " @", C33.GetCallStack());
      }, CheckDefendedObjectsUsedCorrectly2 = function() {
        if (checkRafId = -1, ctorObjectToProxy.size > 0 || ctorProxyToObject.size > 0) {
          let e = [...new Set([...ctorObjectToProxy.keys()].map((e2) => C33.getName(e2)))].join(",");
          console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${e}`), ctorObjectToProxy.clear(), ctorProxyToObject.clear();
        }
      }, getObjectPropertySet2 = function(e) {
        let t = /* @__PURE__ */ new Set();
        for (let r2 in e) t.add(r2);
        return t;
      }, VerifyObjectPropertiesConsistent2 = function(e, t) {
        let r2 = getObjectPropertySet2(t), n = typeProperties.get(e);
        if (n) {
          let t2 = [];
          for (let e2 of n.values()) r2.has(e2) ? r2.delete(e2) : t2.push(e2);
          C33.appendArray(t2, [...r2]), t2.length && console.warn(`[Defence] '${C33.getName(e)}' constructor creates inconsistent properties: ${t2.join(", ")}`);
        } else typeProperties.set(e, r2);
      };
      isValidTypeChange = isValidTypeChange2, logDefendedObjectWarning = logDefendedObjectWarning2, CheckDefendedObjectsUsedCorrectly = CheckDefendedObjectsUsedCorrectly2, getObjectPropertySet = getObjectPropertySet2, VerifyObjectPropertiesConsistent = VerifyObjectPropertiesConsistent2;
      const C33 = self.C3, logRafIds = /* @__PURE__ */ new Map();
      let measures;
      C33.ColorLog = function(e, t) {
        console.log(`%c${e}`, `font-weight: bold; color:${t}`);
      }, C33.RafLog = function(e, ...t) {
        logRafIds.has(e) || logRafIds.set(e, -1), -1 === logRafIds.get(e) && logRafIds.set(e, requestAnimationFrame(() => {
          console.log(`%c${e}`, "font-weight: bold", ...t), logRafIds.set(e, -1);
        }));
      }, C33.StartMeasure = function(e) {
        performance.mark(e), measures || (measures = /* @__PURE__ */ new Map()), measures.has(e) || measures.set(e, { current: 0, total: 0, average: 0, calls: 1, toString: function() {
          return `${e} :: current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ${this.calls}`;
        } });
      }, C33.EndMeasure = function(e) {
        performance.measure(`measure-${e}`, e);
        const t = performance.getEntriesByName(`measure-${e}`)[0], r2 = measures.get(e);
        r2.current = t.duration, r2.total += r2.current, r2.average = r2.total / r2.calls, console.log(r2.toString()), r2.calls++, performance.clearMarks(e), performance.clearMeasures(`measure-${e}`);
      }, C33.GetCallStack = function() {
        return new Error().stack;
      }, C33.Debugger = function() {
      }, C33.cast = function(e, t) {
        return e && e instanceof t ? e : null;
      }, C33.getName = function(e) {
        return void 0 === e ? "undefined" : null === e ? "null" : "boolean" == typeof e ? "<boolean>" : C33.IsNumber(e) ? "<number>" : C33.IsString(e) ? "<string>" : C33.IsArray(e) ? "<array>" : "symbol" == typeof e ? "<" + e.toString() + ">" : C33.IsFunction(e) ? e.name && "Function" !== e.name ? e.name : "<anonymous function>" : "object" == typeof e ? e.constructor && e.constructor.name && "Object" !== e.constructor.name ? e.constructor.name : "<anonymous object>" : "<unknown>";
      }, C33.getType = function(e) {
        return null === e ? "null" : Array.isArray(e) ? "array" : typeof e;
      }, C33.range = function* (e, t) {
        if (!isFinite(Math.abs(e - t))) throw new Error("Invalid parameters");
        if (e > t) for (let r2 = e - 1; r2 >= t; r2--) yield r2;
        else for (let r2 = e; r2 < t; r2++) yield r2;
      };
      let ctorObjectToProxy = /* @__PURE__ */ new Map(), ctorProxyToObject = /* @__PURE__ */ new Map(), proxyToObject = /* @__PURE__ */ new WeakMap(), releasedObjects = /* @__PURE__ */ new WeakMap();
      C33.DefendHandler = {};
      const VALID_GET_MISSING_KEYS = /* @__PURE__ */ new Set(["then", "splice"]);
      C33.DefendHandler.get = function(e, t) {
        return t in e || "symbol" == typeof t || VALID_GET_MISSING_KEYS.has(t) || logDefendedObjectWarning2(`Accessed missing property '${t}' from defended object '${C33.getName(e)}', returning undefined`), releasedObjects.has(e) && "symbol" != typeof t && !VALID_GET_MISSING_KEYS.has(t) && logDefendedObjectWarning2(`Accessed property '${t}' on a released object '${C33.getName(e)}'
Object was originally released at: ${releasedObjects.get(e)})
Call stack at access: `), e[t];
      }, C33.DefendHandler.set = function(e, t, r2) {
        return t in e || ctorObjectToProxy.has(e) || logDefendedObjectWarning2(`Set non-existent property '${t}' to '${r2}' on defended object '${C33.getName(e)}'`), isValidTypeChange2(e[t], r2) || ctorObjectToProxy.has(e) || logDefendedObjectWarning2(`Set '${C33.getType(e[t])}' property '${t}' to type '${C33.getType(r2)}' on defended object '${C33.getName(e)}'`), releasedObjects.has(e) && logDefendedObjectWarning2(`Set property '${t}' on a released object '${C33.getName(e)}'
Object was originally released at: ${releasedObjects.get(e)})
Call stack at access: `), e[t] = r2, true;
      }, C33.DefendHandler.deleteProperty = function(e, t) {
        throw new ReferenceError(`Cannot delete property '${t}' from defended object '${C33.getName(e)}'`);
      }, C33.DefendHandler.defineProperty = function(e, t, r2) {
        throw new ReferenceError(`Cannot define property '${t}' on defended object '${C33.getName(e)}'`);
      }, C33.DefendHandler.enumerate = function(e) {
        throw new ReferenceError(`Cannot enumerate defended object '${C33.getName(e)}'`);
      };
      let checkRafId = -1;
      C33.DefendedBase = class {
        constructor() {
          if (!C33.isDebugDefend || !C33.Supports.Proxies) return;
          let e = new.target, t = Object.create(e.prototype), r2 = new Proxy(t, C33.DefendHandler);
          return ctorObjectToProxy.set(t, r2), ctorProxyToObject.set(r2, t), proxyToObject.set(r2, t), -1 === checkRafId && (checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly2)), r2;
        }
      }, C33.debugDefend = function(e) {
        if (C33.isDebugDefend && C33.Supports.Proxies && e instanceof C33.DefendedBase) {
          if (!ctorProxyToObject.has(e)) return e;
          let t = ctorProxyToObject.get(e);
          return ctorProxyToObject.delete(e), ctorObjectToProxy.delete(t), e;
        }
        return C33.isDebug ? Object.seal(e) : e;
      }, C33.New = function(e, ...t) {
        let r2;
        try {
          r2 = new e(...t);
        } catch (e2) {
          throw ctorProxyToObject.clear(), ctorObjectToProxy.clear(), e2;
        }
        return C33.isDebugDefend && VerifyObjectPropertiesConsistent2(e, r2), C33.debugDefend(r2);
      }, C33.Release = function(e) {
        let t = proxyToObject.get(e);
        t && releasedObjects.set(t, C33.GetCallStack());
      }, C33.WasReleased = function(e) {
        let t = proxyToObject.get(e);
        return !!t && !!releasedObjects.get(t);
      };
      let typeProperties = /* @__PURE__ */ new Map();
      C33.PerfMark = class {
        constructor(e) {
          this._name = "", e && this.start(e);
        }
        start(e) {
          C33.isPerformanceProfiling && (this._name = e, performance.mark(this._name + "-Start"));
        }
        end() {
          C33.isPerformanceProfiling && (performance.mark(this._name + "-End"), performance.measure(this._name, this._name + "-Start", this._name + "-End"));
        }
        next(e) {
          C33.isPerformanceProfiling && (this.end(), this._name = e, performance.mark(this._name + "-Start"));
        }
      };
    }
    var isValidTypeChange;
    var logDefendedObjectWarning;
    var CheckDefendedObjectsUsedCorrectly;
    var getObjectPropertySet;
    var VerifyObjectPropertiesConsistent;
    {
      let isNegativeZero2 = function(t) {
        return 0 === t && 1 / t < 0;
      };
      isNegativeZero = isNegativeZero2;
      const C33 = self.C3, TWO_PI = 2 * Math.PI, D_TO_R = Math.PI / 180, R_TO_D = 180 / Math.PI;
      C33.wrap = function(t, n, e) {
        t = Math.floor(t), n = Math.floor(n);
        const r2 = (e = Math.floor(e)) - n;
        if (0 === r2) return e;
        if (t < n) {
          const a2 = e - (n - t) % r2;
          return a2 === e ? 0 : a2;
        }
        return n + (t - n) % r2;
      }, C33.mapToRange = function(t, n, e, r2, a2) {
        const o2 = e - n;
        if (0 === o2 && 0 === r2) return t;
        return (t - n) * (a2 - r2) / o2 + r2;
      }, C33.normalize = function(t, n, e) {
        return n - e === 0 ? 1 : (t - n) / (e - n);
      }, C33.clamp = function(t, n, e) {
        return t < n ? n : t > e ? e : t;
      }, C33.clampAngle = function(t) {
        return (t %= TWO_PI) < 0 && (t += TWO_PI), t;
      }, C33.toRadians = function(t) {
        return t * D_TO_R;
      }, C33.toDegrees = function(t) {
        return t * R_TO_D;
      }, C33.hypot2DFast = function(t, n) {
        return Math.sqrt(t * t + n * n);
      }, C33.hypot3DFast = function(t, n, e) {
        return Math.sqrt(t * t + n * n + e * e);
      }, C33.distanceTo = function(t, n, e, r2) {
        return C33.hypot2DFast(e - t, r2 - n);
      }, C33.distanceSquared = function(t, n, e, r2) {
        const a2 = e - t, o2 = r2 - n;
        return a2 * a2 + o2 * o2;
      }, C33.angleTo = function(t, n, e, r2) {
        return Math.atan2(r2 - n, e - t);
      }, C33.angleDiff = function(t, n) {
        if (t === n) return 0;
        let e = Math.sin(t), r2 = Math.cos(t), a2 = e * Math.sin(n) + r2 * Math.cos(n);
        return a2 >= 1 ? 0 : a2 <= -1 ? Math.PI : Math.acos(a2);
      }, C33.angleRotate = function(t, n, e) {
        let r2 = Math.sin(t), a2 = Math.cos(t), o2 = Math.sin(n), c2 = Math.cos(n);
        return Math.acos(r2 * o2 + a2 * c2) > e ? a2 * o2 - r2 * c2 > 0 ? C33.clampAngle(t + e) : C33.clampAngle(t - e) : C33.clampAngle(n);
      }, C33.angleClockwise = function(t, n) {
        let e = Math.sin(t);
        return Math.cos(t) * Math.sin(n) - e * Math.cos(n) <= 0;
      }, C33.angleLerp = function(t, n, e, r2 = 0) {
        let a2 = C33.angleDiff(t, n);
        const o2 = TWO_PI * r2;
        return C33.angleClockwise(n, t) ? C33.clampAngle(t + (a2 + o2) * e) : C33.clampAngle(t - (a2 + o2) * e);
      }, C33.angleLerpClockwise = function(t, n, e, r2 = 0) {
        const a2 = C33.angleDiff(t, n), o2 = TWO_PI * r2;
        return C33.angleClockwise(n, t) ? C33.clampAngle(t + (a2 + o2) * e) : C33.clampAngle(t + (TWO_PI - a2 + o2) * e);
      }, C33.angleLerpAntiClockwise = function(t, n, e, r2 = 0) {
        const a2 = C33.angleDiff(t, n), o2 = TWO_PI * r2;
        return C33.angleClockwise(n, t) ? C33.clampAngle(t - (-TWO_PI + a2 - o2) * e) : C33.clampAngle(t - (a2 + o2) * e);
      }, C33.angleReflect = function(t, n) {
        const e = C33.angleDiff(t, n);
        return C33.angleClockwise(t, n) ? C33.clampAngle(n - e) : C33.clampAngle(n + e);
      }, C33.lerp = function(t, n, e) {
        return t + e * (n - t);
      }, C33.unlerp = function(t, n, e) {
        return t === n ? 0 : (e - t) / (n - t);
      }, C33.relerp = function(t, n, e, r2, a2) {
        return C33.lerp(r2, a2, C33.unlerp(t, n, e));
      }, C33.qarp = function(t, n, e, r2) {
        return C33.lerp(C33.lerp(t, n, r2), C33.lerp(n, e, r2), r2);
      }, C33.cubic = function(t, n, e, r2, a2) {
        return C33.lerp(C33.qarp(t, n, e, a2), C33.qarp(n, e, r2, a2), a2);
      }, C33.cosp = function(t, n, e) {
        return (t + n + (t - n) * Math.cos(e * Math.PI)) / 2;
      }, C33.isPOT = function(t) {
        return t > 0 && !(t - 1 & t);
      }, C33.nextHighestPowerOfTwo = function(t) {
        --t;
        for (let n = 1; n < 32; n <<= 1) t |= t >> n;
        return t + 1;
      }, C33.roundToNearestFraction = function(t, n) {
        return Math.round(t * n) / n;
      }, C33.floorToNearestFraction = function(t, n) {
        return Math.floor(t * n) / n;
      }, C33.roundToDp = function(t, n) {
        n = Math.max(Math.floor(n), 0);
        const e = Math.pow(10, n);
        return Math.round(t * e) / e;
      }, C33.countDecimals = function(t) {
        return Math.floor(t) !== t && t.toString().split(".")[1].length || 0;
      }, C33.toFixed = function(t, n) {
        let e = t.toFixed(n), r2 = e.length - 1;
        for (; r2 >= 0 && "0" === e.charAt(r2); --r2) ;
        return r2 >= 0 && "." === e.charAt(r2) && --r2, r2 < 0 ? e : e.substr(0, r2 + 1);
      }, C33.PackRGB = function(t, n, e) {
        return C33.clamp(t, 0, 255) | C33.clamp(n, 0, 255) << 8 | C33.clamp(e, 0, 255) << 16;
      };
      const ALPHAEX_SHIFT = 1024, ALPHAEX_MAX = 1023, RGBEX_SHIFT = 16384, RGBEX_MAX = 8191, RGBEX_MIN = -8192;
      C33.PackRGBAEx = function(t, n, e, r2) {
        return (t = C33.clamp(Math.floor(1024 * t), -8192, 8191)) < 0 && (t += 16384), (n = C33.clamp(Math.floor(1024 * n), -8192, 8191)) < 0 && (n += 16384), (e = C33.clamp(Math.floor(1024 * e), -8192, 8191)) < 0 && (e += 16384), -(16384 * t * 16384 * 1024 + 16384 * n * 1024 + 1024 * e + (r2 = C33.clamp(Math.floor(1023 * r2), 0, 1023)));
      }, C33.PackRGBEx = function(t, n, e) {
        return C33.PackRGBAEx(t, n, e, 1);
      }, C33.GetRValue = function(t) {
        if (t >= 0) return (255 & t) / 255;
        {
          let n = Math.floor(-t / 274877906944);
          return n > 8191 && (n -= 16384), n / 1024;
        }
      }, C33.GetGValue = function(t) {
        if (t >= 0) return ((65280 & t) >> 8) / 255;
        {
          let n = Math.floor(-t % 274877906944 / 16777216);
          return n > 8191 && (n -= 16384), n / 1024;
        }
      }, C33.GetBValue = function(t) {
        if (t >= 0) return ((16711680 & t) >> 16) / 255;
        {
          let n = Math.floor(-t % 16777216 / 1024);
          return n > 8191 && (n -= 16384), n / 1024;
        }
      }, C33.GetAValue = function(t) {
        if (isNegativeZero2(t)) return 0;
        if (t >= 0) return 1;
        return Math.floor(-t % 1024) / 1023;
      }, C33.greatestCommonDivisor = function(t, n) {
        for (t = Math.floor(t), n = Math.floor(n); 0 !== n; ) {
          let e = n;
          n = t % n, t = e;
        }
        return t;
      };
      const COMMON_ASPECT_RATIOS = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];
      C33.getAspectRatio = function(t, n) {
        if ((t = Math.floor(t)) === (n = Math.floor(n))) return [1, 1];
        for (let e2 of COMMON_ASPECT_RATIOS) {
          let r2 = t / e2[0] * e2[1];
          if (Math.abs(n - r2) < 1) return e2.slice(0);
          if (r2 = t / e2[1] * e2[0], Math.abs(n - r2) < 1) return [e2[1], e2[0]];
        }
        let e = C33.greatestCommonDivisor(t, n);
        return [t / e, n / e];
      }, C33.segmentsIntersect = function(t, n, e, r2, a2, o2, c2, u) {
        const i2 = Math.min(t, e), l2 = Math.max(t, e), s2 = Math.min(a2, c2), C = Math.max(a2, c2);
        if (l2 < s2 || i2 > C) return false;
        const f2 = Math.min(n, r2), h = Math.max(n, r2), M = Math.min(o2, u), g = Math.max(o2, u);
        if (h < M || f2 > g) return false;
        const m = a2 - t + c2 - e, p = o2 - n + u - r2, I = e - t, T = r2 - n, P = c2 - a2, A = u - o2, _ = Math.abs(T * P - A * I), x = P * p - A * m;
        if (Math.abs(x) > _) return false;
        const O = I * p - T * m;
        return Math.abs(O) <= _;
      }, C33.segmentsIntersectPreCalc = function(t, n, e, r2, a2, o2, c2, u, i2, l2, s2, C) {
        const f2 = Math.min(i2, s2), h = Math.max(i2, s2);
        if (o2 < f2 || a2 > h) return false;
        const M = Math.min(l2, C), g = Math.max(l2, C);
        if (u < M || c2 > g) return false;
        const m = i2 - t + s2 - e, p = l2 - n + C - r2, I = e - t, T = r2 - n, P = s2 - i2, A = C - l2, _ = Math.abs(T * P - A * I), x = P * p - A * m;
        if (Math.abs(x) > _) return false;
        const O = I * p - T * m;
        return Math.abs(O) <= _;
      }, C33.segmentIntersectsQuad = function(t, n, e, r2, a2) {
        const o2 = Math.min(t, e), c2 = Math.max(t, e), u = Math.min(n, r2), i2 = Math.max(n, r2), l2 = a2.getTlx(), s2 = a2.getTly(), C = a2.getTrx(), f2 = a2.getTry(), h = a2.getBrx(), M = a2.getBry(), g = a2.getBlx(), m = a2.getBly();
        return C33.segmentsIntersectPreCalc(t, n, e, r2, o2, c2, u, i2, l2, s2, C, f2) || C33.segmentsIntersectPreCalc(t, n, e, r2, o2, c2, u, i2, C, f2, h, M) || C33.segmentsIntersectPreCalc(t, n, e, r2, o2, c2, u, i2, h, M, g, m) || C33.segmentsIntersectPreCalc(t, n, e, r2, o2, c2, u, i2, g, m, l2, s2);
      }, C33.segmentIntersectsAnyN = function(t, n, e, r2, a2) {
        const o2 = Math.min(t, e), c2 = Math.max(t, e), u = Math.min(n, r2), i2 = Math.max(n, r2);
        let l2 = 0;
        for (let s2 = a2.length - 4; l2 <= s2; l2 += 2) if (C33.segmentsIntersectPreCalc(t, n, e, r2, o2, c2, u, i2, a2[l2], a2[l2 + 1], a2[l2 + 2], a2[l2 + 3])) return true;
        return C33.segmentsIntersectPreCalc(t, n, e, r2, o2, c2, u, i2, a2[l2], a2[l2 + 1], a2[0], a2[1]);
      };
      const NO_HIT = 2, PADDING = 1e-6;
      C33.rayIntersect = function(t, n, e, r2, a2, o2, c2, u) {
        const i2 = e - t, l2 = u - o2, s2 = i2 * l2 - (r2 - n) * (c2 - a2);
        if (0 === s2) return 2;
        const C = ((n - r2) * (c2 - t) + i2 * (u - n)) / s2;
        return 0 < C && C < 1.000001 ? (l2 * (c2 - t) + (a2 - c2) * (u - n)) / s2 : 2;
      }, C33.rayIntersectExtended = function(t, n, e, r2, a2, o2, c2, u, i2) {
        const l2 = (c2 - a2) * i2, s2 = (u - o2) * i2;
        return C33.rayIntersect(t, n, e, r2, a2 - l2, o2 - s2, c2 + l2, u + s2);
      }, C33.isPointInTriangleInclusive = function(t, n, e, r2, a2, o2, c2, u) {
        const i2 = a2 - e, l2 = o2 - r2, s2 = c2 - e, C = u - r2, f2 = t - e, h = n - r2, M = i2 * i2 + l2 * l2, g = i2 * s2 + l2 * C, m = i2 * f2 + l2 * h, p = s2 * s2 + C * C, I = s2 * f2 + C * h, T = 1 / (M * p - g * g), P = (p * m - g * I) * T, A = (M * I - g * m) * T;
        return P >= 0 && A >= 0 && P + A <= 1;
      }, C33.triangleCartesianToBarycentric = function(t, n, e, r2, a2, o2, c2, u) {
        const i2 = a2 - e, l2 = o2 - r2, s2 = c2 - e, C = u - r2, f2 = t - e, h = n - r2, M = i2 * i2 + l2 * l2, g = i2 * s2 + l2 * C, m = s2 * s2 + C * C, p = f2 * i2 + h * l2, I = f2 * s2 + h * C, T = M * m - g * g, P = (m * p - g * I) / T, A = (M * I - g * p) / T;
        return [1 - P - A, P, A];
      }, C33.triangleBarycentricToCartesian3d = function(t, n, e, r2, a2, o2, c2, u, i2, l2, s2, C) {
        return [t * r2 + n * c2 + e * l2, t * a2 + n * u + e * s2, t * o2 + n * i2 + e * C];
      };
    }
    var isNegativeZero;
    {
      const C33 = self.C3;
      let mainDocument = null, baseHref = "";
      if ("undefined" != typeof document) {
        mainDocument = document;
        const e = document.querySelector("base");
        baseHref = e && e.hasAttribute("href") ? e.getAttribute("href") : "", baseHref && (baseHref.startsWith("/") && (baseHref = baseHref.substr(1)), baseHref.endsWith("/") || (baseHref += "/"));
      }
      C33.GetBaseHref = function() {
        return baseHref;
      }, C33.GetBaseURL = function() {
        if (!mainDocument) return "";
        const e = mainDocument.location;
        return C33.GetPathFromURL(e.origin + e.pathname) + baseHref;
      }, C33.GetPathFromURL = function(e) {
        if (!e.length) return e;
        if (e.endsWith("/") || e.endsWith("\\")) return e;
        const t = Math.max(e.lastIndexOf("/"), e.lastIndexOf("\\"));
        return -1 === t ? "" : e.substr(0, t + 1);
      }, C33.GetFilenameFromURL = function(e) {
        if (!e.length) return e;
        if (e.endsWith("/") || e.endsWith("\\")) return "";
        const t = Math.max(e.lastIndexOf("/"), e.lastIndexOf("\\"));
        return -1 === t ? e : e.substr(t + 1);
      }, C33.GetFileExtension = function(e) {
        let t = e.lastIndexOf(".");
        return t < 1 ? "" : e.substr(t);
      }, C33.SetFileExtension = function(e, t) {
        const n = e.lastIndexOf(".");
        return -1 === n ? e + "." + t : e.substr(0, n + 1) + t;
      }, C33.GetFileNamePart = function(e) {
        let t = e.lastIndexOf(".");
        return t < 1 ? e : e.substr(0, t);
      }, C33.NormalizeFileSeparator = function(e) {
        return e.replace(/\\/g, "/");
      }, C33.IsFileExtension = function(e, t) {
        return t === (e ? C33.GetFileExtension(e).slice(1) : "");
      }, C33.FileNameEquals = function(e, t) {
        let n, r2;
        return C33.IsFileLike(e) && (n = C33.GetFileNamePart(e["name"])), C33.IsString(e) && (n = C33.GetFileNamePart(e)), C33.IsFileLike(t) && (r2 = C33.GetFileNamePart(t["name"])), C33.IsString(t) && (r2 = C33.GetFileNamePart(t)), n === r2;
      }, C33.ParseFilePath = function(e) {
        e = C33.NormalizeFileSeparator(e);
        let t = /^\w\:\//.exec(e);
        t ? (t = t[0], "/" !== (e = e.slice(3))[0] && (e = "/" + e)) : t = "", (e = e.replace(/\/{2,}/g, "/")).length > 1 && "/" === e.slice(-1) && (e = e.slice(0, -1));
        const n = e.lastIndexOf("/") + 1;
        let r2, a2 = "", o2 = e, s2 = "";
        n > 0 && (a2 = e.slice(0, n), o2 = e.slice(n)), r2 = o2;
        const i2 = o2.lastIndexOf(".");
        i2 > 0 && (s2 = o2.slice(i2), r2 = o2.slice(0, -s2.length));
        return { dir: a2, base: o2, name: r2, root: t, ext: s2, full: t + a2 + o2 };
      }, C33.Wait = function(e, t) {
        return new Promise((n, r2) => {
          self.setTimeout(n, e, t);
        });
      }, C33.swallowException = function(e) {
        try {
          e();
        } catch (e2) {
          C33.isDebug && console.warn("Swallowed exception: ", e2);
        }
      }, C33.noop = function() {
      }, C33.equalsNoCase = function(e, t) {
        return "string" == typeof e && "string" == typeof t && (e === t || e.normalize().toLowerCase() === t.normalize().toLowerCase());
      }, C33.equalsCase = function(e, t) {
        return "string" == typeof e && "string" == typeof t && (e === t || e.normalize() === t.normalize());
      }, C33.typedArraySet16 = function(e, t, n) {
        e[n++] = t[0], e[n++] = t[1], e[n++] = t[2], e[n++] = t[3], e[n++] = t[4], e[n++] = t[5], e[n++] = t[6], e[n++] = t[7], e[n++] = t[8], e[n++] = t[9], e[n++] = t[10], e[n++] = t[11], e[n++] = t[12], e[n++] = t[13], e[n++] = t[14], e[n] = t[15];
      }, C33.truncateArray = function(e, t) {
        e.length = t;
      }, C33.clearArray = function(e) {
        e && 0 !== e.length && C33.truncateArray(e, 0);
      }, C33.clear2DArray = function(e) {
        if (e) {
          for (let t = 0; t < e.length; t++) {
            let n = e[t];
            C33.truncateArray(n, 0);
          }
          C33.truncateArray(e, 0);
        }
      }, C33.extendArray = function(e, t, n) {
        t |= 0;
        const r2 = e.length;
        if (!(t <= r2)) for (let a2 = r2; a2 < t; ++a2) e.push(n);
      }, C33.resizeArray = function(e, t, n) {
        t |= 0;
        const r2 = e.length;
        t < r2 ? C33.truncateArray(e, t) : t > r2 && C33.extendArray(e, t, n);
      }, C33.shallowAssignArray = function(e, t) {
        C33.clearArray(e), C33.appendArray(e, t);
      }, C33.appendArray = function(e, t) {
        if (t.length < 1e4) e.push(...t);
        else for (let n = 0, r2 = t.length; n < r2; ++n) e.push(t[n]);
      }, C33.arrayRemove = function(e, t) {
        if ((t = Math.floor(t)) < 0 || t >= e.length) return;
        let n = e.length - 1;
        for (let r2 = t; r2 < n; ++r2) e[r2] = e[r2 + 1];
        C33.truncateArray(e, n);
      }, C33.arrayFindRemove = function(e, t) {
        let n = e.indexOf(t);
        n >= 0 && e.splice(n, 1);
      }, C33.arraysEqual = function(e, t) {
        let n = e.length;
        if (t.length !== n) return false;
        for (let r2 = 0; r2 < n; ++r2) if (e[r2] !== t[r2]) return false;
        return true;
      }, C33.arrayFilterOut = function(e, t) {
        let n = [], r2 = 0;
        for (let a2 = 0, o2 = e.length; a2 < o2; ++a2) {
          let o3 = e[a2];
          t(o3) ? n.push(o3) : (e[r2] = o3, ++r2);
        }
        return C33.truncateArray(e, r2), n;
      }, C33.arrayRemoveAllInSet = function(e, t) {
        const n = e.length;
        let r2 = 0;
        for (let n2 = 0, a2 = e.length; n2 < a2; ++n2) {
          let a3 = e[n2];
          t.has(a3) || (e[r2++] = a3);
        }
        return C33.truncateArray(e, r2), n - r2;
      }, C33.isArrayIndexInBounds = function(e, t) {
        return e === Math.floor(e) && (e >= 0 && e < t.length);
      }, C33.validateArrayIndex = function(e, t) {
        if (!C33.isArrayIndexInBounds(e, t)) throw new RangeError("array index out of bounds");
      }, C33.cloneArray = function(e) {
        return e.slice();
      }, C33.deepCloneArray = function(e, t) {
        let n = [];
        for (let r2 of e) if (C33.IsObject(r2)) {
          let e2 = t(r2);
          if (!e2) throw new Error("missing clone");
          if (e2.constructor !== r2.constructor) throw new Error("object is not a clone");
          n.push(e2);
        } else C33.IsArray(r2) ? n.push(C33.deepCloneArray(r2, t)) : n.push(r2);
        return n;
      }, C33.clone2DArray = function(e) {
        let t = [];
        for (let n of e) t.push(n.slice());
        return t;
      }, C33.splitStringAndNormalize = function(e, t = " ") {
        return e ? e.split(t).map((e2) => e2.trim()).filter((e2) => !!e2) : [];
      }, C33.filterSet = function(e, t, n) {
        const r2 = /* @__PURE__ */ new Set();
        for (const a2 of e.values()) t(a2) && (n ? r2.add(n(a2)) : r2.add(a2));
        return r2;
      }, C33.mergeSets = function(e, t) {
        return e["union"] ? e["union"](t) : /* @__PURE__ */ new Set([...e, ...t]);
      }, C33.mergeSetsInPlace = function(e, t) {
        for (const n of t) e.add(n);
        return e;
      }, C33.first = function(e) {
        for (let t of e) return t;
        return null;
      }, C33.xor = function(e, t) {
        return !e != !t;
      }, C33.compare = function(e, t, n) {
        switch (t) {
          case 0:
            return e === n;
          case 1:
            return e !== n;
          case 2:
            return e < n;
          case 3:
            return e <= n;
          case 4:
            return e > n;
          case 5:
            return e >= n;
          default:
            return false;
        }
      }, C33.hasAnyOwnProperty = function(e) {
        for (let t in e) if (e.hasOwnProperty(t)) return true;
        return false;
      }, C33.PromiseAllWithProgress = function(e, t) {
        return e.length ? new Promise((n, r2) => {
          const a2 = [];
          let o2 = 0, s2 = false;
          for (let i2 = 0, l2 = e.length; i2 < l2; ++i2) a2.push(void 0), e[i2].then((r3) => {
            s2 || (a2[i2] = r3, ++o2, o2 === e.length ? n(a2) : t(o2, e.length));
          }).catch((e2) => {
            s2 = true, r2(e2);
          });
        }) : Promise.resolve([]);
      };
      let memoryCallbacks = [];
      C33.AddLibraryMemoryCallback = function(e) {
        memoryCallbacks.push(e);
      }, C33.GetEstimatedLibraryMemoryUsage = function() {
        let e = 0;
        for (let t of memoryCallbacks) {
          e += t();
        }
        return Math.floor(e);
      };
      let nextTaskId = 1;
      const activeTaskIds = /* @__PURE__ */ new Map(), taskMessageChannel = new MessageChannel();
      taskMessageChannel.port2.onmessage = function(e) {
        const t = e.data, n = activeTaskIds.get(t);
        activeTaskIds.delete(t), n && n(performance.now());
      }, C33.RequestUnlimitedAnimationFrame = function(e) {
        const t = nextTaskId++;
        return activeTaskIds.set(t, e), taskMessageChannel.port1.postMessage(t), t;
      }, C33.CancelUnlimitedAnimationFrame = function(e) {
        activeTaskIds.delete(e);
      }, C33.PostTask = C33.RequestUnlimitedAnimationFrame, C33.WaitForNextTask = function() {
        return new Promise((e) => C33.PostTask(e));
      };
      const activeRPAFids = /* @__PURE__ */ new Set();
      C33.RequestPostAnimationFrame = function(e) {
        const t = self.requestAnimationFrame(async (n) => {
          await C33.WaitForNextTask(), activeRPAFids.has(t) && (activeRPAFids.delete(t), e(n));
        });
        return activeRPAFids.add(t), t;
      }, C33.CancelPostAnimationFrame = function(e) {
        activeRPAFids.has(e) && (self.cancelAnimationFrame(e), activeRPAFids.delete(e));
      };
    }
    {
      const C33 = self.C3;
      C33.IsAbsoluteURL = function(e) {
        return /^(?:[a-z\-]+:)?\/\//.test(e) || "data:" === e.substr(0, 5) || "blob:" === e.substr(0, 5);
      }, C33.IsRelativeURL = function(e) {
        return !C33.IsAbsoluteURL(e);
      }, C33.ThrowIfNotOk = function(e) {
        if (!e.ok) throw new Error(`fetch '${e.url}' response returned ${e.status} ${e.statusText}`);
      }, C33.FetchOk = function(e, t) {
        return fetch(e, t).then((e2) => (C33.ThrowIfNotOk(e2), e2));
      }, C33.FetchText = function(e) {
        return C33.FetchOk(e).then((e2) => e2.text());
      }, C33.FetchJson = function(e) {
        return C33.FetchOk(e).then((e2) => e2.json());
      }, C33.FetchBlob = function(e) {
        return C33.FetchOk(e).then((e2) => e2.blob());
      }, C33.FetchArrayBuffer = function(e) {
        return C33.FetchOk(e).then((e2) => e2.arrayBuffer());
      }, C33.FetchImage = function(e) {
        return new Promise((t, n) => {
          const r2 = new Image();
          r2.onload = () => t(r2), r2.onerror = (e2) => n(e2), r2.src = e;
        });
      }, C33.BlobToArrayBuffer = function(e) {
        return "function" == typeof e["arrayBuffer"] ? e["arrayBuffer"]() : new Promise((t, n) => {
          const r2 = new FileReader();
          r2.onload = () => t(r2.result), r2.onerror = () => n(r2.error), r2.readAsArrayBuffer(e);
        });
      }, C33.BlobToString = function(e) {
        return "function" == typeof e["text"] ? e["text"]() : new Promise((t, n) => {
          const r2 = new FileReader();
          r2.onload = () => t(r2.result), r2.onerror = () => n(r2.error), r2.readAsText(e);
        });
      }, C33.BlobToJson = function(e) {
        return C33.BlobToString(e).then((e2) => JSON.parse(e2));
      }, C33.BlobToImage = async function(e, t) {
        let n = URL.createObjectURL(e);
        try {
          const e2 = await C33.FetchImage(n);
          return URL.revokeObjectURL(n), n = "", t && "function" == typeof e2["decode"] && await e2["decode"](), e2;
        } finally {
          n && URL.revokeObjectURL(n);
        }
      }, C33.CreateCanvas = function(e, t) {
        if ("undefined" != typeof document && "function" == typeof document.createElement) {
          const n = document.createElement("canvas");
          return n.width = e, n.height = t, n;
        }
        return new OffscreenCanvas(e, t);
      }, C33.CanvasToBlob = function(e, t, n) {
        if ("number" != typeof n && (n = 1), t = t || "image/png", n = C33.clamp(n, 0, 1), e["convertToBlob"]) return e["convertToBlob"]({ "type": t, "quality": n });
        if (e.toBlob) return new Promise((r2) => e.toBlob(r2, t, n));
        throw new Error("could not convert canvas to blob");
      }, C33.DrawableToBlob = function(e, t, n) {
        const r2 = C33.CreateCanvas(e.width, e.height);
        return r2.getContext("2d").drawImage(e, 0, 0), C33.CanvasToBlob(r2, t, n);
      }, C33.ImageDataToBlob = function(e, t, n) {
        if (C33.Supports.ImageBitmapOptions) return createImageBitmap(e, { "premultiplyAlpha": "none" }).then((e2) => C33.DrawableToBlob(e2, t, n));
        if (C33.Supports.ImageBitmap) return createImageBitmap(e).then((e2) => C33.DrawableToBlob(e2, t, n));
        {
          const r2 = C33.CreateCanvas(e.width, e.height);
          return r2.getContext("2d").putImageData(e, 0, 0), C33.CanvasToBlob(r2, t, n);
        }
      }, C33.CopySet = function(e, t) {
        e.clear();
        for (const n of t) e.add(n);
      }, C33.MapToObject = function(e) {
        const t = /* @__PURE__ */ Object.create(null);
        for (const [n, r2] of e.entries()) t[n] = r2;
        return t;
      }, C33.ObjectToMap = function(e, t) {
        t.clear();
        for (const [n, r2] of Object.entries(e)) t.set(n, r2);
      }, C33.ToSuperJSON = function e(t) {
        if ("object" == typeof t && null !== t) {
          if (t instanceof Set) return { "_c3type_": "set", "data": [...t].map((t2) => e(t2)) };
          if (t instanceof Map) return { "_c3type_": "map", "data": [...t].map((t2) => [t2[0], e(t2[1])]) };
          {
            const n = /* @__PURE__ */ Object.create(null);
            for (const [r2, o2] of Object.entries(t)) n[r2] = e(o2);
            return n;
          }
        }
        return t;
      }, C33.FromSuperJSON = function e(t) {
        if ("object" == typeof t & null !== t) {
          if ("set" === t["_c3type_"]) return new Set(t["data"].map((t2) => e(t2)));
          if ("map" === t["_c3type_"]) return new Map(t["data"].map((t2) => [t2[0], e(t2[1])]));
          {
            const n = /* @__PURE__ */ Object.create(null);
            for (const [r2, o2] of Object.entries(t)) n[r2] = e(o2);
            return n;
          }
        }
        return t;
      }, C33.CSSToCamelCase = function(e) {
        if (e.startsWith("--")) return e;
        let t = "", n = false, r2 = 0;
        for (const o2 of e) "-" === o2 ? r2 > 0 && (n = true) : n ? (t += o2.toUpperCase(), n = false) : t += o2, ++r2;
        return t;
      }, C33.IsIterator = function(e) {
        return "object" == typeof e && "function" == typeof e.next;
      }, C33.MakeFilledArray = function(e, t) {
        const n = [];
        if ("function" == typeof t) for (let r2 = 0; r2 < e; ++r2) n.push(t());
        else for (let r2 = 0; r2 < e; ++r2) n.push(t);
        return n;
      };
    }
    {
      let padTwoDigits2 = function(t) {
        return 0 === t.length ? "00" : 1 === t.length ? "0" + t : t;
      }, hueToRGB2 = function(t, s2, e) {
        return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? t + 6 * (s2 - t) * e : e < 0.5 ? s2 : e < 2 / 3 ? t + (s2 - t) * (2 / 3 - e) * 6 : t;
      };
      padTwoDigits = padTwoDigits2, hueToRGB = hueToRGB2;
      const C33 = self.C3, HSL_TEST = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?/i, HSLA_TEST = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?,([0-9.])/i;
      C33.Color = class {
        constructor(t, s2, e, r2) {
          this._r = NaN, this._g = NaN, this._b = NaN, this._a = NaN, this._r = 0, this._g = 0, this._b = 0, this._a = 0, t instanceof C33.Color ? this.set(t) : this.setRgba(t || 0, s2 || 0, e || 0, r2 || 0);
        }
        setRgb(t, s2, e) {
          return this._r = +t, this._g = +s2, this._b = +e, this.clamp(), this;
        }
        setRgba(t, s2, e, r2) {
          return this._r = +t, this._g = +s2, this._b = +e, this._a = +r2, this.clamp(), this;
        }
        set(t) {
          return this._r = t._r, this._g = t._g, this._b = t._b, this._a = t._a, this;
        }
        copy(t) {
          return this.set(t);
        }
        add(t) {
          this._r += t._r, this._g += t._g, this._b += t._b, this._a += t._a, this.clamp();
        }
        addRgb(t, s2, e, r2 = 0) {
          this._r += +t, this._g += +s2, this._b += +e, this._a += +r2, this.clamp();
        }
        diff(t) {
          this.setR(Math.max(this._r, t._r) - Math.min(this._r, t._r)), this.setG(Math.max(this._g, t._g) - Math.min(this._g, t._g)), this.setB(Math.max(this._b, t._b) - Math.min(this._b, t._b)), this.setA(Math.max(this._a, t._a) - Math.min(this._a, t._a)), this.clamp();
        }
        copyRgb(t) {
          this._r = t._r, this._g = t._g, this._b = t._b;
        }
        setR(t) {
          this._r = C33.clamp(+t, 0, 1);
        }
        getR() {
          return this._r;
        }
        setG(t) {
          this._g = C33.clamp(+t, 0, 1);
        }
        getG() {
          return this._g;
        }
        setB(t) {
          this._b = C33.clamp(+t, 0, 1);
        }
        getB() {
          return this._b;
        }
        setA(t) {
          this._a = C33.clamp(+t, 0, 1);
        }
        getA() {
          return this._a;
        }
        clone() {
          return C33.New(C33.Color, this._r, this._g, this._b, this._a);
        }
        toArray() {
          return [this._r, this._g, this._b, this._a];
        }
        toTypedArray() {
          return new Float64Array(this.toArray());
        }
        writeToTypedArray(t, s2) {
          t[s2++] = this._r, t[s2++] = this._g, t[s2++] = this._b, t[s2] = this._a;
        }
        writeToTypedArrayx4(t, s2) {
          const e = this._r, r2 = this._g, i2 = this._b, a2 = this._a;
          for (let h = 0; h < 4; ++h) t[s2++] = e, t[s2++] = r2, t[s2++] = i2, t[s2++] = a2;
        }
        writeRGBToTypedArray(t, s2) {
          t[s2++] = this._r, t[s2++] = this._g, t[s2] = this._b;
        }
        equals(t) {
          return this._r === t._r && this._g === t._g && this._b === t._b && this._a === t._a;
        }
        equalsIgnoringAlpha(t) {
          return this._r === t._r && this._g === t._g && this._b === t._b;
        }
        equalsRgb(t, s2, e) {
          return this._r === t && this._g === s2 && this._b === e;
        }
        equalsRgba(t, s2, e, r2) {
          return this._r === t && this._g === s2 && this._b === e && this._a === r2;
        }
        equalsF32Array(t, s2) {
          return t[s2] === Math.fround(this._r) && t[s2 + 1] === Math.fround(this._g) && t[s2 + 2] === Math.fround(this._b) && t[s2 + 3] === Math.fround(this._a);
        }
        equalsRGBF32Array(t, s2) {
          return t[s2] === Math.fround(this._r) && t[s2 + 1] === Math.fround(this._g) && t[s2 + 2] === Math.fround(this._b);
        }
        multiply(t) {
          this._r *= t._r, this._g *= t._g, this._b *= t._b, this._a *= t._a;
        }
        multiplyAlpha(t) {
          this._r *= t, this._g *= t, this._b *= t, this._a *= t;
        }
        premultiply() {
          return this._r *= this._a, this._g *= this._a, this._b *= this._a, this;
        }
        unpremultiply() {
          return this._r /= this._a, this._g /= this._a, this._b /= this._a, this;
        }
        clamp() {
          return this._r = C33.clamp(this._r, 0, 1), this._g = C33.clamp(this._g, 0, 1), this._b = C33.clamp(this._b, 0, 1), this._a = C33.clamp(this._a, 0, 1), this;
        }
        setFromRgbValue(t) {
          this._r = C33.GetRValue(t), this._g = C33.GetGValue(t), this._b = C33.GetBValue(t), this._a = C33.GetAValue(t);
        }
        getCssRgb(t, s2, e) {
          return `rgb(${100 * (C33.IsFiniteNumber(t) ? t : this.getR())}%, ${100 * (C33.IsFiniteNumber(s2) ? s2 : this.getG())}%, ${100 * (C33.IsFiniteNumber(e) ? e : this.getB())}%)`;
        }
        getCssRgba(t, s2, e, r2) {
          return `rgba(${100 * (C33.IsFiniteNumber(t) ? t : this.getR())}%, ${100 * (C33.IsFiniteNumber(s2) ? s2 : this.getG())}%, ${100 * (C33.IsFiniteNumber(e) ? e : this.getB())}%, ${C33.IsFiniteNumber(r2) ? r2 : this.getA()})`;
        }
        toHexString() {
          const t = Math.round(255 * this.getR()), s2 = Math.round(255 * this.getG()), e = Math.round(255 * this.getB());
          return "#" + padTwoDigits2(t.toString(16)) + padTwoDigits2(s2.toString(16)) + padTwoDigits2(e.toString(16));
        }
        parseHexString(t) {
          if ("string" != typeof t) return false;
          let s2, e, r2;
          if ("#" === (t = t.trim()).charAt(0) && (t = t.substr(1)), 3 === t.length) s2 = parseInt(t[0], 16) / 15, e = parseInt(t[1], 16) / 15, r2 = parseInt(t[2], 16) / 15;
          else {
            if (6 !== t.length) return false;
            s2 = parseInt(t.substr(0, 2), 16) / 255, e = parseInt(t.substr(2, 2), 16) / 255, r2 = parseInt(t.substr(4, 2), 16) / 255;
          }
          return isFinite(s2) && this.setR(s2), isFinite(e) && this.setG(e), isFinite(r2) && this.setB(r2), this.setA(1), true;
        }
        toCommaSeparatedRgb() {
          return `${Math.round(255 * this.getR())}, ${Math.round(255 * this.getG())}, ${Math.round(255 * this.getB())}`;
        }
        toRgbArray() {
          return [Math.round(255 * this.getR()), Math.round(255 * this.getG()), Math.round(255 * this.getB())];
        }
        parseCommaSeparatedRgb(t) {
          if ("string" != typeof t) return false;
          const s2 = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
          if (s2.length < 3) return false;
          const e = parseInt(s2[0].trim(), 10) / 255, r2 = parseInt(s2[1].trim(), 10) / 255, i2 = parseInt(s2[2].trim(), 10) / 255;
          return isFinite(e) && this.setR(e), isFinite(r2) && this.setG(r2), isFinite(i2) && this.setB(i2), this.setA(1), true;
        }
        parseCommaSeparatedPercentageRgb(t) {
          if ("string" != typeof t) return false;
          const s2 = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
          if (s2.length < 3) return false;
          const e = parseInt(s2[0].trim(), 10) / 100, r2 = parseInt(s2[1].trim(), 10) / 100, i2 = parseInt(s2[2].trim(), 10) / 100;
          return isFinite(e) && this.setR(e), isFinite(r2) && this.setG(r2), isFinite(i2) && this.setB(i2), this.setA(1), true;
        }
        parseCommaSeparatedRgba(t) {
          if ("string" != typeof t) return false;
          const s2 = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
          if (s2.length < 4) return false;
          const e = parseInt(s2[0].trim(), 10) / 255, r2 = parseInt(s2[1].trim(), 10) / 255, i2 = parseInt(s2[2].trim(), 10) / 255, a2 = parseFloat(s2[3].trim());
          return isFinite(e) && this.setR(e), isFinite(r2) && this.setG(r2), isFinite(i2) && this.setB(i2), isFinite(a2) && this.setA(a2), true;
        }
        parseCommaSeparatedPercentageRgba(t) {
          if ("string" != typeof t) return false;
          const s2 = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
          if (s2.length < 4) return false;
          const e = parseInt(s2[0].trim(), 10) / 100, r2 = parseInt(s2[1].trim(), 10) / 100, i2 = parseInt(s2[2].trim(), 10) / 100, a2 = parseFloat(s2[3].trim());
          return isFinite(e) && this.setR(e), isFinite(r2) && this.setG(r2), isFinite(i2) && this.setB(i2), isFinite(a2) && this.setA(a2), true;
        }
        parseString(t) {
          if ("string" != typeof t) return false;
          if ((t = t.replace(/\s+/, "")).includes(",")) {
            if (t.startsWith("rgb(")) return t.includes("%") ? this.parseCommaSeparatedPercentageRgb(t) : this.parseCommaSeparatedRgb(t);
            if (t.startsWith("rgba(")) return t.includes("%") ? this.parseCommaSeparatedPercentageRgba(t) : this.parseCommaSeparatedRgba(t);
            if (t.startsWith("hsl(") || t.startsWith("hsla(")) return this.parseHSLString(t);
            {
              const s2 = t.split(",");
              return t.includes("%") ? 3 === s2.length ? this.parseCommaSeparatedPercentageRgb(t) : 4 === s2.length && this.parseCommaSeparatedPercentageRgba(t) : 3 === s2.length ? this.parseCommaSeparatedRgb(t) : 4 === s2.length && this.parseCommaSeparatedRgba(t);
            }
          }
          return this.parseHexString(t);
        }
        toJSON() {
          return [this._r, this._g, this._b, this._a];
        }
        setFromHSLA(t, s2, e, r2) {
          let i2, a2, h;
          if (t %= 360, s2 = C33.clamp(s2, 0, 100), e = C33.clamp(e, 0, 100), r2 = C33.clamp(r2, 0, 1), t /= 360, e /= 100, 0 === (s2 /= 100)) i2 = a2 = h = e;
          else {
            const r3 = e < 0.5 ? e * (1 + s2) : e + s2 - e * s2, n = 2 * e - r3;
            i2 = hueToRGB2(n, r3, t + 1 / 3), a2 = hueToRGB2(n, r3, t), h = hueToRGB2(n, r3, t - 1 / 3);
          }
          return this.setR(i2), this.setG(a2), this.setB(h), this.setA(r2), this;
        }
        parseHSLString(t) {
          const s2 = t.replace(/ |hsl|hsla|\(|\)|;/gi, ""), e = HSL_TEST.exec(s2), r2 = HSLA_TEST.exec(s2);
          return e && 4 === e.length ? (this.setFromHSLA(+e[1], +e[2], +e[3], 1), true) : !(!r2 || 5 !== r2.length) && (this.setFromHSLA(+e[1], +e[2], +e[3], +e[4]), true);
        }
        toHSLAString() {
          const t = this._r, s2 = this._g, e = this._b, r2 = this._a;
          return `hsla(${C33.Color.GetHue(t, s2, e)}, ${C33.Color.GetSaturation(t, s2, e)}%, ${C33.Color.GetLuminosity(t, s2, e)}%, ${r2})`;
        }
        toHSLAArray() {
          const t = this._r, s2 = this._g, e = this._b;
          return [C33.Color.GetHue(t, s2, e), C33.Color.GetSaturation(t, s2, e), C33.Color.GetLuminosity(t, s2, e), this._a];
        }
        setFromJSON(t) {
          Array.isArray(t) && (t.length < 3 || (this._r = t[0], this._g = t[1], this._b = t[2], t.length >= 4 ? this._a = t[3] : this._a = 1));
        }
        set r(t) {
          this.setR(t);
        }
        get r() {
          return this.getR();
        }
        set g(t) {
          this.setG(t);
        }
        get g() {
          return this.getG();
        }
        set b(t) {
          this.setB(t);
        }
        get b() {
          return this.getB();
        }
        set a(t) {
          this.setA(t);
        }
        get a() {
          return this.getA();
        }
        setAtIndex(t, s2) {
          switch (t) {
            case 0:
              this.setR(s2);
              break;
            case 1:
              this.setG(s2);
              break;
            case 2:
              this.setB(s2);
              break;
            case 3:
              this.setA(s2);
              break;
            default:
              throw new RangeError("invalid color index");
          }
        }
        getAtIndex(t) {
          switch (t) {
            case 0:
              return this.getR();
            case 1:
              return this.getG();
            case 2:
              return this.getB();
            case 3:
              return this.getA();
            default:
              throw new RangeError("invalid color index");
          }
        }
        static Equals(t, s2) {
          let e, r2;
          if (Array.isArray(t)) e = new C33.Color(), e.setFromJSON(t);
          else {
            if (!(t instanceof C33.Color)) throw new Error("unexpected type");
            e = t;
          }
          if (Array.isArray(s2)) r2 = new C33.Color(), r2.setFromJSON(s2);
          else {
            if (!(s2 instanceof C33.Color)) throw new Error("unexpected type");
            r2 = s2;
          }
          return e.equals(r2);
        }
        static DiffChannel(t, s2) {
          return C33.clamp(Math.max(t, s2) - Math.min(t, s2), 0, 1);
        }
        static Diff(t, s2) {
          const e = new C33.Color();
          return e.setR(Math.max(t._r, s2._r) - Math.min(t._r, s2._r)), e.setG(Math.max(t._g, s2._g) - Math.min(t._g, s2._g)), e.setB(Math.max(t._b, s2._b) - Math.min(t._b, s2._b)), e.setA(Math.max(t._a, s2._a) - Math.min(t._a, s2._a)), e;
        }
        static DiffNoAlpha(t, s2) {
          const e = new C33.Color(0, 0, 0, 1);
          return e.setR(Math.max(t._r, s2._r) - Math.min(t._r, s2._r)), e.setG(Math.max(t._g, s2._g) - Math.min(t._g, s2._g)), e.setB(Math.max(t._b, s2._b) - Math.min(t._b, s2._b)), e;
        }
        static GetHue(t, s2, e) {
          const r2 = Math.max(t, s2, e), i2 = Math.min(t, s2, e);
          if (r2 === i2) return 0;
          let a2 = 0;
          switch (r2) {
            case t:
              a2 = (s2 - e) / (r2 - i2) + (s2 < e ? 6 : 0);
              break;
            case s2:
              a2 = (e - t) / (r2 - i2) + 2;
              break;
            case e:
              a2 = (t - s2) / (r2 - i2) + 4;
          }
          return Math.round(a2 / 6 * 360);
        }
        static GetSaturation(t, s2, e) {
          const r2 = Math.max(t, s2, e), i2 = Math.min(t, s2, e);
          if (r2 === i2) return 0;
          const a2 = r2 - i2, h = (r2 + i2) / 2 > 0.5 ? a2 / (2 - r2 - i2) : a2 / (r2 + i2);
          return Math.round(100 * h);
        }
        static GetLuminosity(t, s2, e) {
          const r2 = Math.max(t, s2, e), i2 = (r2 + Math.min(t, s2, e)) / 2;
          return r2 ? Math.round(100 * i2) : 0;
        }
      }, C33.Color.White = Object.freeze(C33.New(C33.Color, 1, 1, 1, 1)), C33.Color.Black = Object.freeze(C33.New(C33.Color, 0, 0, 0, 1)), C33.Color.TransparentBlack = Object.freeze(C33.New(C33.Color, 0, 0, 0, 0));
    }
    var padTwoDigits;
    var hueToRGB;
    {
      const C33 = self.C3;
      C33.Vector2 = class {
        constructor(t, s2) {
          this._x = 0, this._y = 0, t instanceof C33.Vector2 ? this.copy(t) : this.set(t || 0, s2 || 0);
        }
        set(t, s2) {
          this._x = +t, this._y = +s2;
        }
        copy(t) {
          this._x = t._x, this._y = t._y;
        }
        equals(t) {
          return this._x === t._x && this._y === t._y;
        }
        equalsValues(t, s2) {
          return this._x === t && this._y === s2;
        }
        equalsF32Array(t, s2) {
          return t[s2] === Math.fround(this._x) && t[s2 + 1] === Math.fround(this._y);
        }
        setX(t) {
          this._x = +t;
        }
        getX() {
          return this._x;
        }
        setY(t) {
          this._y = +t;
        }
        getY() {
          return this._y;
        }
        toArray() {
          return [this._x, this._y];
        }
        toTypedArray() {
          return new Float64Array(this.toArray());
        }
        writeToTypedArray(t, s2) {
          t[s2++] = this._x, t[s2] = this._y;
        }
        offset(t, s2) {
          this._x += +t, this._y += +s2;
        }
        scale(t, s2) {
          this._x *= t, this._y *= s2;
        }
        divide(t, s2) {
          this._x /= t, this._y /= s2;
        }
        round() {
          this._x = Math.round(this._x), this._y = Math.round(this._y);
        }
        floor() {
          this._x = Math.floor(this._x), this._y = Math.floor(this._y);
        }
        ceil() {
          this._x = Math.ceil(this._x), this._y = Math.ceil(this._y);
        }
        angle() {
          return C33.angleTo(0, 0, this._x, this._y);
        }
        lengthSquared() {
          return this._x * this._x + this._y * this._y;
        }
        length() {
          return C33.hypot2DFast(this._x, this._y);
        }
        rotatePrecalc(t, s2) {
          const h = this._x * s2 - this._y * t;
          this._y = this._y * s2 + this._x * t, this._x = h;
        }
        rotate(t) {
          0 !== t && this.rotatePrecalc(Math.sin(t), Math.cos(t));
        }
        rotateAbout(t, s2, h) {
          0 === t || s2 === this._x && h === this._y || (this._x -= s2, this._y -= h, this.rotatePrecalc(Math.sin(t), Math.cos(t)), this._x += +s2, this._y += +h);
        }
        move(t, s2) {
          0 !== s2 && (this._x += Math.cos(t) * s2, this._y += Math.sin(t) * s2);
        }
        normalize() {
          const t = this.length();
          0 !== t && 1 !== t && (this._x /= t, this._y /= t);
        }
        clamp(t, s2) {
          this._x = C33.clamp(this._x, t, s2), this._y = C33.clamp(this._y, t, s2);
        }
        dot(t) {
          return this._x * t._x + this._y * t._y;
        }
        reverse() {
          this._x = -this._x, this._y = -this._y;
        }
        perp() {
          let t = this._x;
          return this._x = this._y, this._y = -t, this;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Rect = class {
        constructor(t, h, i2, o2) {
          this._left = NaN, this._top = NaN, this._right = NaN, this._bottom = NaN, this._left = 0, this._top = 0, this._right = 0, this._bottom = 0, t instanceof C33.Rect ? this.copy(t) : this.set(t || 0, h || 0, i2 || 0, o2 || 0);
        }
        set(t, h, i2, o2) {
          this._left = +t, this._top = +h, this._right = +i2, this._bottom = +o2;
        }
        setWH(t, h, i2, o2) {
          t = +t, h = +h, this._left = t, this._top = h, this._right = t + +i2, this._bottom = h + +o2;
        }
        copy(t) {
          this._left = +t._left, this._top = +t._top, this._right = +t._right, this._bottom = +t._bottom;
        }
        clone() {
          return new C33.Rect(this._left, this._top, this._right, this._bottom);
        }
        static Merge(t, h) {
          const i2 = new C33.Rect();
          return i2.setLeft(Math.min(t._left, h._left)), i2.setTop(Math.min(t._top, h._top)), i2.setRight(Math.max(t._right, h._right)), i2.setBottom(Math.max(t._bottom, h._bottom)), i2;
        }
        static FromObject(t) {
          return new C33.Rect(t.left, t.top, t.right, t.bottom);
        }
        equals(t) {
          return this._left === t._left && this._top === t._top && this._right === t._right && this._bottom === t._bottom;
        }
        equalsWH(t, h, i2, o2) {
          return this._left === t && this._top === h && this.width() === i2 && this.height() === o2;
        }
        equalsF32Array(t, h) {
          return t[h] === Math.fround(this._left) && t[h + 1] === Math.fround(this._top) && t[h + 2] === Math.fround(this._right) && t[h + 3] === Math.fround(this._bottom);
        }
        setLeft(t) {
          this._left = +t;
        }
        getLeft() {
          return this._left;
        }
        setTop(t) {
          this._top = +t;
        }
        getTop() {
          return this._top;
        }
        setRight(t) {
          this._right = +t;
        }
        getRight() {
          return this._right;
        }
        setBottom(t) {
          this._bottom = +t;
        }
        getBottom() {
          return this._bottom;
        }
        toArray() {
          return [this._left, this._top, this._right, this._bottom];
        }
        toTypedArray() {
          return new Float64Array(this.toArray());
        }
        toDOMRect() {
          return new DOMRect(this._left, this._top, this.width(), this.height());
        }
        static fromDOMRect(t) {
          return C33.New(C33.Rect, t.left, t.top, t.right, t.bottom);
        }
        writeToTypedArray(t, h) {
          t[h++] = this._left, t[h++] = this._top, t[h++] = this._right, t[h] = this._bottom;
        }
        writeAsQuadToTypedArray(t, h) {
          t[h++] = this._left, t[h++] = this._top, t[h++] = this._right, t[h++] = this._top, t[h++] = this._right, t[h++] = this._bottom, t[h++] = this._left, t[h] = this._bottom;
        }
        writeAsQuadToTypedArray3D(t, h, i2) {
          t[h++] = this._left, t[h++] = this._top, t[h++] = i2, t[h++] = this._right, t[h++] = this._top, t[h++] = i2, t[h++] = this._right, t[h++] = this._bottom, t[h++] = i2, t[h++] = this._left, t[h++] = this._bottom, t[h] = i2;
        }
        width() {
          return this._right - this._left;
        }
        height() {
          return this._bottom - this._top;
        }
        midX() {
          return (this._left + this._right) / 2;
        }
        midY() {
          return (this._top + this._bottom) / 2;
        }
        offset(t, h) {
          t = +t, h = +h, this._left += t, this._top += h, this._right += t, this._bottom += h;
        }
        offsetLeft(t) {
          this._left += +t;
        }
        offsetTop(t) {
          this._top += +t;
        }
        offsetRight(t) {
          this._right += +t;
        }
        offsetBottom(t) {
          this._bottom += +t;
        }
        toSquare(t) {
          if ("x" !== t) throw new Error("invalid axis, only 'x' supported");
          this._top < this._bottom ? this._left < this._right ? this._bottom = this._top + this.width() : this._bottom = this._top - this.width() : this._left < this._right ? this._bottom = this._top - this.width() : this._bottom = this._top + this.width();
        }
        inflate(t, h) {
          t = +t, h = +h, this._left -= t, this._top -= h, this._right += t, this._bottom += h;
        }
        deflate(t, h) {
          t = +t, h = +h, this._left += t, this._top += h, this._right -= t, this._bottom -= h;
        }
        multiply(t, h) {
          this._left *= t, this._top *= h, this._right *= t, this._bottom *= h;
        }
        divide(t, h) {
          this._left /= t, this._top /= h, this._right /= t, this._bottom /= h;
        }
        mirrorAround(t) {
          this._left = +t - this._left, this._right = +t - this._right;
        }
        flipAround(t) {
          this._top = +t - this._top, this._bottom = +t - this._bottom;
        }
        rotate90DegreesAround(t, h) {
          const i2 = this.width(), o2 = this.height(), s2 = this.getLeft() + i2 * t, _ = this.getTop() + o2 * h;
          this.setWH(s2 - o2 * h, _ - i2 * t, o2, i2);
        }
        swapLeftRight() {
          const t = this._left;
          this._left = this._right, this._right = t;
        }
        swapTopBottom() {
          const t = this._top;
          this._top = this._bottom, this._bottom = t;
        }
        shuntY(t) {
          const h = this._top;
          this._top = +t - this._bottom, this._bottom = +t - h;
        }
        round() {
          this._left = Math.round(this._left), this._top = Math.round(this._top), this._right = Math.round(this._right), this._bottom = Math.round(this._bottom);
        }
        roundInner() {
          this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);
        }
        roundOuter() {
          this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);
        }
        floor() {
          this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);
        }
        ceil() {
          this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);
        }
        clamp(t, h, i2, o2) {
          this._left = Math.max(this._left, +t), this._top = Math.max(this._top, +h), this._right = Math.min(this._right, +i2), this._bottom = Math.min(this._bottom, +o2);
        }
        clampBoth(t, h, i2, o2) {
          t = +t, h = +h, i2 = +i2, o2 = +o2, this._left = C33.clamp(this._left, t, i2), this._top = C33.clamp(this._top, h, o2), this._right = C33.clamp(this._right, t, i2), this._bottom = C33.clamp(this._bottom, h, o2);
        }
        normalize() {
          this._left > this._right && this.swapLeftRight(), this._top > this._bottom && this.swapTopBottom();
        }
        intersectsRect(t) {
          return !(t._right < this._left || t._bottom < this._top || t._left > this._right || t._top > this._bottom);
        }
        intersectsRectOffset(t, h, i2) {
          return !(t._right + h < this._left || t._bottom + i2 < this._top || t._left + h > this._right || t._top + i2 > this._bottom);
        }
        containsPoint(t, h) {
          return t >= this._left && t <= this._right && h >= this._top && h <= this._bottom;
        }
        containsRect(t) {
          return t._left >= this._left && t._top >= this._top && t._right <= this._right && t._bottom <= this._bottom;
        }
        expandToContain(t) {
          t._left < this._left && (this._left = +t._left), t._top < this._top && (this._top = +t._top), t._right > this._right && (this._right = +t._right), t._bottom > this._bottom && (this._bottom = +t._bottom);
        }
        lerpInto(t) {
          this._left = C33.lerp(t._left, t._right, this._left), this._top = C33.lerp(t._top, t._bottom, this._top), this._right = C33.lerp(t._left, t._right, this._right), this._bottom = C33.lerp(t._top, t._bottom, this._bottom);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Quad = class {
        constructor(t, s2, i2, h, _, r2, l2, e) {
          this._tlx = NaN, this._tly = NaN, this._trx = NaN, this._try = NaN, this._brx = NaN, this._bry = NaN, this._blx = NaN, this._bly = NaN, this._tlx = 0, this._tly = 0, this._trx = 0, this._try = 0, this._brx = 0, this._bry = 0, this._blx = 0, this._bly = 0, t instanceof C33.Quad ? this.copy(t) : this.set(t || 0, s2 || 0, i2 || 0, h || 0, _ || 0, r2 || 0, l2 || 0, e || 0);
        }
        set(t, s2, i2, h, _, r2, l2, e) {
          this._tlx = +t, this._tly = +s2, this._trx = +i2, this._try = +h, this._brx = +_, this._bry = +r2, this._blx = +l2, this._bly = +e;
        }
        setRect(t, s2, i2, h) {
          this.set(t, s2, i2, s2, i2, h, t, h);
        }
        copy(t) {
          this._tlx = t._tlx, this._tly = t._tly, this._trx = t._trx, this._try = t._try, this._brx = t._brx, this._bry = t._bry, this._blx = t._blx, this._bly = t._bly;
        }
        equals(t) {
          return this._tlx === t._tlx && this._tly === t._tly && this._trx === t._trx && this._try === t._try && this._brx === t._brx && this._bry === t._bry && this._blx === t._blx && this._bly === t._bly;
        }
        setTlx(t) {
          this._tlx = +t;
        }
        getTlx() {
          return this._tlx;
        }
        setTly(t) {
          this._tly = +t;
        }
        getTly() {
          return this._tly;
        }
        setTrx(t) {
          this._trx = +t;
        }
        getTrx() {
          return this._trx;
        }
        setTry(t) {
          this._try = +t;
        }
        getTry() {
          return this._try;
        }
        setBrx(t) {
          this._brx = +t;
        }
        getBrx() {
          return this._brx;
        }
        setBry(t) {
          this._bry = +t;
        }
        getBry() {
          return this._bry;
        }
        setBlx(t) {
          this._blx = +t;
        }
        getBlx() {
          return this._blx;
        }
        setBly(t) {
          this._bly = +t;
        }
        getBly() {
          return this._bly;
        }
        toDOMQuad() {
          return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly));
        }
        static fromDOMQuad(t) {
          return C33.New(C33.Quad, t.p1.x, t.p1.y, t.p2.x, t.p2.y, t.p3.x, t.p3.y, t.p4.x, t.p4.y);
        }
        toArray() {
          return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly];
        }
        toTypedArray() {
          return new Float64Array(this.toArray());
        }
        writeToTypedArray(t, s2) {
          t[s2++] = this._tlx, t[s2++] = this._tly, t[s2++] = this._trx, t[s2++] = this._try, t[s2++] = this._brx, t[s2++] = this._bry, t[s2++] = this._blx, t[s2] = this._bly;
        }
        writeToTypedArray3D(t, s2, i2) {
          t[s2++] = this._tlx, t[s2++] = this._tly, t[s2++] = i2, t[s2++] = this._trx, t[s2++] = this._try, t[s2++] = i2, t[s2++] = this._brx, t[s2++] = this._bry, t[s2++] = i2, t[s2++] = this._blx, t[s2++] = this._bly, t[s2] = i2;
        }
        offset(t, s2) {
          t = +t, s2 = +s2, this._tlx += t, this._tly += s2, this._trx += t, this._try += s2, this._brx += t, this._bry += s2, this._blx += t, this._bly += s2;
        }
        round() {
          this._tlx = Math.round(this._tlx), this._tly = Math.round(this._tly), this._trx = Math.round(this._trx), this._try = Math.round(this._try), this._brx = Math.round(this._brx), this._bry = Math.round(this._bry), this._blx = Math.round(this._blx), this._bly = Math.round(this._bly);
        }
        floor() {
          this._tlx = Math.floor(this._tlx), this._tly = Math.floor(this._tly), this._trx = Math.floor(this._trx), this._try = Math.floor(this._try), this._brx = Math.floor(this._brx), this._bry = Math.floor(this._bry), this._blx = Math.floor(this._blx), this._bly = Math.floor(this._bly);
        }
        ceil() {
          this._tlx = Math.ceil(this._tlx), this._tly = Math.ceil(this._tly), this._trx = Math.ceil(this._trx), this._try = Math.ceil(this._try), this._brx = Math.ceil(this._brx), this._bry = Math.ceil(this._bry), this._blx = Math.ceil(this._blx), this._bly = Math.ceil(this._bly);
        }
        setFromRect(t) {
          this._tlx = t._left, this._tly = t._top, this._trx = t._right, this._try = t._top, this._brx = t._right, this._bry = t._bottom, this._blx = t._left, this._bly = t._bottom;
        }
        setFromRotatedRect(t, s2) {
          0 === s2 ? this.setFromRect(t) : this.setFromRotatedRectPrecalc(t, Math.sin(s2), Math.cos(s2));
        }
        setFromRotatedRectPrecalc(t, s2, i2) {
          const h = t._left * s2, _ = t._top * s2, r2 = t._right * s2, l2 = t._bottom * s2, e = t._left * i2, x = t._top * i2, y = t._right * i2, b = t._bottom * i2;
          this._tlx = e - _, this._tly = x + h, this._trx = y - _, this._try = x + r2, this._brx = y - l2, this._bry = b + r2, this._blx = e - l2, this._bly = b + h;
        }
        getBoundingBox(t) {
          t.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly));
        }
        containsPoint(t, s2) {
          let i2 = this._trx - this._tlx, h = this._try - this._tly;
          const _ = this._brx - this._tlx, r2 = this._bry - this._tly, l2 = t - this._tlx, e = s2 - this._tly;
          let x = i2 * i2 + h * h, y = i2 * _ + h * r2, b = i2 * l2 + h * e;
          const a2 = _ * _ + r2 * r2, n = _ * l2 + r2 * e;
          let o2 = 1 / (x * a2 - y * y), c2 = (a2 * b - y * n) * o2, u = (x * n - y * b) * o2;
          return c2 >= 0 && u > 0 && c2 + u < 1 || (i2 = this._blx - this._tlx, h = this._bly - this._tly, x = i2 * i2 + h * h, y = i2 * _ + h * r2, b = i2 * l2 + h * e, o2 = 1 / (x * a2 - y * y), c2 = (a2 * b - y * n) * o2, u = (x * n - y * b) * o2, c2 >= 0 && u > 0 && c2 + u < 1);
        }
        midX() {
          return (this._tlx + this._trx + this._brx + this._blx) / 4;
        }
        midY() {
          return (this._tly + this._try + this._bry + this._bly) / 4;
        }
        intersectsSegment(t, s2, i2, h) {
          return !(!this.containsPoint(t, s2) && !this.containsPoint(i2, h)) || C33.segmentIntersectsQuad(t, s2, i2, h, this);
        }
        intersectsQuad(t) {
          let s2 = t.midX(), i2 = t.midY();
          if (this.containsPoint(s2, i2)) return true;
          if (s2 = this.midX(), i2 = this.midY(), t.containsPoint(s2, i2)) return true;
          const h = this._tlx, _ = this._tly, r2 = this._trx, l2 = this._try, e = this._brx, x = this._bry, y = this._blx, b = this._bly;
          return C33.segmentIntersectsQuad(h, _, r2, l2, t) || C33.segmentIntersectsQuad(r2, l2, e, x, t) || C33.segmentIntersectsQuad(e, x, y, b, t) || C33.segmentIntersectsQuad(y, b, h, _, t);
        }
        rotatePointsAnticlockwise() {
          const t = this._tlx, s2 = this._tly;
          this._tlx = this._trx, this._tly = this._try, this._trx = this._brx, this._try = this._bry, this._brx = this._blx, this._bry = this._bly, this._blx = t, this._bly = s2;
        }
        mirror() {
          this._swap(0, 2), this._swap(1, 3), this._swap(6, 4), this._swap(7, 5);
        }
        flip() {
          this._swap(0, 6), this._swap(1, 7), this._swap(2, 4), this._swap(3, 5);
        }
        diag() {
          this._swap(2, 6), this._swap(3, 7);
        }
        _swap(t, s2) {
          const i2 = this._getAtIndex(t);
          this._setAtIndex(t, this._getAtIndex(s2)), this._setAtIndex(s2, i2);
        }
        _getAtIndex(t) {
          switch (t) {
            case 0:
              return this._tlx;
            case 1:
              return this._tly;
            case 2:
              return this._trx;
            case 3:
              return this._try;
            case 4:
              return this._brx;
            case 5:
              return this._bry;
            case 6:
              return this._blx;
            case 7:
              return this._bly;
            default:
              throw new RangeError("invalid quad point index");
          }
        }
        _setAtIndex(t, s2) {
          switch (s2 = +s2, t) {
            case 0:
              this._tlx = s2;
              break;
            case 1:
              this._tly = s2;
              break;
            case 2:
              this._trx = s2;
              break;
            case 3:
              this._try = s2;
              break;
            case 4:
              this._brx = s2;
              break;
            case 5:
              this._bry = s2;
              break;
            case 6:
              this._blx = s2;
              break;
            case 7:
              this._bly = s2;
              break;
            default:
              throw new RangeError("invalid quad point index");
          }
        }
        divide(t, s2) {
          this._tlx /= t, this._tly /= s2, this._trx /= t, this._try /= s2, this._brx /= t, this._bry /= s2, this._blx /= t, this._bly /= s2;
        }
      };
    }
    {
      const C33 = self.C3, assert = self.assert, DEFAULT_POLY_POINTS = [0, 0, 1, 0, 1, 1, 0, 1], tempQuad = C33.New(C33.Quad);
      C33.CollisionPoly = class extends C33.DefendedBase {
        constructor(t, s2 = true) {
          super(), t || (t = DEFAULT_POLY_POINTS), this._ptsArr = Float64Array.from(t), this._bbox = new C33.Rect(), this._isBboxChanged = true, this._enabled = s2;
        }
        Release() {
        }
        pointsArr() {
          return this._ptsArr;
        }
        pointCount() {
          return this._ptsArr.length / 2;
        }
        setPoints(t) {
          this._ptsArr.length === t.length ? this._ptsArr.set(t) : this._ptsArr = Float64Array.from(t), this._isBboxChanged = true;
        }
        setDefaultPoints() {
          this.setPoints(DEFAULT_POLY_POINTS);
        }
        copy(t) {
          this.setPoints(t._ptsArr);
        }
        setBboxChanged() {
          this._isBboxChanged = true;
        }
        _updateBbox() {
          if (!this._isBboxChanged) return;
          const t = this._ptsArr;
          let s2 = t[0], e = t[1], r2 = s2, n = e;
          for (let o2 = 0, i2 = t.length; o2 < i2; o2 += 2) {
            const i3 = t[o2], h = t[o2 + 1];
            i3 < s2 && (s2 = i3), i3 > r2 && (r2 = i3), h < e && (e = h), h > n && (n = h);
          }
          this._bbox.set(s2, e, r2, n), this._isBboxChanged = false;
        }
        setFromRect(t, s2, e) {
          let r2 = this._ptsArr;
          8 !== r2.length && (r2 = new Float64Array(8), this._ptsArr = r2), r2[0] = t.getLeft() - s2, r2[1] = t.getTop() - e, r2[2] = t.getRight() - s2, r2[3] = t.getTop() - e, r2[4] = t.getRight() - s2, r2[5] = t.getBottom() - e, r2[6] = t.getLeft() - s2, r2[7] = t.getBottom() - e, this._bbox.copy(t), 0 === s2 && 0 === e || this._bbox.offset(-s2, -e), this._isBboxChanged = false;
        }
        setFromQuad(t, s2, e) {
          tempQuad.copy(t), tempQuad.offset(s2, e), this.setPoints(tempQuad.toArray()), this._isBboxChanged = true;
        }
        transform(t, s2, e) {
          let r2 = 0, n = 1;
          0 !== e && (r2 = Math.sin(e), n = Math.cos(e)), this.transformPrecalc(t, s2, r2, n);
        }
        transformPrecalc(t, s2, e, r2) {
          const n = this._ptsArr;
          for (let o2 = 0, i2 = n.length; o2 < i2; o2 += 2) {
            const i3 = o2 + 1, h = n[o2] * t, l2 = n[i3] * s2;
            n[o2] = h * r2 - l2 * e, n[i3] = l2 * r2 + h * e;
          }
          this._isBboxChanged = true;
        }
        offset(t, s2) {
          const e = this._ptsArr;
          for (let r2 = 0, n = e.length; r2 < n; r2 += 2) e[r2] += t, e[r2 + 1] += s2;
        }
        containsPoint(t, s2) {
          const e = this._ptsArr;
          if (t === e[0] && s2 === e[1]) return true;
          this._updateBbox();
          const r2 = this._bbox, n = r2.getLeft() - 110, o2 = r2.getTop() - 101, i2 = r2.getRight() + 131, h = r2.getBottom() + 120;
          let l2 = 0, a2 = 0, c2 = 0, g = 0, _ = 0, p = 0, f2 = 0, u = 0;
          n < t ? (l2 = n, c2 = t) : (l2 = t, c2 = n), o2 < s2 ? (a2 = o2, g = s2) : (a2 = s2, g = o2), i2 < t ? (_ = i2, f2 = t) : (_ = t, f2 = i2), h < s2 ? (p = h, u = s2) : (p = s2, u = h);
          let C = 0, A = 0;
          for (let r3 = 0, d2 = e.length; r3 < d2; r3 += 2) {
            const b = (r3 + 2) % d2, P = e[r3], m = e[r3 + 1], x = e[b], B = e[b + 1];
            C33.segmentsIntersectPreCalc(n, o2, t, s2, l2, c2, a2, g, P, m, x, B) && ++C, C33.segmentsIntersectPreCalc(i2, h, t, s2, _, f2, p, u, P, m, x, B) && ++A;
          }
          return C % 2 == 1 || A % 2 == 1;
        }
        intersectsPoly(t, s2, e) {
          const r2 = t._ptsArr, n = this._ptsArr;
          if (this.containsPoint(r2[0] + s2, r2[1] + e)) return true;
          if (t.containsPoint(n[0] - s2, n[1] - e)) return true;
          for (let t2 = 0, o2 = n.length; t2 < o2; t2 += 2) {
            const i2 = (t2 + 2) % o2, h = n[t2], l2 = n[t2 + 1], a2 = n[i2], c2 = n[i2 + 1];
            let g = 0, _ = 0, p = 0, f2 = 0;
            h < a2 ? (g = h, p = a2) : (g = a2, p = h), l2 < c2 ? (_ = l2, f2 = c2) : (_ = c2, f2 = l2);
            for (let t3 = 0, n2 = r2.length; t3 < n2; t3 += 2) {
              const o3 = (t3 + 2) % n2, i3 = r2[t3] + s2, u = r2[t3 + 1] + e, C = r2[o3] + s2, A = r2[o3 + 1] + e;
              if (C33.segmentsIntersectPreCalc(h, l2, a2, c2, g, p, _, f2, i3, u, C, A)) return true;
            }
          }
          return false;
        }
        intersectsSegment(t, s2, e, r2, n, o2) {
          if (this.containsPoint(e - t, r2 - s2)) return true;
          if (this.containsPoint(n - t, o2 - s2)) return true;
          let i2 = 0, h = 0, l2 = 0, a2 = 0;
          e < n ? (i2 = e, l2 = n) : (i2 = n, l2 = e), r2 < o2 ? (h = r2, a2 = o2) : (h = o2, a2 = r2);
          const c2 = this._ptsArr;
          for (let g = 0, _ = c2.length; g < _; g += 2) {
            const p = (g + 2) % _, f2 = c2[g] + t, u = c2[g + 1] + s2, C = c2[p] + t, A = c2[p + 1] + s2;
            if (C33.segmentsIntersectPreCalc(e, r2, n, o2, i2, l2, h, a2, f2, u, C, A)) return true;
          }
          return false;
        }
        mirror(t) {
          const s2 = this._ptsArr;
          for (let e = 0, r2 = s2.length; e < r2; e += 2) s2[e] = 2 * t - s2[e];
          this._isBboxChanged = true;
        }
        flip(t) {
          const s2 = this._ptsArr;
          for (let e = 0, r2 = s2.length; e < r2; e += 2) {
            const r3 = e + 1;
            s2[r3] = 2 * t - s2[r3];
          }
          this._isBboxChanged = true;
        }
        diag() {
          const t = this._ptsArr;
          for (let s2 = 0, e = t.length; s2 < e; s2 += 2) {
            const e2 = s2 + 1, r2 = t[s2];
            t[s2] = t[e2], t[e2] = r2;
          }
          this._isBboxChanged = true;
        }
        GetMidX() {
          const t = this._ptsArr;
          let s2 = 0;
          for (let e = 0, r2 = t.length; e < r2; e += 2) s2 += t[e];
          return s2 / this.pointCount();
        }
        GetMidY() {
          const t = this._ptsArr;
          let s2 = 0;
          for (let e = 0, r2 = t.length; e < r2; e += 2) s2 += t[e + 1];
          return s2 / this.pointCount();
        }
        GetPointsArray() {
          return this._ptsArr;
        }
        GetPointCount() {
          return this.pointCount();
        }
        IsEnabled() {
          return this._enabled;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PairMap = class extends C33.DefendedBase {
        constructor(e) {
          if (super(), this._firstMap = /* @__PURE__ */ new Map(), e) for (const [t, s2, r2] of e) this.Set(t, s2, r2);
        }
        Release() {
          this.Clear(), this._firstMap = null;
        }
        IsEmpty() {
          return 0 === this._firstMap.size;
        }
        Clear() {
          const e = this._firstMap;
          for (const t of e.values()) t.clear();
          e.clear();
        }
        Set(e, t, s2) {
          const r2 = this._firstMap;
          let i2 = r2.get(e);
          i2 || (i2 = /* @__PURE__ */ new Map(), r2.set(e, i2)), i2.set(t, s2);
        }
        Get(e, t) {
          const s2 = this._firstMap.get(e);
          return s2 ? s2.get(t) : s2;
        }
        Has(e, t) {
          const s2 = this._firstMap.get(e);
          return !!s2 && s2.has(t);
        }
        Delete(e, t) {
          const s2 = this._firstMap, r2 = s2.get(e);
          if (!r2) return false;
          const i2 = r2.delete(t);
          return i2 && 0 === r2.size && s2.delete(e), i2;
        }
        DeleteEither(e) {
          const t = this._firstMap, s2 = t.get(e);
          s2 && (s2.clear(), t.delete(e));
          for (const [s3, r2] of t.entries()) r2.delete(e) && 0 === r2.size && t.delete(s3);
        }
        GetSize() {
          let e = 0;
          for (const t of this._firstMap.values()) e += t.size;
          return e;
        }
        *values() {
          for (const e of this._firstMap.values()) yield* e.values();
        }
        *keyPairs() {
          for (const [e, t] of this._firstMap.entries()) for (const s2 of t.keys()) yield [e, s2];
        }
        *entries() {
          for (const [e, t] of this._firstMap.entries()) for (const [s2, r2] of t.entries()) yield [e, s2, r2];
        }
      };
    }
    {
      const C33 = self.C3;
      C33.ArraySet = class extends C33.DefendedBase {
        constructor() {
          super(), this._set = /* @__PURE__ */ new Set(), this._arr = [], this._needToRebuildArray = false;
        }
        Release() {
          this.Clear();
        }
        Clear() {
          this._set.clear(), C33.clearArray(this._arr), this._needToRebuildArray = false;
        }
        Add(e) {
          this._set.has(e) || (this._set.add(e), this._needToRebuildArray || this._arr.push(e));
        }
        Has(e) {
          return this._set.has(e);
        }
        Delete(e) {
          this._set.delete(e) && (this._needToRebuildArray = true);
        }
        GetSize() {
          return this._set.size;
        }
        IsEmpty() {
          return 0 === this._set.size;
        }
        GetArray() {
          return this._needToRebuildArray && (this._RebuildArray(), this._needToRebuildArray = false), this._arr;
        }
        _RebuildArray() {
          const e = this._arr;
          C33.clearArray(e);
          for (const r2 of this._set) e.push(r2);
        }
      };
    }
    {
      const C33 = self.C3, EASE_MAP = /* @__PURE__ */ new Map(), PREDEFINED_EASE_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_RUNTIME_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_RUNTIME_MAP = /* @__PURE__ */ new Map(), PRIVATE_EASE_MAP = /* @__PURE__ */ new Map(), BUILT_IN_TRANSITION_MAP = /* @__PURE__ */ new Map(), ALIAS_MAP = /* @__PURE__ */ new Map();
      ALIAS_MAP.set("linear", "noease"), ALIAS_MAP.set("default", "noease");
      const EASE_TRANSLATION_KEYS = ["default", "noease", "easeinquad", "easeoutquad", "easeinoutquad", "easeincubic", "easeoutcubic", "easeinoutcubic", "easeinquart", "easeoutquart", "easeinoutquart", "easeinquint", "easeoutquint", "easeinoutquint", "easeinsine", "easeoutsine", "easeinoutsine", "easeinexpo", "easeoutexpo", "easeinoutexpo", "easeincirc", "easeoutcirc", "easeinoutcirc", "easeinelastic", "easeoutelastic", "easeinoutelastic", "easeinback", "easeoutback", "easeinoutback", "easeinbounce", "easeoutbounce", "easeinoutbounce"], SHORT_EASE_TRANSLATION_KEYS = ["default", "noease", "quad", "cubic", "quart", "quint", "sine", "expo", "circ", "elastic", "back", "bounce"], EASE_API2INTERNAL_NAMES = /* @__PURE__ */ new Map([["linear", "noease"], ["in-sine", "easeinsine"], ["out-sine", "easeoutsine"], ["in-out-sine", "easeinoutsine"], ["in-elastic", "easeinelastic"], ["out-elastic", "easeoutelastic"], ["in-out-elastic", "easeinoutelastic"], ["in-back", "easeinback"], ["out-back", "easeoutback"], ["in-out-back", "easeinoutback"], ["in-bounce", "easeinbounce"], ["out-bounce", "easeoutbounce"], ["in-out-bounce", "easeinoutbounce"], ["in-cubic", "easeincubic"], ["out-cubic", "easeoutcubic"], ["in-out-cubic", "easeinoutcubic"], ["in-quadratic", "easeinquad"], ["out-quadratic", "easeoutquad"], ["in-out-quadratic", "easeinoutquad"], ["in-quartic", "easeinquart"], ["out-quartic", "easeoutquart"], ["in-out-quartic", "easeinoutquart"], ["in-quintic", "easeinquint"], ["out-quintic", "easeoutquint"], ["in-out-quintic", "easeinoutquint"], ["in-circular", "easeincirc"], ["out-circular", "easeoutcirc"], ["in-out-circular", "easeinoutcirc"], ["in-exponential", "easeinexpo"], ["out-exponential", "easeoutexpo"], ["in-out-exponential", "easeinoutexpo"]]);
      self.Ease = class e {
        constructor() {
        }
        static InheritEase() {
          return "default";
        }
        static DefaultEase() {
          return "noease";
        }
        static ToInternal(e2) {
          return EASE_API2INTERNAL_NAMES.get(e2);
        }
        static GetEditorEaseNames(a3, ...s2) {
          let t, i2;
          this._CreateEaseMap(), a3 ? (CUSTOM_EASE_EDITOR_MAP.has(a3) || CUSTOM_EASE_EDITOR_MAP.set(a3, /* @__PURE__ */ new Map()), t = CUSTOM_EASE_EDITOR_MAP.get(a3), i2 = [...t.keys()].filter((s3) => !e.GetEditorEaseData(s3, a3) || e.GetEditorEaseData(s3, a3).transition.IsForAnyPurpose())) : (t = CUSTOM_EASE_RUNTIME_MAP, i2 = [...t.keys()]);
          const x = i2.sort();
          return [...PREDEFINED_EASE_MAP.keys()].concat(x).filter((e2) => !s2.includes(e2));
        }
        static GetRuntimeEaseNames() {
          this._CreateEaseMap();
          const e2 = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
          return e2.sort(), [...PREDEFINED_EASE_MAP.keys()].concat(e2);
        }
        static GetCustomRuntimeEaseNames() {
          this._CreateEaseMap();
          const e2 = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
          return e2.sort(), e2;
        }
        static IsPredefinedTranslatedName(e2) {
          for (const a3 of EASE_TRANSLATION_KEYS) {
            if (self.lang(`ui.bars.timeline.eases.${a3}`) === e2) return true;
          }
          for (const a3 of SHORT_EASE_TRANSLATION_KEYS) {
            if (self.lang(`ui.bars.timeline.short-eases.${a3}`) === e2) return true;
          }
        }
        static IsNamePredefined(e2) {
          return this._CreateEaseMap(), [...PREDEFINED_EASE_MAP.keys()].includes(e2);
        }
        static _GetEase(a3) {
          const s2 = ALIAS_MAP.get(a3);
          return s2 ? EASE_MAP.get(s2) : e.IsNamePredefined(a3) ? EASE_MAP.get(a3) : PRIVATE_EASE_MAP.has(a3) ? PRIVATE_EASE_MAP.get(a3) : void 0;
        }
        static GetBuiltInTransition(e2) {
          return this._CreateEaseMap(), BUILT_IN_TRANSITION_MAP.get(e2);
        }
        static GetEditorEase(a3, s2) {
          this._CreateEaseMap();
          const t = e._GetEase(a3);
          if (t) return t;
          if (!s2) throw new Error("missing ease function");
          return CUSTOM_EASE_EDITOR_MAP.get(s2).get(a3);
        }
        static GetEditorEaseData(e2, a3) {
          this._CreateEaseMap();
          const s2 = CUSTOM_EASE_DATA_EDITOR_MAP.get(a3);
          if (s2) return s2.get(e2);
        }
        static HasEditorEase(a3, s2) {
          this._CreateEaseMap();
          return !!e._GetEase(a3) || !!CUSTOM_EASE_EDITOR_MAP.get(s2).get(a3);
        }
        static GetRuntimeEase(a3) {
          this._CreateEaseMap();
          const s2 = e._GetEase(a3);
          return s2 || CUSTOM_EASE_RUNTIME_MAP.get(a3);
        }
        static GetRuntimeEaseData(e2) {
          return this._CreateEaseMap(), CUSTOM_EASE_DATA_RUNTIME_MAP.get(e2);
        }
        static GetEaseFromIndex(e2) {
          this._CreateEaseMap();
          return this.GetRuntimeEaseNames()[e2];
        }
        static GetIndexForEase(e2, a3) {
          this._CreateEaseMap();
          return this.GetEditorEaseNames(a3).indexOf(e2);
        }
        static GetIndexForEaseAtRuntime(e2) {
          return this.GetIndexForEase(e2);
        }
        static _CreateEaseMap() {
          0 === EASE_MAP.size && (this._AddPredifinedEase("default", () => {
          }), this._AddPredifinedEase("noease", [{ "x": 0, "y": 0, "sax": 0.336, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.336, "eay": 0, "se": false, "ee": true }], true), this._AddPredifinedEase("easeinsine", [{ "x": 0, "y": 0, "sax": 0.485, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.038, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutsine", [{ "x": 0, "y": 0, "sax": 0.038, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.485, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutsine", [{ "x": 0, "y": 0, "sax": 0.336, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.336, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinelastic", [{ "x": 0, "y": 0, "sax": 0.018, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.116, "y": 2e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.266, "y": -5e-3, "sax": 0.024, "say": 0, "eax": -0.021, "eay": 0, "se": true, "ee": true }, { "x": 0.416, "y": 0.016, "sax": 0.024, "say": 0, "eax": -0.026, "eay": 0, "se": true, "ee": true }, { "x": 0.566, "y": -0.045, "sax": 0.061, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.716, "y": 0.132, "sax": 0.072, "say": -4e-3, "eax": -0.045, "eay": 0, "se": true, "ee": true }, { "x": 0.866, "y": -0.373, "sax": 0.06, "say": 0, "eax": -0.049, "eay": -2e-3, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.038, "eay": -0.263, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutelastic", [{ "x": 0, "y": 0, "sax": 0.038, "say": 0.263, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.136, "y": 1.373, "sax": 0.049, "say": 2e-3, "eax": -0.06, "eay": 0, "se": true, "ee": true }, { "x": 0.286, "y": 0.868, "sax": 0.045, "say": 0, "eax": -0.072, "eay": 4e-3, "se": true, "ee": true }, { "x": 0.436, "y": 1.045, "sax": 0.025, "say": 0, "eax": -0.061, "eay": 0, "se": true, "ee": true }, { "x": 0.586, "y": 0.984, "sax": 0.026, "say": 0, "eax": -0.024, "eay": 0, "se": true, "ee": true }, { "x": 0.736, "y": 1.005, "sax": 0.021, "say": 0, "eax": -0.024, "eay": 0, "se": true, "ee": true }, { "x": 0.886, "y": 0.998, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.018, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutelastic", [{ "x": 0, "y": 0, "sax": 0.025, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.067, "y": 1e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.18, "y": -5e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.292, "y": 0.025, "sax": 0.053, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.405, "y": -0.118, "sax": 0.069, "say": 0, "eax": -0.027, "eay": 0, "se": true, "ee": true }, { "x": 0.597, "y": 1.118, "sax": 0.027, "say": 0, "eax": -0.069, "eay": 0, "se": true, "ee": true }, { "x": 0.71, "y": 0.975, "sax": 0.025, "say": 0, "eax": -0.053, "eay": 0, "se": true, "ee": true }, { "x": 0.822, "y": 1.005, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.935, "y": 0.999, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.025, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinback", [{ "x": 0, "y": 0, "sax": 0.35, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.34, "eay": -1.579, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutback", [{ "x": 0, "y": 0, "sax": 0.34, "say": 1.579, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.35, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutback", [{ "x": 0, "y": 0, "sax": 0.035, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.242, "y": -0.1, "sax": 0.258, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.76, "y": 1.1, "sax": 0.025, "say": 0, "eax": -0.26, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.035, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinbounce", [{ "x": 0, "y": 0, "sax": 0.033, "say": 0.025, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.092, "y": 0, "sax": 0.026, "say": 0.078, "eax": -0.033, "eay": 0.025, "se": true, "ee": true }, { "x": 0.274, "y": 0, "sax": 0.097, "say": 0.319, "eax": -0.026, "eay": 0.078, "se": true, "ee": true }, { "x": 0.637, "y": 0, "sax": 0.105, "say": 0.625, "eax": -0.097, "eay": 0.319, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.125, "eay": -4e-3, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutbounce", [{ "x": 0, "y": 0, "sax": 0.125, "say": 4e-3, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.365, "y": 1, "sax": 0.097, "say": -0.319, "eax": -0.105, "eay": -0.625, "se": true, "ee": true }, { "x": 0.728, "y": 1, "sax": 0.026, "say": -0.078, "eax": -0.097, "eay": -0.319, "se": true, "ee": true }, { "x": 0.91, "y": 1, "sax": 0.033, "say": -0.025, "eax": -0.026, "eay": -0.078, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.033, "eay": -0.025, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutbounce", [{ "x": 0, "y": 0, "sax": 0.01, "say": 6e-3, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.046, "y": 0, "sax": 0.021, "say": 0.038, "eax": -0.01, "eay": 6e-3, "se": true, "ee": true }, { "x": 0.137, "y": 0, "sax": 0.059, "say": 0.158, "eax": -0.021, "eay": 0.038, "se": true, "ee": true }, { "x": 0.319, "y": 0, "sax": 0.117, "say": 0.744, "eax": -0.059, "eay": 0.158, "se": true, "ee": true }, { "x": 0.683, "y": 1, "sax": 0.059, "say": -0.158, "eax": -0.117, "eay": -0.744, "se": true, "ee": true }, { "x": 0.865, "y": 1, "sax": 0.021, "say": -0.038, "eax": -0.059, "eay": -0.158, "se": true, "ee": true }, { "x": 0.956, "y": 1, "sax": 0.01, "say": -6e-3, "eax": -0.021, "eay": -0.038, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.01, "eay": -6e-3, "se": false, "ee": true }]), this._AddPredifinedEase("easeincubic", [{ "x": 0, "y": 0, "sax": 0.75, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.138, "eay": -0.321, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutcubic", [{ "x": 0, "y": 0, "sax": 0.138, "say": 0.321, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.75, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutcubic", [{ "x": 0, "y": 0, "sax": 0.285, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.081, "say": 0.272, "eax": -0.081, "eay": -0.272, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.285, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquad", [{ "x": 0, "y": 0, "sax": 0.4, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.178, "eay": -0.392, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquad", [{ "x": 0, "y": 0, "sax": 0.178, "say": 0.392, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.4, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquad", [{ "x": 0, "y": 0, "sax": 0.25, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.03, "say": 0.065, "eax": -0.03, "eay": -0.065, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquart", [{ "x": 0, "y": 0, "sax": 0.5, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquart", [{ "x": 0, "y": 0, "sax": 0.25, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.5, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquart", [{ "x": 0, "y": 0, "sax": 0.765, "say": 0.03, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.765, "eay": -0.03, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquint", [{ "x": 0, "y": 0, "sax": 0.6, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.2, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquint", [{ "x": 0, "y": 0, "sax": 0.2, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.6, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquint", [{ "eax": 0, "eay": 0, "ee": false, "sax": 0.84, "say": 0, "se": true, "x": 0, "y": 0 }, { "eax": -0.84, "eay": 0, "ee": true, "sax": 0, "say": 0, "se": false, "x": 1, "y": 1 }]), this._AddPredifinedEase("easeincirc", [{ "x": 0, "y": 0, "sax": 0.25, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.024, "eay": -0.808, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutcirc", [{ "x": 0, "y": 0, "sax": 0.024, "say": 0.808, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutcirc", [{ "x": 0, "y": 0, "sax": 0.125, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.02, "say": 0.428, "eax": -0.02, "eay": -0.428, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.125, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinexpo", [{ "x": 0, "y": 0, "sax": 0.66, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.14, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutexpo", [{ "x": 0, "y": 0, "sax": 0.14, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.66, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutexpo", [{ "eax": 0, "eay": 0, "ee": false, "sax": 0.345, "say": 0, "se": true, "x": 0, "y": 0 }, { "eax": -0.06, "eay": -0.5, "ee": true, "sax": 0.06, "say": 0.5, "se": true, "x": 0.5, "y": 0.5 }, { "eax": -0.335, "eay": 0, "ee": true, "sax": 0, "say": 0, "se": false, "x": 1, "y": 1 }]), this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier), this._AddPrivateCustomEase("spline", this.EaseSpline));
        }
        static _AddPredifinedEase(a3, s2, t = false) {
          if ("function" == typeof s2) e._AddEase(a3, s2, "predefined");
          else {
            if (!C33.IsArray(s2)) throw new Error("unexpected arguments");
            if (self.BuiltInTransition) {
              const i2 = C33.New(self.BuiltInTransition, a3, t);
              i2.SetFromJson(s2), e._AddEase(a3, (e2, a4, s3, t2) => i2.Interpolate(e2, a4, s3, t2), "predefined"), BUILT_IN_TRANSITION_MAP.set(a3, i2);
            } else {
              const i2 = C33.New(C33.Transition, [a3, s2.map((e2) => [e2["x"], e2["y"], e2["sax"], e2["say"], e2["eax"], e2["eay"], e2["se"], e2["ee"]])], false);
              i2.MakeLinear(t), e._AddEase(a3, (e2, a4, s3, t2) => i2.Interpolate(e2, a4, s3, t2), "predefined");
            }
          }
        }
        static _AddPrivateCustomEase(a3, s2) {
          e._AddEase(a3, s2, "private");
        }
        static AddCustomEase(a3, s2, t, i2) {
          this._CreateEaseMap(), e._AddEase(a3, s2, "custom", t, i2);
        }
        static RemoveCustomEase(e2, a3) {
          if (this.IsNamePredefined(e2)) return;
          if ([...PRIVATE_EASE_MAP.keys()].includes(e2)) return;
          const s2 = CUSTOM_EASE_EDITOR_MAP.get(a3);
          s2 && s2.delete(e2);
          const t = CUSTOM_EASE_DATA_EDITOR_MAP.get(a3);
          t && t.delete(e2);
        }
        static _AddEase(e2, a3, s2, t, i2) {
          switch (s2) {
            case "predefined":
              EASE_MAP.set(e2, a3), PREDEFINED_EASE_MAP.set(e2, a3);
              break;
            case "custom":
              if (t) {
                CUSTOM_EASE_EDITOR_MAP.has(t) || CUSTOM_EASE_EDITOR_MAP.set(t, /* @__PURE__ */ new Map()), CUSTOM_EASE_DATA_EDITOR_MAP.has(t) || CUSTOM_EASE_DATA_EDITOR_MAP.set(t, /* @__PURE__ */ new Map());
                CUSTOM_EASE_EDITOR_MAP.get(t).set(e2, a3);
                CUSTOM_EASE_DATA_EDITOR_MAP.get(t).set(e2, i2);
              } else CUSTOM_EASE_RUNTIME_MAP.set(e2, a3), CUSTOM_EASE_DATA_RUNTIME_MAP.set(e2, i2);
              break;
            case "private":
              EASE_MAP.set(e2, a3), PRIVATE_EASE_MAP.set(e2, a3);
              break;
            default:
              throw new Error("unexpected ease mode");
          }
        }
        static NoEase(e2, a3, s2, t) {
          return 0 === t ? a3 : s2 * e2 / t + a3;
        }
        static EaseCubicBezier(e2, a3, s2, t, i2) {
          return a3 + 3 * e2 * (s2 - a3) + 3 * e2 ** 2 * (a3 + t - 2 * s2) + e2 ** 3 * (i2 - a3 + 3 * s2 - 3 * t);
        }
        static EaseSpline(e2, s2, t, i2, x, y, n, E, _, r2) {
          if (i2 === x && y === n) return e2;
          const u = get_t_for_x(e2, s2, i2, y, E, r2), d2 = a2(t, x, n, _), A = b(t, x, n, _), o2 = c2(t, x, n, _);
          return calc_bezier(u, d2, A, o2);
        }
        static GetBezierSamples(e2, s2, t, i2) {
          const x = [], y = a2(e2, s2, t, i2), n = b(e2, s2, t, i2), E = c2(e2, s2, t, i2);
          for (let e3 = 0; e3 < SAMPLE_COUNT; ++e3) {
            const a3 = calc_bezier(e3 * SAMPLE_STEP, y, n, E);
            x.push(a3);
          }
          return x;
        }
      };
      const SAMPLE_COUNT = 11, SAMPLE_STEP = 1 / (SAMPLE_COUNT - 1), NEWTON_RAPHSON_ITERATIONS = 4, NEWTON_RAPHSON_MIN_SLOPE = 0.01, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, a2 = (e, a3, s2, t) => t - 3 * s2 + 3 * a3 - e, b = (e, a3, s2, t) => 3 * s2 - 6 * a3 + 3 * e, c2 = (e, a3, s2, t) => 3 * (a3 - e), calc_bezier = (e, a3, s2, t) => ((a3 * e + s2) * e + t) * e, get_slope = (e, a3, s2, t) => 3 * a3 * e * e + 2 * s2 * e + t, get_t_for_x = (e, s2, t, i2, x, y) => {
        if (1 == e) return 1;
        let n = 0, E = 1, _ = y[E], r2 = SAMPLE_COUNT - 1;
        y[SAMPLE_COUNT - 1];
        for (; E != r2 && _ <= e; ) E++, _ = y[E], n += SAMPLE_STEP;
        E--, _ = y[E];
        let u = n + (e - _) / (y[E + 1] - _) * SAMPLE_STEP;
        const d2 = a2(s2, t, i2, x), A = b(s2, t, i2, x), o2 = c2(s2, t, i2, x), M = get_slope(u, d2, A, o2);
        if (0 === M) return u;
        if (M >= 0.01) {
          for (let a3 = 0; a3 < 4; ++a3) {
            u -= (calc_bezier(u, d2, A, o2) - e) / get_slope(u, d2, A, o2);
          }
          return u;
        }
        {
          let a3, s3, t2 = n, i3 = n + SAMPLE_STEP, x2 = 0;
          do {
            u = t2 + (i3 - t2) / 2;
            let y2 = calc_bezier(u, d2, A, o2) - e;
            y2 > 0 ? i3 = u : t2 = u, a3 = Math.abs(y2) > 1e-7, s3 = ++x2 < 10;
          } while (a3 && s3);
          return u;
        }
      };
    }
    {
      let RequireStringOrNumber2 = function(t) {
        C33.IsString(t);
      };
      RequireStringOrNumber = RequireStringOrNumber2;
      const C33 = self.C3;
      C33.ProbabilityTable = class {
        constructor(t) {
          this._items = [], this._name = t || "", this._totalWeight = 0;
        }
        Release() {
          this.Clear(), this._items = null;
        }
        GetName() {
          return this._name;
        }
        Clear() {
          C33.clear2DArray(this._items), this._totalWeight = 0;
        }
        GetTotalWeight() {
          return this._totalWeight;
        }
        Sample(t = Math.random() * this.GetTotalWeight()) {
          let e = 0;
          for (const [i2, s2] of this._items) if (e += i2, t < e) return s2;
          return 0;
        }
        HasItems() {
          return !!this._items.length;
        }
        AddItem(t, e) {
          RequireStringOrNumber2(e), this._totalWeight += t, this._items.push([t, e]);
        }
        RemoveItem(t, e) {
          RequireStringOrNumber2(e);
          const i2 = 0 === t;
          for (let s2 = 0; s2 < this._items.length; s2++) {
            const r2 = this._items[s2], h = i2 || r2[0] === t, n = r2[1] === e;
            if (h && n) {
              this._items.splice(s2, 1), this._totalWeight -= r2[0];
              break;
            }
          }
        }
        asJSON() {
          return JSON.stringify(this._items);
        }
        static fromJSON(t, e) {
          const i2 = new C33.ProbabilityTable(e), s2 = JSON.parse(t);
          for (const t2 of s2) {
            const e2 = t2[0], s3 = t2[1];
            i2.AddItem(e2, s3);
          }
          return i2;
        }
      };
    }
    var RequireStringOrNumber;
    {
      const C33 = self.C3;
      let nextId = 0;
      C33.ScreenReaderText = class {
        constructor(t, e) {
          this._runtime = t, this._text = e, this._id = nextId++, this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "create", "id": this._id, "text": this._text });
        }
        Release() {
          this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "release", "id": this._id }), this._runtime = null, this._text = "", this._id = -1;
        }
        SetText(t) {
          this._text !== t && (this._text = t, this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "update", "id": this._id, "text": this._text }));
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Event = class {
        constructor(t, e) {
          this.type = t, this.cancelable = !!e, this.defaultPrevented = false, this.propagationStopped = false, this.isAsync = false;
        }
        preventDefault() {
          if (!this.cancelable) throw new Error(`event '${this.type}' is not cancelable`);
          this.defaultPrevented = true;
        }
        stopPropagation() {
          if (!this.cancelable) throw new Error(`event '${this.type}' cannot be stopped`);
          if (this.isAsync) throw new Error(`cannot stop async event '${this.type}' propagation`);
          this.propagationStopped = true;
        }
      };
    }
    {
      const C33 = self.C3, assert = self.assert;
      C33.Event.Handler = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._type = e, this._captureListeners = [], this._captureListenersSet = /* @__PURE__ */ new Set(), this._listeners = [], this._listenersSet = /* @__PURE__ */ new Set(), this._fireDepth = 0, this._queueModifyListeners = [];
        }
        Release() {
          this._fireDepth > 0 || (C33.clearArray(this._captureListeners), this._captureListenersSet.clear(), C33.clearArray(this._listeners), this._listenersSet.clear(), C33.clearArray(this._queueModifyListeners), C33.Release(this));
        }
        _AddListener(e, t) {
          if (this._IsFiring()) this._queueModifyListeners.push({ op: "add", func: e, capture: t });
          else if (t) {
            if (this._captureListenersSet.has(e)) return;
            this._captureListeners.push(e), this._captureListenersSet.add(e);
          } else {
            if (this._listenersSet.has(e)) return;
            this._listeners.push(e), this._listenersSet.add(e);
          }
        }
        _RemoveListener(e, t) {
          this._IsFiring() ? this._queueModifyListeners.push({ op: "remove", func: e, capture: t }) : t ? this._captureListenersSet.has(e) && (this._captureListenersSet.delete(e), C33.arrayFindRemove(this._captureListeners, e)) : this._listenersSet.has(e) && (this._listenersSet.delete(e), C33.arrayFindRemove(this._listeners, e));
        }
        _IsEmpty() {
          return !this._captureListeners.length && !this._listeners.length;
        }
        _IsFiring() {
          return this._fireDepth > 0;
        }
        _ProcessQueuedListeners() {
          const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();
          for (const s2 of this._queueModifyListeners) if ("add" === s2.op) this._AddListener(s2.func, s2.capture), s2.capture ? t.delete(s2.func) : e.delete(s2.func);
          else {
            if ("remove" !== s2.op) throw new Error("invalid op");
            s2.capture ? (this._captureListenersSet.delete(s2.func), t.add(s2.func)) : (this._listenersSet.delete(s2.func), e.add(s2.func));
          }
          C33.arrayRemoveAllInSet(this._listeners, e), C33.arrayRemoveAllInSet(this._captureListeners, t), C33.clearArray(this._queueModifyListeners);
        }
        _FireCancellable(e) {
          this._IncreaseFireDepth();
          let t = false;
          for (let s2 = 0, r2 = this._captureListeners.length; s2 < r2; ++s2) if (this._captureListeners[s2](e), e.propagationStopped) {
            t = true;
            break;
          }
          if (!t) for (let t2 = 0, s2 = this._listeners.length; t2 < s2 && (this._listeners[t2](e), !e.propagationStopped); ++t2) ;
          return this._DecreaseFireDepth(), !e.defaultPrevented;
        }
        _FireNonCancellable(e) {
          this._IncreaseFireDepth();
          for (let t = 0, s2 = this._captureListeners.length; t < s2; ++t) this._captureListeners[t](e);
          for (let t = 0, s2 = this._listeners.length; t < s2; ++t) this._listeners[t](e);
          return this._DecreaseFireDepth(), true;
        }
        _IncreaseFireDepth() {
          this._fireDepth++;
        }
        _DecreaseFireDepth() {
          this._fireDepth--, 0 === this._fireDepth && this._queueModifyListeners.length > 0 && this._ProcessQueuedListeners();
        }
        SetDelayRemoveEventsEnabled(e) {
          e ? this._IncreaseFireDepth() : this._DecreaseFireDepth();
        }
        _FireAsync(e) {
          let t = [];
          for (let s2 = 0, r2 = this._captureListeners.length; s2 < r2; ++s2) {
            let r3 = this._captureListeners[s2];
            t.push(C33.Asyncify(() => r3(e)));
          }
          for (let s2 = 0, r2 = this._listeners.length; s2 < r2; ++s2) {
            let r3 = this._listeners[s2];
            t.push(C33.Asyncify(() => r3(e)));
          }
          return Promise.all(t).then(() => !e.defaultPrevented);
        }
        _FireAndWait_AsyncOptional(e) {
          const t = [];
          this._IncreaseFireDepth();
          for (let s2 = 0, r2 = this._captureListeners.length; s2 < r2; ++s2) {
            const r3 = this._captureListeners[s2](e);
            r3 instanceof Promise && t.push(r3);
          }
          for (let s2 = 0, r2 = this._listeners.length; s2 < r2; ++s2) {
            const r3 = this._listeners[s2](e);
            r3 instanceof Promise && t.push(r3);
          }
          return this._DecreaseFireDepth(), t.length ? Promise.all(t).then(() => !e.defaultPrevented) : !e.defaultPrevented;
        }
        async _FireAndWaitAsync(e) {
          return await this._FireAndWait_AsyncOptional(e);
        }
        async _FireAndWaitAsyncSequential(e) {
          this._IncreaseFireDepth();
          for (let t = 0, s2 = this._captureListeners.length; t < s2; ++t) {
            const s3 = this._captureListeners[t](e);
            s3 instanceof Promise && await s3;
          }
          for (let t = 0, s2 = this._listeners.length; t < s2; ++t) {
            const s3 = this._listeners[t](e);
            s3 instanceof Promise && await s3;
          }
          return this._DecreaseFireDepth(), !e.defaultPrevented;
        }
        *_FireAsGenerator(e) {
          this._IncreaseFireDepth();
          for (let t = 0, s2 = this._captureListeners.length; t < s2; ++t) {
            const s3 = this._captureListeners[t](e);
            C33.IsIterator(s3) && (yield* s3);
          }
          for (let t = 0, s2 = this._listeners.length; t < s2; ++t) {
            const s3 = this._listeners[t](e);
            C33.IsIterator(s3) && (yield* s3);
          }
          this._DecreaseFireDepth();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Event.Dispatcher = class extends C33.DefendedBase {
        constructor() {
          super(), this._eventHandlers = /* @__PURE__ */ new Map(), this._dispatcherWasReleased = false;
        }
        Release() {
          if (this._dispatcherWasReleased) throw new Error("already released");
          this.ClearEvents(), this._dispatcherWasReleased = true, C33.Release(this);
        }
        WasReleased() {
          return this._dispatcherWasReleased;
        }
        ClearEvents() {
          if (this._eventHandlers) {
            for (let e of this._eventHandlers.values()) e.Release();
            this._eventHandlers.clear();
          }
        }
        _GetHandlerByType(e, t) {
          let n = this._eventHandlers.get(e);
          return n || (t ? (n = C33.New(C33.Event.Handler, e), this._eventHandlers.set(e, n), n) : null);
        }
        HasAnyHandlerFor(e) {
          return this._eventHandlers.has(e);
        }
        addEventListener(e, t, n) {
          this._GetHandlerByType(e, true)._AddListener(t, !!n);
        }
        removeEventListener(e, t, n) {
          let s2 = this._GetHandlerByType(e, false);
          s2 && (s2._RemoveListener(t, !!n), s2._IsEmpty() && this._eventHandlers.delete(e));
        }
        dispatchEvent(e) {
          const t = this._GetHandlerByType(e.type, false);
          return !t || (e.cancelable ? t._FireCancellable(e) : t._FireNonCancellable(e));
        }
        dispatchEventAsync(e) {
          const t = this._GetHandlerByType(e.type, false);
          return t ? (e.isAsync = true, t._FireAsync(e)) : Promise.resolve(true);
        }
        async dispatchEventAndClearAsync(e) {
          const t = this._GetHandlerByType(e.type, false);
          if (!t) return true;
          this._eventHandlers.delete(e.type), e.isAsync = true;
          const n = await t._FireAsync(e);
          return t.Release(), n;
        }
        async dispatchEventAndWaitAsync(e) {
          const t = this._GetHandlerByType(e.type, false);
          return !t || await t._FireAndWaitAsync(e);
        }
        dispatchEventAndWait_AsyncOptional(e) {
          const t = this._GetHandlerByType(e.type, false);
          return !t || t._FireAndWait_AsyncOptional(e);
        }
        async dispatchEventAndWaitAsyncSequential(e) {
          const t = this._GetHandlerByType(e.type, false);
          return !t || await t._FireAndWaitAsyncSequential(e);
        }
        dispatchGeneratorEvent(e) {
          const t = this._GetHandlerByType(e.type, false);
          if (!t) return null;
          if (e.cancelable) throw new Error("not supported");
          return t._FireAsGenerator(e);
        }
        SetDelayRemoveEventsEnabled(e) {
          for (const t of this._eventHandlers.values()) t.SetDelayRemoveEventsEnabled(e);
        }
      };
    }
    {
      let SetNewCallback2 = function(e) {
        callbackId = SUPPORTS_RIC && 0 === highThroughputMode ? requestIdleCallback(DoAsyncifiedWork2, { timeout: 35 }) : setTimeout(DoAsyncifiedWork2, highThroughputMode > 0 ? 1 : e);
      }, DoAsyncifiedWork2 = function(e) {
        if (callbackId = -1, !workQueue.length) return;
        let o2 = performance.now(), i2 = o2, t = 0, n = 0;
        do {
          DoNextAsyncifiedJob2(workQueue.shift()), i2 = performance.now(), ++t, n = (i2 - o2) / t * 1.1;
        } while (workQueue.length && (SUPPORTS_RIC && 0 === highThroughputMode && void 0 !== e ? n < e["timeRemaining"]() : i2 - o2 + n < 12));
        if (-1 === callbackId && workQueue.length) {
          let e2 = i2 - o2;
          SetNewCallback2(Math.max(16 - e2, 4));
        }
      }, DoNextAsyncifiedJob2 = function(e) {
        let o2;
        try {
          o2 = e.func();
        } catch (o3) {
          return void e.reject(o3);
        }
        e.resolve(o2);
      };
      SetNewCallback = SetNewCallback2, DoAsyncifiedWork = DoAsyncifiedWork2, DoNextAsyncifiedJob = DoNextAsyncifiedJob2;
      const C33 = self.C3, SETTIMEOUT_WORK_DURATION = 12, SETTIMEOUT_INTERVAL = 16, IDLECALLBACK_TIMEOUT = 35, SUPPORTS_RIC = "undefined" != typeof requestIdleCallback;
      let workQueue = [], callbackId = -1, highThroughputMode = 0;
      let asyncifyDisabled = C33.QueryString.Has("disable-asyncify");
      asyncifyDisabled && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."), C33.Asyncify = function(e) {
        let o2 = null;
        return C33.isDebug && (o2 = C33.GetCallStack()), new Promise((i2, t) => {
          workQueue.push({ func: e, resolve: i2, reject: t, stack: o2 }), asyncifyDisabled ? DoNextAsyncifiedJob2(workQueue.pop()) : -1 === callbackId && SetNewCallback2(16);
        });
      }, C33.Asyncify.SetHighThroughputMode = function(e) {
        if (e) ++highThroughputMode;
        else if (--highThroughputMode, highThroughputMode < 0) throw new Error("already turned off high throughput mode");
      };
    }
    var SetNewCallback;
    var DoAsyncifiedWork;
    var DoNextAsyncifiedJob;
    {
      let ClearTimeCache2 = function() {
        cachedNowTime = -1;
      }, CheckActiveIdleTimeouts2 = function() {
        timerId = -1, nextDeadline = -1;
        let e = Date.now();
        for (let t of activeIdleTimeouts) if (t._CheckTimeout(e)) {
          let e2 = t._GetDeadline();
          (-1 === nextDeadline || e2 < nextDeadline) && (nextDeadline = e2);
        } else activeIdleTimeouts.delete(t);
        if (-1 !== nextDeadline) {
          let t = Math.max(nextDeadline - e + 100, 1e3);
          timerId = self.setTimeout(CheckActiveIdleTimeouts2, t);
        }
      };
      ClearTimeCache = ClearTimeCache2, CheckActiveIdleTimeouts = CheckActiveIdleTimeouts2;
      const C33 = self.C3, IDLE_CHECK_MIN_INTERVAL = 1e3, IDLE_CHECK_TIMER_OVERSHOOT = 100;
      let cachedNowTime = -1;
      C33.FastGetDateNow = function() {
        return -1 === cachedNowTime && (cachedNowTime = Date.now(), self.setTimeout(ClearTimeCache2, 16)), cachedNowTime;
      };
      let timerId = -1, nextDeadline = -1, activeIdleTimeouts = /* @__PURE__ */ new Set();
      C33.IdleTimeout = class {
        constructor(e, t) {
          this._callback = e, this._timeout = 1e3 * t, this._deadline = 0, this._isActive = false;
        }
        Reset() {
          let e = C33.FastGetDateNow();
          this._deadline = e + this._timeout, this._isActive || (activeIdleTimeouts.add(this), this._isActive = true), -1 === timerId ? (nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts2, this._timeout + 100)) : this._deadline < nextDeadline && nextDeadline > e + 1e3 && (self.clearTimeout(timerId), nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts2, this._timeout + 100));
        }
        _CheckTimeout(e) {
          return !(e >= this._deadline) || (this._callback() ? (this._deadline = e + this._timeout, true) : (this._isActive = false, false));
        }
        _GetDeadline() {
          return this._deadline;
        }
        Cancel() {
          this._isActive && (activeIdleTimeouts.delete(this), this._isActive = false, 0 === activeIdleTimeouts.size && -1 !== timerId && (self.clearTimeout(timerId), timerId = -1, nextDeadline = -1));
        }
        Release() {
          this.Cancel(), this._callback = null;
        }
      };
    }
    var ClearTimeCache;
    var CheckActiveIdleTimeouts;
    {
      const C33 = self.C3;
      C33.Disposable = class s2 {
        constructor(s3) {
          this._disposed = false, this._disposeAction = s3;
        }
        Dispose() {
          this._disposed || (this._disposed = true, this._disposeAction && (this._disposeAction(), this._disposeAction = null));
        }
        IsDisposed() {
          return this._disposed;
        }
        Release() {
          this.Dispose();
        }
        static Release(e) {
          return new s2(() => e.Release());
        }
        static From(s3, e, i2, o2, t) {
          if ("string" != typeof e && !Array.isArray(e)) throw new TypeError("expected string or array");
          if (null == o2) o2 = false;
          else if ("boolean" != typeof o2 && "object" != typeof o2) throw new TypeError("invalid event listener options");
          if (t && (i2 = i2.bind(t)), Array.isArray(e) || e.includes(" ")) {
            "string" == typeof e && (e = e.split(" "));
            const t2 = new C33.CompositeDisposable();
            for (const r2 of e) s3.addEventListener(r2, i2, o2), t2.Add(C33.New(C33.Disposable, () => s3.removeEventListener(r2, i2, o2)));
            return t2;
          }
          return s3.addEventListener(e, i2, o2), C33.New(C33.Disposable, () => s3.removeEventListener(e, i2, o2));
        }
      }, C33.StubDisposable = class extends C33.Disposable {
        SetAction(s2) {
          this._disposeAction = s2;
        }
      }, C33.CompositeDisposable = class extends C33.Disposable {
        constructor(...s2) {
          super(), this._disposables = /* @__PURE__ */ new Set();
          for (let e of s2) this.Add(e);
        }
        Add(...s2) {
          if (this._disposed) throw new Error("already disposed");
          for (let e of s2) this._disposables.add(e);
        }
        Remove(s2) {
          if (this._disposed) throw new Error("already disposed");
          this._disposables.delete(s2);
        }
        RemoveAll() {
          if (this._disposed) throw new Error("already disposed");
          if (this._disposables) {
            for (let s2 of this._disposables) s2.Dispose();
            this._disposables.clear();
          }
        }
        IsDisposed() {
          return this._disposed;
        }
        Dispose() {
          if (this._disposed) throw new Error("already disposed");
          this._disposed = true;
          for (let s2 of this._disposables) s2.Dispose();
          this._disposables.clear(), this._disposables = null;
        }
        Release() {
          this.Dispose();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.KahanSum = class extends C33.DefendedBase {
        constructor() {
          super(), this._c = 0, this._y = 0, this._t = 0, this._sum = 0;
        }
        Add(s2) {
          s2 = +s2, this._y = s2 - this._c, this._t = this._sum + this._y, this._c = this._t - this._sum - this._y, this._sum = this._t;
        }
        Subtract(s2) {
          this._sum -= +s2;
        }
        Get() {
          return this._sum;
        }
        Reset() {
          this._c = 0, this._y = 0, this._t = 0, this._sum = 0;
        }
        Set(s2) {
          this._c = 0, this._y = 0, this._t = 0, this._sum = +s2;
        }
        Copy(s2) {
          this._c = s2._c, this._y = s2._y, this._t = s2._t, this._sum = s2._sum;
        }
        Release() {
        }
      };
    }
    {
      const C33 = self.C3, js_cols = {}, RED = true, BLACK = false;
      js_cols.RBnode = function(t) {
        this.tree = t, this.right = this.tree.sentinel, this.left = this.tree.sentinel, this.parent = null, this.color = false, this.key = null;
      }, js_cols.RedBlackSet = function(t) {
        this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = false, this.root = this.sentinel, this.root.parent = this.sentinel, this.compare = t || this.default_compare;
      }, js_cols.RedBlackSet.prototype.default_compare = function(t, e) {
        return t < e ? -1 : e < t ? 1 : 0;
      }, js_cols.RedBlackSet.prototype.clone = function() {
        var t = new js_cols.RedBlackSet(this.compare);
        return t.insertAll(this), t;
      }, js_cols.RedBlackSet.prototype.clear = function() {
        this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = false, this.root = this.sentinel, this.root.parent = this.sentinel;
      }, js_cols.RedBlackSet.prototype.leftRotate = function(t) {
        var e = t.right;
        t.right = e.left, e.left != this.sentinel && (e.left.parent = t), e.parent = t.parent, t.parent == this.sentinel ? this.root = e : t == t.parent.left ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;
      }, js_cols.RedBlackSet.prototype.rightRotate = function(t) {
        var e = t.left;
        t.left = e.right, e.right != this.sentinel && (e.right.parent = t), e.parent = t.parent, t.parent == this.sentinel ? this.root = e : t == t.parent.right ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;
      }, js_cols.RedBlackSet.prototype.insert = function(t) {
        if (this.contains(t)) {
          this.get_(t).key = t;
        } else {
          var e = new js_cols.RBnode(this);
          e.key = t;
          for (var s2 = this.sentinel, r2 = this.root; r2 != this.sentinel; ) s2 = r2, r2 = this.compare(e.key, r2.key) < 0 ? r2.left : r2.right;
          e.parent = s2, s2 == this.sentinel ? this.root = e : this.compare(e.key, s2.key) < 0 ? s2.left = e : s2.right = e, e.left = this.sentinel, e.right = this.sentinel, e.color = RED, this.insertFixup(e), this.size++;
        }
      }, js_cols.RedBlackSet.prototype.insertFixup = function(t) {
        for (; t != this.sentinel && t != this.root && t.parent.color == RED; ) {
          var e;
          if (t.parent == t.parent.parent.left) (e = t.parent.parent.right).color == RED ? (t.parent.color = false, e.color = false, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.right && (t = t.parent, this.leftRotate(t)), t.parent.color = false, t.parent.parent.color = RED, t.parent.parent != this.sentinel && this.rightRotate(t.parent.parent));
          else (e = t.parent.parent.left).color == RED ? (t.parent.color = false, e.color = false, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.left && (t = t.parent, this.rightRotate(t)), t.parent.color = false, t.parent.parent.color = RED, t.parent.parent != this.sentinel && this.leftRotate(t.parent.parent));
        }
        this.root.color = false;
      }, js_cols.RedBlackSet.prototype.delete_ = function(t) {
        var e, s2;
        (s2 = (e = t.left == this.sentinel || t.right == this.sentinel ? t : this.successor_(t)).left != this.sentinel ? e.left : e.right).parent = e.parent, e.parent == this.sentinel ? this.root = s2 : e == e.parent.left ? e.parent.left = s2 : e.parent.right = s2, e != t && (t.key = e.key), false == e.color && this.deleteFixup(s2), this.size--;
      }, js_cols.RedBlackSet.prototype.deleteFixup = function(t) {
        for (; t != this.root && false == t.color; ) {
          var e;
          if (t == t.parent.left) (e = t.parent.right).color == RED && (e.color = false, t.parent.color = RED, this.leftRotate(t.parent), e = t.parent.right), false == e.left.color && false == e.right.color ? (e.color = RED, t = t.parent) : (false == e.right.color && (e.left.color = false, e.color = RED, this.rightRotate(e), e = t.parent.right), e.color = t.parent.color, t.parent.color = false, e.right.color = false, this.leftRotate(t.parent), t = this.root);
          else (e = t.parent.left).color == RED && (e.color = false, t.parent.color = RED, this.rightRotate(t.parent), e = t.parent.left), false == e.right.color && false == e.left.color ? (e.color = RED, t = t.parent) : (false == e.left.color && (e.right.color = false, e.color = RED, this.leftRotate(e), e = t.parent.left), e.color = t.parent.color, t.parent.color = false, e.left.color = false, this.rightRotate(t.parent), t = this.root);
        }
        t.color = false;
      }, js_cols.RedBlackSet.prototype.remove = function(t) {
        var e = this.get_(t);
        if (e != this.sentinel) {
          var s2 = e.key;
          return this.delete_(e), s2;
        }
        return null;
      }, js_cols.RedBlackSet.prototype.removeSwapped = function(t, e) {
        this.remove(e);
      }, js_cols.RedBlackSet.prototype.min = function(t) {
        for (; t.left != this.sentinel; ) t = t.left;
        return t;
      }, js_cols.RedBlackSet.prototype.max = function(t) {
        for (; t.right != this.sentinel; ) t = t.right;
        return t;
      }, js_cols.RedBlackSet.prototype.successor_ = function(t) {
        if (t.right != this.sentinel) return this.min(t.right);
        for (var e = t.parent; e != this.sentinel && t == e.right; ) t = e, e = e.parent;
        return e;
      }, js_cols.RedBlackSet.prototype.predeccessor_ = function(t) {
        if (t.left != this.sentinel) return this.max(t.left);
        for (var e = t.parent; e != this.sentinel && t == e.left; ) t = e, e = e.parent;
        return e;
      }, js_cols.RedBlackSet.prototype.successor = function(t) {
        if (this.size > 0) {
          var e = this.get_(t);
          if (e == this.sentinel) return null;
          if (e.right != this.sentinel) return this.min(e.right).key;
          for (var s2 = e.parent; s2 != this.sentinel && e == s2.right; ) e = s2, s2 = s2.parent;
          return s2 != this.sentinel ? s2.key : null;
        }
        return null;
      }, js_cols.RedBlackSet.prototype.predecessor = function(t) {
        if (this.size > 0) {
          var e = this.get_(t);
          if (e == this.sentinel) return null;
          if (e.left != this.sentinel) return this.max(e.left).key;
          for (var s2 = e.parent; s2 != this.sentinel && e == s2.left; ) e = s2, s2 = s2.parent;
          return s2 != this.sentinel ? s2.key : null;
        }
        return null;
      }, js_cols.RedBlackSet.prototype.getMin = function() {
        return this.min(this.root).key;
      }, js_cols.RedBlackSet.prototype.getMax = function() {
        return this.max(this.root).key;
      }, js_cols.RedBlackSet.prototype.get_ = function(t) {
        for (var e = this.root; e != this.sentinel && 0 != this.compare(e.key, t); ) e = this.compare(t, e.key) < 0 ? e.left : e.right;
        return e;
      }, js_cols.RedBlackSet.prototype.contains = function(t) {
        return null != this.get_(t).key;
      }, js_cols.RedBlackSet.prototype.getValues = function() {
        var t = [];
        return this.forEach(function(e) {
          t.push(e);
        }), t;
      }, js_cols.RedBlackSet.prototype.insertAll = function(t) {
        if ("array" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.insert(t[e]);
        else if ("function" == js_cols.typeOf(t.forEach)) t.forEach(this.insert, this);
        else if ("function" == js_cols.typeOf(t.getValues)) {
          var s2 = t.getValues();
          for (e = 0; e < s2.length; e++) this.insert(s2[e]);
        } else if ("object" == js_cols.typeOf(t)) for (var r2 in t) this.insert(t[r2]);
      }, js_cols.RedBlackSet.prototype.removeAll = function(t) {
        if ("array" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.remove(t[e]);
        else if ("function" == js_cols.typeOf(t.forEach)) t.forEach(this.removeSwapped, this);
        else if ("function" == js_cols.typeOf(t.getValues)) {
          var s2 = t.getValues();
          for (e = 0; e < s2.length; e++) this.remove(s2[e]);
        } else if ("object" == js_cols.typeOf(t)) for (var r2 in t) this.remove(t[r2]);
      }, js_cols.RedBlackSet.prototype.containsAll = function(t) {
        if ("array" == js_cols.typeOf(t)) {
          for (var e = 0; e < t.length; e++) if (!this.contains(t[e])) return false;
          return true;
        }
        if ("function" == js_cols.typeOf(t.forEach)) return t.every(this.contains, this);
        if ("function" == js_cols.typeOf(t.getValues)) {
          var s2 = t.getValues();
          for (e = 0; e < s2.length; e++) if (!this.contains(s2[e])) return false;
          return true;
        }
        if ("object" == js_cols.typeOf(t)) {
          for (var r2 in t) if (!this.contains(t[r2])) return false;
          return true;
        }
      }, js_cols.RedBlackSet.prototype.range = function(t, e) {
        var s2 = [];
        return this.traverseFromTo(function(t2) {
          s2.push(t2);
        }, t, e), s2;
      }, js_cols.RedBlackSet.prototype.traverse = function(t, e) {
        if (!this.isEmpty()) for (var s2 = this.min(this.root); s2 != this.sentinel; ) {
          if (t.call(e, s2.key, this)) return;
          s2 = this.successor_(s2);
        }
      }, js_cols.RedBlackSet.prototype.traverseFrom = function(t, e, s2) {
        if (!this.isEmpty()) for (var r2 = this.get_(e); r2 != this.sentinel; ) {
          if (t.call(s2, r2.key, this)) return;
          r2 = this.successor_(r2);
        }
      }, js_cols.RedBlackSet.prototype.traverseTo = function(t, e, s2) {
        if (!this.isEmpty()) for (var r2 = this.min(this.root), i2 = this.get_(e); r2 != i2; ) {
          if (t.call(s2, r2.key, this)) return;
          r2 = this.successor_(r2);
        }
      }, js_cols.RedBlackSet.prototype.traverseFromTo = function(t, e, s2, r2) {
        if (!this.isEmpty()) for (var i2 = this.get_(e), o2 = this.get_(s2); i2 != o2; ) {
          if (t.call(r2, i2.key, this)) return;
          i2 = this.successor_(i2);
        }
      }, js_cols.RedBlackSet.prototype.traverseBackwards = function(t, e) {
        if (!this.isEmpty()) for (var s2 = this.max(this.root); s2 != this.sentinel; ) {
          if (t.call(e, s2.key, this)) return;
          s2 = this.predeccessor_(s2);
        }
      }, js_cols.RedBlackSet.prototype.forEach = function(t, e) {
        if (!this.isEmpty()) for (var s2 = this.min(this.root); s2 != this.sentinel; s2 = this.successor_(s2)) t.call(e, s2.key, s2.key, this);
      }, js_cols.RedBlackSet.prototype.some = function(t, e) {
        if (this.isEmpty()) return false;
        for (var s2 = this.min(this.root); s2 != this.sentinel; s2 = this.successor_(s2)) if (t.call(e, s2.key, s2.key, this)) return true;
        return false;
      }, js_cols.RedBlackSet.prototype.every = function(t, e) {
        if (this.isEmpty()) return false;
        for (var s2 = this.min(this.root); s2 != this.sentinel; s2 = this.successor_(s2)) if (!t.call(e, s2.key, s2.key, this)) return false;
        return true;
      }, js_cols.RedBlackSet.prototype.map = function(t, e) {
        var s2 = [];
        if (this.isEmpty()) return s2;
        for (var r2 = this.min(this.root); r2 != this.sentinel; r2 = this.successor_(r2)) s2.push(t.call(e, r2.key, r2.key, this));
        return s2;
      }, js_cols.RedBlackSet.prototype.filter = function(t, e) {
        var s2 = [];
        if (this.isEmpty()) return s2;
        for (var r2 = this.min(this.root); r2 != this.sentinel; r2 = this.successor_(r2)) t.call(e, r2.key, r2.key, this) && s2.push(r2.key);
        return s2;
      }, js_cols.RedBlackSet.prototype.getCount = function() {
        return this.size;
      }, js_cols.RedBlackSet.prototype.isEmpty = function() {
        return 0 == this.size;
      }, js_cols.RedBlackSet.prototype.isSubsetOf = function(t) {
        var e = js_cols.getCount(t);
        if (this.getCount() > e) return false;
        var s2 = 0;
        if (this.isEmpty()) return true;
        for (var r2 = this.min(this.root); r2 != this.sentinel; r2 = this.successor_(r2)) js_cols.contains.call(t, t, r2.key) && s2++;
        return s2 == this.getCount();
      }, js_cols.RedBlackSet.prototype.intersection = function(t) {
        var e = new js_cols.RedBlackSet(this.compare);
        if (this.isEmpty()) return e;
        for (var s2 = this.min(this.root); s2 != this.sentinel; s2 = this.successor_(s2)) t.contains.call(t, s2.key, s2.key, this) && e.insert(s2.key);
        return e;
      }, C33.RedBlackSet = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._rbSet = new js_cols.RedBlackSet(t), this._enableQueue = false, this._queueInsert = /* @__PURE__ */ new Set(), this._queueRemove = /* @__PURE__ */ new Set();
        }
        Add(t) {
          this._enableQueue ? this._rbSet.contains(t) ? this._queueRemove.delete(t) : this._queueInsert.add(t) : this._rbSet.insert(t);
        }
        Remove(t) {
          this._enableQueue ? this._rbSet.contains(t) ? this._queueRemove.add(t) : this._queueInsert.delete(t) : this._rbSet.remove(t);
        }
        Has(t) {
          return this._enableQueue ? !!this._queueInsert.has(t) || !this._queueRemove.has(t) && this._rbSet.contains(t) : this._rbSet.contains(t);
        }
        Clear() {
          this._rbSet.clear(), this._queueInsert.clear(), this._queueRemove.clear();
        }
        toArray() {
          if (this._enableQueue) throw new Error("cannot be used in queueing mode");
          return this._rbSet.getValues();
        }
        GetSize() {
          return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size;
        }
        IsEmpty() {
          return 0 === this.GetSize();
        }
        Front() {
          if (this.IsEmpty()) throw new Error("empty set");
          if (this._enableQueue) throw new Error("cannot be used in queueing mode");
          const t = this._rbSet;
          return t.min(t.root).key;
        }
        Shift() {
          if (this.IsEmpty()) throw new Error("empty set");
          if (this._enableQueue) throw new Error("cannot be used in queueing mode");
          const t = this.Front();
          return this.Remove(t), t;
        }
        SetQueueingEnabled(t) {
          if (t = !!t, this._enableQueue !== t && (this._enableQueue = t, !t)) {
            for (const t2 of this._queueRemove) this._rbSet.remove(t2);
            this._queueRemove.clear();
            for (const t2 of this._queueInsert) this._rbSet.insert(t2);
            this._queueInsert.clear();
          }
        }
        ForEach(t) {
          this._rbSet.forEach(t);
        }
        *values() {
          if (this.IsEmpty()) return;
          const t = this._rbSet;
          for (let e = t.min(t.root); e != t.sentinel; e = t.successor_(e)) yield e.key;
        }
        [Symbol.iterator]() {
          return this.values();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PromiseThrottle = class {
        constructor(e = C33.hardwareConcurrency) {
          this._maxParallel = e, this._queue = [], this._activeCount = 0;
        }
        Add(e, t) {
          return new Promise((r2, n) => {
            const s2 = { func: e, resolve: r2, reject: n, opts: t };
            t?.signal && t.signal.aborted ? n(new Error("abort")) : (t?.signal && (s2.onabort = () => {
              const e2 = this._queue.indexOf(s2);
              -1 !== e2 && (this._queue.splice(e2, 1), n(new Error("abort")));
            }, t.signal.addEventListener("abort", s2.onabort)), this._queue.push(s2), this._MaybeStartNext());
          });
        }
        _FindInQueue(e) {
          for (let t = 0, r2 = this._queue.length; t < r2; ++t) if (this._queue[t].func === e) return t;
          return -1;
        }
        RemoveAndResolve(e, t) {
          const r2 = this._FindInQueue(e);
          if (-1 === r2) throw new Error("cannot find promise to resolve");
          this._queue[r2].resolve(t), this._queue.splice(r2, 1);
        }
        RemoveAndReject(e, t) {
          const r2 = this._FindInQueue(e);
          if (-1 === r2) throw new Error("cannot find promise to reject");
          this._queue[r2].reject(t), this._queue.splice(r2, 1);
        }
        async _MaybeStartNext() {
          if (!this._queue.length) return;
          if (this._activeCount >= this._maxParallel) return;
          this._activeCount++;
          const e = this._queue.shift();
          e.opts?.signal && e.onabort && e.opts.signal.removeEventListener("abort", e.onabort);
          try {
            const t = await e.func();
            e.resolve(t);
          } catch (t) {
            e.reject(t);
          }
          this._activeCount--, this._MaybeStartNext();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.RateLimiter = class {
        constructor(t, e, i2) {
          this._callback = t, this._interval = e, this._intervalOnBattery = i2 || 2 * e, this._timerId = -1, this._lastCallTime = -1 / 0, this._timerCallFunc = () => this._OnTimer(), this._ignoreReset = false, this._canRunImmediate = false, this._callbackArguments = null;
        }
        SetCanRunImmediate(t) {
          this._canRunImmediate = !!t;
        }
        _GetInterval() {
          return void 0 !== C33.Battery && C33.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval;
        }
        Call(...t) {
          if (-1 !== this._timerId) return;
          this._callbackArguments = t;
          let e = C33.FastGetDateNow(), i2 = e - this._lastCallTime, l2 = this._GetInterval();
          i2 >= l2 && this._canRunImmediate ? (this._lastCallTime = e, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(l2 - i2, 4));
        }
        _RunCallback() {
          this._ignoreReset = true;
          const t = this._callbackArguments;
          this._callbackArguments = null, t ? this._callback(...t) : this._callback(), this._ignoreReset = false;
        }
        Reset() {
          this._ignoreReset || (this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = C33.FastGetDateNow());
        }
        _OnTimer() {
          this._timerId = -1, this._lastCallTime = C33.FastGetDateNow(), this._RunCallback();
        }
        _CancelTimer() {
          -1 !== this._timerId && (self.clearTimeout(this._timerId), this._timerId = -1);
        }
        Release() {
          this._CancelTimer(), this._callback = null, this._callbackArguments = null, this._timerCallFunc = null;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SVGRasterManager = class {
        constructor() {
          this._images = /* @__PURE__ */ new Map(), this._allowNpotSurfaces = false, this._getBaseSizeCallback = null, this._rasterAtSizeCallback = null, this._releaseResultCallback = null, this._redrawCallback = null;
        }
        SetNpotSurfaceAllowed(e) {
          this._allowNpotSurfaces = !!e;
        }
        IsNpotSurfaceAllowed() {
          return this._allowNpotSurfaces;
        }
        SetGetBaseSizeCallback(e) {
          this._getBaseSizeCallback = e;
        }
        GetBaseSize(e) {
          if (!this._getBaseSizeCallback) throw new Error("no get base size callback set");
          return this._getBaseSizeCallback(e);
        }
        SetRasterAtSizeCallback(e) {
          this._rasterAtSizeCallback = e;
        }
        RasterAtSize(e, a2, t, l2, s2, r2) {
          if (!this._rasterAtSizeCallback) throw new Error("no raster at size callback set");
          return this._rasterAtSizeCallback(e, a2, t, l2, s2, r2);
        }
        SetReleaseResultCallback(e) {
          this._releaseResultCallback = e;
        }
        ReleaseResult(e) {
          if (!this._releaseResultCallback) throw new Error("no release result callback set");
          this._releaseResultCallback(e);
        }
        SetRedrawCallback(e) {
          this._redrawCallback = e;
        }
        Redraw() {
          if (!this._redrawCallback) throw new Error("no redraw callback set");
          this._redrawCallback();
        }
        AddImage(e) {
          let a2 = this._images.get(e);
          return a2 || (a2 = C33.New(C33.SVGRasterImage, this, e), this._images.set(e, a2)), a2.IncReference(), a2;
        }
        _RemoveImage(e) {
          this._images.delete(e.GetDataSource());
        }
        OnTexturesChanged() {
          for (const e of this._images.values()) e.ReleaseRasterizedResult(), e.ForceRasterAgain();
        }
      };
    }
    {
      const C33 = self.C3, MAX_SURFACE_SIZE = 4096;
      C33.SVGRasterImage = class {
        constructor(e, t) {
          this._manager = e, this._dataSource = t, this._refCount = 0, this._baseWidth = 0, this._baseHeight = 0, this._getBaseSizePromise = this._manager.GetBaseSize(t).then((e2) => {
            this._manager && (this._baseWidth = e2[0], this._baseHeight = e2[1], this._manager.Redraw());
          }).catch((e2) => {
            console.error("[SVG] Error loading SVG: ", e2), this._hadError = true, this._manager && this._manager.Redraw();
          }), this._rasterSurfaceWidth = 0, this._rasterSurfaceHeight = 0, this._rasterImageWidth = 0, this._rasterImageHeight = 0, this._isRasterizing = false, this._rasterizedResult = null, this._forceRaster = false, this._hadError = false;
        }
        Release() {
          if (this._refCount <= 0) throw new Error("already released");
          this._refCount--, 0 === this._refCount && this._Release();
        }
        ReleaseRasterizedResult() {
          this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null);
        }
        _Release() {
          this.ReleaseRasterizedResult(), this._manager._RemoveImage(this), this._manager = null;
        }
        GetDataSource() {
          return this._dataSource;
        }
        IncReference() {
          this._refCount++;
        }
        HasReferences() {
          return this._refCount > 0;
        }
        GetRasterizedResult() {
          return this._rasterizedResult;
        }
        ForceRasterAgain() {
          this._forceRaster = true;
        }
        async StartRasterForSize(e, t, r2) {
          if (0 === t || 0 === r2 || this._hadError) return;
          if (this._isRasterizing) return;
          let s2 = C33.nextHighestPowerOfTwo(Math.ceil(t)), a2 = C33.nextHighestPowerOfTwo(Math.ceil(r2));
          const i2 = Math.max(s2, a2);
          if (i2 > 4096) {
            const e2 = 4096 / i2;
            t *= e2, r2 *= e2, s2 = Math.min(Math.ceil(s2 * e2), 4096), a2 = Math.min(Math.ceil(a2 * e2), 4096);
          }
          if (t < s2 && r2 < a2) {
            const e2 = t / r2;
            s2 / a2 > e2 ? (t = a2 * e2, r2 = a2) : (t = s2, r2 = s2 / e2);
          }
          if (this._manager.IsNpotSurfaceAllowed() && (s2 = Math.ceil(t), a2 = Math.ceil(r2)), s2 <= this._rasterSurfaceWidth && a2 <= this._rasterSurfaceHeight && !this._forceRaster) return;
          this._isRasterizing = true, this._rasterSurfaceWidth = s2, this._rasterSurfaceHeight = a2;
          const h = await this._manager.RasterAtSize(this._dataSource, e, this._rasterSurfaceWidth, this._rasterSurfaceHeight, t, r2);
          this._manager && (this.ReleaseRasterizedResult(), this._rasterizedResult = h, this._rasterImageWidth = t, this._rasterImageHeight = r2, this._isRasterizing = false, this._forceRaster = false, this._manager.Redraw());
        }
        WhenBaseSizeReady() {
          return this._getBaseSizePromise;
        }
        GetBaseWidth() {
          return this._baseWidth;
        }
        GetBaseHeight() {
          return this._baseHeight;
        }
        GetRasterWidth() {
          return this._rasterImageWidth;
        }
        GetRasterHeight() {
          return this._rasterImageHeight;
        }
        HadError() {
          return this._hadError;
        }
      };
    }
    {
      let lookupHtmlEntity2 = function(t) {
        return HTML_ENTITY_MAP.get(t);
      };
      lookupHtmlEntity = lookupHtmlEntity2;
      const C33 = self.C3;
      C33.UTF8_BOM = "\uFEFF";
      const NUMERIC_CHARS = new Set("0123456789");
      C33.IsNumericChar = function(t) {
        return NUMERIC_CHARS.has(t);
      };
      const WHITESPACE_CHARS = new Set(" 	\n\r\xA0\x85\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u2028\u2029\u202F\u205F\u3000");
      C33.IsWhitespaceChar = function(t) {
        return WHITESPACE_CHARS.has(t);
      }, C33.FilterWhitespace = function(t) {
        return [...t].filter((t2) => !C33.IsWhitespaceChar(t2)).join("");
      }, C33.IsStringAllWhitespace = function(t) {
        for (const e of t) if (!C33.IsWhitespaceChar(e)) return false;
        return true;
      }, C33.IsCharArrayAllWhitespace = function(t) {
        for (const e of t) if (!C33.IsWhitespaceChar(e)) return false;
        return true;
      }, C33.IsUnprintableChar = function(t) {
        return 1 === t.length && t.charCodeAt(0) < 32;
      }, C33.FilterUnprintableChars = function(t) {
        return [...t].filter((t2) => !C33.IsUnprintableChar(t2)).join("");
      };
      let cjkPunctuationRegex = null;
      try {
        cjkPunctuationRegex = new RegExp("\\p{P}(?<=[\\u3000-\\u303F\\uFF00-\\uFFEF])", "u");
      } catch (t) {
        console.warn("Unable to detect CJK punctuation: ", t);
      }
      C33.IsCJKPunctuationChar = function(t) {
        return !C33.IsWhitespaceChar(t) && cjkPunctuationRegex && cjkPunctuationRegex.test(t);
      };
      const NUMERIC_STRING_CHARS = new Set("0123456789.+-e");
      C33.IsStringNumber = function(t) {
        if (!(t = t.trim()).length) return false;
        let e = t.charAt(0);
        if ("-" !== e && !NUMERIC_CHARS.has(e)) return false;
        for (let e2 of t) if (!NUMERIC_STRING_CHARS.has(e2)) return false;
        return true;
      }, C33.RemoveTrailingDigits = function(t) {
        let e = t.length;
        for (; e > 0; ) {
          let n = t.charAt(e - 1);
          if (!C33.IsNumericChar(n)) break;
          --e;
        }
        return t.substr(0, e);
      }, C33.IncrementNumberAtEndOf = function(t) {
        let e = C33.RemoveTrailingDigits(t), n = t.substr(e.length);
        return n = n ? (parseInt(n, 10) + 1).toString() : "2", e + n;
      };
      const HTML_ENTITY_MAP = /* @__PURE__ */ new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ['"', "&quot;"], ["'", "&#39;"]]);
      const HTML_ENTITY_REGEX = /[&<>"']/g;
      C33.EscapeHTML = function(t) {
        return t.replace(HTML_ENTITY_REGEX, lookupHtmlEntity2);
      }, C33.EscapeJS = function(t) {
        let e = C33.ReplaceAll(t, "\\", "\\\\");
        return e = C33.ReplaceAll(e, '"', '\\"'), e = C33.ReplaceAll(e, "	", "\\t"), e = C33.ReplaceAll(e, "\r", ""), C33.ReplaceAll(e, "\n", "\\n");
      }, C33.EscapeXML = function(t) {
        let e = C33.ReplaceAll(t, "&", "&amp;");
        return e = C33.ReplaceAll(e, "<", "&lt;"), e = C33.ReplaceAll(e, ">", "&gt;"), C33.ReplaceAll(e, '"', "&quot;");
      };
      const ESCAPE_REGEX = /[-[\]{}()*+?.,\\^$|#\s]/g;
      C33.EscapeRegex = function(t) {
        return t.replace(ESCAPE_REGEX, "\\$&");
      }, C33.CountCharsInString = function(t, e) {
        let n = 0;
        for (const r2 of t) r2 === e && ++n;
        return n;
      }, C33.StringPosToLineNumber = function(t, e) {
        let n = 0, r2 = 0;
        for (; n < e; ) {
          if (n = t.indexOf("\n", n), -1 === n) return r2;
          r2++, n++;
        }
        return r2;
      }, C33.FindAll = function(t, e, n = false) {
        if (!e) return [];
        n || (t = t.toLowerCase(), e = e.toLowerCase());
        const r2 = e.length;
        let o2 = 0, i2 = 0, l2 = [];
        for (; (i2 = t.indexOf(e, o2)) > -1; ) l2.push(i2), o2 = i2 + r2;
        return l2;
      }, C33.ReplaceAll = function(t, e, n) {
        return t.replaceAll(e, () => n);
      }, C33.ReplaceAllCaseInsensitive = function(t, e, n) {
        return t.replace(new RegExp(C33.EscapeRegex(e), "gi"), () => n);
      }, C33.SetElementContent = function(t, e) {
        "string" == typeof e ? t.textContent = e : e.isPlainText() ? t.textContent = e.toString() : (t.innerHTML = e.toHTML(), e instanceof C33.BBString && e.attachLinkHandlers(t));
      }, C33.StringLikeEquals = function(t, e) {
        return t instanceof C33.HtmlString || t instanceof C33.BBString ? t.equals(e) : e instanceof C33.HtmlString || e instanceof C33.BBString ? e.equals(t) : t === e;
      }, C33.StringSubstitute = function(t, ...e) {
        let n = t;
        for (let r2 = 0, o2 = e.length; r2 < o2; ++r2) {
          const o3 = `{${r2}}`;
          if (!t.includes(o3)) throw new Error(`missing placeholder '${o3}' in string substitution`);
          n = n.replace(o3, e[r2].toString());
        }
        return n;
      }, C33.StringSubstituteAllowMissing = function(t, ...e) {
        let n = t, r2 = -1, o2 = -1;
        for (let i2 = 0, l2 = e.length; i2 < l2; ++i2) {
          const l3 = `{${i2}}`;
          t.includes(l3) ? (o2 = i2, n = n.replace(l3, e[i2].toString())) : -1 === r2 && (r2 = i2);
        }
        if (r2 >= 0 && o2 >= 0 && r2 < o2) throw new Error(`missing placeholder '${r2}' in string substitution`);
        return n;
      }, C33.StringSubstituteMap = function(t, e) {
        let n = t;
        for (let [t2, r2] of Object.entries(e)) n = n.replaceAll(t2, r2.toString());
        return n;
      }, C33.SortAZ = function(t, e) {
        return t > e ? 1 : t < e ? -1 : 0;
      }, C33.SortAZCaseInsensitive = function(t, e) {
        let n = t.toLowerCase(), r2 = e.toLowerCase();
        return n > r2 ? 1 : n < r2 ? -1 : 0;
      };
      const intlSegmenter = new self["Intl"]["Segmenter"]();
      C33.SplitGraphemes = function(t) {
        const e = [];
        for (const n of intlSegmenter["segment"](t)) e.push(n["segment"]);
        return e;
      }, C33.IterateGraphemes = function* (t) {
        for (const e of intlSegmenter["segment"](t)) yield e["segment"];
      }, C33.CountGraphemes = function(t) {
        let e = 0;
        for (const n of intlSegmenter["segment"](t)) ++e;
        return e;
      };
      const KILOBYTE = 1024, MEGABYTE = 1048576, GIGABYTE = 1073741824, TERABYTE = 1099511627776;
      C33.FormatDataSize = function(t, e) {
        let n = "common." + (e ? "dataRates" : "dataSizes") + ".";
        const r2 = self.langSub;
        if (t < 1024) return r2(n + "bytes", t);
        if (t < 1048576) {
          let e2 = t / 1024;
          return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r2(n + "kilobytes", e2);
        }
        if (t < GIGABYTE) {
          let e2 = t / 1048576;
          return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r2(n + "megabytes", e2);
        }
        if (t < TERABYTE) {
          let e2 = t / GIGABYTE;
          return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r2(n + "gigabytes", e2);
        }
        {
          let e2 = t / TERABYTE;
          return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r2(n + "terabytes", e2);
        }
      };
      const DEFAULT_FORMATTIME_OPTS = { approximate: false, days: true, hours: true, minutes: true, seconds: true };
      C33.FormatTime = function(t, e) {
        e = Object.assign({}, DEFAULT_FORMATTIME_OPTS, e), C33.Lang.PushContext("common.time");
        const n = [], r2 = self.lang, o2 = self.langPluralSub;
        if (e.days) {
          const e2 = Math.floor(t / 86400);
          e2 > 0 && (t -= 24 * e2 * 3600, n.push(o2(".days", null, e2)));
        }
        if (e.hours) {
          const e2 = Math.floor(t / 3600);
          (e2 > 0 || n.length) && (t -= 3600 * e2, n.push(o2(".hours", null, e2)));
        }
        if (e.minutes) {
          const r3 = Math.floor(t / 60);
          (r3 > 0 || n.length || !e.seconds) && (t -= 60 * r3, n.push(o2(".minutes", null, r3)));
        }
        if (e.seconds) {
          const e2 = Math.floor(t % 60);
          n.push(o2(".seconds", null, e2));
        }
        const i2 = (e.approximate ? r2(".approx-prefix") : "") + n.join(r2(".separator"));
        return C33.Lang.PopContext(), i2;
      }, C33.ZeroPad = function(t, e) {
        let n = t < 0 ? "-" : "", r2 = (t = Math.abs(t)).toString(), o2 = e - r2.length;
        for (let t2 = 0; t2 < o2; ++t2) n += "0";
        return n + r2;
      }, C33.StringToTitleCase = function(t) {
        return t.toLowerCase().replace(/\b\w/g, (t2) => t2.toUpperCase());
      }, C33.CompareVersionStrings = function(t, e) {
        let n = t.split(".").map((t2) => t2.trim()), r2 = e.split(".").map((t2) => t2.trim());
        C33.resizeArray(n, 4, "0"), C33.resizeArray(r2, 4, "0"), n = n.map((t2) => parseInt(t2, 10)), r2 = r2.map((t2) => parseInt(t2, 10));
        for (let t2 = 0; t2 < 4; ++t2) {
          const e2 = n[t2] - r2[t2];
          if (0 !== e2) return e2 < 0 ? -1 : 1;
        }
        return 0;
      }, C33.CreateGUID = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
          const e = Math.floor(16 * Math.random());
          return ("x" === t ? e : 3 & e | 8).toString(16);
        });
      }, C33.StringHammingDistance = function(t, e) {
        if (t.length !== e.length) throw new Error("strings must be same length");
        let n = 0;
        for (let r2 = 0, o2 = t.length; r2 < o2; ++r2) t.charAt(r2) !== e.charAt(r2) && ++n;
        return n;
      }, C33.StringLevenshteinDistance = function(t, e) {
        if (0 === t.length) return e.length;
        if (0 === e.length) return t.length;
        let n, r2, o2, i2, l2, s2;
        for (t.length > e.length && (n = t, t = e, e = n), s2 = Array(t.length + 1), r2 = 0; r2 <= t.length; r2++) s2[r2] = r2;
        for (r2 = 1; r2 <= e.length; r2++) {
          for (i2 = r2, o2 = 1; o2 <= t.length; o2++) l2 = e[r2 - 1] === t[o2 - 1] ? s2[o2 - 1] : Math.min(s2[o2 - 1] + 1, Math.min(i2 + 1, s2[o2] + 1)), s2[o2 - 1] = i2, i2 = l2;
          s2[t.length] = i2;
        }
        return s2[t.length];
      };
    }
    var lookupHtmlEntity;
    {
      let bbToHtmlReplacerFunc2 = function(t, s2, i2) {
        const n = BB_CODE_MAP.get(i2);
        if (!n) return "class" === i2 ? s2 ? "</span>" : `<span class="bbclass${classIndex++}">` : t;
        if ("string" == typeof n) {
          if ("a" === n && 0 === linkActions.length || "abbr" === n && 0 === tipList.length) return t;
          if ("a" !== n || s2) {
            if ("abbr" !== n || s2) return "<" + s2 + n + ">";
            {
              const t2 = parseInt(i2.substring(3), 10) - 1;
              if (t2 < 0 || t2 >= tipList.length) throw new Error("invalid bbcode tip substitution");
              const s3 = tipList[t2];
              let n2 = "";
              if ("string" == typeof s3 ? n2 = s3 : "function" == typeof s3 && (n2 = s3()), "string" != typeof n2) throw new TypeError("invalid bbcode tip");
              return `<abbr title="${C33.ReplaceAll(n2, '"', "&quot;")}">`;
            }
          }
          {
            const t2 = parseInt(i2.substring(1), 10) - 1;
            if (t2 < 0 || t2 >= linkActions.length) throw new Error("invalid bbcode link substitution");
            const s3 = linkActions[t2];
            if ("string" == typeof s3) return `<a href="${linkActions[t2]}">`;
            if ("function" == typeof s3) return `<a class="bblink${t2}">`;
            throw new TypeError("invalid bbcode link action");
          }
        }
        if (Array.isArray(n)) {
          let t2 = n[0], i3 = n[1];
          return s2 ? "</" + t2 + ">" : `<${t2} class="${i3}">`;
        }
      };
      bbToHtmlReplacerFunc = bbToHtmlReplacerFunc2;
      const C33 = self.C3, assert = self.assert, BB_CODE_MAP = /* @__PURE__ */ new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["sub", "sub"], ["sup", "sup"], ["small", "small"], ["mark", "mark"], ["code", "code"], ["a1", "a"], ["a2", "a"], ["a3", "a"], ["a4", "a"], ["a5", "a"], ["a6", "a"], ["a7", "a"], ["a8", "a"], ["a9", "a"], ["tip1", "abbr"], ["tip2", "abbr"], ["tip3", "abbr"], ["tip4", "abbr"], ["tip5", "abbr"], ["tip6", "abbr"], ["tip7", "abbr"], ["tip8", "abbr"], ["tip9", "abbr"], ["bad", ["span", "bbCodeBad"]], ["good", ["span", "bbCodeGood"]], ["info", ["span", "bbCodeInfo"]], ["h1", ["span", "bbCodeH1"]], ["h2", ["span", "bbCodeH2"]], ["h3", ["span", "bbCodeH3"]], ["h4", ["span", "bbCodeH4"]], ["item", ["span", "bbCodeItem"]]]), SELF_CLOSING_TAGS = /* @__PURE__ */ new Set(["icon"]), BBREGEX = /\[(\/?)([a-zA-Z0-9]+)\]/g, CUSTOM_BBREGEX = /\[(\/?)([^\[\n]*?)\]/g;
      let linkActions = null, tipList = null, classIndex = 0;
      const LINEBREAK_REGEX = /\n/g;
      C33.BBString = class {
        constructor(t, s2) {
          if (this._bbstr = s2 && s2.noEscape ? t : C33.EscapeHTML(t), this._htmlstr = "", this._convertLineBreaks = false, this._linkActions = [], this._tipList = [], s2) {
            if (this._convertLineBreaks = !!s2.convertLineBreaks, s2.links) {
              if (s2.links.length > 9) throw new Error("too many links");
              this._linkActions = s2.links;
            }
            if (s2.tips) {
              if (s2.tips.length > 9) throw new Error("too many tips");
              this._tipList = s2.tips;
            }
          }
          this._hasAnyBBtags = this._bbstr.includes("["), this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes("\n"), this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes("&"), this._hasParsedFragments = false, this._fragments = [];
        }
        toString() {
          return this._bbstr;
        }
        valueOf() {
          return this._bbstr;
        }
        isPlainText() {
          return this._isPlain;
        }
        toPlainText() {
          return this._hasAnyBBtags ? this._bbstr.replace(BBREGEX, "") : this._bbstr;
        }
        toHTML() {
          if (this._isPlain) return this._bbstr;
          if (!this._htmlstr && this._bbstr) {
            let t = this._bbstr;
            this._hasAnyBBtags && (classIndex = 0, linkActions = this._linkActions, tipList = this._tipList, t = t.replace(BBREGEX, bbToHtmlReplacerFunc2), linkActions = null, tipList = null), this._needsLineBreakConversion && (t = t.replace(LINEBREAK_REGEX, "<br>")), this._htmlstr = t;
          }
          return this._htmlstr;
        }
        attachLinkHandlers(t) {
          if (this._linkActions.length) for (let s2 = 0, i2 = this._linkActions.length; s2 < i2; ++s2) {
            const i3 = this._linkActions[s2];
            if ("function" != typeof i3) continue;
            const n = t.querySelector(".bblink" + s2);
            if (!n) throw new Error("unable to attach BBString link handler");
            n.onclick = i3;
          }
        }
        equals(t) {
          return t instanceof C33.HtmlString ? this.toHTML() === t.toHTML() : t instanceof C33.BBString ? this._bbstr === t._bbstr : this._bbstr === t;
        }
        toFragmentList() {
          if (this._hasParsedFragments) return this._fragments;
          const t = [], s2 = this._bbstr, i2 = [];
          CUSTOM_BBREGEX.lastIndex = 0;
          let n = 0, e = null;
          for (; null !== (e = CUSTOM_BBREGEX.exec(s2)); ) {
            const r2 = e.index;
            if (r2 > 0 && "\\" === s2.charAt(r2 - 1)) continue;
            const a2 = e[0], o2 = e[1], l2 = e[2], b = s2.substring(n, r2);
            if (n = r2 + a2.length, b && t.push({ text: b, styles: i2.slice(0) }), l2) if (o2) {
              const t2 = l2.toLowerCase();
              for (let s3 = i2.length - 1; s3 >= 0; --s3) if (i2[s3].tag === t2) {
                i2.splice(s3, 1);
                break;
              }
            } else {
              let s3 = l2, n2 = null;
              const e2 = l2.indexOf("=");
              if (-1 !== e2 ? (s3 = l2.substring(0, e2).toLowerCase(), n2 = l2.substring(e2 + 1)) : s3 = s3.toLowerCase(), SELF_CLOSING_TAGS.has(s3)) {
                if ("icon" !== s3) throw new Error(`unknown self-closing tag ${s3}`);
                t.push({ icon: n2, styles: i2.slice(0) });
              } else i2.push({ tag: s3, param: n2 });
            }
          }
          n < s2.length && t.push({ text: s2.substring(n), styles: i2.slice(0) });
          for (const s3 of t) s3.text && (s3.text = this._ProcessBBCodeEscapeSequences(s3.text));
          return this._fragments = t.map((t2) => t2.icon ? C33.New(C33.IconFragment, { icon: t2.icon, styles: t2.styles }) : C33.New(C33.TextFragment, { chArr: C33.SplitGraphemes(t2.text), styles: t2.styles })), this._hasParsedFragments = true, this._fragments;
        }
        _ProcessBBCodeEscapeSequences(t) {
          return t = C33.ReplaceAll(t, "\\[", "["), C33.ReplaceAll(t, "\\\\", "\\");
        }
        static StripTags(t) {
          return C33.New(C33.BBString, t, { noEscape: true }).toPlainText();
        }
        static StripAnyTags(t) {
          return t.replace(CUSTOM_BBREGEX, "");
        }
      };
    }
    var bbToHtmlReplacerFunc;
    {
      let IsWordBreakWhiteSpace2 = function(t) {
        return "\xA0" !== t && "\u202F" !== t && C33.IsWhitespaceChar(t);
      }, IsOpeningCJKPunctiationChar2 = function(t) {
        return CJK_OPEN_PUNCTUATION.has(t);
      }, IsContinuingCJKPunctuationChar2 = function(t) {
        return C33.IsCJKPunctuationChar(t) && !IsOpeningCJKPunctiationChar2(t);
      }, WordBreakTrimEnd2 = function(t) {
        for (; t.length > 0 && IsWordBreakWhiteSpace2(t.at(-1)); ) t.pop();
      }, IsNewline2 = function(t) {
        return "\n" === t || "\r\n" === t;
      };
      IsWordBreakWhiteSpace = IsWordBreakWhiteSpace2, IsOpeningCJKPunctiationChar = IsOpeningCJKPunctiationChar2, IsContinuingCJKPunctuationChar = IsContinuingCJKPunctuationChar2, WordBreakTrimEnd = WordBreakTrimEnd2, IsNewline = IsNewline2;
      const C33 = self.C3;
      const CJK_OPEN_PUNCTUATION = new Set("\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D");
      C33.WordWrap = class {
        constructor() {
          this._lines = [], this._iconSet = null;
        }
        GetLines() {
          return this._lines;
        }
        GetLineCount() {
          return this._lines.length;
        }
        SetIconSet(t) {
          this._iconSet = t;
        }
        _MeasureLine(t, e) {
          let n = 0, s2 = 0, i2 = 0, o2 = 0, r2 = 0;
          for (const h of t) {
            if (-1 === h.GetWidth()) {
              const t2 = e(h);
              h.SetHeight(t2.height), h.SetFontBoundingBoxAscent(t2.fontBoundingBoxAscent || 0), h.SetFontBoundingBoxDescent(t2.fontBoundingBoxDescent || 0), h.SetTopToAlphabeticDistance(t2.topToAlphabeticDistance || 0), h.IsText() ? h.SetWidth(t2.width) : h.IsIcon() && h.CalculateWidthFromHeight(this._iconSet);
            }
            n += h.GetWidth(), s2 = Math.max(s2, h.GetHeight()), i2 = Math.max(i2, h.GetFontBoundingBoxAscent()), o2 = Math.max(o2, h.GetFontBoundingBoxDescent()), r2 = Math.max(r2, h.GetTopToAlphabeticDistance());
          }
          return { width: n, height: s2, fontBoundingBoxAscent: i2, fontBoundingBoxDescent: o2, topToAlphabeticDistance: r2 };
        }
        _AddLine(t, e, n, s2, i2, o2) {
          this._lines.push(C33.New(C33.WordWrap.Line, { fragments: t, width: e, height: n, fontBoundingBoxAscent: s2, fontBoundingBoxDescent: i2, topToAlphabeticDistance: o2 }));
        }
        WordWrap(t, e, n, s2, i2) {
          if ("string" == typeof t && (t = [C33.New(C33.TextFragment, { chArr: C33.SplitGraphemes(t) })]), C33.clearArray(this._lines), !t.length || 1 === t.length && t[0].IsText() && t[0].IsEmpty() || n < 2) return;
          if (1 === t.length) {
            const s3 = t[0];
            if (s3.IsText() && s3.GetLength() <= 100 && !s3.HasNewLine()) {
              let { width: t2, height: o3, fontBoundingBoxAscent: r2, fontBoundingBoxDescent: h, topToAlphabeticDistance: a2 } = e(s3);
              if (t2 += i2, s3.SetWidth(t2), s3.SetHeight(o3), s3.SetFontBoundingBoxAscent(r2 || 0), s3.SetFontBoundingBoxDescent(h || 0), s3.SetTopToAlphabeticDistance(a2 || 0), t2 <= n) return void this._AddLine([s3], t2, o3, r2, h, a2);
            }
          }
          let o2;
          o2 = "word" === s2 ? this._TokeniseByWord(t) : "cjk" === s2 ? this._TokeniseByCJK(t) : this._TokeniseByChar(t), this._WrapText(o2, e, n, i2);
        }
        _TokeniseByWord(t) {
          const e = [];
          let n = [], s2 = false;
          for (const i2 of t) {
            const t2 = i2.GetStyles();
            if (i2.IsIcon()) n.length > 0 && e.push(n), e.push([i2]), n = [];
            else for (const o2 of i2.GetCharacterArray()) if (IsNewline2(o2)) n.length > 0 && e.push(n), e.push([C33.New(C33.TextFragment, { chArr: ["\n"], styles: t2 })]), n = [];
            else if (0 === n.length) n.push(C33.New(C33.TextFragment, { chArr: [o2], styles: t2 })), s2 = IsWordBreakWhiteSpace2(o2);
            else {
              const i3 = IsWordBreakWhiteSpace2(o2);
              if (i3 === s2) {
                const e2 = n.at(-1);
                e2.GetStyles() === t2 ? e2._AppendChar(o2) : n.push(C33.New(C33.TextFragment, { chArr: [o2], styles: t2 }));
              } else e.push(n), n = [C33.New(C33.TextFragment, { chArr: [o2], styles: t2 })], s2 = i3;
            }
          }
          return n.length > 0 && e.push(n), e;
        }
        _TokeniseByCJK(t) {
          const e = [];
          let n = [], s2 = false;
          for (const i2 of t) {
            const t2 = i2.GetStyles();
            if (i2.IsIcon()) n.length > 0 && e.push(n), e.push([i2]), n = [];
            else for (const o2 of i2.GetCharacterArray()) if (IsNewline2(o2)) n.length > 0 && e.push(n), e.push([C33.New(C33.TextFragment, { chArr: ["\n"], styles: t2 })]), n = [];
            else if (0 === n.length) n.push(C33.New(C33.TextFragment, { chArr: [o2], styles: t2 })), s2 = IsOpeningCJKPunctiationChar2(o2);
            else if (s2 || IsContinuingCJKPunctuationChar2(o2)) {
              const e2 = n.at(-1);
              e2.GetStyles() === t2 ? e2._AppendChar(o2) : n.push(C33.New(C33.TextFragment, { chArr: [o2], styles: t2 })), s2 = IsOpeningCJKPunctiationChar2(o2);
            } else e.push(n), n = [C33.New(C33.TextFragment, { chArr: [o2], styles: t2 })], s2 = IsOpeningCJKPunctiationChar2(o2);
          }
          return n.length > 0 && e.push(n), e;
        }
        _TokeniseByChar(t) {
          const e = [];
          for (const n of t) if (n.IsText()) {
            const t2 = n.GetCharacterArray();
            C33.appendArray(e, t2.map((t3) => [C33.New(C33.TextFragment, { chArr: [t3], styles: n.GetStyles() })]));
          } else e.push([n]);
          return e;
        }
        _CopyLine(t) {
          return t.map((t2) => t2._Clone());
        }
        _AddWordToLine(t, e) {
          const n = t.length ? t.at(-1) : null;
          let s2 = 0;
          n && n.IsText() && e[0].IsText() && e[0].GetStyles() === n.GetStyles() && (n._Append(e[0].GetCharacterArray()), s2 = 1);
          for (let n2 = e.length; s2 < n2; ++s2) {
            const n3 = e[s2];
            t.push(n3._Clone());
          }
        }
        _WrapText(t, e, n, s2) {
          let i2 = [], o2 = 0, r2 = 0, h = 0, a2 = 0, c2 = 0;
          for (const s3 of t) {
            if (1 === s3.length && s3[0].IsText() && 1 === s3[0].GetLength() && IsNewline2(s3[0].GetCharacterArray()[0])) {
              if (0 === r2) {
                const t3 = e(C33.New(C33.TextFragment, { chArr: [" "], styles: s3[0].GetStyles() }));
                r2 = t3.height, h = t3.fontBoundingBoxAscent || 0, a2 = t3.fontBoundingBoxDescent || 0, c2 = t3.topToAlphabeticDistance || 0;
              }
              this._AddLine(i2, o2, r2, h, a2, c2), i2 = [], o2 = 0, r2 = 0, h = 0, a2 = 0, c2 = 0;
              continue;
            }
            const t2 = this._CopyLine(i2);
            this._AddWordToLine(t2, s3);
            const l2 = this._MeasureLine(t2, e), u = l2.width;
            if (u >= n) if (i2.length > 0 && this._AddLine(i2, o2, r2, h, a2, c2), i2 = [], s3[0].IsText() && C33.IsCharArrayAllWhitespace(s3[0].GetCharacterArray())) o2 = 0, r2 = 0, h = 0, a2 = 0, c2 = 0;
            else {
              this._AddWordToLine(i2, s3);
              const t3 = this._MeasureLine(i2, e);
              o2 = t3.width, r2 = t3.height, h = t3.fontBoundingBoxAscent, a2 = t3.fontBoundingBoxDescent, c2 = t3.topToAlphabeticDistance;
            }
            else i2 = t2, o2 = u, r2 = l2.height, h = l2.fontBoundingBoxAscent, a2 = l2.fontBoundingBoxDescent, c2 = l2.topToAlphabeticDistance;
          }
          i2.length > 0 && this._AddLine(i2, o2, r2, h, a2, c2), this._TrimLinesTrailingWhitespace(e, s2);
        }
        _TrimLinesTrailingWhitespace(t, e) {
          for (const n of this._lines) {
            const s2 = n._GetFragmentsArray();
            if (!s2.length) continue;
            let i2 = s2.at(-1);
            if (i2.IsText()) {
              const o2 = i2.GetCharacterArray(), r2 = o2.slice(0);
              if (WordBreakTrimEnd2(r2), 0 === r2.length) n.OffsetWidth(-i2.GetWidth()), s2.pop();
              else if (r2.length < o2.length) {
                i2.SetCharacterArray(r2);
                const e2 = t(i2).width, s3 = i2.GetWidth() - e2;
                i2.SetWidth(e2), n.OffsetWidth(-s3);
              }
              0 !== e && s2.length > 0 && (i2 = s2.at(-1), i2.OffsetWidth(e), n.OffsetWidth(e));
            }
          }
        }
        Clear() {
          C33.clearArray(this._lines);
        }
        GetMaxLineWidth() {
          return this._lines.reduce((t, e) => Math.max(t, e.GetWidth()), 0);
        }
        GetTotalLineHeight() {
          return this._lines.reduce((t, e) => t + e.GetHeight(), 0);
        }
      };
    }
    var IsWordBreakWhiteSpace;
    var IsOpeningCJKPunctiationChar;
    var IsContinuingCJKPunctuationChar;
    var WordBreakTrimEnd;
    var IsNewline;
    {
      const C33 = self.C3;
      C33.WordWrap.Line = class {
        constructor(t) {
          this._fragments = t.fragments || [], this._width = t.width || -1, this._height = t.height || -1, this._fontBoundingBoxAscent = t.fontBoundingBoxAscent || -1, this._fontBoundingBoxDescent = t.fontBoundingBoxDescent || -1, this._topToAlphabeticDistance = t.topToAlphabeticDistance || -1, this._posX = 0, this._posY = 0;
        }
        fragments() {
          return this._fragments.values();
        }
        *fragmentsReverse() {
          const t = this._fragments;
          for (let e = t.length - 1; e >= 0; --e) yield t[e];
        }
        _GetFragmentsArray() {
          return this._fragments;
        }
        OffsetWidth(t) {
          this._width += t;
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        GetFoundBoundingBoxAscent() {
          return this._fontBoundingBoxAscent;
        }
        GetFontBoundingBoxDescent() {
          return this._fontBoundingBoxDescent;
        }
        GetTopToAlphabeticDistance() {
          return this._topToAlphabeticDistance;
        }
        SetPosX(t) {
          this._posX = t;
        }
        GetPosX() {
          return this._posX;
        }
        SetPosY(t) {
          this._posY = t;
        }
        GetPosY() {
          return this._posY;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.FragmentBase = class {
        constructor(t) {
          this._styles = t.styles || [], this._width = t.width || -1, this._height = t.height || -1, this._fontBoundingBoxAscent = t.fontBoundingBoxAscent || -1, this._fontBoundingBoxDescent = t.fontBoundingBoxDescent || -1, this._topToAlphabeticDistance = t.topToAlphabeticDistance || -1, this._posX = 0, this._posY = 0;
        }
        IsText() {
          return false;
        }
        IsIcon() {
          return false;
        }
        GetStyles() {
          return this._styles;
        }
        GetStyleTag(t) {
          const e = this._styles;
          for (let s2 = e.length - 1; s2 >= 0; --s2) {
            const n = e[s2];
            if (n.tag === t) return n;
          }
          return null;
        }
        HasStyleTag(t) {
          return !!this.GetStyleTag(t);
        }
        GetStyleMap() {
          const t = /* @__PURE__ */ new Map();
          for (const e of this._styles) t.set(e.tag, e.param);
          return t;
        }
        OffsetWidth(t) {
          this._width += t;
        }
        SetWidth(t) {
          this._width = t;
        }
        GetWidth() {
          return this._width;
        }
        SetHeight(t) {
          this._height = t;
        }
        GetHeight() {
          return this._height;
        }
        SetFontBoundingBoxAscent(t) {
          this._fontBoundingBoxAscent = t;
        }
        GetFontBoundingBoxAscent() {
          return this._fontBoundingBoxAscent;
        }
        SetFontBoundingBoxDescent(t) {
          this._fontBoundingBoxDescent = t;
        }
        GetFontBoundingBoxDescent() {
          return this._fontBoundingBoxDescent;
        }
        SetTopToAlphabeticDistance(t) {
          this._topToAlphabeticDistance = t;
        }
        GetTopToAlphabeticDistance() {
          return this._topToAlphabeticDistance;
        }
        SetPosX(t) {
          this._posX = t;
        }
        GetPosX() {
          return this._posX;
        }
        SetPosY(t) {
          this._posY = t;
        }
        GetPosY() {
          return this._posY;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TextFragment = class extends C33.FragmentBase {
        constructor(t) {
          super(t), this._chArr = t.chArr;
        }
        IsText() {
          return true;
        }
        _Append(t) {
          C33.appendArray(this._chArr, t), this._width = -1, this._height = -1, this._fontBoundingBoxAscent = -1, this._fontBoundingBoxDescent = -1, this._topToAlphabeticDistance = -1;
        }
        _AppendChar(t) {
          this._chArr.push(t);
        }
        _Clone() {
          return C33.New(C33.TextFragment, { chArr: this._chArr.slice(0), styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });
        }
        GetCharacterArray() {
          return this._chArr;
        }
        SetCharacterArray(t) {
          this._chArr = t;
        }
        GetLength() {
          return this._chArr.length;
        }
        IsEmpty() {
          return 0 === this._chArr.length;
        }
        HasNewLine() {
          return this._chArr.includes("\n");
        }
      };
    }
    {
      const C33 = self.C3;
      C33.IconFragment = class extends C33.FragmentBase {
        constructor(t) {
          super(t), this._icon = t.icon;
        }
        IsIcon() {
          return true;
        }
        GetIconParameter() {
          return this._icon;
        }
        _Clone() {
          return C33.New(C33.IconFragment, { icon: this._icon, styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });
        }
        GetTextIcon(t) {
          if (!t) return null;
          let e = Number(this._icon);
          return String(e) === this._icon ? (e = Math.floor(e), t.GetTextIconByIndex(e)) : t.GetTextIconByTag(this._icon);
        }
        CalculateWidthFromHeight(t) {
          const e = this.GetTextIcon(t);
          this._width = e ? this._height * e.GetWidth() / e.GetHeight() : 0;
        }
        GetDrawable(t) {
          const e = this.GetTextIcon(t);
          return e ? e.GetDrawable() : null;
        }
        GetLength() {
          return 1;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TextIconManager = class {
        constructor(t) {
          this._iconSets = /* @__PURE__ */ new Map(), this._getIconSetMetaCallback = t.getIconSetMeta, this._getIconSetContentCallback = t.getIconSetContent;
        }
        Release() {
          for (const t of this._iconSets.values()) t.Release();
          this._iconSets.clear();
        }
        GetIconSet(t) {
          let e = this._iconSets.get(t);
          if (e) return e;
          const n = this._getIconSetMetaCallback(t);
          return e = C33.New(C33.TextIconSet, this, { source: t, iconMeta: n }), this._iconSets.set(t, e), e;
        }
        HasIconSet(t) {
          return this._iconSets.has(t);
        }
        DeleteIconSet(t) {
          const e = this._iconSets.get(t);
          e && e.Release(), this._iconSets.delete(t);
        }
        async _GetIconSetContent(t) {
          return await this._getIconSetContentCallback(t);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TextIconSet = class {
        constructor(t, s2) {
          this._textIconManager = t, this._source = s2.source, this._iconsArray = [], this._iconsByTag = /* @__PURE__ */ new Map(), this._hasStartedLoad = false, this._isLoading = false, this._loadPromise = null;
          const o2 = s2.iconMeta.icons;
          for (let t2 = 0, s3 = o2.length; t2 < s3; ++t2) {
            const s4 = o2[t2], e = C33.New(C33.TextIcon, this, { index: t2, tag: s4.tag, source: s4.source, width: s4.width, height: s4.height });
            this._iconsArray.push(e), s4.tag && this._iconsByTag.set(s4.tag.toLowerCase(), e);
          }
        }
        Release() {
          for (const t of this._iconsArray) t.Release();
          C33.clearArray(this._iconsArray), this._iconsByTag.clear(), this._textIconManager = null, this._source = null;
        }
        HasLoaded() {
          return this._hasStartedLoad;
        }
        IsLoading() {
          return this._isLoading;
        }
        LoadContent() {
          return this._loadPromise || (this._loadPromise = this._DoLoadContent()), this._loadPromise;
        }
        async _DoLoadContent() {
          if (this._hasStartedLoad) return;
          this._hasStartedLoad = true, this._isLoading = true;
          const t = await this._textIconManager._GetIconSetContent(this._source);
          if (!this._textIconManager) return;
          const s2 = t.icons;
          for (let t2 = 0, o2 = Math.min(s2.length, this._iconsArray.length); t2 < o2; ++t2) {
            const o3 = s2[t2].drawable;
            this._iconsArray[t2]._SetDrawable(o3);
          }
          this._isLoading = false;
        }
        GetTextIconByIndex(t) {
          return (t = Math.floor(t)) < 0 || t >= this._iconsArray.length ? null : this._iconsArray[t];
        }
        GetTextIconByTag(t) {
          return this._iconsByTag.get(t.toLowerCase()) || null;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TextIcon = class {
        constructor(t, e) {
          this._textIconSet = t, this._source = e.source || null, this._index = e.index, this._tag = e.tag, this._width = e.width, this._height = e.height, this._drawable = null;
        }
        Release() {
          this._width = 0, this._height = 0, this._textIconSet = null;
        }
        GetSource() {
          return this._source;
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        _SetDrawable(t) {
          this._drawable = t;
        }
        GetDrawable() {
          return this._drawable;
        }
      };
    }
    {
      let PlaneFromPoints2 = function(t, e, r2, n) {
        const a2 = tempVec3c;
        vec32.subtract(tempVec3a, r2, e), vec32.subtract(tempVec3b, t, e), vec32.cross(a2, tempVec3a, tempVec3b), vec32.normalize(a2, a2), n.set(a2[0], a2[1], a2[2], vec32.dot(t, a2));
      }, IsInFrontOfPlane2 = function(t, e, r2, n, a2, c2, s2) {
        const o2 = s2.x, i2 = s2.y, l2 = s2.z, f2 = s2.w, P = s2.xF, h = s2.yF, m = s2.zF, p = 1 - P, v = 1 - h, u = 1 - m;
        if (o2 * t * P + o2 * n * p + i2 * e * h + i2 * a2 * v + l2 * r2 * m + l2 * c2 * u >= f2) return true;
        return o2 * n * P + o2 * t * p + i2 * a2 * h + i2 * e * v + l2 * c2 * m + l2 * r2 * u > f2;
      }, IsPointInFrontOfPlane2 = function(t, e, r2, n) {
        return n.x * t + n.y * e + n.z * r2 >= n.w;
      };
      PlaneFromPoints = PlaneFromPoints2, IsInFrontOfPlane = IsInFrontOfPlane2, IsPointInFrontOfPlane = IsPointInFrontOfPlane2;
      const C33 = self.C3, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, vec42 = glMatrix.vec4, mat42 = glMatrix.mat4, tempVec3a = vec32.create(), tempVec3b = vec32.create(), tempVec3c = vec32.create(), tempVec4 = vec42.create(), tempMat4 = mat42.create(), neartl = vec32.create(), neartr = vec32.create(), nearbl = vec32.create(), nearbr = vec32.create(), fartl = vec32.create(), fartr = vec32.create(), farbl = vec32.create(), farbr = vec32.create(), unitViewport = vec42.fromValues(0, 0, 1, 1);
      C33.Gfx = { Project(t, e, r2, n, a2, c2, s2) {
        const o2 = n[0] * t + n[4] * e + n[8] * r2 + n[12], i2 = n[1] * t + n[5] * e + n[9] * r2 + n[13], l2 = n[2] * t + n[6] * e + n[10] * r2 + n[14], f2 = n[3] * t + n[7] * e + n[11] * r2 + n[15];
        let P = a2[0] * o2 + a2[4] * i2 + a2[8] * l2 + a2[12] * f2, h = a2[1] * o2 + a2[5] * i2 + a2[9] * l2 + a2[13] * f2, m = a2[2] * o2 + a2[6] * i2 + a2[10] * l2 + a2[14] * f2, p = a2[3] * o2 + a2[7] * i2 + a2[11] * l2 + a2[15] * f2;
        return 0 !== p && (p = 1 / p, P *= p, h *= p, m *= p, s2[0] = (0.5 * P + 0.5) * c2[2] + c2[0], s2[1] = (0.5 * h + 0.5) * c2[3] + c2[1], s2[2] = 0.5 * (1 + m), true);
      }, Unproject(t, e, r2, n, a2, c2, s2) {
        const o2 = tempMat4, i2 = tempVec4;
        return mat42.multiply(o2, a2, n), null !== mat42.invert(o2, o2) && (i2[0] = (t - c2[0]) / c2[2] * 2 - 1, i2[1] = (e - c2[1]) / c2[3] * 2 - 1, i2[2] = 2 * r2 - 1, i2[3] = 1, vec42.transformMat4(i2, i2, o2), 0 !== i2[3] && (i2[3] = 1 / i2[3], s2[0] = i2[0] * i2[3], s2[1] = i2[1] * i2[3], s2[2] = i2[2] * i2[3], true));
      }, UnprojectScreenToWorldZ(t, e, r2, n, a2, c2, s2) {
        const o2 = tempVec3a, i2 = tempVec3b;
        if (!C33.Gfx.Unproject(t, e, 0, n, a2, c2, o2)) return false;
        if (!C33.Gfx.Unproject(t, e, 1, n, a2, c2, i2)) return false;
        const l2 = tempVec3b;
        vec32.subtract(l2, i2, o2);
        const f2 = tempVec3c;
        vec32.set(f2, 0, 0, 1);
        const P = -r2, h = vec32.dot(f2, l2);
        let m = 0;
        if (0 === h) {
          if (0 !== vec32.dot(f2, o2) + P) return false;
        } else if (m = -(vec32.dot(o2, f2) + P) / h, m < 0) return false;
        return vec32.scaleAndAdd(s2, o2, l2, m), true;
      } };
      class Plane {
        constructor() {
          this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, this.xF = NaN, this.yF = NaN, this.zF = NaN;
        }
        set(t, e, r2, n) {
          this.x = t, this.y = e, this.z = r2, this.w = n, this.xF = t > 0 ? 1 : 0, this.yF = e > 0 ? 1 : 0, this.zF = r2 > 0 ? 1 : 0;
        }
      }
      C33.Gfx.ViewFrustum = class {
        constructor() {
          this._leftP = new Plane(), this._topP = new Plane(), this._rightP = new Plane(), this._bottomP = new Plane(), this._nearP = new Plane(), this._farP = new Plane();
        }
        CalculatePlanes(t, e) {
          const r2 = unitViewport;
          C33.Gfx.Unproject(0, 1, 0, t, e, r2, neartl), C33.Gfx.Unproject(1, 1, 0, t, e, r2, neartr), C33.Gfx.Unproject(0, 0, 0, t, e, r2, nearbl), C33.Gfx.Unproject(1, 0, 0, t, e, r2, nearbr), C33.Gfx.Unproject(0, 1, 1, t, e, r2, fartl), C33.Gfx.Unproject(1, 1, 1, t, e, r2, fartr), C33.Gfx.Unproject(0, 0, 1, t, e, r2, farbl), C33.Gfx.Unproject(1, 0, 1, t, e, r2, farbr), PlaneFromPoints2(nearbl, neartl, fartl, this._leftP), PlaneFromPoints2(neartl, neartr, fartr, this._topP), PlaneFromPoints2(neartr, nearbr, farbr, this._rightP), PlaneFromPoints2(nearbr, nearbl, farbl, this._bottomP), PlaneFromPoints2(farbl, fartl, fartr, this._farP), PlaneFromPoints2(nearbr, neartr, neartl, this._nearP);
        }
        ContainsAABB(t, e, r2, n, a2, c2) {
          return IsInFrontOfPlane2(t, e, r2, n, a2, c2, this._leftP) && IsInFrontOfPlane2(t, e, r2, n, a2, c2, this._topP) && IsInFrontOfPlane2(t, e, r2, n, a2, c2, this._rightP) && IsInFrontOfPlane2(t, e, r2, n, a2, c2, this._bottomP) && IsInFrontOfPlane2(t, e, r2, n, a2, c2, this._nearP) && IsInFrontOfPlane2(t, e, r2, n, a2, c2, this._farP);
        }
        IsBehindNearPlane(t, e, r2) {
          return !IsPointInFrontOfPlane2(t, e, r2, this._nearP);
        }
      };
    }
    var PlaneFromPoints;
    var IsInFrontOfPlane;
    var IsPointInFrontOfPlane;
    {
      const C33 = self.C3, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, vec42 = glMatrix.vec4, mat42 = glMatrix.mat4, tempMat4 = mat42.create(), tmpVec3a = vec32.fromValues(0, 0, 0), tmpVec3b = vec32.fromValues(0, 0, 0), tmpVec3c = vec32.fromValues(0, 0, 0), defaultUpVector = vec32.fromValues(0, 1, 0), tmpVec4 = vec42.fromValues(0, 0, 0, 0), tmpQuad = new C33.Quad(), tmpRect = new C33.Rect(), defaultTexCoordsQuad = new C33.Quad(0, 0, 1, 0, 1, 1, 0, 1), DEFAULT_RENDERERBASE_OPTS = { nearZ: 1, farZ: 1e4 }, matWebGLtoWebGPU = mat42.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
      C33.Gfx.RendererBase = class {
        constructor(e) {
          e = Object.assign({}, DEFAULT_RENDERERBASE_OPTS, e), this._width = 0, this._height = 0, this._fovY = C33.toRadians(45), this._tan_fovY_2 = Math.tan(this._fovY / 2), this._matP = mat42.create(), this._matMV = mat42.create(), this._zAxisScale = false, this._nearZ = e.nearZ, this._farZ = e.farZ, this._allShaderPrograms = [], this._shaderProgramsByName = /* @__PURE__ */ new Map(), this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._stateGroups = /* @__PURE__ */ new Map(), this._currentStateGroup = null, this._blendModeTable = [], this._namedBlendModeMap = /* @__PURE__ */ new Map(), this._baseZ = 0, this._currentZ = 0, this._lineWidth = 1, this._lineWidthStack = [this._lineWidth], this._lineCap = 1, this._lineCapStack = [this._lineCap], this._lineOffset = 0.5, this._lineOffsetStack = [this._lineOffset], this._frameNumber = 0, this._enableMipmaps = true, this._hasMajorPerformanceCaveat = false;
        }
        _ClearState() {
          this._baseZ = 0, this._currentZ = 0, this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._ClearAllShaderPrograms();
        }
        InitState() {
          this._ClearState(), this._currentStateGroup = null;
        }
        OnDeviceOrContextLost() {
          for (const e of this._allShaderPrograms) e.Release();
          this._ClearState();
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        GetDefaultCameraZ(e) {
          return this.IsZAxisScaleNormalized() ? 100 : e / (2 * this._GetTanFovYDiv2());
        }
        GetZAxisScaleFactor(e) {
          if (this.IsZAxisScaleNormalized()) {
            return e / (2 * this._GetTanFovYDiv2()) / this.GetDefaultCameraZ(e);
          }
          return 1;
        }
        SetNearZ(e) {
          this._nearZ = e;
        }
        GetNearZ() {
          return this._nearZ;
        }
        SetFarZ(e) {
          this._farZ = e;
        }
        GetFarZ() {
          return this._farZ;
        }
        SetFovY(e) {
          this._fovY = e, this._tan_fovY_2 = Math.tan(this._fovY / 2);
        }
        GetFovY() {
          return this._fovY;
        }
        _GetTanFovYDiv2() {
          return this._tan_fovY_2;
        }
        SetZAxisScaleNormalized() {
          this._zAxisScale = false;
        }
        SetZAxisScaleRegular() {
          this._zAxisScale = true;
        }
        IsZAxisScaleNormalized() {
          return !this._zAxisScale;
        }
        IsZAxisScaleRegular() {
          return this._zAxisScale;
        }
        CalculatePerspectiveMatrix(e, t, i2 = 0.5, a2 = 0.5) {
          const s2 = this.GetNearZ(), r2 = this.GetFarZ(), l2 = this.GetFovY();
          if (0.5 === i2 && 0.5 === a2) this.IsWebGPU() ? mat42.perspectiveZO(e, l2, t, s2, r2) : mat42.perspective(e, l2, t, s2, r2);
          else {
            const l3 = 2 * (i2 = 1 - i2) - 2, n = 2 * i2, h = 2 * a2 - 2, o2 = 2 * a2, p = this._GetTanFovYDiv2() * s2, _ = p * t;
            mat42.frustum(e, l3 * _, n * _, h * p, o2 * p, s2, r2), this.IsWebGPU() && mat42.mul(e, matWebGLtoWebGPU, e);
          }
        }
        CalculateOrthographicMatrix(e, t, i2, a2 = 1) {
          const s2 = self.devicePixelRatio, r2 = 2 * this.GetDefaultCameraZ(i2) * s2 * this._GetTanFovYDiv2() / i2, l2 = t * r2 / (2 * s2 * a2), n = i2 * r2 / (2 * s2 * a2), h = -l2, o2 = l2, p = -n, _ = n;
          this.IsWebGPU() ? mat42.orthoZO(e, h, o2, p, _, this.GetNearZ(), this.GetFarZ()) : mat42.ortho(e, h, o2, p, _, this.GetNearZ(), this.GetFarZ());
        }
        CalculateLookAtModelView(e, t, i2, a2, s2, r2 = 1) {
          let l2 = 1;
          this.IsZAxisScaleNormalized() && (l2 = 200 * this._GetTanFovYDiv2() / s2);
          const n = tmpVec3c;
          vec32.set(n, l2, -l2, 1);
          const h = tmpVec3a, o2 = tmpVec3b;
          vec32.multiply(h, t, n), vec32.multiply(o2, i2, n), mat42.lookAt(e, h, o2, a2 || defaultUpVector), n[2] = r2, mat42.scale(e, e, n);
        }
        CalculateLookAtModelView2(e, t, i2, a2, s2, r2, l2, n) {
          return vec32.set(tmpVec3a, e, t, i2), vec32.set(tmpVec3b, a2, s2, r2), this.CalculateLookAtModelView(tempMat4, tmpVec3a, tmpVec3b, defaultUpVector, l2, n), tempMat4;
        }
        _AddShaderProgram(e) {
          this._allShaderPrograms.push(e), this._shaderProgramsByName.set(e.GetName(), e);
        }
        _RemoveShaderProgram(e) {
          const t = this._allShaderPrograms.indexOf(e);
          -1 !== t && this._allShaderPrograms.splice(t, 1), this._shaderProgramsByName.delete(e.GetName());
        }
        _ClearAllShaderPrograms() {
          C33.clearArray(this._allShaderPrograms), this._shaderProgramsByName.clear();
        }
        GetShaderProgramByName(e) {
          return this._shaderProgramsByName.get(e) || null;
        }
        GetTextureFillShaderProgram() {
          return this._spTextureFill;
        }
        SetTextureFillMode() {
          this.SetProgram(this._spTextureFill);
        }
        GetPointsRenderingProgram() {
          return this._spPoints;
        }
        SetPointsRenderingProgram() {
          this.SetProgram(this._spPoints);
        }
        SetTilemapFillMode() {
          this.SetProgram(this._spTilemapFill);
        }
        SetTileRandomizationMode() {
          this.SetProgram(this._spTileRandomization);
        }
        SetColorFillMode() {
          this.SetProgram(this._spColorFill);
        }
        SetLinearGradientFillMode() {
          this.SetProgram(this._spLinearGradientFill);
        }
        SetPenumbraFillMode() {
          this.SetProgram(this._spPenumbraFill);
        }
        SetHardEllipseFillMode() {
          this.SetProgram(this._spHardEllipseFill);
        }
        SetHardEllipseOutlineMode() {
          this.SetProgram(this._spHardEllipseOutline);
        }
        SetSmoothEllipseFillMode() {
          this.SetProgram(this._spSmoothEllipseFill);
        }
        SetSmoothEllipseOutlineMode() {
          this.SetProgram(this._spSmoothEllipseOutline);
        }
        SetSmoothLineFillMode() {
          this.SetProgram(this._spSmoothLineFill);
        }
        _SetCurrentStateGroup(e) {
          this._currentStateGroup = e;
        }
        GetCurrentStateGroup() {
          return this._currentStateGroup;
        }
        AcquireStateGroup(e, t, i2, a2, s2, r2) {
          const l2 = C33.Gfx.StateGroup.MakeKey(e, t, i2, a2, s2, r2);
          let n = this._stateGroups.get(l2);
          return n || (n = C33.New(C33.Gfx.StateGroup, this, e, t, i2, a2, s2, r2), this._stateGroups.set(l2, n)), n.AddRef(), n;
        }
        ReleaseStateGroup(e) {
          e.DecRef(), 0 === e._GetRefCount() && (this._currentStateGroup === e && (this._currentStateGroup = null), this._stateGroups.delete(e.GetKey()), e.Release());
        }
        _InitBlendModeData(e) {
          C33.clearArray(this._blendModeTable), this._namedBlendModeMap.clear();
          let t = 0;
          for (const i2 of e) {
            const e2 = i2[0], a2 = i2[1], s2 = i2[2];
            this._blendModeTable.push([a2, s2]), this._namedBlendModeMap.set(e2, { number: t, srcBlend: a2, destBlend: s2 }), t++;
          }
        }
        _GetBlendByIndex(e) {
          return this._blendModeTable[e];
        }
        GetSrcBlendByIndex(e) {
          return this._GetBlendByIndex(e)[0];
        }
        GetDestBlendByIndex(e) {
          return this._GetBlendByIndex(e)[1];
        }
        GetNamedBlend(e) {
          const t = this._namedBlendModeMap.get(e);
          if (void 0 === t) throw new Error("invalid blend name");
          return t;
        }
        NamedBlendToNumber(e) {
          const t = this._namedBlendModeMap.get(e);
          if (void 0 === t) throw new Error("invalid blend name");
          return t.number;
        }
        SetBaseZ(e) {
          this._baseZ = e;
        }
        GetBaseZ() {
          return this._baseZ;
        }
        SetCurrentZ(e) {
          this._currentZ = e, this._currentStateGroup = null;
        }
        GetCurrentZ() {
          return this._currentZ;
        }
        Line(e, t, i2, a2) {
          const s2 = C33.angleTo(e, t, i2, a2), r2 = Math.sin(s2), l2 = Math.cos(s2), n = 0.5 * this._lineWidth, h = r2 * n, o2 = l2 * n, p = this._lineCap;
          2 === p ? this.LinePreCalc_LineCap2(e, t, 0, i2, a2, 0, h, o2) : 1 === p ? this.LinePreCalc_LineCap1(e, t, 0, i2, a2, 0, h, o2) : this.LinePreCalc_LineCap0(e, t, 0, i2, a2, 0, h, o2);
        }
        Line3D(e, t, i2, a2, s2, r2) {
          const l2 = C33.angleTo(e, t, a2, s2), n = Math.sin(l2), h = Math.cos(l2), o2 = 0.5 * this._lineWidth, p = n * o2, _ = h * o2, c2 = this._lineCap;
          2 === c2 ? this.LinePreCalc_LineCap2(e, t, i2, a2, s2, r2, p, _) : 1 === c2 ? this.LinePreCalc_LineCap1(e, t, i2, a2, s2, r2, p, _) : this.LinePreCalc_LineCap0(e, t, i2, a2, s2, r2, p, _);
        }
        LinePreCalc_LineCap2(e, t, i2, a2, s2, r2, l2, n) {
          const h = this._lineOffset, o2 = e + h - n, p = t + h - l2, _ = a2 + h + n, c2 = s2 + h + l2, u = 2 * n, d2 = 2 * l2, C = o2 + l2, m = p - n, L = o2 - l2 + u, g = p + n + d2, S = _ + l2, f2 = c2 - n, P = _ - l2 - u, G = c2 + n - d2;
          this.Quad3D2(C, m, i2, S, f2, r2, P, G, r2, L, g, i2, defaultTexCoordsQuad);
        }
        LinePreCalc_LineCap1(e, t, i2, a2, s2, r2, l2, n) {
          const h = this._lineOffset, o2 = e + h - n, p = t + h - l2, _ = a2 + h + n, c2 = s2 + h + l2, u = o2 + l2, d2 = p - n, C = o2 - l2, m = p + n, L = _ + l2, g = c2 - n, S = _ - l2, f2 = c2 + n;
          this.Quad3D2(u, d2, i2, L, g, r2, S, f2, r2, C, m, i2, defaultTexCoordsQuad);
        }
        LinePreCalc_LineCap0(e, t, i2, a2, s2, r2, l2, n) {
          const h = this._lineOffset, o2 = e + h, p = t + h, _ = a2 + h, c2 = s2 + h, u = o2 + l2, d2 = p - n, C = o2 - l2, m = p + n, L = _ + l2, g = c2 - n, S = _ - l2, f2 = c2 + n;
          this.Quad3D2(u, d2, i2, L, g, r2, S, f2, r2, C, m, i2, defaultTexCoordsQuad);
        }
        TexturedLine(e, t, i2, a2, s2, r2) {
          const l2 = C33.angleTo(e, t, i2, a2), n = Math.sin(l2), h = Math.cos(l2), o2 = 0.5 * this._lineWidth, p = n * o2, _ = h * o2, c2 = this._lineCap;
          2 === c2 ? this.TexturedLinePreCalc_LineCap2(e, t, i2, a2, p, _, s2, r2) : 1 === c2 ? this.TexturedLinePreCalc_LineCap1(e, t, i2, a2, p, _, s2, r2) : this.TexturedLinePreCalc_LineCap0(e, t, i2, a2, p, _, s2, r2);
        }
        TexturedLinePreCalc_LineCap2(e, t, i2, a2, s2, r2, l2, n) {
          const h = this._lineOffset, o2 = e + h - r2, p = t + h - s2, _ = i2 + h + r2, c2 = a2 + h + s2, u = 2 * r2, d2 = 2 * s2, C = o2 + s2, m = p - r2, L = o2 - s2 + u, g = p + r2 + d2, S = _ + s2, f2 = c2 - r2, P = _ - s2 - u, G = c2 + r2 - d2;
          tmpQuad.set(C, m, S, f2, P, G, L, g), tmpRect.set(l2, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
        }
        TexturedLinePreCalc_LineCap1(e, t, i2, a2, s2, r2, l2, n) {
          const h = this._lineOffset, o2 = e + h - r2, p = t + h - s2, _ = i2 + h + r2, c2 = a2 + h + s2, u = o2 + s2, d2 = p - r2, C = o2 - s2, m = p + r2, L = _ + s2, g = c2 - r2, S = _ - s2, f2 = c2 + r2;
          tmpQuad.set(u, d2, L, g, S, f2, C, m), tmpRect.set(l2, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
        }
        TexturedLinePreCalc_LineCap0(e, t, i2, a2, s2, r2, l2, n) {
          const h = this._lineOffset, o2 = e + h, p = t + h, _ = i2 + h, c2 = a2 + h, u = o2 + s2, d2 = p - r2, C = o2 - s2, m = p + r2, L = _ + s2, g = c2 - r2, S = _ - s2, f2 = c2 + r2;
          tmpQuad.set(u, d2, L, g, S, f2, C, m), tmpRect.set(l2, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
        }
        LineRect(e, t, i2, a2) {
          const s2 = 0.5 * this._lineWidth, r2 = this._lineCap;
          2 === r2 ? this._LineRectPreCalc_LineCap2(e, t, i2, a2, s2) : 1 === r2 ? this._LineRectPreCalc_LineCap1(e, t, i2, a2, s2) : this._LineRectPreCalc_LineCap0(e, t, i2, a2, s2);
        }
        _LineRectPreCalc_LineCap2(e, t, i2, a2, s2) {
          this.LinePreCalc_LineCap2(e, t, 0, i2, t, 0, 0, s2), this.LinePreCalc_LineCap2(i2, t, 0, i2, a2, 0, s2, 0), this.LinePreCalc_LineCap2(i2, a2, 0, e, a2, 0, 0, -s2), this.LinePreCalc_LineCap2(e, a2, 0, e, t, 0, -s2, 0);
        }
        _LineRectPreCalc_LineCap1(e, t, i2, a2, s2) {
          this.LinePreCalc_LineCap1(e, t, 0, i2, t, 0, 0, s2), this.LinePreCalc_LineCap1(i2, t, 0, i2, a2, 0, s2, 0), this.LinePreCalc_LineCap1(i2, a2, 0, e, a2, 0, 0, -s2), this.LinePreCalc_LineCap1(e, a2, 0, e, t, 0, -s2, 0);
        }
        _LineRectPreCalc_LineCap0(e, t, i2, a2, s2) {
          this.LinePreCalc_LineCap0(e, t, 0, i2, t, 0, 0, s2), this.LinePreCalc_LineCap0(i2, t, 0, i2, a2, 0, s2, 0), this.LinePreCalc_LineCap0(i2, a2, 0, e, a2, 0, 0, -s2), this.LinePreCalc_LineCap0(e, a2, 0, e, t, 0, -s2, 0);
        }
        LineRect2(e) {
          this.LineRect(e.getLeft(), e.getTop(), e.getRight(), e.getBottom());
        }
        LineQuad(e) {
          const t = C33.angleTo(e.getTlx(), e.getTly(), e.getTrx(), e.getTry()), i2 = Math.sin(t), a2 = Math.cos(t), s2 = 0.5 * this._lineWidth, r2 = i2 * s2, l2 = a2 * s2, n = this._lineCap;
          2 === n ? this._LineQuadPreCalc_LineCap2(e, r2, l2) : 1 === n ? this._LineQuadPreCalc_LineCap1(e, r2, l2) : this._LineQuadPreCalc_LineCap0(e, r2, l2);
        }
        _LineQuadPreCalc_LineCap2(e, t, i2) {
          this.LinePreCalc_LineCap2(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i2), this.LinePreCalc_LineCap2(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i2, -t), this.LinePreCalc_LineCap2(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i2), this.LinePreCalc_LineCap2(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i2, t);
        }
        _LineQuadPreCalc_LineCap1(e, t, i2) {
          this.LinePreCalc_LineCap1(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i2), this.LinePreCalc_LineCap1(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i2, -t), this.LinePreCalc_LineCap1(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i2), this.LinePreCalc_LineCap1(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i2, t);
        }
        _LineQuadPreCalc_LineCap0(e, t, i2) {
          this.LinePreCalc_LineCap0(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i2), this.LinePreCalc_LineCap0(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i2, -t), this.LinePreCalc_LineCap0(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i2), this.LinePreCalc_LineCap0(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i2, t);
        }
        SetLineWidth(e) {
          this._lineWidth = e, this._lineWidthStack[this._lineWidthStack.length - 1] = e;
        }
        GetLineWidth() {
          return this._lineWidth;
        }
        PushLineWidth(e) {
          if (this._lineWidthStack.length >= 100) throw new Error("pushed too many line widths - check push/pop pairs");
          this._lineWidthStack.push(e), this._lineWidth = e;
        }
        PopLineWidth() {
          if (this._lineWidthStack.length <= 1) throw new Error("cannot pop last line width - check push/pop pairs");
          this._lineWidthStack.pop(), this._lineWidth = this._lineWidthStack.at(-1);
        }
        SetLineCapButt() {
          this._lineCap = 0, this._lineCapStack[this._lineCapStack.length - 1] = 0;
        }
        SetLineCapSquare() {
          this._lineCap = 1, this._lineCapStack[this._lineCapStack.length - 1] = 0;
        }
        SetLineCapZag() {
          this._lineCap = 2, this._lineCapStack[this._lineCapStack.length - 1] = 0;
        }
        PushLineCap(e) {
          if ("butt" === e) this.PushLineCapButt();
          else if ("square" === e) this.PushLineCapSquare();
          else {
            if ("zag" !== e) throw new Error("invalid line cap");
            this.PushLineCapZag();
          }
        }
        PushLineCapButt() {
          if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
          this._lineCapStack.push(0), this._lineCap = 0;
        }
        PushLineCapSquare() {
          if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
          this._lineCapStack.push(1), this._lineCap = 1;
        }
        PushLineCapZag() {
          if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
          this._lineCapStack.push(2), this._lineCap = 2;
        }
        PopLineCap() {
          if (this._lineCapStack.length <= 1) throw new Error("cannot pop last line cap - check push/pop pairs");
          this._lineCapStack.pop(), this._lineCap = this._lineCapStack.at(-1);
        }
        SetLineOffset(e) {
          this._lineOffset = e, this._lineOffsetStack[this._lineOffsetStack.length - 1] = e;
        }
        GetLineOffset() {
          return this._lineOffset;
        }
        PushLineOffset(e) {
          if (this._lineOffsetStack.length >= 100) throw new Error("pushed too many line offsets - check push/pop pairs");
          this._lineOffsetStack.push(e), this._lineOffset = e;
        }
        PopLineOffset() {
          if (this._lineOffsetStack.length <= 1) throw new Error("cannot pop last line offset - check push/pop pairs");
          this._lineOffsetStack.pop(), this._lineOffset = this._lineOffsetStack.at(-1);
        }
        ResetCullState() {
          this.SetCullFaceMode(0), this.SetFrontFaceWinding(0);
        }
        ConvexPoly(e) {
          const t = e.length / 2;
          if (t < 3) throw new Error("need at least 3 points");
          const i2 = t - 2, a2 = i2 - 1, s2 = e[0], r2 = e[1];
          for (let t2 = 0; t2 < i2; t2 += 2) {
            const i3 = 2 * t2, l2 = e[i3 + 2], n = e[i3 + 3], h = e[i3 + 4], o2 = e[i3 + 5];
            if (t2 === a2) this.Quad2(s2, r2, l2, n, h, o2, h, o2);
            else {
              const t3 = e[i3 + 6], a3 = e[i3 + 7];
              this.Quad2(s2, r2, l2, n, h, o2, t3, a3);
            }
          }
        }
        Finish() {
          this.EndBatch(true), this._frameNumber++;
        }
        GetFrameNumber() {
          return this._frameNumber;
        }
        IncrementFrameNumber() {
          this._frameNumber++;
        }
        SetMipmapsEnabled(e) {
          this._enableMipmaps = !!e;
        }
        AreMipmapsEnabled() {
          return this._enableMipmaps;
        }
        SetHasMajorPerformanceCaveat(e) {
          this._hasMajorPerformanceCaveat = !!e;
        }
        HasMajorPerformanceCaveat() {
          return this._hasMajorPerformanceCaveat;
        }
        IsWebGL() {
          return false;
        }
        IsWebGPU() {
          return false;
        }
        GetEstimatedBackBufferMemoryUsage() {
        }
        GetEstimatedRenderBufferMemoryUsage() {
        }
        GetEstimatedTextureMemoryUsage() {
        }
        GetEstimatedTotalMemoryUsage() {
          return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage();
        }
        CreateRendererText() {
          return C33.New(C33.Gfx.RendererText, this);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.ShaderProgramBase = class {
        constructor(e, t) {
          this._name = t.name, this._renderer = e, this._extendBoxHorizontal = t.extendBoxHorizontal || 0, this._extendBoxVertical = t.extendBoxVertical || 0, this._crossSampling = !!t.crossSampling, this._mustPreDraw = !!t.mustPreDraw, this._preservesOpaqueness = !!t.preservesOpaqueness, this._supports3dDirectRendering = !!t.supports3dDirectRendering, this._animated = !!t.animated, this._blendsBackground = !!t.blendsBackground, this._usesDepth = !!t.usesDepth, this._usesAnySrcRectOrPixelSize = false, this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
        }
        Release() {
          this._renderer = null;
        }
        GetRenderer() {
          return this._renderer;
        }
        GetName() {
          return this._name;
        }
        ExtendsBox() {
          return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
        }
        GetBoxExtendHorizontal() {
          return this._extendBoxHorizontal;
        }
        GetBoxExtendVertical() {
          return this._extendBoxVertical;
        }
        UsesCrossSampling() {
          return this._crossSampling;
        }
        MustPreDraw() {
          return this._mustPreDraw;
        }
        PreservesOpaqueness() {
          return this._preservesOpaqueness;
        }
        Supports3DDirectRendering() {
          return this._supports3dDirectRendering;
        }
        IsAnimated() {
          return this._animated;
        }
        BlendsBackground() {
          return this._blendsBackground;
        }
        UsesDepth() {
          return this._usesDepth;
        }
        UsesAnySrcRectOrPixelSize() {
          return this._usesAnySrcRectOrPixelSize;
        }
        NeedsPostDrawOrExtendsBox() {
          return this._needsPostDrawOrExtendBox;
        }
        UsesIsSrcTexRotated() {
          return false;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.StateGroup = class {
        constructor(e, r2, t, s2, o2, a2, i2) {
          this._renderer = e, this._refCount = 0, this._shaderProgram = null, this._shaderProgramName = "", this._blendMode = t, this._color = C33.New(C33.Color), this._color.set(s2), this._zElevation = o2, this._cullFaceMode = a2, this._frontFaceWinding = i2, "string" == typeof r2 ? this._shaderProgramName = r2 : (this._shaderProgram = r2, this._shaderProgramName = this._shaderProgram.GetName());
        }
        Release() {
          if (this._refCount > 0) throw new Error("releasing state group still in use");
          this._renderer = null, this._shaderProgram = null, this._shaderProgramName = "";
        }
        Apply() {
          const e = this._renderer;
          e.SetProgram(this._shaderProgram), e.SetBlendMode(this._blendMode), e.SetColor(this._color), e.SetCurrentZ(this._zElevation), e.SetCullFaceMode(this._cullFaceMode), e.SetFrontFaceWinding(this._frontFaceWinding), e._SetCurrentStateGroup(this);
        }
        GetKey() {
          return C33.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation, this._cullFaceMode, this._frontFaceWinding);
        }
        AddRef() {
          ++this._refCount;
        }
        DecRef() {
          --this._refCount;
        }
        _GetRefCount() {
          return this._refCount;
        }
        OnContextLost() {
          this._shaderProgram = null;
        }
        OnContextRestored(e) {
          if (this._shaderProgram = e.GetShaderProgramByName(this._shaderProgramName), !this._shaderProgram) throw new Error("failed to restore shader program");
        }
        static MakeKey(e, r2, t, s2, o2, a2) {
          return ("string" == typeof e ? e : e.GetName()) + "," + r2 + "," + t.getR() + "," + t.getG() + "," + t.getB() + "," + t.getA() + "," + s2 + "," + o2 + "," + a2;
        }
      };
    }
    {
      let interpolateQuad2 = function(t, e, s2) {
        const i2 = s2.getTlx(), n = s2.getTly(), r2 = s2.getTrx() - i2, h = s2.getTry() - n;
        return [i2 + r2 * t + (s2.getBlx() - i2) * e, n + h * t + (s2.getBly() - n) * e];
      };
      interpolateQuad = interpolateQuad2;
      const C33 = globalThis.C3, assert = globalThis.assert, MAX_VERTICES = 65535;
      C33.Gfx.MeshPoint = class {
        constructor(t, e, s2) {
          this._mesh = t, this._col = e, this._row = s2, this._x = NaN, this._y = NaN, this._zElevation = NaN, this._u = NaN, this._v = NaN, this._x = 0, this._y = 0, this._zElevation = 0, this._u = 0, this._v = 0;
        }
        _Init(t, e, s2, i2) {
          this._x = t, this._y = e, this._u = s2, this._v = i2;
        }
        GetX() {
          return this._x;
        }
        SetX(t) {
          this._x !== t && (this._x = t, this._mesh._SetPointsChanged());
        }
        GetY() {
          return this._y;
        }
        SetY(t) {
          this._y !== t && (this._y = t, this._mesh._SetPointsChanged());
        }
        GetZElevation() {
          return this._zElevation;
        }
        SetZElevation(t) {
          this._zElevation !== t && (this._zElevation = Math.max(t, 0), this._mesh._SetPointsChanged());
        }
        GetU() {
          return this._u;
        }
        SetU(t) {
          this._u = t;
        }
        GetV() {
          return this._v;
        }
        SetV(t) {
          this._v = t;
        }
        _Interpolate_TexRect(t, e, s2) {
          [this._x, this._y] = interpolateQuad2(t._x, t._y, e), this._zElevation = t._zElevation, this._u = C33.lerp(s2.getLeft(), s2.getRight(), t._u), this._v = C33.lerp(s2.getTop(), s2.getBottom(), t._v);
        }
        _Interpolate_TexQuad(t, e, s2) {
          [this._x, this._y] = interpolateQuad2(t._x, t._y, e), this._zElevation = t._zElevation, [this._u, this._v] = interpolateQuad2(t._u, t._v, s2);
        }
        SaveToJson() {
          return { "x": this.GetX(), "y": this.GetY(), "z": this.GetZElevation(), "u": this.GetU(), "v": this.GetV() };
        }
        LoadFromJson(t) {
          this.SetX(t["x"]), this.SetY(t["y"]), t.hasOwnProperty("z") && this.SetZElevation(t["z"]), this.SetU(t["u"]), this.SetV(t["v"]);
        }
        GetMesh() {
          return this._mesh;
        }
        GetColumn() {
          return this._col;
        }
        GetRow() {
          return this._row;
        }
      }, C33.Gfx.Mesh = class {
        constructor(t, e, s2) {
          if (t < 2 || e < 2) throw new Error("invalid mesh size");
          this._hsize = t, this._vsize = e, this._owner = s2 || null, this._pts = [], this._minX = 0, this._minY = 0, this._maxX = 1, this._maxY = 1, this._maxZ = 0, this._bboxChanged = false, this._meshChunks = [], this._lastZOffset = 0, this._dataArrsChanged = true;
          const i2 = t - 1, n = e - 1;
          for (let s3 = 0; s3 < e; ++s3) {
            const e2 = [];
            for (let r2 = 0; r2 < t; ++r2) {
              const t2 = C33.New(C33.Gfx.MeshPoint, this, r2, s3), h = r2 / i2, o2 = s3 / n;
              t2._Init(h, o2, h, o2), e2.push(t2);
            }
            this._pts.push(e2);
          }
        }
        Release() {
          C33.clearArray(this._pts), C33.clearArray(this._meshChunks);
        }
        GetHSize() {
          return this._hsize;
        }
        GetVSize() {
          return this._vsize;
        }
        GetOwner() {
          return this._owner;
        }
        _GetPoints() {
          return this._pts;
        }
        _SetPointsChanged() {
          this._bboxChanged = true, this._dataArrsChanged = true;
        }
        _MaybeComputeBounds() {
          if (!this._bboxChanged) return;
          let t = 1 / 0, e = 1 / 0, s2 = -1 / 0, i2 = -1 / 0, n = 0;
          for (const r2 of this._pts) for (const h of r2) {
            const r3 = h.GetX(), o2 = h.GetY();
            t = Math.min(t, r3), e = Math.min(e, o2), s2 = Math.max(s2, r3), i2 = Math.max(i2, o2), n = Math.max(n, h.GetZElevation());
          }
          this._minX = t, this._minY = e, this._maxX = s2, this._maxY = i2, this._maxZ = n, this._bboxChanged = false;
        }
        GetMinX() {
          return this._MaybeComputeBounds(), this._minX;
        }
        GetMinY() {
          return this._MaybeComputeBounds(), this._minY;
        }
        GetMaxX() {
          return this._MaybeComputeBounds(), this._maxX;
        }
        GetMaxY() {
          return this._MaybeComputeBounds(), this._maxY;
        }
        GetMaxZ() {
          return this._MaybeComputeBounds(), this._maxZ;
        }
        HasAnyZElevation() {
          return this.GetMaxZ() > 0;
        }
        GetMeshPointAt(t, e) {
          return t = Math.floor(t), e = Math.floor(e), t < 0 || t >= this._hsize || e < 0 || e >= this._vsize ? null : this._pts[e][t];
        }
        CalculateTransformedMesh(t, e, s2) {
          const i2 = s2 instanceof C33.Rect;
          if (t.GetHSize() !== this.GetHSize() || t.GetVSize() !== this.GetVSize()) throw new Error("source mesh wrong size");
          const n = t._pts, r2 = this._pts;
          for (let t2 = 0, h = r2.length; t2 < h; ++t2) {
            const h2 = n[t2], o2 = r2[t2];
            for (let t3 = 0, n2 = o2.length; t3 < n2; ++t3) {
              const n3 = h2[t3], r3 = o2[t3];
              i2 ? r3._Interpolate_TexRect(n3, e, s2) : r3._Interpolate_TexQuad(n3, e, s2);
            }
          }
          this._dataArrsChanged = true;
        }
        _MaybeUpdateDataArrays(t) {
          if (!this._dataArrsChanged && this._lastZOffset === t) return;
          const e = this._hsize, s2 = this._vsize, i2 = this._meshChunks, n = Math.floor(65535 / e) - 1;
          if (n <= 0) throw new Error("mesh too large");
          const r2 = Math.ceil((s2 - 1) / n);
          r2 < i2.length && (i2.length = r2);
          let h = 0;
          for (let o2 = 0; o2 < r2; ++o2) {
            const r3 = Math.min(n, s2 - h - 1), a2 = (r3 + 1) * e, l2 = 3 * a2, _ = 2 * a2, u = (e - 1) * r3 * 6;
            if (o2 === i2.length) i2.push({ posArr: new Float32Array(l2), uvArr: new Float32Array(_), indexArr: new Uint16Array(u) });
            else {
              const t2 = i2[o2];
              t2.posArr.length !== l2 && (t2.posArr = new Float32Array(l2)), t2.uvArr.length !== _ && (t2.uvArr = new Float32Array(_)), t2.indexArr.length !== u && (t2.indexArr = new Uint16Array(u));
            }
            const { posArr: c2, uvArr: G, indexArr: m } = i2[o2];
            this._WriteChunkDataArrays(h, r3, t, c2, G, m), h += n;
          }
          this._lastZOffset = t, this._dataArrsChanged = false;
        }
        _WriteChunkDataArrays(t, e, s2, i2, n, r2) {
          const h = this._pts, o2 = this._hsize;
          let a2 = 0, l2 = 0, _ = 0;
          for (let u = t, c2 = t + e + 1; u < c2; ++u) {
            const e2 = h[u], G = u + 1, m = u - t, C = m * o2, f2 = (m + 1) * o2;
            for (let t2 = 0, h2 = e2.length; t2 < h2; ++t2) {
              const o3 = e2[t2], u2 = t2 + 1;
              if (i2[a2++] = o3.GetX(), i2[a2++] = o3.GetY(), i2[a2++] = o3.GetZElevation() + s2, n[l2++] = o3.GetU(), n[l2++] = o3.GetV(), u2 < h2 && G < c2) {
                const e3 = t2 + C, s3 = u2 + C, i3 = u2 + f2, n2 = t2 + f2;
                r2[_++] = e3, r2[_++] = s3, r2[_++] = i3, r2[_++] = e3, r2[_++] = i3, r2[_++] = n2;
              }
            }
          }
        }
        Draw(t, e) {
          this._MaybeUpdateDataArrays(e);
          for (const { posArr: e2, uvArr: s2, indexArr: i2 } of this._meshChunks) t.DrawMesh(e2, s2, i2);
        }
        Outline(t, e) {
          e || (e = (t2, e2, s3) => [t2, e2, s3]);
          const s2 = this._pts;
          let i2 = s2[0];
          for (let n = 1, r2 = s2.length; n < r2; ++n) {
            const h = s2[n];
            let o2 = i2[0], a2 = h[0];
            for (let s3 = 1, l2 = h.length; s3 < l2; ++s3) {
              const _ = i2[s3], u = h[s3], [c2, G, m] = e(o2.GetX(), o2.GetY(), o2.GetZElevation()), [C, f2, p] = e(_.GetX(), _.GetY(), _.GetZElevation()), [g, y, d2] = e(u.GetX(), u.GetY(), u.GetZElevation()), [x, M, v] = e(a2.GetX(), a2.GetY(), a2.GetZElevation());
              t.Line3D(c2, G, m, C, f2, p), t.Line3D(c2, G, m, g, y, d2), t.Line3D(c2, G, m, x, M, v), s3 === l2 - 1 && t.Line3D(C, f2, p, g, y, d2), n === r2 - 1 && t.Line3D(x, M, v, g, y, d2), o2 = _, a2 = u;
            }
            i2 = h;
          }
        }
        InsertPolyMeshVertices(t) {
          const e = 1e-3, s2 = 0.99999999, i2 = t.pointsArr(), n = [], r2 = this.GetHSize() - 1, h = this.GetVSize() - 1, o2 = 1 / r2, a2 = 1 / h, l2 = r2 - 1, _ = h - 1;
          let u = i2[0], c2 = i2[1], G = C33.clamp(Math.floor(u * r2), 0, l2), m = C33.clamp(Math.floor(c2 * h), 0, _), C = true, f2 = 0, p = 0, g = 0;
          let y = -1;
          const d2 = () => {
            u = C33.clamp(C33.lerp(u, f2, g), 0, 1), c2 = C33.clamp(C33.lerp(c2, p, g), 0, 1), n.push(u, c2);
          };
          for (let t2 = 0, x = i2.length; t2 < x; t2 += 2) {
            u = i2[t2], c2 = i2[t2 + 1], n.push(u, c2), G = C33.clamp(Math.floor(u * r2), 0, l2), m = C33.clamp(Math.floor(c2 * h), 0, _);
            const M = (t2 + 2) % x;
            for (f2 = i2[M], p = i2[M + 1], y = -1; ; ) {
              if (n.length > 1e6) throw new Error("Too many mesh poly points");
              const t3 = G * o2, i3 = m * a2, r3 = (G + 1) * o2, h2 = (m + 1) * a2;
              if (C = C33.isPointInTriangleInclusive(u, c2, t3, i3, r3, i3, r3, h2), 0 !== y && (g = C33.rayIntersectExtended(u, c2, f2, p, t3, i3, r3, h2, -1e-3), g >= 0 && g <= s2)) d2(), C = !C, y = 0;
              else if (m > 0 && 2 !== y && (g = C33.rayIntersectExtended(u, c2, f2, p, t3, i3, r3, i3, e), g >= 0 && g <= s2)) d2(), m--, C = false, y = 4;
              else if (G < l2 && 3 !== y && (g = C33.rayIntersectExtended(u, c2, f2, p, r3, i3, r3, h2, e), g >= 0 && g <= s2)) d2(), G++, C = false, y = 1;
              else if (G > 0 && 1 !== y && (g = C33.rayIntersectExtended(u, c2, f2, p, t3, i3, t3, h2, e), g >= 0 && g <= s2)) d2(), G--, C = true, y = 3;
              else {
                if (!(m < _ && 4 !== y && (g = C33.rayIntersectExtended(u, c2, f2, p, t3, h2, r3, h2, e), g >= 0 && g <= s2))) break;
                d2(), m++, C = true, y = 2;
              }
            }
          }
          return C33.New(C33.CollisionPoly, n);
        }
        TransformCollisionPoly(t, e) {
          const s2 = this._TransformPolyPoints(t);
          this._SimplifyPoly(s2), e.setPoints(s2);
        }
        _TransformPolyPoints(t) {
          const e = [], s2 = t.pointsArr();
          for (let t2 = 0, i2 = s2.length; t2 < i2; t2 += 2) {
            const i3 = s2[t2], n = s2[t2 + 1], [r2, h] = this.TransformPoint(i3, n);
            e.push(r2, h);
          }
          return e;
        }
        TransformPoint(t, e) {
          const s2 = this.GetHSize() - 1, i2 = this.GetVSize() - 1, n = 1 / s2, r2 = 1 / i2, h = C33.clamp(Math.floor(t * s2), 0, s2 - 1), o2 = C33.clamp(Math.floor(e * i2), 0, i2 - 1), a2 = h * n, l2 = o2 * r2, _ = (h + 1) * n, u = (o2 + 1) * r2, c2 = this.GetMeshPointAt(h, o2), G = this.GetMeshPointAt(h + 1, o2 + 1), m = C33.isPointInTriangleInclusive(t, e, a2, l2, _, l2, _, u), C = m ? a2 + n : a2, f2 = m ? l2 : l2 + r2, p = this.GetMeshPointAt(h + (m ? 1 : 0), o2 + (m ? 0 : 1)), [g, y, d2] = C33.triangleCartesianToBarycentric(t, e, a2, l2, C, f2, _, u);
          return C33.triangleBarycentricToCartesian3d(g, y, d2, c2.GetX(), c2.GetY(), c2.GetZElevation(), p.GetX(), p.GetY(), p.GetZElevation(), G.GetX(), G.GetY(), G.GetZElevation());
        }
        _SimplifyPoly(t) {
          const e = [], s2 = 1e-7;
          let i2 = t[0], n = t[1], r2 = i2 - t.at(-2), h = n - t.at(-1);
          for (let o2 = 0, a2 = t.length; o2 < a2; o2 += 2) {
            const l2 = (o2 + 2) % a2, _ = t[l2], u = t[l2 + 1], c2 = _ - i2, G = u - n, m = Math.abs(c2) < s2 && Math.abs(r2) < s2 && Math.sign(G) === Math.sign(h), C = Math.abs(G) < s2 && Math.abs(h) < s2 && Math.sign(c2) === Math.sign(r2);
            (!m && !C && Math.abs(c2 / r2 - G / h) > 1e-3 || 0 == c2 && 0 === G) && e.push(i2, n), i2 = _, n = u, r2 = c2, h = G;
          }
          e.length >= 6 && e.length < t.length && C33.shallowAssignArray(t, e);
        }
        SaveToJson() {
          return { "cols": this.GetHSize(), "rows": this.GetVSize(), "points": this._pts.map((t) => t.map((t2) => t2.SaveToJson())) };
        }
        LoadFromJson(t) {
          const e = this.GetHSize(), s2 = this.GetVSize();
          if (t["cols"] !== e || t["rows"] !== s2) throw new Error("mesh data wrong size");
          const i2 = t["points"];
          for (let t2 = 0; t2 < s2; ++t2) {
            const s3 = i2[t2];
            for (let i3 = 0; i3 < e; ++i3) {
              this.GetMeshPointAt(i3, t2).LoadFromJson(s3[i3]);
            }
          }
        }
      };
    }
    var interpolateQuad;
    {
      let GetFormatSpecifiers2 = function(e, t) {
        let i2, r2, a2, s2;
        switch (e) {
          case "rgba8":
            i2 = t.RGBA8, r2 = t.RGBA, a2 = t.RGBA, s2 = t.UNSIGNED_BYTE;
            break;
          case "rgb8":
            i2 = t.RGB8, r2 = t.RGB, a2 = t.RGB, s2 = t.UNSIGNED_BYTE;
            break;
          case "rgba4":
            i2 = t.RGBA4, r2 = t.RGBA, a2 = t.RGBA, s2 = t.UNSIGNED_SHORT_4_4_4_4;
            break;
          case "rgb5_a1":
            i2 = t.RGB5_A1, r2 = t.RGBA, a2 = t.RGBA, s2 = t.UNSIGNED_SHORT_5_5_5_1;
            break;
          case "rgb565":
            i2 = t.RGB565, r2 = t.RGB, a2 = t.RGB, s2 = t.UNSIGNED_SHORT_5_6_5;
            break;
          default:
            throw new Error("invalid pixel format");
        }
        return { sizedinternalformat: i2, internalformat: r2, format: a2, type: s2 };
      };
      GetFormatSpecifiers = GetFormatSpecifiers2;
      const C33 = self.C3, VALID_PIXEL_FORMATS = /* @__PURE__ */ new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]), VALID_SAMPLINGS = /* @__PURE__ */ new Set(["nearest", "bilinear", "trilinear"]), VALID_MIPMAP_QUALITIES = /* @__PURE__ */ new Set(["default", "low", "high"]), VALID_WRAP_MODES = /* @__PURE__ */ new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);
      const CREATEFROM_DEFAULT_OPTIONS = { wrapX: "clamp-to-edge", wrapY: "clamp-to-edge", sampling: "trilinear", anisotropy: 0, pixelFormat: "rgba8", mipMap: true, mipMapQuality: "default", premultiplyAlpha: true, isSvg: false, width: -1, height: -1 }, UPDATE_DEFAULT_OPTIONS = { premultiplyAlpha: true, flipY: false }, allTextures = /* @__PURE__ */ new Set();
      C33.Gfx.WebGLRendererTexture = class {
        constructor(e) {
          this._renderer = e, this._texture = null, this._width = 0, this._height = 0, this._isStatic = true, this._wrapX = "clamp-to-edge", this._wrapY = "clamp-to-edge", this._sampling = "trilinear", this._anisotropy = 0, this._pixelFormat = "rgba8", this._isMipMapped = false, this._mipMapQuality = "default", this._refCount = 0;
        }
        _CreateStatic(e, t) {
          if (!("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData || e instanceof ArrayBuffer)) throw new Error("invalid texture source");
          if (t = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, t), this._texture) throw new Error("already created texture");
          if (this._wrapX = t.wrapX, this._wrapY = t.wrapY, this._sampling = t.sampling, this._anisotropy = t.anisotropy, this._pixelFormat = t.pixelFormat, this._isMipMapped = !!t.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = t.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error("invalid wrap mode");
          if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
          if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error("invalid pixel format");
          if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error("invalid mipmap quality");
          if (this._isStatic = true, e instanceof ArrayBuffer || null === e || t.isSvg) {
            if (this._width = t.width, this._height = t.height, e instanceof ArrayBuffer && e.byteLength !== this._width * this._height * 4) throw new Error("ArrayBuffer wrong size");
          } else this._width = e.width, this._height = e.height;
          if (this._width <= 0 || this._height <= 0) throw new Error("invalid texture data size");
          if (t.isSvg) {
            const t2 = C33.CreateCanvas(this._width, this._height);
            t2.getContext("2d").drawImage(e, 0, 0, this._width, this._height), e = t2;
          }
          const i2 = C33.isPOT(this._width) && C33.isPOT(this._height), r2 = this._renderer.GetMaxTextureSize();
          if (this._width > r2 || this._height > r2) throw new Error("texture data exceeds maximum texture size");
          const a2 = this._renderer.GetContext(), s2 = this._renderer.GetWebGLVersionNumber();
          this._texture = a2.createTexture(), a2.bindTexture(a2.TEXTURE_2D, this._texture), a2.pixelStorei(a2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], t.premultiplyAlpha), a2.pixelStorei(a2["UNPACK_FLIP_Y_WEBGL"], false);
          const h = GetFormatSpecifiers2(this._pixelFormat, a2);
          if (this._renderer.SupportsNPOTTextures() || i2 || !this._IsTiled()) if (s2 >= 2) {
            let t2;
            t2 = this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, a2.texStorage2D(a2.TEXTURE_2D, t2, h.sizedinternalformat, this._width, this._height), e instanceof ArrayBuffer ? a2.texSubImage2D(a2.TEXTURE_2D, 0, 0, 0, this._width, this._height, h.format, h.type, new Uint8Array(e)) : null !== e && a2.texSubImage2D(a2.TEXTURE_2D, 0, 0, 0, h.format, h.type, e);
          } else e instanceof ArrayBuffer ? a2.texImage2D(a2.TEXTURE_2D, 0, h.internalformat, this._width, this._height, 0, h.format, h.type, new Uint8Array(e)) : null === e ? a2.texImage2D(a2.TEXTURE_2D, 0, h.internalformat, this._width, this._height, 0, h.format, h.type, null) : a2.texImage2D(a2.TEXTURE_2D, 0, h.internalformat, h.format, h.type, e);
          else {
            if (null === e) throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
            if (e instanceof ArrayBuffer && (e = new ImageData(new Uint8ClampedArray(e), this._width, this._height)), e instanceof ImageData) {
              const t3 = C33.CreateCanvas(this._width, this._height);
              t3.getContext("2d").putImageData(e, 0, 0), e = t3;
            }
            const t2 = C33.CreateCanvas(C33.nextHighestPowerOfTwo(this._width), C33.nextHighestPowerOfTwo(this._height)), i3 = t2.getContext("2d");
            i3.imageSmoothingEnabled = "nearest" !== this._sampling, i3.drawImage(e, 0, 0, this._width, this._height, 0, 0, t2.width, t2.height), a2.texImage2D(a2.TEXTURE_2D, 0, h.internalformat, h.format, h.type, t2);
          }
          null !== e && this._SetTextureParameters(a2), a2.bindTexture(a2.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);
        }
        _CreateDynamic(e, t, i2) {
          if (i2 = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, i2), this._texture) throw new Error("already created texture");
          if (this._wrapX = i2.wrapX, this._wrapY = i2.wrapY, this._sampling = i2.sampling, this._pixelFormat = i2.pixelFormat, this._isMipMapped = !!i2.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = i2.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error("invalid wrap mode");
          if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
          if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error("invalid pixel format");
          if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error("invalid mipmap quality");
          this._isStatic = false, this._width = Math.floor(e), this._height = Math.floor(t);
          const r2 = C33.isPOT(this._width) && C33.isPOT(this._height), a2 = this._renderer.GetMaxTextureSize();
          if (this._width <= 0 || this._height <= 0) throw new Error("invalid texture size");
          if (this._width > a2 || this._height > a2) throw new Error("texture exceeds maximum texture size");
          if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !r2) throw new Error("non-power-of-two tiled textures not supported");
          const s2 = this._renderer.GetContext(), h = this._renderer.GetWebGLVersionNumber();
          this._texture = s2.createTexture(), s2.bindTexture(s2.TEXTURE_2D, this._texture), s2.pixelStorei(s2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], i2.premultiplyAlpha), s2.pixelStorei(s2["UNPACK_FLIP_Y_WEBGL"], false);
          const n = GetFormatSpecifiers2(this._pixelFormat, s2), _ = h >= 2 ? n.sizedinternalformat : n.internalformat;
          s2.texImage2D(s2.TEXTURE_2D, 0, _, this._width, this._height, 0, n.format, n.type, null), this._SetTextureParameters(s2), s2.bindTexture(s2.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);
        }
        _GetMipMapHint(e) {
          if ("default" === this._mipMapQuality) return this._isStatic ? e.NICEST : e.FASTEST;
          if ("low" === this._mipMapQuality) return e.FASTEST;
          if ("high" === this._mipMapQuality) return e.NICEST;
          throw new Error("invalid mipmap quality");
        }
        _IsTiled() {
          return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY;
        }
        _GetTextureWrapMode(e, t) {
          if ("clamp-to-edge" === t) return e.CLAMP_TO_EDGE;
          if ("repeat" === t) return e.REPEAT;
          if ("mirror-repeat" === t) return e.MIRRORED_REPEAT;
          throw new Error("invalid wrap mode");
        }
        _SetTextureParameters(e) {
          const t = C33.isPOT(this._width) && C33.isPOT(this._height);
          if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, this._GetTextureWrapMode(e, this._wrapX)), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, this._GetTextureWrapMode(e, this._wrapY)), "nearest" === this._sampling) e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), this._isMipMapped = false;
          else if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), (t || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {
            e.hint(e.GENERATE_MIPMAP_HINT, this._GetMipMapHint(e)), e.generateMipmap(e.TEXTURE_2D);
            const t2 = "trilinear" === this._sampling && !this._renderer.HasMajorPerformanceCaveat();
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t2 ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR_MIPMAP_NEAREST);
          } else e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), this._isMipMapped = false;
          const i2 = this._renderer._GetAnisotropicExtension();
          i2 && this._anisotropy > 0 && "nearest" !== this._sampling && e.texParameterf(e.TEXTURE_2D, i2["TEXTURE_MAX_ANISOTROPY_EXT"], Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()));
        }
        _Update(e, t) {
          if (!("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData)) throw new Error("invalid texture source");
          if (!this._texture || this._refCount <= 0) throw new Error("texture not created");
          if (this._isStatic) throw new Error("cannot update static texture");
          t = Object.assign({}, UPDATE_DEFAULT_OPTIONS, t);
          const i2 = e.width || e.videoWidth, r2 = e.height || e.videoHeight, a2 = this._renderer.GetWebGLVersionNumber(), s2 = this._renderer.GetContext();
          s2.bindTexture(s2.TEXTURE_2D, this._texture), s2.pixelStorei(s2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], t.premultiplyAlpha), s2.pixelStorei(s2["UNPACK_FLIP_Y_WEBGL"], !!t.flipY);
          const h = GetFormatSpecifiers2(this._pixelFormat, s2), n = a2 >= 2 ? h.sizedinternalformat : h.internalformat;
          try {
            if (this._width === i2 && this._height === r2) {
              const t2 = C33.isPOT(this._width) && C33.isPOT(this._height);
              s2.texSubImage2D(s2.TEXTURE_2D, 0, 0, 0, h.format, h.type, e), (t2 || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s2.hint(s2.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s2)), s2.generateMipmap(s2.TEXTURE_2D));
            } else {
              this._width = i2, this._height = r2;
              const t2 = C33.isPOT(this._width) && C33.isPOT(this._height);
              if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !t2) throw new Error("non-power-of-two tiled textures not supported");
              s2.texImage2D(s2.TEXTURE_2D, 0, n, h.format, h.type, e), (t2 || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s2.hint(s2.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s2)), s2.generateMipmap(s2.TEXTURE_2D));
            }
          } catch (e2) {
            console.error("Error updating WebGL texture: ", e2);
          }
          s2.bindTexture(s2.TEXTURE_2D, null), this._renderer._ResetLastTexture();
        }
        _Delete() {
          if (this._refCount > 0) throw new Error("texture still has references");
          if (!this._texture) throw new Error("already deleted texture");
          allTextures.delete(this);
          this._renderer.GetContext().deleteTexture(this._texture), this._texture = null;
        }
        IsValid() {
          return !!this._texture;
        }
        _GetTexture() {
          return this._texture;
        }
        GetRenderer() {
          return this._renderer;
        }
        AddReference() {
          this._refCount++;
        }
        SubtractReference() {
          if (this._refCount <= 0) throw new Error("no more references");
          this._refCount--;
        }
        GetReferenceCount() {
          return this._refCount;
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        IsStatic() {
          return this._isStatic;
        }
        GetEstimatedMemoryUsage() {
          let e = this._width * this._height;
          switch (this._pixelFormat) {
            case "rgba8":
              e *= 4;
              break;
            case "rgb8":
              e *= 3;
              break;
            case "rgba4":
            case "rgb5_a1":
            case "rgb565":
              e *= 2;
          }
          return this._isMipMapped && (e += Math.floor(e / 3)), e;
        }
        static OnContextLost() {
          allTextures.clear();
        }
        static allTextures() {
          return allTextures.values();
        }
      };
    }
    var GetFormatSpecifiers;
    {
      const C33 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, mat42 = glMatrix.mat4, VALID_SAMPLINGS = /* @__PURE__ */ new Set(["nearest", "bilinear", "trilinear"]), DEFAULT_RENDERTARGET_OPTIONS = { sampling: "trilinear", alpha: true, depth: false, isSampled: true, isDefaultSize: true, multisampling: 0 }, allRenderTargets = /* @__PURE__ */ new Set();
      C33.Gfx.WebGLRenderTarget = class {
        constructor(e) {
          this._renderer = e, this._frameBuffer = null, this._frameBufferNoDepth = null, this._texture = null, this._renderBuffer = null, this._width = 0, this._height = 0, this._isDefaultSize = true, this._sampling = "trilinear", this._alpha = true, this._depth = false, this._isSampled = true, this._multisampling = 0, this._projectionMatrix = mat42.create(), this._lastFov = 0, this._lastNearZ = 0, this._lastFarZ = 0;
        }
        _Create(e, t, r2) {
          r2 = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, r2);
          const i2 = this._renderer.GetWebGLVersionNumber();
          if (this._texture || this._renderBuffer) throw new Error("already created render target");
          if (this._sampling = r2.sampling, this._alpha = !!r2.alpha, this._depth = !!r2.depth, this._isSampled = !!r2.isSampled, this._isDefaultSize = !!r2.isDefaultSize, this._multisampling = r2.multisampling, !VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
          if (this._multisampling > 0 && (i2 < 2 || this._isSampled)) throw new Error("invalid use of multisampling");
          if (i2 < 2 && (this._isSampled = true), this._width = e, this._height = t, this._width <= 0 || this._height <= 0) throw new Error("invalid render target size");
          this._CalculateProjection();
          const s2 = this._renderer.GetContext();
          if (this._frameBuffer = s2.createFramebuffer(), this._depth && (this._frameBufferNoDepth = s2.createFramebuffer()), this._isSampled) {
            this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, { sampling: this._sampling, pixelFormat: this._alpha ? "rgba8" : "rgb8", mipMap: false });
            const e2 = this._texture._GetTexture();
            s2.bindFramebuffer(s2.FRAMEBUFFER, this._frameBuffer), s2.framebufferTexture2D(s2.FRAMEBUFFER, s2.COLOR_ATTACHMENT0, s2.TEXTURE_2D, e2, 0), this._depth && (s2.bindFramebuffer(s2.FRAMEBUFFER, this._frameBufferNoDepth), s2.framebufferTexture2D(s2.FRAMEBUFFER, s2.COLOR_ATTACHMENT0, s2.TEXTURE_2D, e2, 0));
          } else {
            this._renderBuffer = s2.createRenderbuffer(), s2.bindRenderbuffer(s2.RENDERBUFFER, this._renderBuffer);
            const e2 = this._alpha ? s2.RGBA8 : s2.RGB8;
            if (this._multisampling > 0) {
              const t2 = s2.getInternalformatParameter(s2.RENDERBUFFER, e2, s2.SAMPLES);
              if (t2 && t2[0]) {
                const e3 = t2[0];
                this._multisampling > e3 && (this._multisampling = e3);
              } else this._multisampling = 0;
            }
            0 === this._multisampling ? s2.renderbufferStorage(s2.RENDERBUFFER, e2, this._width, this._height) : s2.renderbufferStorageMultisample(s2.RENDERBUFFER, this._multisampling, e2, this._width, this._height), s2.bindFramebuffer(s2.FRAMEBUFFER, this._frameBuffer), s2.framebufferRenderbuffer(s2.FRAMEBUFFER, s2.COLOR_ATTACHMENT0, s2.RENDERBUFFER, this._renderBuffer), this._depth && (s2.bindFramebuffer(s2.FRAMEBUFFER, this._frameBufferNoDepth), s2.framebufferRenderbuffer(s2.FRAMEBUFFER, s2.COLOR_ATTACHMENT0, s2.RENDERBUFFER, this._renderBuffer)), s2.bindRenderbuffer(s2.RENDERBUFFER, null);
          }
          const h = this._renderer._GetDepthBuffer();
          this._depth && h && (s2.bindFramebuffer(s2.FRAMEBUFFER, this._frameBuffer), this._renderer._CanSampleDepth() ? s2.framebufferTexture2D(s2.FRAMEBUFFER, s2.DEPTH_STENCIL_ATTACHMENT, s2.TEXTURE_2D, h, 0) : s2.framebufferRenderbuffer(s2.FRAMEBUFFER, s2.DEPTH_STENCIL_ATTACHMENT, s2.RENDERBUFFER, h)), s2.bindFramebuffer(s2.FRAMEBUFFER, null), allRenderTargets.add(this);
        }
        _Resize(e, t) {
          if (this._width === e && this._height === t) return;
          this._width = e, this._height = t, this._CalculateProjection();
          const r2 = this._renderer.GetContext();
          r2.bindFramebuffer(r2.FRAMEBUFFER, this._frameBuffer), this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (r2.bindRenderbuffer(r2.RENDERBUFFER, this._renderBuffer), r2.renderbufferStorage(r2.RENDERBUFFER, this._alpha ? r2.RGBA8 : r2.RGB8, this._width, this._height), r2.bindRenderbuffer(r2.RENDERBUFFER, null));
          const i2 = this._renderer._GetDepthBuffer();
          this._depth && i2 && (this._renderer._CanSampleDepth() ? r2.framebufferTexture2D(r2.FRAMEBUFFER, r2.DEPTH_STENCIL_ATTACHMENT, r2.TEXTURE_2D, i2, 0) : r2.framebufferRenderbuffer(r2.FRAMEBUFFER, r2.DEPTH_STENCIL_ATTACHMENT, r2.RENDERBUFFER, i2)), r2.bindFramebuffer(r2.FRAMEBUFFER, null);
        }
        _Delete() {
          if (!this._texture && !this._renderBuffer) throw new Error("already deleted render target");
          allRenderTargets.delete(this);
          const e = this._renderer.GetContext();
          this._texture ? (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0)), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null)), e.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null), e.bindFramebuffer(e.FRAMEBUFFER, null), this._renderer.GetWebGLVersionNumber() >= 2 && (e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null)), e.deleteFramebuffer(this._frameBuffer), this._depth && e.deleteFramebuffer(this._frameBufferNoDepth);
          const t = this._renderer.GetBatchState();
          t.currentFramebuffer = null, t.currentFramebufferNoDepth = null, this._frameBuffer = null;
        }
        _CalculateProjection() {
          this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height), this._lastFov = this._renderer.GetFovY(), this._lastNearZ = this._renderer.GetNearZ(), this._lastFarZ = this._renderer.GetFarZ();
        }
        _GetFramebuffer() {
          return this._frameBuffer;
        }
        _GetFramebufferNoDepth() {
          return this._frameBufferNoDepth;
        }
        GetRenderer() {
          return this._renderer;
        }
        GetTexture() {
          return this._texture;
        }
        GetProjectionMatrix() {
          return this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection(), this._projectionMatrix;
        }
        IsLinearSampling() {
          return "nearest" !== this._sampling;
        }
        HasAlpha() {
          return this._alpha;
        }
        IsSampled() {
          return this._isSampled;
        }
        HasDepthBuffer() {
          return this._depth;
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        IsDefaultSize() {
          return this._isDefaultSize;
        }
        GetMultisampling() {
          return this._multisampling;
        }
        GetOptions() {
          const e = { sampling: this._sampling, alpha: this._alpha, isSampled: this._isSampled };
          return this._isDefaultSize || (e.width = this._width, e.height = this._height), e;
        }
        IsCompatibleWithOptions(e) {
          return "nearest" !== (e = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, e)).sampling === this.IsLinearSampling() && (!!e.alpha === this.HasAlpha() && (!!e.depth === this.HasDepthBuffer() && (!(this._renderer.GetWebGLVersionNumber() >= 2 && !!e.isSampled !== this.IsSampled()) && ("number" == typeof e.width || "number" == typeof e.height ? !this.IsDefaultSize() && this.GetWidth() === Math.floor(e.width) && this.GetHeight() === Math.floor(e.height) : this.IsDefaultSize()))));
        }
        _GetWebGLTexture() {
          return this._texture ? this._texture._GetTexture() : null;
        }
        GetEstimatedMemoryUsage() {
          return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3);
        }
        static async DebugReadPixelsToBlob(e, t) {
          const r2 = await e.ReadBackRenderTargetToImageData(t, true);
          return await C33.ImageDataToBlob(r2);
        }
        static OnContextLost() {
          allRenderTargets.clear();
        }
        static allRenderTargets() {
          return allRenderTargets.values();
        }
        static ResizeAll(e, t) {
          for (const r2 of allRenderTargets) r2.IsDefaultSize() && r2._Resize(e, t);
        }
      };
    }
    {
      const C33 = self.C3, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, mat42 = glMatrix.mat4, RESERVED_UNIFORM_NAMES = /* @__PURE__ */ new Set(["aPos", "aTex", "aColor", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "samplerDepth", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "devicePixelRatio", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness", "zNear", "zFar"]);
      C33.Gfx.WebGLShaderProgram = class extends C33.Gfx.ShaderProgramBase {
        static async Compile(e, t) {
          const i2 = e.GetContext(), r2 = t.src, o2 = t.vertexSrc, n = t.name, a2 = i2.createShader(i2.FRAGMENT_SHADER);
          i2.shaderSource(a2, r2), i2.compileShader(a2);
          const l2 = i2.createShader(i2.VERTEX_SHADER);
          i2.shaderSource(l2, o2), i2.compileShader(l2);
          const s2 = i2.createProgram();
          i2.attachShader(s2, a2), i2.attachShader(s2, l2), i2.bindAttribLocation(s2, 0, "aPos"), i2.bindAttribLocation(s2, 1, "aTex"), i2.bindAttribLocation(s2, 2, "aColor"), i2.bindAttribLocation(s2, 3, "aPoints"), i2.linkProgram(s2);
          const h = e._GetParallelShaderCompileExtension();
          if (h ? await e._WaitForObjectReady(() => i2.getProgramParameter(s2, h["COMPLETION_STATUS_KHR"])) : await C33.Wait(5), !i2.getShaderParameter(a2, i2.COMPILE_STATUS)) {
            const e2 = i2.getShaderInfoLog(a2);
            throw i2.deleteShader(a2), i2.deleteShader(l2), i2.deleteProgram(s2), new Error("Error compiling fragment shader: " + e2);
          }
          if (!i2.getShaderParameter(l2, i2.COMPILE_STATUS)) {
            const e2 = i2.getShaderInfoLog(l2);
            throw i2.deleteShader(a2), i2.deleteShader(l2), i2.deleteProgram(s2), new Error("Error compiling vertex shader: " + e2);
          }
          if (!i2.getProgramParameter(s2, i2.LINK_STATUS)) {
            const e2 = i2.getProgramInfoLog(s2);
            throw i2.deleteShader(a2), i2.deleteShader(l2), i2.deleteProgram(s2), new Error("Error linking shader program: " + e2);
          }
          const c2 = C33.FilterUnprintableChars(i2.getProgramInfoLog(s2) || "").trim();
          return c2 && !C33.IsStringAllWhitespace(c2) && console.info(`[WebGL] Shader program '${n}' compilation log: `, c2), i2.deleteShader(a2), i2.deleteShader(l2), s2;
        }
        static async Create(e, t) {
          const i2 = await C33.Gfx.WebGLShaderProgram.Compile(e, t);
          return new C33.Gfx.WebGLShaderProgram(e, i2, t);
        }
        constructor(e, t, i2) {
          super(e, i2);
          const r2 = e.GetContext(), o2 = e.GetBatchState();
          e.EndBatch(), r2.useProgram(t), this._gl = r2, this._shaderProgram = t, this._isDeviceTransform = "<default-device-transform>" === i2.name;
          const n = r2.getAttribLocation(t, "aPos"), a2 = r2.getAttribLocation(t, "aTex"), l2 = r2.getAttribLocation(t, "aColor");
          this._locAPoints = r2.getAttribLocation(t, "aPoints"), -1 !== n && (r2.bindBuffer(r2.ARRAY_BUFFER, e._vertexBuffer), r2.vertexAttribPointer(n, 3, r2.FLOAT, false, 0, 0), r2.enableVertexAttribArray(n)), -1 !== a2 && (r2.bindBuffer(r2.ARRAY_BUFFER, e._texcoordBuffer), r2.vertexAttribPointer(a2, 2, r2.FLOAT, false, 0, 0), r2.enableVertexAttribArray(a2)), -1 !== l2 && (r2.bindBuffer(r2.ARRAY_BUFFER, e._colorBuffer), r2.vertexAttribPointer(l2, 4, e.IsColorDataF16() ? r2["HALF_FLOAT"] : r2.FLOAT, false, 0, 0), r2.enableVertexAttribArray(l2)), -1 !== this._locAPoints && (r2.bindBuffer(r2.ARRAY_BUFFER, e._pointBuffer), r2.vertexAttribPointer(this._locAPoints, 4, r2.FLOAT, false, 0, 0), r2.enableVertexAttribArray(this._locAPoints)), r2.bindBuffer(r2.ARRAY_BUFFER, null), this._uMatP = new C33.Gfx.WebGLShaderUniform(this, "matP", "mat4"), this._uMatMV = new C33.Gfx.WebGLShaderUniform(this, "matMV", "mat4"), this._uColor = new C33.Gfx.WebGLShaderUniform(this, "color", "vec4"), this._uSamplerFront = new C33.Gfx.WebGLShaderUniform(this, "samplerFront", "sampler"), this._uPointTexStart = new C33.Gfx.WebGLShaderUniform(this, "pointTexStart", "vec2"), this._uPointTexEnd = new C33.Gfx.WebGLShaderUniform(this, "pointTexEnd", "vec2"), this._uZElevation = new C33.Gfx.WebGLShaderUniform(this, "zElevation", "float"), this._uTileSize = new C33.Gfx.WebGLShaderUniform(this, "tileSize", "vec2"), this._uTileSpacing = new C33.Gfx.WebGLShaderUniform(this, "tileSpacing", "vec2"), this._uColor2 = new C33.Gfx.WebGLShaderUniform(this, "color2_", "vec4"), this._uOutlineThickness = new C33.Gfx.WebGLShaderUniform(this, "outlineThickness", "float"), this._uSamplerBack = new C33.Gfx.WebGLShaderUniform(this, "samplerBack", "sampler"), this._uSamplerDepth = new C33.Gfx.WebGLShaderUniform(this, "samplerDepth", "sampler"), this._uDestStart = new C33.Gfx.WebGLShaderUniform(this, "destStart", "vec2"), this._uDestEnd = new C33.Gfx.WebGLShaderUniform(this, "destEnd", "vec2"), this._uSrcStart = new C33.Gfx.WebGLShaderUniform(this, "srcStart", "vec2"), this._uSrcEnd = new C33.Gfx.WebGLShaderUniform(this, "srcEnd", "vec2"), this._uSrcOriginStart = new C33.Gfx.WebGLShaderUniform(this, "srcOriginStart", "vec2"), this._uSrcOriginEnd = new C33.Gfx.WebGLShaderUniform(this, "srcOriginEnd", "vec2"), this._uPixelSize = new C33.Gfx.WebGLShaderUniform(this, "pixelSize", "vec2"), this._uSeconds = new C33.Gfx.WebGLShaderUniform(this, "seconds", "float"), this._uDevicePixelRatio = new C33.Gfx.WebGLShaderUniform(this, "devicePixelRatio", "float"), this._uLayerScale = new C33.Gfx.WebGLShaderUniform(this, "layerScale", "float"), this._uLayerAngle = new C33.Gfx.WebGLShaderUniform(this, "layerAngle", "float"), this._uLayoutStart = new C33.Gfx.WebGLShaderUniform(this, "layoutStart", "vec2"), this._uLayoutEnd = new C33.Gfx.WebGLShaderUniform(this, "layoutEnd", "vec2"), this._uZNear = new C33.Gfx.WebGLShaderUniform(this, "zNear", "float"), this._uZFar = new C33.Gfx.WebGLShaderUniform(this, "zFar", "float"), this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());
          const s2 = i2.parameters || [];
          this._uCustomParameters = [], this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed(), this._hasCurrentMatP = false, this._hasCurrentMatMV = false, this._uColor.Init4f(1, 1, 1, 1), this._uColor2.Init4f(1, 1, 1, 1), this._uSamplerFront.Init1i(0), this._uSamplerBack.Init1i(1), this._uSamplerDepth.Init1i(2), this._uPointTexStart.Init2f(0, 0), this._uPointTexEnd.Init2f(1, 1), this._uZElevation.Init1f(0), this._uTileSize.Init2f(0, 0), this._uTileSpacing.Init2f(0, 0), this._uDestStart.Init2f(0, 0), this._uDestEnd.Init2f(1, 1), this._uSrcStart.Init2f(0, 0), this._uSrcEnd.Init2f(0, 0), this._uSrcOriginStart.Init2f(0, 0), this._uSrcOriginEnd.Init2f(0, 0), this._uPixelSize.Init2f(0, 0), this._uDevicePixelRatio.Init1f(1), this._uZNear.Init1f(e.GetNearZ()), this._uZFar.Init1f(e.GetFarZ()), this._uLayerScale.Init1f(1), this._uLayerAngle.Init1f(0), this._uSeconds.Init1f(0), this._uLayoutStart.Init2f(0, 0), this._uLayoutEnd.Init2f(0, 0), this._uOutlineThickness.Init1f(1);
          for (const e2 of s2) {
            const t2 = e2[0], i3 = e2[2], r3 = new C33.Gfx.WebGLShaderUniform(this, t2, i3);
            "color" === i3 ? r3.Init3f(0, 0, 0) : r3.Init1f(0), this._uCustomParameters.push(r3);
          }
          this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(o2.currentMatP) : (this.UpdateMatP(o2.currentMatP, true), this.UpdateMatMV(o2.currentMV, true));
          const h = o2.currentShader;
          r2.useProgram(h ? h._shaderProgram : null);
        }
        Release() {
          this._gl.deleteProgram(this._shaderProgram), this._shaderProgram = null, this._renderer._RemoveShaderProgram(this), this._gl = null, super.Release();
        }
        GetWebGLContext() {
          return this._gl;
        }
        GetShaderProgram() {
          return this._shaderProgram;
        }
        GetParameterCount() {
          return this._uCustomParameters.length;
        }
        GetParameterType(e) {
          return e < 0 || e >= this._uCustomParameters.length ? null : this._uCustomParameters[e].GetType();
        }
        AreCustomParametersAlreadySetInBatch(e) {
          for (let t = 0, i2 = e.length; t < i2; ++t) if (!this._uCustomParameters[t].IsSetToCustomInBatch(e[t])) return false;
          return true;
        }
        SetCustomParametersInBatch(e) {
          for (let t = 0, i2 = e.length; t < i2; ++t) this._uCustomParameters[t].SetBatchValueCustom(e[t]);
        }
        AreOptionalUniformsAlreadySetInBatch(e, t, i2, r2, o2, n, a2, l2, s2, h) {
          return !this._uSamplerBack.IsUsed() && (!(this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(o2, n)) && (!(this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(e.getLeft(), e.getTop())) && (!(this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(e.getRight(), e.getBottom())) && (!(this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(a2)) && (!(this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(l2)) && (!(this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(s2)) && (!(this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(t.getLeft(), t.getTop())) && (!(this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(t.getRight(), t.getBottom())) && (!(this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(i2.getLeft(), i2.getTop())) && (!(this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(i2.getRight(), i2.getBottom())) && (!(this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(r2.getLeft(), r2.getTop())) && (!(this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(r2.getTop(), r2.getBottom())) && !(this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(h))))))))))))));
        }
        SetOptionalUniformsInBatch(e, t, i2, r2, o2, n, a2, l2, s2, h) {
          this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(o2, n), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(e.getLeft(), e.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(e.getRight(), e.getBottom()), this._uDevicePixelRatio.IsUsed() && this._uDevicePixelRatio.SetBatch1(a2), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(l2), this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(s2), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(t.getLeft(), t.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(t.getRight(), t.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(i2.getLeft(), i2.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(i2.getRight(), i2.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(r2.getLeft(), r2.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(r2.getTop(), r2.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(h));
        }
        UpdateMatP(e, t) {
          this._hasCurrentMatP && !t || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(e), this._hasCurrentMatP = true);
        }
        SetMatPStale() {
          this._hasCurrentMatP = false;
        }
        UpdateMatMV(e, t) {
          this._hasCurrentMatMV && !t || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(e), this._hasCurrentMatMV = true);
        }
        SetMatMVStale() {
          this._hasCurrentMatMV = false;
        }
        _UpdateDeviceTransformUniforms(e) {
          if (!this._isDeviceTransform) throw new Error("not device transform shader");
          this._uMatP.UpdateMatrix4fv(e);
          const t = this._renderer, i2 = t.GetWidth() / 2, r2 = t.GetHeight() / 2, o2 = t.CalculateLookAtModelView2(i2, r2, t.GetDefaultCameraZ(t.GetHeight()), i2, r2, 0, t.GetHeight());
          this._uMatMV.UpdateMatrix4fv(o2);
        }
        UpdateColor(e) {
          this._uColor.IsUsed() && this._uColor.Update4f(e[0], e[1], e[2], e[3]);
        }
        static GetReservedUniformNames() {
          return RESERVED_UNIFORM_NAMES;
        }
        static _GetConservativeDepthShaderPrefix(e) {
          return e ? "\n#extension GL_EXT_conservative_depth : enable\nlayout (depth_greater) out highp float gl_FragDepth;\n	" : "";
        }
        static GetDefaultVertexShaderSource(e) {
          const t = e ? "highp" : "mediump";
          return ["attribute highp vec3 aPos;", `attribute ${t} vec2 aTex;`, `varying ${t} vec2 vTex;`, "attribute lowp vec4 aColor;", "varying lowp vec4 vColor;", "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPos, 1.0);", "	vTex = aTex;", "	vColor = aColor;", "}"].join("\n");
        }
        static GetDefaultVertexShaderSource_WebGL2(e) {
          const t = e ? "highp" : "mediump";
          return ["#version 300 es", "in highp vec3 aPos;", `in ${t} vec2 aTex;`, `out ${t} vec2 vTex;`, "in lowp vec4 aColor;", "out lowp vec4 vColor;", "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPos, 1.0);", "	vTex = aTex;", "	vColor = aColor;", "}"].join("\n");
        }
        static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth() {
          return ["varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	gl_FragColor = texture2D(samplerFront, vTex) * vColor;", "}"].join("\n");
        }
        static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT() {
          return ["#extension GL_EXT_frag_depth : enable", "varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	gl_FragColor = texture2D(samplerFront, vTex) * vColor;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetTextureFillFragmentShaderSource_WebGL2(e) {
          return ["#version 300 es", C33.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), "in mediump vec2 vTex;", "out lowp vec4 outColor;", "in lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	outColor = texture(samplerFront, vTex) * vColor;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetTilemapFragmentShaderSource_WebGL1_NoFragDepth() {
          return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "	highp vec2 tile = floor(vTex);", "	highp vec2 tex = fract(vTex);", "	highp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	gl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "}"].join("\n");
        }
        static GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT() {
          return ["#extension GL_EXT_frag_depth : enable", "varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "	highp vec2 tile = floor(vTex);", "	highp vec2 tex = fract(vTex);", "	highp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	gl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetTilemapFragmentShaderSource_WebGL2(e) {
          return ["#version 300 es", C33.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), "in highp vec2 vTex;", "out lowp vec4 outColor;", "in lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "	highp vec2 tile = floor(vTex);", "	highp vec2 tex = fract(vTex);", "	highp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	outColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetTileRandomizationFragmentShaderSource(e, t, i2, r2) {
          let o2 = "";
          return e >= 2 ? o2 = "#version 300 es\n" + C33.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(r2) : (t && (o2 = "#extension GL_EXT_frag_depth : enable\n"), i2 && (o2 += "#extension GL_EXT_shader_texture_lod : enable\n", o2 += "#extension GL_OES_standard_derivatives : enable\n")), o2 + `
precision highp float;
${e >= 2 ? "in" : "varying"} vec2 vTex;
${e >= 2 ? "out lowp vec4 outColor;" : ""}
${e >= 2 ? "in" : "varying"} lowp vec4 vColor;
uniform lowp sampler2D samplerFront;
uniform vec2 pixelSize;

uniform vec2 tileSize;
uniform vec2 tileSpacing;
uniform float outlineThickness;

const float PI = 3.1415926;

lowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

vec3 randVec3(vec2 seed)
{
	return vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),
				fract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),
				fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));
}

lowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)
{
	vec2 posRandom = tileSize;
	float angleRandom = outlineThickness;
	
	vec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;
	
	float angle = angleRandom * rand.z * PI;
	float sin_a = sin(angle);
	float cos_a = cos(angle);
	float aspect = pixelSize.x / pixelSize.y;

	vec2 mid = tile + vec2(0.5, 0.5);
	vec2 dp = uv - mid;
	dp.x /= aspect;
	vec2 r = vec2(dp.x * cos_a - dp.y * sin_a,
				  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	vec2 p = mid + r + (posRandom * rand.xy / 2.0);
	
	${e >= 2 ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}
	${e < 2 && i2 ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}
	${e < 2 && !i2 ? "return texture2D(samplerFront, p);" : ""}
}

void main(void) {
	
	${e < 2 ? "lowp vec4 outColor;" : ""}
	
	float blendMarginX = tileSpacing.x;
	float blendMarginY = tileSpacing.y;
	
	vec2 tile = floor(vTex);
	vec2 tex = fract(vTex);
	vec2 ddx = ${e >= 2 || i2 ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};
	vec2 ddy = ${e >= 2 || i2 ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};
	
	vec4 curTile = sampleTile(tile, vTex, ddx, ddy);
	
	bool inLeftMargin = (tex.x < blendMarginX);
	bool inRightMargin = (tex.x > 1.0 - blendMarginX);
	bool inTopMargin = (tex.y < blendMarginY);
	bool inBottomMargin = (tex.y > 1.0 - blendMarginY);
	
	if (inLeftMargin)
	{
		lowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);
		float leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		lowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
			
			outColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
			
			outColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		lowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);
		float rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		lowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
			
			outColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
			
			outColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		lowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
		outColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		lowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
		outColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		outColor = curTile;
	}
	
	outColor *= vColor;
	${e < 2 ? "gl_FragColor = outColor;" : ""}
	${e >= 2 ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
	${e < 2 && t ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
}
`;
        }
        static GetPointVertexShaderSource_WebGL1() {
          return ["attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "	gl_PointSize = aPoints.z;", "	pointOpacity = aPoints.w;", "}"].join("\n");
        }
        static GetPointVertexShaderSource_WebGL2() {
          return ["#version 300 es", "in vec4 aPoints;", "out float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "	gl_PointSize = aPoints.z;", "	pointOpacity = aPoints.w;", "}"].join("\n");
        }
        static GetPointFragmentShaderSource_WebGL1_NoFragDepth() {
          return ["uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	gl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "}"].join("\n");
        }
        static GetPointFragmentShaderSource_WebGL1_FragDepthEXT() {
          return ["#extension GL_EXT_frag_depth : enable", "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	gl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetPointFragmentShaderSource_WebGL2(e) {
          return ["#version 300 es", C33.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), "uniform lowp sampler2D samplerFront;", "in lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "out lowp vec4 outColor;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	outColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetColorFillFragmentShaderSource() {
          return ["varying lowp vec4 vColor;", "void main(void) {", "	gl_FragColor = vColor;", "}"].join("\n");
        }
        static GetLinearGradientFillFragmentShaderSource() {
          return ["precision lowp float;", "varying mediump vec2 vTex;", "varying vec4 vColor;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "	bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "	vec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);", "	vec3 lower = linearRGB * vec3(12.92);", "	return mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "	bvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "	vec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));", "	vec3 lower = sRGB/vec3(12.92);", "	return mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "	vec3 linearGrad = mix(toLinear(vColor.rgb), toLinear(color2_.rgb), vTex.x);", "	float a = mix(vColor.a, color2_.a, vTex.x);", "	gl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}"].join("\n");
        }
        static GetPenumbraFillFragmentShaderSource() {
          return ["precision lowp float;", "varying highp vec2 vTex;", "varying vec4 vColor;", "void main(void) {", "	highp float grad = vTex.x / (1.0 - vTex.y);", "	gl_FragColor = vColor * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);", "}"].join("\n");
        }
        static GetSmoothLineFillFragmentShaderSource() {
          return ["varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "void main(void) {", "	lowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "	gl_FragColor = vColor * f;", "}"].join("\n");
        }
        static GetHardEllipseFillFragmentShaderSource() {
          return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp float f = step(diffSq.x + diffSq.y, 0.25);", "	gl_FragColor = vColor * f;", "}"].join("\n");
        }
        static GetHardEllipseOutlineFragmentShaderSource() {
          return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "uniform highp float outlineThickness;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp float distSq = diffSq.x + diffSq.y;", "	highp vec2 norm = normalize(diff);", "	highp vec2 halfNorm = norm * 0.5;", "	highp float innerF = step(distSq, 0.25);", "	highp vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "	highp vec2 innerEdgeSq = innerEdge * innerEdge;", "	highp float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "	gl_FragColor = vColor * innerF * outerF;", "}"].join("\n");
        }
        static GetSmoothEllipseFillFragmentShaderSource() {
          return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp vec2 norm = normalize(diff);", "	highp vec2 halfNorm = norm * 0.5;", "	highp vec2 halfNormSq = halfNorm * halfNorm;", "	highp vec2 innerEdge = halfNorm - pixelSize * norm;", "	highp vec2 innerEdgeSq = innerEdge * innerEdge;", "	highp float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "	gl_FragColor = vColor * f;", "}"].join("\n");
        }
        static GetSmoothEllipseOutlineFragmentShaderSource() {
          return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "uniform highp float outlineThickness;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp float distSq = diffSq.x + diffSq.y;", "	highp vec2 norm = normalize(diff);", "	highp vec2 halfNorm = norm * 0.5;", "	highp vec2 halfNormSq = halfNorm * halfNorm;", "	highp vec2 pxNorm = pixelSize * norm;", "	highp vec2 innerEdge1 = halfNorm - pxNorm;", "	highp vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "	highp float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "	highp vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "	highp vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "	highp vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "	highp vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "	highp float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "	gl_FragColor = vColor * innerF * outerF;", "}"].join("\n");
        }
      };
    }
    {
      const C33 = self.C3, glMatrix = self.glMatrix, mat42 = glMatrix.mat4, TYPE_SIZES = /* @__PURE__ */ new Map([["float", 1], ["percent", 1], ["sampler", 1], ["vec2", 2], ["vec3", 3], ["color", 3], ["vec4", 4], ["mat4", 16]]);
      C33.Gfx.WebGLShaderUniform = class {
        constructor(t, s2, a2) {
          if (!TYPE_SIZES.has(a2)) throw new Error("invalid uniform type");
          this._owner = t, this._gl = this._owner.GetWebGLContext(), this._name = s2, this._type = a2, this._isColorType = "color" === this._type, this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), s2), this._isUsed = !!this._location;
          const i2 = TYPE_SIZES.get(a2);
          this._lastValue = new Float32Array(i2), this._lastBatchValue = new Float32Array(i2);
        }
        Release() {
          this._owner = null, this._gl = null, this._location = null;
        }
        IsUsed() {
          return this._isUsed;
        }
        GetType() {
          return this._type;
        }
        IsColorType() {
          return this._isColorType;
        }
        Init1f(t) {
          this.IsUsed() && (this._lastValue[0] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, t));
        }
        Init1i(t) {
          this.IsUsed() && (this._lastValue[0] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, t));
        }
        Init2f(t, s2) {
          this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s2, this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, t, s2));
        }
        Init3f(t, s2, a2) {
          this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s2, this._lastValue[2] = a2, this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, t, s2, a2));
        }
        Init4f(t, s2, a2, i2) {
          this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s2, this._lastValue[2] = a2, this._lastValue[3] = i2, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, t, s2, a2, i2));
        }
        Update1f(t) {
          t = Math.fround(t);
          const s2 = this._lastValue;
          s2[0] !== t && (s2[0] = t, this._gl.uniform1f(this._location, t));
        }
        Update1i(t) {
          const s2 = this._lastValue;
          s2[0] !== t && (s2[0] = t, this._gl.uniform1i(this._location, t));
        }
        Update2f(t, s2) {
          t = Math.fround(t), s2 = Math.fround(s2);
          const a2 = this._lastValue;
          a2[0] === t && a2[1] === s2 || (a2[0] = t, a2[1] = s2, this._gl.uniform2f(this._location, t, s2));
        }
        Update3f(t, s2, a2) {
          t = Math.fround(t), s2 = Math.fround(s2), a2 = Math.fround(a2);
          const i2 = this._lastValue;
          i2[0] === t && i2[1] === s2 && i2[2] === a2 || (i2[0] = t, i2[1] = s2, i2[2] = a2, this._gl.uniform3f(this._location, t, s2, a2));
        }
        Update4f(t, s2, a2, i2) {
          t = Math.fround(t), s2 = Math.fround(s2), a2 = Math.fround(a2), i2 = Math.fround(i2);
          const l2 = this._lastValue;
          l2[0] === t && l2[1] === s2 && l2[2] === a2 && l2[3] === i2 || (l2[0] = t, l2[1] = s2, l2[2] = a2, l2[3] = i2, this._gl.uniform4f(this._location, t, s2, a2, i2));
        }
        UpdateMatrix4fv(t) {
          const s2 = this._lastValue;
          mat42.exactEquals(s2, t) || (C33.typedArraySet16(s2, t, 0), this._gl.uniformMatrix4fv(this._location, false, t));
        }
        IsSetToCustomInBatch(t) {
          const s2 = this._lastBatchValue;
          return this.IsColorType() ? s2[0] === Math.fround(t.getR()) && s2[1] === Math.fround(t.getG()) && s2[2] === Math.fround(t.getB()) : s2[0] === Math.fround(t);
        }
        SetBatchValueCustom(t) {
          const s2 = this._lastBatchValue;
          this.IsColorType() ? (s2[0] = t.getR(), s2[1] = t.getG(), s2[2] = t.getB()) : s2[0] = t;
        }
        IsSetTo1InBatch(t) {
          return this._lastBatchValue[0] === Math.fround(t);
        }
        IsSetTo2InBatch(t, s2) {
          const a2 = this._lastBatchValue;
          return a2[0] === Math.fround(t) && a2[1] === Math.fround(s2);
        }
        SetBatch1(t) {
          this._lastBatchValue[0] = t;
        }
        SetBatch2(t, s2) {
          const a2 = this._lastBatchValue;
          a2[0] = t, a2[1] = s2;
        }
      };
    }
    {
      const C33 = self.C3, glMatrix = self.glMatrix, vec42 = glMatrix.vec4, mat42 = glMatrix.mat4, BATCH_NULL = 0, BATCH_DRAW = 1, BATCH_SETTEXTURE = 2, BATCH_SETBLEND = 3, BATCH_SETVIEWPORT = 4, BATCH_SETPROJECTION = 5, BATCH_SETMODELVIEW = 6, BATCH_SETRENDERTARGET = 7, BATCH_CLEARSURFACE = 8, BATCH_POINTS = 9, BATCH_SETPROGRAM = 10, BATCH_SETPROGRAMPARAMETERS = 11, BATCH_SETPROGRAMCUSTOMPARAMETERS = 12, BATCH_INVALIDATEFRAMEBUFFER = 13, BATCH_SETPOINTTEXCOORDS = 14, BATCH_SETTILEMAPINFO = 15, BATCH_BLITFRAMEBUFFER = 16, BATCH_STARTQUERY = 17, BATCH_ENDQUERY = 18, BATCH_SETELLIPSEPARAMS = 19, BATCH_SETGRADIENTCOLOR = 20, BATCH_CLEARDEPTH = 21, BATCH_SETDEPTHENABLED = 22, BATCH_SETDEPTHSAMPLINGENABLED = 23, BATCH_COPLANAR_STARTSTENCILPASS = 24, BATCH_COPLANAR_STARTCOLORPASS = 25, BATCH_COPLANAR_RESTORE = 26, BATCH_SET_SCISSOR = 27, BATCH_SETTILERANDOMIZATIONINFO = 28, BATCH_SETCULLFACEMODE = 29, BATCH_SETFRONTFACEWINDING = 30;
      C33.Gfx.BatchState = class {
        constructor(t) {
          this.renderer = t, this.currentMV = mat42.create(), this.currentMatP = mat42.create(), this.currentFramebuffer = null, this.currentFramebufferNoDepth = null, this.isDepthSamplingEnabled = false, this.currentShader = null, this.pointTexCoords = new C33.Rect(), this.clearColor = C33.New(C33.Color, 0, 0, 0, 0);
        }
      }, C33.Gfx.WebGLBatchJob = class {
        constructor(t) {
          const e = new ArrayBuffer(96);
          this._type = 0, this._batchState = t, this._gl = t.renderer.GetContext(), this._startIndex = 0, this._indexCount = 0, this._texParam = null, this._mat4param = new Float32Array(e, 0, 16), this._colorParam = new Float32Array(e, 64, 4), this._srcOriginRect = new Float32Array(e, 80, 4), this._shaderParams = [];
        }
        InitDraw(t, e) {
          this._type = 1, this._startIndex = t, this._indexCount = e;
        }
        DoDraw() {
          const t = this._gl;
          t.drawElements(t.TRIANGLES, this._indexCount, t.UNSIGNED_SHORT, this._startIndex);
        }
        InitSetTexture(t) {
          this._type = 2, this._texParam = t;
        }
        DoSetTexture() {
          const t = this._gl, e = this._texParam;
          t.bindTexture(t.TEXTURE_2D, e ? e._GetTexture() : null);
        }
        InitSetGradientColor(t) {
          this._type = 20, t.writeToTypedArray(this._colorParam, 0);
        }
        DoSetGradientColor() {
          const t = this._colorParam, e = this._batchState.currentShader;
          e._uColor2.IsUsed() && e._uColor2.Update4f(t[0], t[1], t[2], t[3]);
        }
        InitSetBlend(t, e) {
          this._type = 3, this._startIndex = t, this._indexCount = e;
        }
        DoSetBlend() {
          this._gl.blendFunc(this._startIndex, this._indexCount);
        }
        InitSetViewport(t, e, r2, a2) {
          this._type = 4;
          const s2 = this._colorParam;
          s2[0] = t, s2[1] = e, s2[2] = r2, s2[3] = a2;
        }
        DoSetViewport() {
          const t = this._colorParam;
          this._gl.viewport(t[0], t[1], t[2], t[3]);
        }
        InitSetProjection(t) {
          this._type = 5, mat42.copy(this._mat4param, t);
        }
        DoSetProjection() {
          const t = this._batchState, e = t.renderer._allShaderPrograms, r2 = t.currentShader, a2 = this._mat4param;
          for (let t2 = 0, s2 = e.length; t2 < s2; ++t2) {
            const s3 = e[t2];
            s3 === r2 ? s3.UpdateMatP(a2, true) : s3.SetMatPStale();
          }
          mat42.copy(t.currentMatP, a2);
        }
        InitSetModelView(t) {
          this._type = 6, mat42.copy(this._mat4param, t);
        }
        DoSetModelView() {
          const t = this._batchState, e = t.renderer._allShaderPrograms, r2 = t.currentShader, a2 = this._mat4param;
          for (let t2 = 0, s2 = e.length; t2 < s2; ++t2) {
            const s3 = e[t2];
            s3 === r2 ? s3.UpdateMatMV(a2, true) : s3.SetMatMVStale();
          }
          mat42.copy(t.currentMV, a2);
        }
        InitSetRenderTarget(t) {
          this._type = 7, this._texParam = t;
        }
        DoSetRenderTarget() {
          const t = this._gl, e = this._texParam, r2 = this._batchState;
          e ? (r2.currentFramebuffer = e._GetFramebuffer(), r2.currentFramebufferNoDepth = e._GetFramebufferNoDepth(), r2.isDepthSamplingEnabled && r2.currentFramebufferNoDepth ? t.bindFramebuffer(t.FRAMEBUFFER, r2.currentFramebufferNoDepth) : t.bindFramebuffer(t.FRAMEBUFFER, r2.currentFramebuffer)) : (r2.currentFramebuffer = null, r2.currentFramebufferNoDepth = null, t.bindFramebuffer(t.FRAMEBUFFER, null));
        }
        InitClearSurface(t) {
          this._type = 8, t.writeToTypedArray(this._mat4param, 0);
        }
        InitClearSurface2(t, e, r2, a2) {
          this._type = 8;
          const s2 = this._mat4param;
          s2[0] = t, s2[1] = e, s2[2] = r2, s2[3] = a2;
        }
        DoClearSurface() {
          const t = this._gl, e = this._mat4param, r2 = this._batchState.clearColor, a2 = e[0], s2 = e[1], i2 = e[2], n = e[3];
          r2.equalsRgba(a2, s2, i2, n) || (t.clearColor(a2, s2, i2, n), r2.setRgba(a2, s2, i2, n)), t.clear(t.COLOR_BUFFER_BIT);
        }
        InitSetPointTexCoords(t) {
          this._type = 14, t.writeToTypedArray(this._mat4param, 0);
        }
        DoSetPointTextureCoords() {
          const t = this._mat4param;
          this._batchState.pointTexCoords.set(t[0], t[1], t[2], t[3]);
        }
        InitPoints(t, e, r2) {
          this._type = 9, this._startIndex = t, this._indexCount = 1, this._mat4param[0] = e, r2.writeToTypedArray(this._colorParam, 0);
        }
        DoPoints() {
          const t = this._gl, e = this._batchState, r2 = e.renderer._spPoints;
          t.useProgram(r2._shaderProgram), r2.UpdateMatP(e.currentMatP, false), r2.UpdateMatMV(e.currentMV, false);
          const a2 = e.pointTexCoords;
          r2._uPointTexStart.IsUsed() && r2._uPointTexStart.Update2f(a2.getLeft(), a2.getTop()), r2._uPointTexEnd.IsUsed() && r2._uPointTexEnd.Update2f(a2.getRight(), a2.getBottom());
          const s2 = this._mat4param[0];
          if (r2._uZElevation.IsUsed() && r2._uZElevation.Update1f(s2), r2._uColor.IsUsed()) {
            const t2 = this._colorParam;
            r2._uColor.Update4f(t2[0], t2[1], t2[2], t2[3]);
          }
          t.drawArrays(t.POINTS, this._startIndex / 4, this._indexCount), t.useProgram(e.currentShader._shaderProgram);
        }
        InitSetProgram(t) {
          this._type = 10, this._texParam = t;
        }
        DoSetProgram() {
          const t = this._gl, e = this._batchState, r2 = this._texParam;
          e.currentShader = r2, t.useProgram(r2._shaderProgram), r2.UpdateMatP(e.currentMatP, false), r2.UpdateMatMV(e.currentMV, false);
        }
        InitSetProgramParameters() {
          this._type = 11;
        }
        DoSetProgramParameters() {
          const t = this._batchState.currentShader, e = this._gl, r2 = this._mat4param, a2 = this._colorParam, s2 = this._srcOriginRect;
          if (t._uSamplerBack.IsUsed()) {
            const t2 = this._batchState.renderer, r3 = this._texParam;
            t2._lastTexture1 !== r3 && (e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, r3 ? r3._GetTexture() : null), t2._lastTexture1 = r3, e.activeTexture(e.TEXTURE0));
          }
          t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(r2[0], r2[1]), t._uDestStart.IsUsed() && t._uDestStart.Update2f(r2[2], r2[3]), t._uDestEnd.IsUsed() && t._uDestEnd.Update2f(r2[4], r2[5]), t._uDevicePixelRatio.IsUsed() && t._uDevicePixelRatio.Update1f(this._indexCount), t._uLayerScale.IsUsed() && t._uLayerScale.Update1f(r2[6]), t._uLayerAngle.IsUsed() && t._uLayerAngle.Update1f(r2[7]), t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(r2[12], r2[13]), t._uSrcEnd.IsUsed() && t._uSrcEnd.Update2f(r2[14], r2[15]), t._uSrcOriginStart.IsUsed() && t._uSrcOriginStart.Update2f(s2[0], s2[1]), t._uSrcOriginEnd.IsUsed() && t._uSrcOriginEnd.Update2f(s2[2], s2[3]), t._uLayoutStart.IsUsed() && t._uLayoutStart.Update2f(a2[0], a2[1]), t._uLayoutEnd.IsUsed() && t._uLayoutEnd.Update2f(a2[2], a2[3]), t._uSeconds.IsUsed() && t._uSeconds.Update1f(this._startIndex);
        }
        InitSetProgramCustomParameters() {
          this._type = 12;
        }
        DoSetProgramCustomParameters() {
          const t = this._batchState.currentShader._uCustomParameters, e = this._shaderParams;
          for (let r2 = 0, a2 = t.length; r2 < a2; ++r2) {
            const a3 = t[r2], s2 = e[r2];
            a3.IsColorType() ? a3.Update3f(s2.getR(), s2.getG(), s2.getB()) : a3.Update1f(s2);
          }
        }
        InitInvalidateFramebuffer(t) {
          this._type = 13, this._texParam = t;
        }
        DoInvalidateFramebuffer() {
          const t = this._gl, e = this._texParam, r2 = this._batchState.currentFramebuffer;
          e !== r2 && t.bindFramebuffer(t.FRAMEBUFFER, e), t.invalidateFramebuffer(t.FRAMEBUFFER, [t.COLOR_ATTACHMENT0]), e !== r2 && t.bindFramebuffer(t.FRAMEBUFFER, r2);
        }
        InitBlitFramebuffer(t, e, r2) {
          this._type = 16;
          const a2 = this._mat4param, s2 = this._batchState.renderer;
          a2[0] = t.GetWidth(), a2[1] = t.GetHeight(), a2[2] = e ? e.GetWidth() : s2.GetWidth(), a2[3] = e ? e.GetHeight() : s2.GetHeight(), a2[4] = t.IsLinearSampling() ? 1 : 0, a2[5] = "stretch" === r2;
          const i2 = this._shaderParams;
          C33.clearArray(i2), i2.push(t._GetFramebuffer()), i2.push(e ? e._GetFramebuffer() : null);
        }
        DoBlitFramebuffer() {
          const t = this._mat4param, e = this._shaderParams, r2 = this._gl, a2 = t[0], s2 = t[1], i2 = t[2], n = t[3], o2 = 0 !== t[4], _ = 0 !== t[5], h = e[0], d2 = e[1];
          if (r2.bindFramebuffer(r2.READ_FRAMEBUFFER, h), r2.bindFramebuffer(r2.DRAW_FRAMEBUFFER, d2), _) r2.blitFramebuffer(0, 0, a2, s2, 0, 0, i2, n, r2.COLOR_BUFFER_BIT, o2 ? r2.LINEAR : r2.NEAREST);
          else {
            const t2 = Math.min(a2, i2), e2 = Math.min(s2, n), o3 = Math.max(s2 - n, 0), _2 = Math.max(n - s2, 0);
            r2.blitFramebuffer(0, o3, t2, e2 + o3, 0, _2, t2, e2 + _2, r2.COLOR_BUFFER_BIT, r2.NEAREST);
          }
        }
        InitStartQuery(t) {
          this._type = 17, this._texParam = t;
        }
        DoStartQuery() {
          this._texParam.BeginTimeElapsed(), this._texParam = null;
        }
        InitEndQuery(t) {
          this._type = 18, this._texParam = t;
        }
        DoEndQuery() {
          this._texParam.EndTimeElapsed(), this._texParam = null;
        }
        InitSetEllipseParams(t, e, r2) {
          this._type = 19;
          const a2 = this._mat4param;
          a2[0] = t, a2[1] = e, a2[2] = r2;
        }
        DoSetEllipseParams() {
          const t = this._batchState.currentShader, e = this._mat4param;
          t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[0], e[1]), t._uOutlineThickness.IsUsed() && t._uOutlineThickness.Update1f(e[2]);
        }
        InitSetTilemapInfo(t, e, r2, a2, s2, i2, n) {
          this._type = 15;
          const o2 = this._mat4param;
          t.writeToTypedArray(o2, 0), o2[4] = 1 / e, o2[5] = 1 / r2, o2[6] = a2 / e, o2[7] = s2 / r2, o2[8] = i2 / e, o2[9] = n / r2;
        }
        DoSetTilemapInfo() {
          const t = this._batchState.currentShader, e = this._mat4param;
          t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(e[0], e[1]), t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[4], e[5]), t._uTileSize.IsUsed() && t._uTileSize.Update2f(e[6], e[7]), t._uTileSpacing.IsUsed() && t._uTileSpacing.Update2f(e[8], e[9]);
        }
        InitSetTileRandomizationInfo(t, e, r2, a2, s2, i2, n) {
          this._type = 28;
          const o2 = this._mat4param;
          o2[0] = 1 / t, o2[1] = 1 / e, o2[2] = r2, o2[3] = a2, o2[4] = s2, o2[5] = i2, o2[6] = n;
        }
        DoSetTileRandomizationInfo() {
          const t = this._batchState.currentShader, e = this._mat4param;
          t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[0], e[1]), t._uTileSize.IsUsed() && t._uTileSize.Update2f(e[2], e[3]), t._uOutlineThickness.IsUsed() && t._uOutlineThickness.Update1f(e[4]), t._uTileSpacing.IsUsed() && t._uTileSpacing.Update2f(e[5], e[6]);
        }
        InitClearDepth(t) {
          this._type = 21, this._startIndex = t ? 1 : 0;
        }
        DoClearDepth() {
          const t = this._gl, e = 0 !== this._startIndex;
          e || t.depthMask(true), t.clear(t.DEPTH_BUFFER_BIT), e || t.depthMask(false);
        }
        InitSetDepthEnabled(t) {
          this._type = 22, this._startIndex = t ? 1 : 0;
        }
        DoSetDepthEnabled() {
          const t = this._gl;
          0 === this._startIndex ? (t.disable(t.DEPTH_TEST), t.depthMask(false)) : (t.enable(t.DEPTH_TEST), t.depthMask(true));
        }
        InitSetDepthSamplingEnabled(t) {
          this._type = 23, this._startIndex = t ? 1 : 0;
        }
        DoSetDepthSamplingEnabled() {
          const t = this._gl, e = this._batchState, r2 = e.renderer, a2 = 0 !== this._startIndex;
          e.isDepthSamplingEnabled = a2, t.activeTexture(t.TEXTURE2), a2 ? (e.currentFramebufferNoDepth && t.bindFramebuffer(t.FRAMEBUFFER, e.currentFramebufferNoDepth), t.bindTexture(t.TEXTURE_2D, r2._GetDepthBuffer())) : (t.bindTexture(t.TEXTURE_2D, null), e.currentFramebufferNoDepth && t.bindFramebuffer(t.FRAMEBUFFER, e.currentFramebuffer)), t.activeTexture(t.TEXTURE0);
        }
        InitCoplanarStartStencilPass() {
          this._type = 24;
        }
        DoCoplanarStartStencilPass() {
          const t = this._gl;
          t.clear(t.STENCIL_BUFFER_BIT), t.enable(t.STENCIL_TEST), t.stencilFunc(t.ALWAYS, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.REPLACE), t.colorMask(false, false, false, false);
        }
        InitCoplanarStartColorPass() {
          this._type = 25;
        }
        DoCoplanarStartColorPass() {
          const t = this._gl;
          t.enable(t.STENCIL_TEST), t.colorMask(true, true, true, true), t.stencilFunc(t.EQUAL, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
        }
        InitCoplanarRestore() {
          this._type = 26;
        }
        DoCoplanarRestore() {
          const t = this._gl;
          t.disable(t.STENCIL_TEST);
        }
        InitSetScissor(t, e, r2, a2, s2) {
          this._type = 27, this._startIndex = t ? 1 : 0;
          const i2 = this._mat4param;
          i2[0] = e, i2[1] = r2, i2[2] = a2, i2[3] = s2;
        }
        DoSetScissor() {
          const t = this._gl, e = this._mat4param;
          1 === this._startIndex ? (t.enable(t.SCISSOR_TEST), t.scissor(e[0], e[1], e[2], e[3])) : t.disable(t.SCISSOR_TEST);
        }
        InitSetCullFaceMode(t) {
          this._type = 29, this._startIndex = t;
        }
        DoSetCullFaceMode() {
          const t = this._gl, e = this._startIndex;
          0 === e ? t.disable(t.CULL_FACE) : (t.enable(t.CULL_FACE), 1 === e ? t.cullFace(t.BACK) : t.cullFace(t.FRONT));
        }
        InitSetFrontFaceWinding(t) {
          this._type = 30, this._startIndex = t;
        }
        DoSetFrontFaceWinding() {
          const t = this._gl;
          t.frontFace(0 === this._startIndex ? t.CW : t.CCW);
        }
        Run() {
          switch (this._type) {
            case 1:
              return void this.DoDraw();
            case 2:
              return void this.DoSetTexture();
            case 3:
              return void this.DoSetBlend();
            case 4:
              return void this.DoSetViewport();
            case 5:
              return void this.DoSetProjection();
            case 6:
              return void this.DoSetModelView();
            case 7:
              return void this.DoSetRenderTarget();
            case 8:
              return void this.DoClearSurface();
            case 9:
              return void this.DoPoints();
            case 10:
              return void this.DoSetProgram();
            case 11:
              return void this.DoSetProgramParameters();
            case 12:
              return void this.DoSetProgramCustomParameters();
            case 13:
              return void this.DoInvalidateFramebuffer();
            case 14:
              return void this.DoSetPointTextureCoords();
            case 15:
              return void this.DoSetTilemapInfo();
            case 16:
              return void this.DoBlitFramebuffer();
            case 17:
              return void this.DoStartQuery();
            case 18:
              return void this.DoEndQuery();
            case 19:
              return void this.DoSetEllipseParams();
            case 20:
              return void this.DoSetGradientColor();
            case 21:
              return void this.DoClearDepth();
            case 22:
              return void this.DoSetDepthEnabled();
            case 23:
              return void this.DoSetDepthSamplingEnabled();
            case 24:
              return void this.DoCoplanarStartStencilPass();
            case 25:
              return void this.DoCoplanarStartColorPass();
            case 26:
              return void this.DoCoplanarRestore();
            case 27:
              return void this.DoSetScissor();
            case 28:
              return void this.DoSetTileRandomizationInfo();
            case 29:
              return void this.DoSetCullFaceMode();
            case 30:
              return void this.DoSetFrontFaceWinding();
          }
        }
      };
    }
    {
      let fillOrStrokeRect2 = function(t, e, i2, s2, a2, n) {
        e ? t.strokeRect(i2, s2, a2, n) : t.fillRect(i2, s2, a2, n);
      }, ptToPx2 = function(t) {
        return t * (4 / 3);
      }, getOffsetParam2 = function(t, e) {
        t = t.trim();
        const i2 = parseFloat(t);
        return isFinite(i2) ? t.endsWith("%") ? e * i2 / 100 : i2 : 0;
      };
      fillOrStrokeRect = fillOrStrokeRect2, ptToPx = ptToPx2, getOffsetParam = getOffsetParam2;
      const C33 = self.C3, MAX_TEXTURE_SIZE = 4096, EXTRA_LINE_HEIGHT = 4, GENERIC_FONT_FAMILIES = /* @__PURE__ */ new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), DEFAULT_OPTS = { timeout: 60 }, tempColor = new C33.Color(0, 0, 0, 1), VALID_HORIZ_ALIGNMENTS = /* @__PURE__ */ new Set(["left", "center", "right"]), VALID_VERT_ALIGNMENTS = /* @__PURE__ */ new Set(["top", "center", "bottom"]), VALID_WORD_WRAP_MODES = /* @__PURE__ */ new Set(["word", "cjk", "character"]), VALID_TEXT_DIRECTIONS = /* @__PURE__ */ new Set(["ltr", "rtl"]), allRendererTexts = /* @__PURE__ */ new Set();
      C33.FontManager && C33.FontManager.addEventListener("fontload", (t) => {
        const e = t.font.GetName();
        for (const t2 of allRendererTexts) (t2.IsBBCodeEnabled() || C33.equalsNoCase(t2.GetFontName(), e)) && t2._SetWordWrapChanged();
      });
      let didCheckFoundBoundingBoxSupport = false, supportsFontBoundingBoxMeasurements = false;
      C33.Gfx.RendererText = class {
        constructor(t, e) {
          e = Object.assign({}, DEFAULT_OPTS, e), this._renderer = t, this._fontName = "Arial", this._fontSize = 16, this._fontSizeScale = 1, this._lineHeight = 0, this._isBold = false, this._isItalic = false, this._colorStr = "black", this._isBBcodeEnabled = false, this._iconSet = null, this._iconSmoothing = true, this.onloadfont = null, this._alreadyLoadedFonts = /* @__PURE__ */ new Set(), this._horizontalAlign = "left", this._verticalAlign = "top", this._text = "", this._bbString = null, this._wrappedText = C33.New(C33.WordWrap), this._wrapMode = "word", this._textDirection = "ltr", this._wordWrapChanged = false, this._textLayoutChanged = false, this._drawChanged = false, this._drawMaxCharCount = -1, this._drawCharCount = 0, this._cssWidth = 0, this._cssHeight = 0, this._width = 0, this._height = 0, this._zoom = 1, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._lastCanvasWidth = -1, this._lastCanvasHeight = -1, this._lastTextCanvasFont = "", this._lastMeasureCanvasFont = "", this._lastTextCanvasFillStyle = "", this._lastTextCanvasOpacity = 1, this._lastTextCanvasLineWidth = 1, this._measureTextCallback = (t2) => this._MeasureText(t2), this._texture = null, this._rcTex = new C33.Rect(), this._scaleFactor = 1, this._textureTimeout = new C33.IdleTimeout(() => {
            this.ReleaseTexture(), this._SetTextCanvasSize(8, 8);
          }, e.timeout), this.ontextureupdate = null, this._wasReleased = false, allRendererTexts.add(this);
        }
        Release() {
          this.onloadfont = null, this._alreadyLoadedFonts.clear(), this._iconSet = null, this._bbString = null, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._measureTextCallback = null, this._textureTimeout.Release(), this.ontextureupdate = null, this.ReleaseTexture(), this._wrappedText.Clear(), this._wrappedText = null, this._renderer = null, this._wasReleased = true, allRendererTexts.delete(this);
        }
        _SetDrawChanged() {
          this._drawChanged = true;
        }
        _SetTextLayoutChanged() {
          this._SetDrawChanged(), this._textLayoutChanged = true;
        }
        _SetWordWrapChanged() {
          this._SetTextLayoutChanged(), this._wordWrapChanged = true;
        }
        SetBBCodeEnabled(t) {
          if (t = !!t, this._isBBcodeEnabled === t) return;
          this._isBBcodeEnabled = t;
          const e = this._isBBcodeEnabled ? "alphabetic" : "top";
          this._textContext && (this._textContext.textBaseline = e), this._measureContext && (this._measureContext.textBaseline = e), this._SetWordWrapChanged();
        }
        IsBBCodeEnabled() {
          return this._isBBcodeEnabled;
        }
        SetIconSet(t) {
          this._iconSet !== t && (this._iconSet = t, this._wrappedText.SetIconSet(t), this._iconSet && this._iconSet.IsLoading() && this._iconSet.LoadContent().then(() => this._SetDrawChanged()), this._SetWordWrapChanged());
        }
        SetIconSmoothing(t) {
          t = !!t, this._iconSmoothing !== t && (this._iconSmoothing = t, this._SetDrawChanged());
        }
        SetFontName(t) {
          t || (t = "serif"), this._fontName !== t && (this._fontName = t, this._SetWordWrapChanged());
        }
        GetFontName() {
          return this._fontName;
        }
        SetFontSize(t) {
          t < 0.1 && (t = 0.1), this._fontSize !== t && (this._fontSize = t, this._SetWordWrapChanged());
        }
        GetFontSize() {
          return this._fontSize;
        }
        SetFontSizeScale(t) {
          this._fontSizeScale !== t && (this._fontSizeScale = t, this._SetWordWrapChanged());
        }
        SetLineHeight(t) {
          this._lineHeight !== t && (this._lineHeight = t, this._SetTextLayoutChanged());
        }
        GetLineHeight() {
          return this._lineHeight;
        }
        SetBold(t) {
          t = !!t, this._isBold !== t && (this._isBold = t, this._SetWordWrapChanged());
        }
        IsBold() {
          return this._isBold;
        }
        SetItalic(t) {
          t = !!t, this._isItalic !== t && (this._isItalic = t, this._SetWordWrapChanged());
        }
        IsItalic() {
          return this._isItalic;
        }
        SetDrawMaxCharacterCount(t) {
          t = Math.floor(t), this._drawMaxCharCount !== t && (this._drawMaxCharCount = t, this._SetDrawChanged());
        }
        GetDrawMaxCharacterCount() {
          return this._drawMaxCharCount;
        }
        _GetFontString(t, e) {
          let i2 = [];
          (this._isBold || e.HasStyleTag("b")) && i2.push("bold"), (this._isItalic || e.HasStyleTag("i")) && i2.push("italic");
          const s2 = e.GetStyleTag("size"), a2 = (s2 ? parseFloat(s2.param) : this._fontSize) * this._fontSizeScale;
          t ? i2.push(a2 + "pt") : i2.push(a2 * this.GetDrawScale() + "pt");
          let n = this._fontName;
          const h = e.GetStyleTag("font");
          return h && h.param && (n = h.param, this.onloadfont && !this._alreadyLoadedFonts.has(n) && (this.onloadfont(n), this._alreadyLoadedFonts.add(n))), n && (GENERIC_FONT_FAMILIES.has(n) ? i2.push(n) : i2.push('"' + n + '"')), i2.join(" ");
        }
        SetColor(t) {
          t instanceof C33.Color && (t = t.getCssRgb()), this._colorStr !== t && (this._colorStr = t, this._SetDrawChanged());
        }
        SetColorRgb(t, e, i2) {
          tempColor.setRgb(t, e, i2), this.SetColor(tempColor);
        }
        SetHorizontalAlignment(t) {
          if (!VALID_HORIZ_ALIGNMENTS.has(t)) throw new Error("invalid horizontal alignment");
          this._horizontalAlign !== t && (this._horizontalAlign = t, this._SetTextLayoutChanged());
        }
        GetHorizontalAlignment() {
          return this._horizontalAlign;
        }
        SetVerticalAlignment(t) {
          if (!VALID_VERT_ALIGNMENTS.has(t)) throw new Error("invalid vertical alignment");
          this._verticalAlign !== t && (this._verticalAlign = t, this._SetTextLayoutChanged());
        }
        GetVerticalAlignment() {
          return this._verticalAlign;
        }
        SetWordWrapMode(t) {
          if (!VALID_WORD_WRAP_MODES.has(t)) throw new Error("invalid word wrap mode");
          this._wrapMode !== t && (this._wrapMode = t, this._SetWordWrapChanged());
        }
        GetWordWrapMode() {
          return this._wrapMode;
        }
        SetTextDirection(t) {
          if (!VALID_TEXT_DIRECTIONS.has(t)) throw new Error("invalid text direction");
          this._textDirection !== t && (this._textDirection = t, this._textContext && (this._textContext.direction = this._textDirection), this._measureContext && (this._measureContext.direction = this._textDirection), this._SetWordWrapChanged());
        }
        GetTextDirection() {
          return this._textDirection;
        }
        SetText(t) {
          this._text !== t && (this._text = t, this._SetWordWrapChanged());
        }
        GetText() {
          return this._text;
        }
        GetDrawScale() {
          return this._scaleFactor * this._zoom * self.devicePixelRatio;
        }
        SetSize(t, e, i2) {
          if (void 0 === i2 && (i2 = 1), t <= 0 || t <= 0) return;
          if (this._cssWidth === t && this._cssHeight === e && this._zoom === i2) return;
          const s2 = this._cssWidth;
          this._cssWidth = t, this._cssHeight = e, this._zoom = i2;
          const a2 = self.devicePixelRatio;
          this._width = this._cssWidth * this._zoom * a2, this._height = this._cssHeight * this._zoom * a2;
          const n = Math.max(this._width, this._height), h = Math.min(this._renderer.GetMaxTextureSize(), 4096);
          let o2 = 1;
          n > h && (o2 = h / n, this._width = Math.min(this._width * o2, h), this._height = Math.min(this._height * o2, h)), this._scaleFactor = o2, this._cssWidth !== s2 ? this._SetWordWrapChanged() : this._SetTextLayoutChanged();
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        GetZoom() {
          return this._zoom;
        }
        GetTextWidth() {
          return this._UpdateTextMeasurements(), this._wrappedText.GetMaxLineWidth();
        }
        GetTextHeight() {
          return this._UpdateTextMeasurements(), this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + 4) - this._lineHeight;
        }
        GetLengthInGraphemes() {
          this._UpdateTextMeasurements();
          let t = 0;
          for (const e of this._wrappedText.GetLines()) for (const i2 of e.fragments()) t += i2.GetLength();
          return t;
        }
        GetTexture() {
          return this._textureTimeout.Reset(), this._MaybeUpdate(), this._texture;
        }
        HitTestFragment(t, e) {
          this._UpdateTextMeasurements();
          const i2 = this.GetDrawScale(), s2 = this._wrappedText.GetLines();
          for (const a2 of s2) {
            const s3 = a2.GetFontBoundingBoxDescent() * i2;
            if (e >= a2.GetPosY() - a2.GetHeight() * i2 + s3 && e < a2.GetPosY() + s3) {
              for (const e2 of a2.fragments()) if (t >= e2.GetPosX() && t < e2.GetPosX() + e2.GetWidth() * i2) return e2;
            }
          }
          return null;
        }
        *fragmentsWithTag(t) {
          this._UpdateTextMeasurements();
          const e = this._wrappedText.GetLines();
          for (const i2 of e) for (const e2 of i2.fragments()) {
            const i3 = e2.GetStyleTag("tag");
            i3 && C33.equalsNoCase(i3.param, t) && (yield e2);
          }
        }
        FindFragmentWithTag(t, e) {
          for (const i2 of this.fragmentsWithTag(t)) {
            if (0 === e) return i2;
            --e;
          }
          return null;
        }
        CountFragmentsWithTag(t) {
          let e = 0;
          for (const i2 of this.fragmentsWithTag(t)) ++e;
          return e;
        }
        _MaybeUpdate() {
          (!this._texture || this._drawChanged || this._textLayoutChanged || this._wordWrapChanged) && (this._wasReleased || this._width <= 0 || this._height <= 0 || (this._drawChanged = false, this._DoUpdate()));
        }
        _DoUpdate() {
          this._wasReleased || (this._UpdateTextMeasurements(), this._SetTextCanvasSize(Math.max(C33.nextHighestPowerOfTwo(Math.ceil(this._width)), 128), Math.max(C33.nextHighestPowerOfTwo(Math.ceil(this._height)), 64)), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset());
        }
        _SetTextCanvasSize(t, e) {
          this._textCanvas || (this._textCanvas = C33.CreateCanvas(16, 16));
          let i2 = false;
          this._lastCanvasWidth === t && this._lastCanvasHeight === e || (this._lastCanvasWidth = t, this._lastCanvasHeight = e, this._textCanvas.width = t, this._textCanvas.height = e, i2 = true), this._textContext || (this._textContext = this._textCanvas.getContext("2d"), i2 = true), i2 ? (this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._textContext.direction = this._textDirection, this._textContext.font = this._lastTextCanvasFont, this._textContext.fillStyle = this._lastTextCanvasFillStyle, this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, t, e);
        }
        _MaybeCreateMeasureContext() {
          this._measureContext || (this._measureContext = C33.CreateCanvas(16, 16).getContext("2d"), this._measureContextTop = C33.CreateCanvas(16, 16).getContext("2d"), this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._measureContextTop.textBaseline = "top", this._measureContext.direction = this._textDirection, this._measureContextTop.direction = this._textDirection);
        }
        _SetMeasureFontString(t) {
          this._lastMeasureCanvasFont !== t && (this._lastMeasureCanvasFont = t, this._measureContext.font = t, this._measureContextTop.font = t);
        }
        _SupportsFontBoundingBoxMeasurements() {
          if (!didCheckFoundBoundingBoxSupport) {
            didCheckFoundBoundingBoxSupport = true, this._MaybeCreateMeasureContext();
            const t = this._measureContext.measureText("test");
            supportsFontBoundingBoxMeasurements = "number" == typeof t["fontBoundingBoxAscent"] && "number" == typeof t["fontBoundingBoxDescent"];
          }
          return supportsFontBoundingBoxMeasurements;
        }
        _UpdateTextMeasurements() {
          this._UpdateWordWrap(), this._UpdateTextLayout();
        }
        _UpdateWordWrap() {
          this._wordWrapChanged && (this._MaybeCreateMeasureContext(), !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C33.BBString(this._text, { noEscape: true })), this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._wordWrapChanged = false);
        }
        _UpdateTextLayout() {
          this._textLayoutChanged && (this._LayoutText(), this._textLayoutChanged = false);
        }
        _MeasureText(t) {
          const e = t.IsText() ? t.GetCharacterArray().join("") : " ";
          this._SetMeasureFontString(this._GetFontString(true, t));
          const i2 = t.GetStyleTag("size"), s2 = (i2 ? parseFloat(i2.param) : this._fontSize) * this._fontSizeScale, a2 = this._measureContext.measureText(e);
          let n = 0;
          if (this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements()) {
            const t2 = this._measureContextTop.measureText(e);
            n = a2["fontBoundingBoxAscent"] - t2["fontBoundingBoxAscent"];
          }
          return { width: a2.width, height: ptToPx2(s2), fontBoundingBoxAscent: a2["fontBoundingBoxAscent"] || 0, fontBoundingBoxDescent: a2["fontBoundingBoxDescent"] || 0, topToAlphabeticDistance: n };
        }
        _SetDrawFontString(t) {
          this._lastTextCanvasFont !== t && (this._lastTextCanvasFont = t, this._textContext.font = t);
        }
        _SetDrawCanvasColor(t) {
          this._lastTextCanvasFillStyle !== t && (this._lastTextCanvasFillStyle = t, this._textContext.fillStyle = t, this._textContext.strokeStyle = t);
        }
        _SetDrawCanvasOpacity(t) {
          this._lastTextCanvasOpacity !== t && (this._lastTextCanvasOpacity = t, this._textContext.globalAlpha = t);
        }
        _SetDrawCanvasLineWith(t) {
          this._lastTextCanvasLineWidth !== t && (this._lastTextCanvasLineWidth = t, this._textContext.lineWidth = t);
        }
        _LayoutText() {
          const t = this.GetDrawScale(), e = (4 + this._lineHeight) * t;
          let i2 = 0;
          const s2 = this._wrappedText.GetLines();
          if (0 === s2.length) return;
          for (const t2 of s2) {
            t2.SetPosX(NaN), t2.SetPosY(NaN);
            for (const e2 of t2.fragments()) e2.SetPosX(NaN), e2.SetPosY(NaN);
          }
          const a2 = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements();
          let n = s2[0].GetHeight() * t;
          if ("center" === this._verticalAlign) {
            const h = s2.reduce((i3, s3) => i3 + s3.GetHeight() * t + e, 0) - e;
            i2 = Math.max(this._height / 2 - h / 2, 0), a2 && (n = s2[0].GetTopToAlphabeticDistance() * t);
          } else if ("bottom" === this._verticalAlign) {
            const n2 = s2.reduce((i3, s3) => i3 + s3.GetHeight() * t + e, 0) - this._lineHeight * t, h = a2 ? s2.at(-1).GetFontBoundingBoxDescent() * t : 0;
            i2 = this._height - n2 - h - 2;
          }
          for (let a3 = 0, h = s2.length; a3 < h; ++a3) {
            const h2 = s2[a3], o2 = h2.GetHeight() * t, r2 = i2;
            if (this._isBBcodeEnabled) {
              if (i2 += 0 === a3 ? n : o2, a3 > 0 && i2 > this._height - 4 * t) break;
            } else if (a3 > 0 && i2 >= this._height - o2) break;
            r2 >= 0 && this._LayoutTextLine(h2, i2, t), this._isBBcodeEnabled || (i2 += o2), i2 += e;
          }
        }
        _LayoutTextLine(t, e, i2) {
          let s2 = 0;
          "center" === this._horizontalAlign ? s2 = Math.floor((this._width - t.GetWidth() * i2) / 2) : "right" === this._horizontalAlign && (s2 = this._width - t.GetWidth() * i2), t.SetPosX(s2), t.SetPosY(e);
          for (const a2 of "ltr" === this._textDirection ? t.fragments() : t.fragmentsReverse()) this._LayoutFragment(a2, s2, e, i2), s2 += a2.GetWidth() * i2;
        }
        _LayoutFragment(t, e, i2, s2) {
          const a2 = t.GetStyleTag("offsetx");
          e += a2 ? getOffsetParam2(a2.param, t.GetHeight()) * s2 : 0;
          const n = t.GetStyleTag("offsety");
          if (i2 += n ? getOffsetParam2(n.param, t.GetHeight()) * s2 : 0, t.IsIcon()) {
            const e2 = t.GetStyleTag("iconoffsety");
            i2 += e2 ? getOffsetParam2(e2.param, t.GetHeight()) * s2 : 0.2 * t.GetHeight() * s2;
          }
          t.SetPosX(e), t.SetPosY(i2);
        }
        _DrawTextToCanvas() {
          this._textContext.imageSmoothingEnabled = this._iconSmoothing, this._textContext.imageSmoothingQuality = "high", this._drawCharCount = 0;
          const t = this.GetDrawScale(), e = this._wrappedText.GetLines();
          for (const i2 of e) this._DrawTextLine(i2, t);
        }
        _DrawTextLine(t, e) {
          const i2 = t.GetPosX(), s2 = t.GetPosY();
          if (Number.isFinite(i2) && Number.isFinite(s2)) for (const i3 of "ltr" === this._textDirection ? t.fragments() : t.fragmentsReverse()) this._DrawFragment(i3, e, t.GetHeight());
        }
        _DrawFragment(t, e, i2) {
          const s2 = this._textContext, a2 = t.GetPosX(), n = t.GetPosY();
          if (!Number.isFinite(a2) || !Number.isFinite(n)) return;
          const h = i2 / 16;
          let o2 = t.GetWidth() * e;
          const r2 = t.GetHeight() * e, _ = t.GetHeight() / 16, l2 = (4 + this._lineHeight) * e;
          let d2 = t.IsText() ? t.GetCharacterArray() : null;
          if (-1 !== this._drawMaxCharCount) {
            if (this._drawCharCount >= this._drawMaxCharCount) return;
            t.IsText() && this._drawCharCount + d2.length > this._drawMaxCharCount && (d2 = d2.slice(0, this._drawMaxCharCount - this._drawCharCount), o2 = this._MeasureText(t).width * e), this._drawCharCount += t.GetLength();
          }
          const x = t.GetStyleTag("background"), u = t.HasStyleTag("u"), C = t.HasStyleTag("s");
          if (t.IsText() && C33.IsCharArrayAllWhitespace(d2) && !x && !u && !C || t.HasStyleTag("hide")) return;
          const c2 = t.GetStyleTag("color"), g = t.GetStyleTag("opacity");
          this._SetDrawCanvasOpacity(g ? parseFloat(g.param) / 100 : 1), x && (this._SetDrawCanvasColor(x.param), s2.fillRect(a2, n - r2, o2, r2 + l2));
          const S = t.GetStyleTag("linethickness"), T = S ? parseFloat(S.param) : 1, p = t.HasStyleTag("stroke");
          if (p && this._SetDrawCanvasLineWith(0.5 * _ * T * this.GetDrawScale()), t.IsText()) {
            const e2 = d2.join("");
            if (this._SetDrawFontString(this._GetFontString(false, t)), !p) {
              this._SetDrawCanvasLineWith(0.5 * _ * T * this.GetDrawScale());
              const i3 = t.GetStyleTag("outlineback");
              i3 && (this._SetDrawCanvasColor(i3.param), this._FillOrStrokeText(true, e2, a2, n, o2));
            }
            if (this._SetDrawCanvasColor(c2 ? c2.param : this._colorStr), this._FillOrStrokeText(p, e2, a2, n, o2), !p) {
              this._SetDrawCanvasLineWith(0.5 * _ * T * this.GetDrawScale());
              const i3 = t.GetStyleTag("outline");
              i3 && (this._SetDrawCanvasColor(i3.param), this._FillOrStrokeText(true, e2, a2, n, o2));
            }
          } else if (t.IsIcon() && t.GetWidth() > 0) {
            const e2 = t.GetDrawable(this._iconSet);
            e2 && s2.drawImage(e2, a2, n - r2, o2, r2);
          }
          if (this._SetDrawCanvasColor(c2 ? c2.param : this._colorStr), u && fillOrStrokeRect2(s2, p, a2, n + e * h, o2, e * h * T), C) {
            const t2 = e * _, i3 = n - r2 / 4 + t2 / 2;
            s2.fillRect(a2, i3 - t2 * T / 2, o2, t2 * T);
          }
        }
        _FillOrStrokeText(t, e, i2, s2, a2) {
          "rtl" === this._textDirection && (i2 += a2), t ? "Gecko" === C33.Platform.BrowserEngine ? this._textContext.strokeText(e, i2, s2, a2) : this._textContext.strokeText(e, i2, s2) : "Gecko" === C33.Platform.BrowserEngine ? this._textContext.fillText(e, i2, s2, a2) : this._textContext.fillText(e, i2, s2);
        }
        _UpdateTexture() {
          this._renderer.IsContextLost() || (this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textCanvas.width, this._textCanvas.height, { mipMap: true, mipMapQuality: "high" })), this._renderer.UpdateTexture(this._textCanvas, this._texture), this._rcTex.set(0, 0, this._width / this._texture.GetWidth(), this._height / this._texture.GetHeight()), this.ontextureupdate && this.ontextureupdate());
        }
        GetTexRect() {
          return this._rcTex;
        }
        ReleaseTexture() {
          this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture), this._texture = null);
        }
        static OnContextLost() {
          for (const t of allRendererTexts) t.ReleaseTexture();
        }
        static GetAll() {
          return allRendererTexts.values();
        }
      };
    }
    var fillOrStrokeRect;
    var ptToPx;
    var getOffsetParam;
    {
      const C33 = self.C3;
      class WebGLRealTimeElapsedQuery {
        constructor(e) {
          this._gl = e.GetContext(), this._version = e.GetWebGLVersionNumber(), this._timerExt = e._GetDisjointTimerQueryExtension(), this._query = null, this._isActive = false, this._hasResult = false, this._result = 0, 1 === this._version ? this._query = this._timerExt["createQueryEXT"]() : this._query = this._gl["createQuery"]();
        }
        Release() {
          this._DeleteQueryObject(), this._gl = null, this._timerExt = null, this._hasResult = false;
        }
        _DeleteQueryObject() {
          this._query && (1 === this._version ? this._timerExt["deleteQueryEXT"](this._query) : this._gl["deleteQuery"](this._query), this._query = null);
        }
        BeginTimeElapsed() {
          if (this._isActive) throw new Error("query already active");
          1 === this._version ? this._timerExt["beginQueryEXT"](this._timerExt["TIME_ELAPSED_EXT"], this._query) : this._gl["beginQuery"](this._timerExt["TIME_ELAPSED_EXT"], this._query), this._isActive = true;
        }
        EndTimeElapsed() {
          if (!this._isActive) throw new Error("query not active");
          1 === this._version ? this._timerExt["endQueryEXT"](this._timerExt["TIME_ELAPSED_EXT"]) : this._gl["endQuery"](this._timerExt["TIME_ELAPSED_EXT"]), this._isActive = false;
        }
        CheckForResult() {
          if (!this._query || this._hasResult || this._isActive) return;
          let e = false;
          e = 1 === this._version ? this._timerExt["getQueryObjectEXT"](this._query, this._timerExt["QUERY_RESULT_AVAILABLE_EXT"]) : this._gl["getQueryParameter"](this._query, this._gl["QUERY_RESULT_AVAILABLE"]);
          const t = this._gl.getParameter(this._timerExt["GPU_DISJOINT_EXT"]);
          e && !t && (1 === this._version ? this._result = this._timerExt["getQueryObjectEXT"](this._query, this._timerExt["QUERY_RESULT_EXT"]) : this._result = this._gl["getQueryParameter"](this._query, this._gl["QUERY_RESULT"]), this._result /= 1e9, this._hasResult = true), (e || t) && this._DeleteQueryObject();
        }
        HasResult() {
          return this._hasResult;
        }
        GetResult() {
          if (!this._hasResult) throw new Error("no result available");
          return this._result;
        }
      }
      C33.Gfx.WebGLTimeElapsedQuery = class {
        constructor(e) {
          this._renderer = e, this._frameNumber = e.GetFrameNumber(), this._isActive = false, this._parentQuery = null, this._isNested = false, this._realQuery = null, this._queries = [];
        }
        Release() {
          for (const e of this._queries) e instanceof WebGLRealTimeElapsedQuery && e.Release();
          C33.clearArray(this._queries), this._parentQuery = null, this._realQuery = null, this._renderer = null;
        }
        BeginTimeElapsed() {
          if (this._isActive) throw new Error("query already active");
          const e = this._renderer._GetTimeQueryStack();
          e.length > 0 ? (this._isNested = true, this._parentQuery = e.at(-1), this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = false, this._parentQuery = null), this._isActive = true, e.push(this), this._StartReal();
        }
        EndTimeElapsed() {
          if (!this._isActive) throw new Error("query not active");
          if (this._renderer._GetTimeQueryStack().pop() !== this) throw new Error("can only end most nested query");
          this._isActive = false, this._EndReal(), this._parentQuery && (this._parentQuery._StartReal(), this._parentQuery = null);
        }
        _StartReal() {
          this._realQuery = C33.New(WebGLRealTimeElapsedQuery, this._renderer), this._queries.push(this._realQuery), this._realQuery.BeginTimeElapsed();
        }
        _EndReal() {
          this._realQuery.EndTimeElapsed(), this._realQuery = null;
        }
        CheckForResult() {
          for (const e of this._queries) e.CheckForResult();
        }
        IsNested() {
          return this._isNested;
        }
        HasResult() {
          return this._queries.every((e) => e.HasResult());
        }
        GetResult() {
          return this._queries.reduce((e, t) => e + t.GetResult(), 0);
        }
        GetFrameNumber() {
          return this._frameNumber;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.WebGLQueryResultBuffer = class {
        constructor(e, r2 = 1e3) {
          this._renderer = e, this._maxQueries = r2, this._buffer = [], this._renderer._AddQueryResultBuffer(this);
        }
        Release() {
          this.Clear(), this._renderer._RemoveQueryResultBuffer(this), this._renderer = null;
        }
        Clear() {
          for (const e of this._buffer) e.Release();
          C33.clearArray(this._buffer);
        }
        AddTimeElapsedQuery() {
          const e = new C33.Gfx.WebGLTimeElapsedQuery(this._renderer);
          if (this._buffer.push(e), this._buffer.length > this._maxQueries) {
            this._buffer.shift().Release();
          }
          return e;
        }
        CheckForResults(e) {
          for (const r2 of this._buffer) {
            if (r2.GetFrameNumber() >= e) return;
            if (r2.IsNested()) return;
            r2.CheckForResult();
          }
        }
        GetFrameRangeResultSum(e, r2) {
          if (r2 <= e) return NaN;
          let t = 0;
          for (const s2 of this._buffer) {
            if (s2.GetFrameNumber() >= r2) break;
            if (!(s2.GetFrameNumber() < e)) {
              if (!s2.HasResult()) return NaN;
              t += s2.GetResult();
            }
          }
          return t;
        }
        DeleteAllBeforeFrameNumber(e) {
          for (let r2 = 0, t = this._buffer.length; r2 < t; ++r2) {
            const t2 = this._buffer[r2];
            if (!(t2.GetFrameNumber() < e)) return void (r2 > 0 && this._buffer.splice(0, r2));
            t2.Release();
          }
        }
      };
    }
    {
      let CheckPendingPolls2 = function() {
        pollRafId = -1;
        for (const t of pendingPolls) t.checkFunc() && (t.resolve(), pendingPolls.delete(t));
        pendingPolls.size > 0 && (pollRafId = self.requestAnimationFrame(CheckPendingPolls2));
      };
      CheckPendingPolls = CheckPendingPolls2;
      const C33 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, vec42 = glMatrix.vec4, mat42 = glMatrix.mat4, DEFAULT_WEBGLRENDERER_OPTS = { powerPreference: "default", enableGpuProfiling: true, alpha: false, depth: false, canSampleDepth: false, maxWebGLVersion: 2, failIfMajorPerformanceCaveat: false }, VALID_POWER_PREFERENCES = /* @__PURE__ */ new Set(["default", "low-power", "high-performance"]), MAX_VERTICES = 65535, MAX_INDICES = 393210, MAX_POINTS = 8e3, LAST_POINT = 7996, defaultTexCoordsQuad = new C33.Quad(0, 0, 1, 0, 1, 1, 0, 1), tmpProjection = mat42.create(), tmpModelView = mat42.create(), tmpQuad = new C33.Quad(), tmpRect = new C33.Rect();
      let loseContextExtension = null;
      C33.isDebug && (self.debug_lose_webgl_context = function() {
        loseContextExtension ? loseContextExtension.loseContext() : console.warn("WEBGL_lose_context not supported");
      }, self.debug_restore_webgl_context = function() {
        loseContextExtension ? loseContextExtension.restoreContext() : console.warn("WEBGL_lose_context not supported");
      });
      const pendingPolls = /* @__PURE__ */ new Set();
      let pollRafId = -1;
      C33.Gfx.WebGLRenderer = class extends C33.Gfx.RendererBase {
        constructor(t, e) {
          if (super(e), e = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, e), !VALID_POWER_PREFERENCES.has(e.powerPreference)) throw new Error("invalid power preference");
          const r2 = { "alpha": !!e.alpha, "depth": false, "antialias": false, "powerPreference": e.powerPreference, "failIfMajorPerformanceCaveat": !!e.failIfMajorPerformanceCaveat };
          let i2 = null, s2 = 0;
          if (e.maxWebGLVersion >= 2 && (i2 = t.getContext("webgl2", r2), s2 = 2), i2 || (i2 = t.getContext("webgl", r2), s2 = 1), !i2) throw new Error("renderer-unavailable (could not get WebGL context)");
          this._gl = i2, this._attribs = i2.getContextAttributes(), this._versionString = i2.getParameter(i2.VERSION), this._version = s2, this._viewport = vec42.create(), this._didChangeTransform = false, this._bbProjectionMatrix = mat42.create(), this._usesDepthBuffer = !!e.depth, this._canSampleDepth = !(!e.depth || !e.canSampleDepth), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._depthBuffer = null, this._isAutoSizeDepthBuffer = true, this._depthBufferWidth = 0, this._depthBufferHeight = 0, this._vertexBuffer = null, this._texcoordBuffer = null, this._colorBuffer = null, this._indexBuffer = null, this._pointBuffer = null, this._isColorDataF16 = this._version >= 2 && void 0 !== globalThis["Float16Array"], this._vertexData = new Float32Array(196605), this._indexData = new Uint16Array(393210), this._texcoordData = new Float32Array(131070), this._colorData = this._isColorDataF16 ? new globalThis["Float16Array"](262140) : new Float32Array(262140), this._pointData = new Float32Array(32e3), this._vertexPtr = 0, this._indexPtr = 0, this._pointPtr = 0, this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._batch = [], this._batchPtr = 0, this._topOfBatch = 0, this._currentRenderTarget = null, this._lastPointZ = 0, this._batchState = C33.New(C33.Gfx.BatchState, this), this._lastColor = C33.New(C33.Color, 1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._lastSrcBlend = 0, this._lastDestBlend = 0, this._lastPointTexCoords = new C33.Rect(), this._lastScissorRect = C33.New(C33.Rect, 0, 0, -1, -1), this._coplanarMode = 0, this._lastCullFace = 0, this._lastFrontFaceWinding = 0, this._maxTextureSize = -1, this._minPointSize = 0, this._maxPointSize = 0, this._unmaskedVendor = "(unavailable)", this._unmaskedRenderer = "(unavailable)", this._extensions = [], this._isInitialisingAfterContextRestored = false, this._parallelShaderCompileExt = null, this._anisotropicExt = null, this._conservativeDepthExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._isGpuProfilingEnabled = !!e.enableGpuProfiling, this._timerExt = null, this._allQueryResultBuffers = /* @__PURE__ */ new Set(), this._timeQueryStack = [];
        }
        IsWebGL() {
          return true;
        }
        async InitState() {
          super.InitState();
          const t = this._gl;
          this._lastColor.setRgba(1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._vertexPtr = 0, this._indexPtr = 0, this._pointPtr = 0, C33.clearArray(this._batch), this._batchPtr = 0, this._topOfBatch = 0, this._lastProgram = null, this._currentRenderTarget = null, this._lastPointTexCoords.set(0, 0, 1, 1), this._lastPointZ = 0;
          const e = this._batchState;
          e.currentShader = null, e.currentFramebuffer = null, e.currentFramebufferNoDepth = null, e.clearColor.setRgba(0, 0, 0, 0), e.pointTexCoords.set(0, 0, 1, 1), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.BLEND), t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), this._lastSrcBlend = t.ONE, this._lastDestBlend = t.ONE_MINUS_SRC_ALPHA, this._InitBlendModes(t), t.cullFace(t.BACK), t.disable(t.CULL_FACE), this._lastCullFace = 0, t.frontFace(t.CW), this._lastFrontFaceWinding = 0, t.disable(t.STENCIL_TEST), t.disable(t.DITHER), this._usesDepthBuffer ? (t.enable(t.DEPTH_TEST), t.depthMask(true), t.depthFunc(t.LEQUAL)) : (t.disable(t.DEPTH_TEST), t.depthMask(false)), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._pointBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferData(t.ARRAY_BUFFER, this._pointData.byteLength, t.DYNAMIC_DRAW), this._vertexBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this._vertexData.byteLength, t.DYNAMIC_DRAW), this._texcoordBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferData(t.ARRAY_BUFFER, this._texcoordData.byteLength, t.DYNAMIC_DRAW), this._colorBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._colorBuffer), t.bufferData(t.ARRAY_BUFFER, this._colorData.byteLength, t.DYNAMIC_DRAW), this._indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indexData.byteLength, t.DYNAMIC_DRAW), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, null), this._maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE);
          const r2 = t.getParameter(t.ALIASED_POINT_SIZE_RANGE);
          this._minPointSize = r2[0], this._maxPointSize = r2[1], this._maxPointSize > 2048 && (this._maxPointSize = 2048), this._extensions = t.getSupportedExtensions();
          const i2 = t.getExtension("WEBGL_debug_renderer_info");
          if (i2 && (this._unmaskedVendor = t.getParameter(i2["UNMASKED_VENDOR_WEBGL"]), this._unmaskedRenderer = t.getParameter(i2["UNMASKED_RENDERER_WEBGL"])), this._parallelShaderCompileExt = t.getExtension("KHR_parallel_shader_compile"), this._version >= 2 && ("Chromium" !== C33.Platform.BrowserEngine || C33.Platform.BrowserVersionNumber >= 135) && (this._conservativeDepthExt = t.getExtension("EXT_conservative_depth")), C33.isDebug && (loseContextExtension = t.getExtension("WEBGL_lose_context")), this._isGpuProfilingEnabled && (1 === this.GetWebGLVersionNumber() ? this._timerExt = t.getExtension("EXT_disjoint_timer_query") : this._timerExt = t.getExtension("EXT_disjoint_timer_query_webgl2") || t.getExtension("EXT_disjoint_timer_query")), this._anisotropicExt = t.getExtension("EXT_texture_filter_anisotropic"), this._anisotropicExt ? this._maxAnisotropy = t.getParameter(this._anisotropicExt["MAX_TEXTURE_MAX_ANISOTROPY_EXT"]) : this._maxAnisotropy = 0, this.GetWebGLVersionNumber() < 2 && this._usesDepthBuffer && this._canSampleDepth && (this._depthTextureExt = t.getExtension("WEBGL_depth_texture"), !this._depthTextureExt)) throw new Error("no depth texture support");
          this.GetWebGLVersionNumber() < 2 && (this._fragDepthExt = t.getExtension("EXT_frag_depth"), this._stdDerivativesExt = t.getExtension("OES_standard_derivatives"), this._textureLodExt = t.getExtension("EXT_shader_texture_lod"));
          const s2 = C33.Gfx.WebGLShaderProgram, a2 = s2.GetDefaultVertexShaderSource(false);
          let h = s2.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth(), n = a2, o2 = s2.GetPointFragmentShaderSource_WebGL1_NoFragDepth(), l2 = s2.GetPointVertexShaderSource_WebGL1(), _ = s2.GetTilemapFragmentShaderSource_WebGL1_NoFragDepth(), u = s2.GetDefaultVertexShaderSource(true), d2 = false;
          this._usesDepthBuffer && (this.GetWebGLVersionNumber() < 2 ? this._fragDepthExt && (h = s2.GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT(), o2 = s2.GetPointFragmentShaderSource_WebGL1_FragDepthEXT(), _ = s2.GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT(), d2 = true) : (n = s2.GetDefaultVertexShaderSource_WebGL2(), h = s2.GetTextureFillFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), o2 = s2.GetPointFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), l2 = s2.GetPointVertexShaderSource_WebGL2(), _ = s2.GetTilemapFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), u = s2.GetDefaultVertexShaderSource_WebGL2(true)));
          const c2 = s2.GetTileRandomizationFragmentShaderSource(this.GetWebGLVersionNumber(), d2, this._stdDerivativesExt && this._textureLodExt, this._SupportsConservativeDepth()), f2 = this.GetWebGLVersionNumber() >= 2 ? s2.GetDefaultVertexShaderSource_WebGL2() : a2, p = [[h, n, "<default>"], [h, n, "<default-device-transform>"], [o2, l2, "<point>"], [s2.GetColorFillFragmentShaderSource(), a2, "<fill>"], [s2.GetLinearGradientFillFragmentShaderSource(), a2, "<lineargradient>"], [s2.GetPenumbraFillFragmentShaderSource(), a2, "<penumbra>"], [s2.GetHardEllipseFillFragmentShaderSource(), a2, "<hardellipse>"], [s2.GetHardEllipseOutlineFragmentShaderSource(), a2, "<hardellipseoutline>"], [s2.GetSmoothEllipseFillFragmentShaderSource(), a2, "<smoothellipse>"], [s2.GetSmoothEllipseOutlineFragmentShaderSource(), a2, "<smoothellipseoutline>"], [s2.GetSmoothLineFillFragmentShaderSource(), a2, "<smoothline>"], [_, u, "<tilemap>"], [c2, f2, "<tilerandomization>"]], x = await Promise.all(p.map((t2) => this.CreateShaderProgram({ src: t2[0], vertexSrc: t2[1], name: t2[2] })));
          this._spTextureFill = x[0], this._spDeviceTransformTextureFill = x[1], this._spPoints = x[2], this._spColorFill = x[3], this._spLinearGradientFill = x[4], this._spPenumbraFill = x[5], this._spHardEllipseFill = x[6], this._spHardEllipseOutline = x[7], this._spSmoothEllipseFill = x[8], this._spSmoothEllipseOutline = x[9], this._spSmoothLineFill = x[10], this._spTilemapFill = x[11], this._spTileRandomization = x[12], this.SetTextureFillMode();
        }
        async CreateShaderProgram(t) {
          const e = await C33.Gfx.WebGLShaderProgram.Create(this, t);
          return this._AddShaderProgram(e), e;
        }
        ResetLastProgram() {
          this._lastProgram = null;
        }
        SetSize(t, e, r2) {
          if (this._width === t && this._height === e && !r2) return;
          this.EndBatch();
          const i2 = this._gl, s2 = this._batchState;
          this._width = t, this._height = e, this._SetViewport(0, 0, t, e), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, t / e), this.SetProjectionMatrix(this._bbProjectionMatrix), this._spDeviceTransformTextureFill && (i2.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), this._lastProgram = this._spDeviceTransformTextureFill, this._batchState.currentShader = this._spDeviceTransformTextureFill), i2.bindTexture(i2.TEXTURE_2D, null), i2.activeTexture(i2.TEXTURE1), i2.bindTexture(i2.TEXTURE_2D, null), i2.activeTexture(i2.TEXTURE0), this._lastTexture0 = null, this._lastTexture1 = null, this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height), this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height), i2.bindFramebuffer(i2.FRAMEBUFFER, null), this._currentRenderTarget = null, s2.currentFramebuffer = null, s2.currentFramebufferNoDepth = null;
        }
        _SetDepthBufferSize(t, e) {
          const r2 = this._gl;
          this._depthBuffer && this._depthBufferWidth === t && this._depthBufferHeight === e || (this._canSampleDepth ? (this._depthBuffer && r2.deleteTexture(this._depthBuffer), this._depthBuffer = r2.createTexture(), r2.bindTexture(r2.TEXTURE_2D, this._depthBuffer), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.NEAREST), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.NEAREST), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, r2.CLAMP_TO_EDGE), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, r2.CLAMP_TO_EDGE), this.GetWebGLVersionNumber() >= 2 ? r2.texImage2D(r2.TEXTURE_2D, 0, r2.DEPTH24_STENCIL8, t, e, 0, r2.DEPTH_STENCIL, r2.UNSIGNED_INT_24_8, null) : this._depthTextureExt && r2.texImage2D(r2.TEXTURE_2D, 0, r2.DEPTH_STENCIL, t, e, 0, r2.DEPTH_STENCIL, this._depthTextureExt["UNSIGNED_INT_24_8_WEBGL"], null), r2.bindTexture(r2.TEXTURE_2D, null)) : (this._depthBuffer && r2.deleteRenderbuffer(this._depthBuffer), this._depthBuffer = r2.createRenderbuffer(), r2.bindRenderbuffer(r2.RENDERBUFFER, this._depthBuffer), r2.renderbufferStorage(r2.RENDERBUFFER, this._version >= 2 ? r2.DEPTH24_STENCIL8 : r2.DEPTH_STENCIL, t, e), r2.bindRenderbuffer(r2.RENDERBUFFER, null)), this._depthBufferWidth = t, this._depthBufferHeight = e);
        }
        SetFixedSizeDepthBuffer(t, e) {
          this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = false, this._SetDepthBufferSize(t, e));
        }
        SetAutoSizeDepthBuffer() {
          this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = true, this._SetDepthBufferSize(this._width, this._height));
        }
        _SetViewport(t, e, r2, i2) {
          const s2 = this._viewport;
          if (s2[0] === t && s2[1] === e && s2[2] === r2 && s2[3] === i2) return;
          this.PushBatch().InitSetViewport(t, e, r2, i2), vec42.set(s2, t, e, r2, i2), this._topOfBatch = 0;
        }
        SetFovY(t) {
          super.SetFovY(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
        }
        SetNearZ(t) {
          super.SetNearZ(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
        }
        SetFarZ(t) {
          super.SetFarZ(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
        }
        SetProjectionMatrix(t) {
          if (mat42.exactEquals(this._matP, t)) return;
          this.PushBatch().InitSetProjection(t), mat42.copy(this._matP, t), this._topOfBatch = 0, this._didChangeTransform = true;
        }
        SetDefaultRenderTargetProjectionState() {
          let t, e, r2;
          const i2 = this._currentRenderTarget;
          null === i2 ? (t = this._bbProjectionMatrix, e = this.GetWidth(), r2 = this.GetHeight()) : (t = i2.GetProjectionMatrix(), e = i2.GetWidth(), r2 = i2.GetHeight()), this.SetProjectionMatrix(t), this._SetViewport(0, 0, e, r2);
        }
        SetModelViewMatrix(t) {
          if (mat42.exactEquals(this._matMV, t)) return;
          this.PushBatch().InitSetModelView(t), mat42.copy(this._matMV, t), this._topOfBatch = 0, this._didChangeTransform = true;
        }
        ResetDidChangeTransformFlag() {
          this._didChangeTransform = false;
        }
        DidChangeTransform() {
          return this._didChangeTransform;
        }
        GetBatchState() {
          return this._batchState;
        }
        PushBatch() {
          const t = this._batch;
          return this._batchPtr === t.length && t.push(new C33.Gfx.WebGLBatchJob(this._batchState)), t[this._batchPtr++];
        }
        EndBatch() {
          0 !== this._batchPtr && (this.IsContextLost() || (this._WriteBuffers(), this._ExecuteBatch(), this._batchPtr = 0, this._vertexPtr = 0, this._indexPtr = 0, this._pointPtr = 0, this._topOfBatch = 0));
        }
        _WriteBuffers() {
          const t = this._gl;
          this._vertexPtr > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._vertexData.subarray(0, 3 * this._vertexPtr)), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, 2 * this._vertexPtr)), t.bindBuffer(t.ARRAY_BUFFER, this._colorBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._colorData.subarray(0, 4 * this._vertexPtr))), this._indexPtr > 0 && (t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, this._indexData.subarray(0, this._indexPtr))), this._pointPtr > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr)));
        }
        _ExecuteBatch() {
          const t = this._batch;
          for (let e = 0, r2 = this._batchPtr; e < r2; ++e) t[e].Run();
        }
        GetOpacity() {
          return this._lastColor.getA();
        }
        SetColorRgba(t, e, r2, i2) {
          const s2 = this._lastColor;
          s2.equalsRgba(t, e, r2, i2) || (s2.setRgba(t, e, r2, i2), this._currentStateGroup = null, 2 === this._topOfBatch && (this._topOfBatch = 0));
        }
        SetOpacity(t) {
          const e = this._lastColor;
          e.getA() !== t && (e.setA(t), this._currentStateGroup = null, 2 === this._topOfBatch && (this._topOfBatch = 0));
        }
        SetColor(t) {
          const e = this._lastColor;
          e.equals(t) || (e.set(t), this._currentStateGroup = null, 2 === this._topOfBatch && (this._topOfBatch = 0));
        }
        ResetColor() {
          this.SetColorRgba(1, 1, 1, 1);
        }
        GetColor() {
          return this._lastColor;
        }
        SetTexture(t) {
          if (t === this._lastTexture0) return;
          this.PushBatch().InitSetTexture(t), this._lastTexture0 = t, this._topOfBatch = 0;
        }
        _ResetLastTexture() {
          this._lastTexture0 = null;
        }
        SetBlendMode(t) {
          const e = this._GetBlendByIndex(t);
          this._SetBlend(e[0], e[1]);
        }
        SetNamedBlendMode(t) {
          const e = this.GetNamedBlend(t);
          this._SetBlend(e.srcBlend, e.destBlend);
        }
        _SetBlend(t, e) {
          if (t === this._lastSrcBlend && e === this._lastDestBlend) return;
          this.PushBatch().InitSetBlend(t, e), this._lastSrcBlend = t, this._lastDestBlend = e, this._topOfBatch = 0, this._currentStateGroup = null;
        }
        IsPremultipliedAlphaBlend() {
          return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA;
        }
        SetAlphaBlend() {
          this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
        }
        SetNoPremultiplyAlphaBlend() {
          this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
        }
        SetCullFaceMode(t) {
          if (this._lastCullFace === t) return;
          this.PushBatch().InitSetCullFaceMode(t), this._lastCullFace = t, this._topOfBatch = 0, this._currentStateGroup = null;
        }
        GetCullFaceMode() {
          return this._lastCullFace;
        }
        SetFrontFaceWinding(t) {
          if (this._lastFrontFaceWinding === t) return;
          this.PushBatch().InitSetFrontFaceWinding(t), this._lastFrontFaceWinding = t, this._topOfBatch = 0, this._currentStateGroup = null;
        }
        GetFrontFaceWinding() {
          return this._lastFrontFaceWinding;
        }
        SetCopyBlend() {
          this._SetBlend(this._gl.ONE, this._gl.ZERO);
        }
        Rect(t) {
          this.Rect2(t.getLeft(), t.getTop(), t.getRight(), t.getBottom());
        }
        Rect2(t, e, r2, i2) {
          this.Quad2(t, e, r2, e, r2, i2, t, i2);
        }
        _AddToDrawBatch(t, e) {
          if ((this._vertexPtr + t > 65535 || this._indexPtr + e > 393210) && this.EndBatch(), 1 === this._topOfBatch) this._batch[this._batchPtr - 1]._indexCount += e;
          else {
            this.PushBatch().InitDraw(2 * this._indexPtr, e), this._topOfBatch = 1;
          }
        }
        _AddIndicesForQuad() {
          const t = this._vertexPtr;
          let e = this._indexPtr;
          this._indexPtr += 6;
          const r2 = this._indexData;
          r2[e++] = t, r2[e++] = t + 1, r2[e++] = t + 2, r2[e++] = t, r2[e++] = t + 2, r2[e] = t + 3;
        }
        Quad(t) {
          this.Quad4(t, defaultTexCoordsQuad);
        }
        Quad2(t, e, r2, i2, s2, a2, h, n) {
          this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
          const o2 = this._vertexData, l2 = this._vertexPtr;
          this._vertexPtr += 4;
          let _ = 3 * l2;
          const u = this._baseZ + this._currentZ;
          o2[_++] = t, o2[_++] = e, o2[_++] = u, o2[_++] = r2, o2[_++] = i2, o2[_++] = u, o2[_++] = s2, o2[_++] = a2, o2[_++] = u, o2[_++] = h, o2[_++] = n, o2[_] = u, defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, 2 * l2), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * l2);
        }
        Quad3(t, e) {
          this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
          const r2 = this._vertexPtr;
          this._vertexPtr += 4, t.writeToTypedArray3D(this._vertexData, 3 * r2, this._baseZ + this._currentZ), e.writeAsQuadToTypedArray(this._texcoordData, 2 * r2), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * r2);
        }
        Quad4(t, e) {
          this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
          const r2 = this._vertexPtr;
          this._vertexPtr += 4, t.writeToTypedArray3D(this._vertexData, 3 * r2, this._baseZ + this._currentZ), e.writeToTypedArray(this._texcoordData, 2 * r2), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * r2);
        }
        Quad5(t, e, r2) {
          this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
          const i2 = this._vertexPtr;
          this._vertexPtr += 4, t.writeToTypedArray3D(this._vertexData, 3 * i2, this._baseZ + this._currentZ), e.writeToTypedArray(this._texcoordData, 2 * i2), this._colorData.set(r2, 4 * i2);
        }
        Quad3D(t, e, r2, i2, s2, a2, h, n, o2, l2, _, u, d2) {
          this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
          const c2 = this._vertexData, f2 = this._vertexPtr;
          this._vertexPtr += 4;
          let p = 3 * f2;
          const x = this._baseZ + this._currentZ;
          c2[p++] = t, c2[p++] = e, c2[p++] = x + r2, c2[p++] = i2, c2[p++] = s2, c2[p++] = x + a2, c2[p++] = h, c2[p++] = n, c2[p++] = x + o2, c2[p++] = l2, c2[p++] = _, c2[p] = x + u, d2.writeAsQuadToTypedArray(this._texcoordData, 2 * f2), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * f2);
        }
        Quad3D2(t, e, r2, i2, s2, a2, h, n, o2, l2, _, u, d2) {
          this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
          const c2 = this._vertexData, f2 = this._vertexPtr;
          this._vertexPtr += 4;
          let p = 3 * f2;
          const x = this._baseZ + this._currentZ;
          c2[p++] = t, c2[p++] = e, c2[p++] = x + r2, c2[p++] = i2, c2[p++] = s2, c2[p++] = x + a2, c2[p++] = h, c2[p++] = n, c2[p++] = x + o2, c2[p++] = l2, c2[p++] = _, c2[p] = x + u, d2.writeToTypedArray(this._texcoordData, 2 * f2), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * f2);
        }
        Quad3D3(t, e, r2, i2, s2, a2, h, n, o2, l2, _, u, d2, c2) {
          this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
          const f2 = this._vertexData, p = this._vertexPtr;
          this._vertexPtr += 4;
          let x = 3 * p;
          const E = this._baseZ + this._currentZ;
          f2[x++] = t, f2[x++] = e, f2[x++] = E + r2, f2[x++] = i2, f2[x++] = s2, f2[x++] = E + a2, f2[x++] = h, f2[x++] = n, f2[x++] = E + o2, f2[x++] = l2, f2[x++] = _, f2[x] = E + u, d2.writeToTypedArray(this._texcoordData, 2 * p), this._colorData.set(c2, 4 * p);
        }
        DrawMesh(t, e, r2, i2) {
          if (t.length % 3 != 0) throw new Error("vertex buffer length not multiple of 3");
          if (t.length > 196605) throw new Error(`too many vertices (${t.length / 3}, limit 65535)`);
          if (r2.length % 3 != 0) throw new Error("index buffer length not multiple of 3");
          if (r2.length > 393210) throw new Error(`too many indices (${r2.length}, limit 393210)`);
          this._AddToDrawBatch(t.length, r2.length);
          const s2 = this._vertexPtr;
          this._vertexData.set(t, 3 * s2), this._texcoordData.set(e, 2 * s2);
          const a2 = this._indexData;
          if (0 === s2) a2.set(r2, this._indexPtr);
          else {
            let t2 = this._indexPtr;
            for (let e2 = 0, i3 = r2.length; e2 < i3; ++e2) a2[t2++] = r2[e2] + s2;
          }
          const h = this._colorData;
          if (void 0 !== i2) h.set(i2, 4 * s2);
          else {
            const e2 = this._lastColor, r3 = e2.getR(), i3 = e2.getG(), a3 = e2.getB(), n = e2.getA();
            let o2 = 4 * s2;
            for (let e3 = 0, s3 = t.length; e3 < s3; ++e3) h[o2++] = r3, h[o2++] = i3, h[o2++] = a3, h[o2++] = n;
          }
          this._vertexPtr += t.length / 3, this._indexPtr += r2.length;
        }
        FullscreenQuad(t, e) {
          this.SetCurrentZ(0), mat42.copy(tmpProjection, this._matP), mat42.copy(tmpModelView, this._matMV), this.SetDefaultRenderTargetProjectionState();
          const [r2, i2] = this.GetRenderTargetSize(this._currentRenderTarget), s2 = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ(i2), 0, 0, 0, i2);
          if (this.SetModelViewMatrix(s2), "crop" === t && this._currentRenderTarget && e) {
            const t2 = this._width / 2, r3 = this._height / 2, i3 = e.GetWidth(), s3 = e.GetHeight(), a2 = this._currentRenderTarget.GetWidth(), h = this._currentRenderTarget.GetHeight(), n = Math.min(a2, i3), o2 = Math.min(h, s3), l2 = Math.max(s3 - h, 0), _ = Math.max(h - s3, 0);
            tmpRect.set(-t2, r3 - _, -t2 + n, r3 - o2 - _), tmpQuad.setFromRect(tmpRect), tmpRect.set(0, l2, n, o2 + l2), tmpRect.divide(i3, s3), this.Quad3(tmpQuad, tmpRect);
          } else {
            const t2 = r2 / 2, e2 = i2 / 2;
            this.Rect2(-t2, e2, t2, -e2);
          }
          this.SetProjectionMatrix(tmpProjection), this.SetModelViewMatrix(tmpModelView);
        }
        StartRenderingPoints(t) {
          if (this._lastPointTexCoords.equals(t)) return;
          this._lastPointTexCoords.copy(t);
          this.PushBatch().InitSetPointTexCoords(t), this._topOfBatch = 0;
        }
        FinishRenderingPoints() {
        }
        Point(t, e, r2, i2) {
          this._pointPtr >= 7996 && this.EndBatch();
          let s2 = this._pointPtr;
          const a2 = this._baseZ + this._currentZ;
          if (2 === this._topOfBatch && this._lastPointZ === a2) this._batch[this._batchPtr - 1]._indexCount++;
          else {
            this.PushBatch().InitPoints(s2, a2, this._lastColor), this._topOfBatch = 2, this._lastPointZ = a2;
          }
          const h = this._pointData;
          h[s2++] = t, h[s2++] = e, h[s2++] = r2, h[s2++] = i2, this._pointPtr = s2;
        }
        SetProgram(t) {
          if (this._lastProgram === t) return;
          this.PushBatch().InitSetProgram(t), this._lastProgram = t, this._topOfBatch = 0, this._currentStateGroup = null;
        }
        GetProgram() {
          return this._lastProgram;
        }
        SetDeviceTransformTextureFillMode() {
          this.SetProgram(this._spDeviceTransformTextureFill);
        }
        SetGradientColor(t) {
          this.PushBatch().InitSetGradientColor(t), this._topOfBatch = 0;
        }
        SetEllipseParams(t, e, r2 = 1) {
          this.PushBatch().InitSetEllipseParams(t, e, r2), this._topOfBatch = 0;
        }
        SetTilemapInfo(t, e, r2, i2, s2, a2, h) {
          if (this._lastProgram !== this._spTilemapFill) throw new Error("must set tilemap fill mode first");
          this.PushBatch().InitSetTilemapInfo(t, e, r2, i2, s2, a2, h), this._topOfBatch = 0;
        }
        SetTileRandomizationInfo(t, e, r2, i2, s2, a2, h) {
          if (this._lastProgram !== this._spTileRandomization) throw new Error("must set tile randomization mode first");
          this.PushBatch().InitSetTileRandomizationInfo(t, e, r2, i2, s2, a2, h), this._topOfBatch = 0;
        }
        SetProgramParameters(t, e, r2, i2, s2, a2, h, n, o2, l2, _) {
          const u = this._lastProgram;
          if (_ %= 10800, !u._hasAnyOptionalUniforms || u.AreOptionalUniformsAlreadySetInBatch(e, r2, i2, s2, a2, h, n, o2, l2, _)) return;
          const d2 = this.PushBatch();
          d2.InitSetProgramParameters(), u.SetOptionalUniformsInBatch(e, r2, i2, s2, a2, h, n, o2, l2, _);
          const c2 = d2._mat4param;
          c2[0] = a2, c2[1] = h, e.writeToTypedArray(c2, 2), c2[6] = o2, c2[7] = l2, r2.writeToTypedArray(c2, 12);
          const f2 = d2._colorParam;
          s2.writeToTypedArray(f2, 0);
          const p = f2[1];
          f2[1] = f2[3], f2[3] = p, i2.writeToTypedArray(d2._srcOriginRect, 0), d2._startIndex = _, d2._indexCount = n, u._uSamplerBack.IsUsed() ? d2._texParam = t ? t.GetTexture() : null : d2._texParam = null, this._topOfBatch = 0;
        }
        SetProgramCustomParameters(t) {
          const e = this._lastProgram;
          if (0 === t.length || e.AreCustomParametersAlreadySetInBatch(t)) return;
          const r2 = this.PushBatch();
          r2.InitSetProgramCustomParameters(), e.SetCustomParametersInBatch(t), C33.shallowAssignArray(r2._shaderParams, t), this._topOfBatch = 0;
        }
        ClearRgba(t, e, r2, i2) {
          this.PushBatch().InitClearSurface2(t, e, r2, i2), this._topOfBatch = 0;
        }
        Clear(t) {
          this.PushBatch().InitClearSurface(t), this._topOfBatch = 0;
        }
        Start() {
        }
        Finish() {
          super.Finish(), this._gl.flush();
        }
        ClearDepth() {
          if (!this._usesDepthBuffer || !this._currentRenderTarget || !this._currentRenderTarget.HasDepthBuffer()) return;
          this.PushBatch().InitClearDepth(this._isDepthEnabled), this._topOfBatch = 0;
        }
        SetDepthEnabled(t) {
          if (t = !!t, this._isDepthEnabled === t) return;
          if (!this._usesDepthBuffer) return;
          this._isDepthEnabled = t;
          this.PushBatch().InitSetDepthEnabled(t), this._topOfBatch = 0;
        }
        IsDepthEnabled() {
          return this._isDepthEnabled;
        }
        _GetDepthBuffer() {
          return this._depthBuffer;
        }
        _CanSampleDepth() {
          return this._canSampleDepth;
        }
        SetDepthSamplingEnabled(t) {
          if (t = !!t, !this._canSampleDepth) return;
          if (this._isDepthSamplingEnabled === t) return;
          if (t && this.IsDepthEnabled()) throw new Error("depth still enabled");
          this._isDepthSamplingEnabled = t;
          this.PushBatch().InitSetDepthSamplingEnabled(t), this._topOfBatch = 0;
        }
        SetScissorRect(t, e, r2, i2, s2 = 0) {
          if (t = Math.floor(t), e = Math.floor(e), r2 = Math.floor(r2), i2 = Math.floor(i2), this._lastScissorRect.equalsWH(t, e, r2, i2)) return;
          this._lastScissorRect.setWH(t, e, r2, i2);
          e = (s2 || this.GetRenderTargetSize(this.GetRenderTarget())[1]) - e - i2;
          this.PushBatch().InitSetScissor(true, t, e, r2, i2), this._topOfBatch = 0;
        }
        RemoveScissorRect() {
          if (-1 === this._lastScissorRect.getRight()) return;
          this._lastScissorRect.set(0, 0, -1, -1);
          this.PushBatch().InitSetScissor(false, 0, 0, 0, 0), this._topOfBatch = 0;
        }
        CheckForQueryResults() {
          for (const t of this._allQueryResultBuffers) t.CheckForResults(this._frameNumber);
        }
        IsContextLost() {
          return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored;
        }
        OnContextLost() {
          super.OnDeviceOrContextLost(), C33.Gfx.WebGLRendererTexture.OnContextLost(), C33.Gfx.WebGLRenderTarget.OnContextLost(), C33.Gfx.RendererText.OnContextLost();
          for (const t of this._allQueryResultBuffers) t.Clear();
          this._extensions = [], this._timerExt = null, this._parallelShaderCompileExt = null, this._conservativeDepthExt = null, this._anisotropicExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._unmaskedVendor = "(unavailable)", this._unmaskedRenderer = "(unavailable)", this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._depthBuffer = null;
          for (const t of this._stateGroups.values()) t.OnContextLost();
        }
        async OnContextRestored() {
          this._isInitialisingAfterContextRestored = true, await this.InitState(), this._isInitialisingAfterContextRestored = false;
          for (const t of this._stateGroups.values()) t.OnContextRestored(this);
          this.SetSize(this._width, this._height, true);
        }
        CreateStaticTexture(t, e) {
          if (this.IsContextLost()) throw new Error("context lost");
          this.EndBatch();
          const r2 = C33.New(C33.Gfx.WebGLRendererTexture, this);
          return r2._CreateStatic(t, e), r2;
        }
        async CreateStaticTextureAsync(t, e) {
          if (this.IsContextLost()) throw new Error("context lost");
          if (e = Object.assign({}, e), C33.Supports.ImageBitmapOptions) {
            let r2 = await createImageBitmap(t, { "premultiplyAlpha": "premultiply" });
            const i2 = e.wrapX && "clamp-to-edge" !== e.wrapX || e.wrapY && "clamp-to-edge" !== e.wrapY, s2 = C33.isPOT(r2.width) && C33.isPOT(r2.height);
            return this.SupportsNPOTTextures() || s2 || !i2 ? e.premultiplyAlpha = false : C33.Supports.ImageBitmapOptionsResize ? (r2 = await createImageBitmap(t, { "premultiplyAlpha": "premultiply", "resizeWidth": C33.nextHighestPowerOfTwo(r2.width), "resizeHeight": C33.nextHighestPowerOfTwo(r2.height) }), e.premultiplyAlpha = false) : r2 = await createImageBitmap(t, { "premultiplyAlpha": "none" }), await C33.Asyncify(() => this.CreateStaticTexture(r2, e));
          }
          if (t instanceof Blob) {
            if ("undefined" == typeof Image) throw new Error("texture upload variant not supported in worker");
            const e2 = await C33.BlobToImage(t);
            t = e2;
          }
          return await C33.Asyncify(() => this.CreateStaticTexture(t, e));
        }
        CreateDynamicTexture(t, e, r2) {
          this.EndBatch();
          const i2 = C33.New(C33.Gfx.WebGLRendererTexture, this);
          return i2._CreateDynamic(t, e, r2), i2;
        }
        UpdateTexture(t, e, r2) {
          this.EndBatch(), e._Update(t, r2);
        }
        DeleteTexture(t) {
          t && (t.SubtractReference(), t.GetReferenceCount() > 0 || (this.EndBatch(), t === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), t === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t._Delete()));
        }
        CreateRenderTarget(t) {
          let e = this._width, r2 = this._height, i2 = true;
          if (t && ("number" == typeof t.width && (e = Math.floor(t.width), i2 = false), "number" == typeof t.height && (r2 = Math.floor(t.height), i2 = false)), e <= 0 || r2 <= 0) throw new Error("invalid size");
          this.EndBatch();
          const s2 = C33.New(C33.Gfx.WebGLRenderTarget, this);
          return s2._Create(e, r2, Object.assign({ isDefaultSize: i2 }, t)), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, s2;
        }
        SetRenderTarget(t, e = true) {
          if (t === this._currentRenderTarget) return;
          t && t.IsDefaultSize() && t._Resize(this._width, this._height);
          this.PushBatch().InitSetRenderTarget(t), this._currentRenderTarget = t, this._topOfBatch = 0, e && this.SetDefaultRenderTargetProjectionState();
        }
        GetRenderTarget() {
          return this._currentRenderTarget;
        }
        GetRenderTargetSize(t) {
          return t ? [t.GetWidth(), t.GetHeight()] : [this._width, this._height];
        }
        CopyRenderTarget(t, e = "stretch") {
          if (this._version < 2 || this._currentRenderTarget && this._currentRenderTarget.GetMultisampling() > 0) this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(t, e);
          else {
            this.PushBatch().InitBlitFramebuffer(t, this._currentRenderTarget, e), this._topOfBatch = 0;
          }
        }
        DrawRenderTarget(t, e = "stretch") {
          const r2 = t.GetTexture();
          if (!r2) throw new Error("not a texture-backed render target");
          this.SetTexture(r2), this.FullscreenQuad(e, r2);
        }
        InvalidateRenderTarget(t) {
          if (this._version < 2) return;
          this.PushBatch().InitInvalidateFramebuffer(t._GetFramebuffer()), this._topOfBatch = 0;
        }
        DeleteRenderTarget(t) {
          this.SetRenderTarget(null), this.EndBatch();
          const e = t.GetTexture();
          e === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), e === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t._Delete();
        }
        async ReadBackRenderTargetToImageData(t, e, r2) {
          this.EndBatch();
          const i2 = this._currentRenderTarget;
          let s2, a2, h;
          t ? (s2 = t.GetWidth(), a2 = t.GetHeight(), h = t._GetFramebuffer()) : (s2 = this.GetWidth(), a2 = this.GetHeight(), h = null);
          let n = 0, o2 = 0, l2 = s2, _ = a2;
          if (r2) {
            n = C33.clamp(Math.floor(r2.getLeft()), 0, s2 - 1), o2 = C33.clamp(Math.floor(r2.getTop()), 0, a2 - 1);
            let t2 = r2.width();
            t2 = 0 === t2 ? s2 - n : C33.clamp(Math.floor(t2), 0, s2 - n);
            let e2 = r2.height();
            e2 = 0 === e2 ? a2 - o2 : C33.clamp(Math.floor(e2), 0, a2 - o2), l2 = t2, _ = e2, o2 = a2 - (o2 + _);
          }
          const u = this._gl;
          u.bindFramebuffer(u.FRAMEBUFFER, h);
          const d2 = () => {
            u.bindFramebuffer(u.FRAMEBUFFER, null), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, this.SetRenderTarget(i2);
          };
          let c2;
          if (!e && this.GetWebGLVersionNumber() >= 2) {
            u.bindFramebuffer(u.READ_FRAMEBUFFER, h);
            const t2 = u.createBuffer(), e2 = l2 * _ * 4, r3 = u["PIXEL_PACK_BUFFER"];
            u.bindBuffer(r3, t2), u.bufferData(r3, e2, u["STREAM_READ"]), u.readPixels(n, o2, l2, _, u.RGBA, u.UNSIGNED_BYTE, 0), u.bindFramebuffer(u.READ_FRAMEBUFFER, null), u.bindBuffer(r3, null), d2();
            const i3 = u["fenceSync"](u["SYNC_GPU_COMMANDS_COMPLETE"], 0);
            await this._WaitForObjectReady(() => u["getSyncParameter"](i3, u["SYNC_STATUS"]) === u["SIGNALED"]), u["deleteSync"](i3), c2 = new ImageData(l2, _), u.bindBuffer(r3, t2), u["getBufferSubData"](r3, 0, new Uint8Array(c2.data.buffer), 0, e2), u.bindBuffer(r3, null), u.deleteBuffer(t2);
          } else c2 = new ImageData(l2, _), u.readPixels(n, o2, l2, _, u.RGBA, u.UNSIGNED_BYTE, new Uint8Array(c2.data.buffer)), d2();
          return c2;
        }
        CoplanarStartStencilPass() {
          this.SetDepthEnabled(true);
          this.PushBatch().InitCoplanarStartStencilPass(), this._topOfBatch = 0, this._coplanarMode = 1;
        }
        CoplanarStartColorPass() {
          this.SetDepthEnabled(false);
          this.PushBatch().InitCoplanarStartColorPass(), this._topOfBatch = 0, this._coplanarMode = 2;
        }
        IsCoplanarColorPass() {
          return 2 === this._coplanarMode;
        }
        CoplanarRestoreStandardRendering() {
          this.SetDepthEnabled(true);
          this.PushBatch().InitCoplanarRestore(), this._topOfBatch = 0, this._coplanarMode = 0;
        }
        StartQuery(t) {
          if (!this.SupportsGPUProfiling()) return;
          this.PushBatch().InitStartQuery(t), this._topOfBatch = 0;
        }
        EndQuery(t) {
          if (!this.SupportsGPUProfiling()) return;
          this.PushBatch().InitEndQuery(t), this._topOfBatch = 0;
        }
        _WaitForObjectReady(t) {
          const e = new Promise((e2) => pendingPolls.add({ resolve: e2, checkFunc: t }));
          return -1 === pollRafId && (pollRafId = self.requestAnimationFrame(CheckPendingPolls2)), e;
        }
        GetEstimatedBackBufferMemoryUsage() {
          return this._width * this._height * (this._attribs["alpha"] ? 4 : 3);
        }
        GetEstimatedRenderBufferMemoryUsage() {
          let t = 0;
          for (const e of C33.Gfx.WebGLRenderTarget.allRenderTargets()) e.GetTexture() || (t += e.GetEstimatedMemoryUsage());
          return t;
        }
        GetEstimatedTextureMemoryUsage() {
          let t = 0;
          for (const e of C33.Gfx.WebGLRendererTexture.allTextures()) t += e.GetEstimatedMemoryUsage();
          return t;
        }
        GetWebGLVersionString() {
          return this._versionString;
        }
        GetWebGLVersionNumber() {
          return this._version;
        }
        IsColorDataF16() {
          return this._isColorDataF16;
        }
        GetDisplayName() {
          return "webgl" + this.GetWebGLVersionNumber();
        }
        SupportsNPOTTextures() {
          return this.GetWebGLVersionNumber() >= 2;
        }
        GetMaxTextureSize() {
          return this._maxTextureSize;
        }
        GetMinPointSize() {
          return this._minPointSize;
        }
        GetMaxPointSize() {
          return this._maxPointSize;
        }
        GetUnmaskedVendor() {
          return this._unmaskedVendor;
        }
        GetUnmaskedRenderer() {
          return this._unmaskedRenderer;
        }
        GetWebGLExtensionsAnalyticsString() {
          if (this.GetWebGLVersionNumber() >= 2) return "webgl2";
          {
            const t = [];
            return this._fragDepthExt && t.push("EXT_frag_depth"), this._stdDerivativesExt && t.push("OES_standard_derivatives"), this._textureLodExt && t.push("EXT_shader_texture_lod"), t.length > 0 ? "webgl1:" + t.join(",") : "webgl1:none";
          }
        }
        GetExtensions() {
          return this._extensions;
        }
        SupportsGPUProfiling() {
          return !!this._timerExt;
        }
        _GetDisjointTimerQueryExtension() {
          return this._timerExt;
        }
        _GetParallelShaderCompileExtension() {
          return this._parallelShaderCompileExt;
        }
        _SupportsConservativeDepth() {
          return !!this._conservativeDepthExt;
        }
        _GetAnisotropicExtension() {
          return this._anisotropicExt;
        }
        _GetMaxAnisotropy() {
          return this._maxAnisotropy;
        }
        _AddQueryResultBuffer(t) {
          this._allQueryResultBuffers.add(t);
        }
        _RemoveQueryResultBuffer(t) {
          this._allQueryResultBuffers.delete(t);
        }
        _GetTimeQueryStack() {
          return this._timeQueryStack;
        }
        GetContext() {
          return this._gl;
        }
        _InitBlendModes(t) {
          this._InitBlendModeData([["normal", t.ONE, t.ONE_MINUS_SRC_ALPHA], ["additive", t.ONE, t.ONE], ["xor", t.ONE, t.ONE_MINUS_SRC_ALPHA], ["copy", t.ONE, t.ZERO], ["destination-over", t.ONE_MINUS_DST_ALPHA, t.ONE], ["source-in", t.DST_ALPHA, t.ZERO], ["destination-in", t.ZERO, t.SRC_ALPHA], ["source-out", t.ONE_MINUS_DST_ALPHA, t.ZERO], ["destination-out", t.ZERO, t.ONE_MINUS_SRC_ALPHA], ["source-atop", t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], ["destination-atop", t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]]);
        }
        CreateWebGLText() {
          return this.CreateRendererText();
        }
      };
    }
    var CheckPendingPolls;
    {
      const C33 = self.C3, DEFAULT_CTOR_OPTS = { getDrawSize: null, getRenderTarget: null, releaseRenderTarget: null, getTime: null, redraw: null };
      C33.Gfx.EffectChainManager = class {
        constructor(e) {
          e = Object.assign({}, DEFAULT_CTOR_OPTS, e), this._cbGetDrawSize = e.getDrawSize, this._cbGetRenderTarget = e.getRenderTarget, this._cbReleaseRenderTarget = e.releaseRenderTarget, this._cbGetTime = e.getTime, this._cbRedraw = e.redraw, this._webgpuBackTexture = null, this._allEffectChains = /* @__PURE__ */ new Set();
        }
        _AddEffectChain(e) {
          this._allEffectChains.add(e);
        }
        _RemoveEffectChain(e) {
          this._allEffectChains.delete(e);
        }
        OnContextLost() {
          this._webgpuBackTexture = null;
          for (const e of this._allEffectChains) e.OnContextLost();
        }
        GetDrawSize(e) {
          return this._cbGetDrawSize ? this._cbGetDrawSize(e) : [e.GetWidth(), e.GetHeight()];
        }
        GetRenderTarget(e) {
          return this._cbGetRenderTarget(e);
        }
        ReleaseRenderTarget(e, t) {
          this._cbReleaseRenderTarget(e, t);
        }
        GetTime() {
          return this._cbGetTime();
        }
        Redraw(e) {
          this._cbRedraw(e);
        }
        _GetWebGPUBackTexture(e, t, r2) {
          return t = Math.floor(t), r2 = Math.floor(r2), !this._webgpuBackTexture || this._webgpuBackTexture.GetWidth() === t && this._webgpuBackTexture.GetHeight() === r2 || (e.DeleteTexture(this._webgpuBackTexture), this._webgpuBackTexture = null), null === this._webgpuBackTexture && (this._webgpuBackTexture = e.CreateStaticTexture(null, { width: t, height: r2, sampling: "nearest", mipMap: false })), this._webgpuBackTexture;
        }
      };
    }
    {
      const C33 = self.C3, assert = self.assert, glMatrix = self.glMatrix, mat42 = glMatrix.mat4, tempRect = C33.New(C33.Rect), tempRect2 = C33.New(C33.Rect), tempRect3 = C33.New(C33.Rect), tempRect4 = C33.New(C33.Rect), tempMat4a = mat42.create(), tempMat4b = mat42.create(), DEFAULT_CTOR_OPTS = { drawContent: null, getSourceTextureInfo: null, getShaderParameters: null, invalidateRenderTargets: false }, DEFAULT_BUILDSTEPS_OPTS = { indexMap: null, forcePreDraw: false, forcePostDraw: false, is3D: false, isSourceTextureRotated: false, isRotatedOrNegativeSizeInstance: false, useFullSurface: false };
      C33.Gfx.EffectChain = class {
        constructor(e, t) {
          t = Object.assign({}, DEFAULT_CTOR_OPTS, t), this._manager = e, this._cbDrawContent = t.drawContent, this._cbGetSourceTextureInfo = t.getSourceTextureInfo, this._cbGetShaderParameters = t.getShaderParameters, this._cbDrawContentHook = null, this._shaderProgramList = [], this._shaderProgramIndices = [], this._steps = [], this._needsRebuild = false, this._blendMode = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._didChangeTransform = false, this._depthEnabledAtStart = false, this._coplanarColorPassAtStart = false, this._canUseFastPath = false, this._useFullSurface = false, this._isSourceTextureRotated = false, this._numTempSurfacesRequired = 0, this._renderTargets = [null, null, null], this._invalidateRenderTargets = !!t.invalidateRenderTargets, this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._drawWidth = 0, this._drawHeight = 0, this._contentObject = null, this._contextObject = null, this._layoutRect = C33.New(C33.Rect), this._drawSurfaceRect = C33.New(C33.Rect), this._rcTexOriginal = C33.New(C33.Rect), this._rcTexBounce = C33.New(C33.Rect), this._rcTexDest = C33.New(C33.Rect), this._devicePixelRatio = 1, this._layerScale = 1, this._layerAngle = 0, this._time = 0, this._destRenderTarget = null, this._backTex = null, this._compositOffX = 0, this._compositOffY = 0, this._compositRtWidth = 0, this._compositRtHeight = 0, this._updateOwnProjection = false, this._projectionMatrix = mat42.create(), this._modelViewMatrix = mat42.create(), this._manager._AddEffectChain(this);
        }
        Release() {
          this._manager._RemoveEffectChain(this), C33.clearArray(this._steps), C33.clearArray(this._shaderProgramList), C33.clearArray(this._shaderProgramIndices), this._contentObject = null, this._contextObject = null, this._cbDrawContent = null, this._cbGetSourceTextureInfo = null, this._cbGetShaderParameters = null;
        }
        OnContextLost() {
          this._needsRebuild = true, C33.clearArray(this._steps), C33.clearArray(this._shaderProgramList), C33.clearArray(this._shaderProgramIndices);
        }
        NeedsRebuild() {
          return this._needsRebuild;
        }
        BuildSteps(e, t) {
          if (t = Object.assign({}, DEFAULT_BUILDSTEPS_OPTS, t), C33.clearArray(this._steps), this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._numTempSurfacesRequired = 0, this._isSourceTextureRotated = !!t.isSourceTextureRotated, this._useFullSurface = !!t.useFullSurface, this._needsRebuild = false, C33.shallowAssignArray(this._shaderProgramList, e), 0 === e.length) return;
          if (t.indexMap) {
            if (t.indexMap.length !== e.length) throw new Error("incorrect indexMap length");
            C33.shallowAssignArray(this._shaderProgramIndices, t.indexMap);
          } else {
            C33.clearArray(this._shaderProgramIndices);
            for (let t2 = 0, r3 = e.length; t2 < r3; ++t2) this._shaderProgramIndices.push(t2);
          }
          for (const t2 of e) this._boxExtendHorizontal += t2.GetBoxExtendHorizontal(), this._boxExtendVertical += t2.GetBoxExtendVertical(), t2.IsAnimated() && (this._isAnyShaderAnimated = true), t2.UsesDepth() && (this._isAnyShaderDepthSampling = true), t2.BlendsBackground() && (this._isAnyShaderBackgroundBlending = true), t2.UsesCrossSampling() && (this._isAnyShaderCrossSampling = true), t2.UsesIsSrcTexRotated() && (this._isAnyIsSrcTexRotated = true);
          this._useCopyTextureBackgroundSampling = this._ShouldUseCopyTextureBackgroundSampling(e[0].GetRenderer());
          const r2 = this._ShouldPreDraw(e[0], t), s2 = this._ShouldPostDraw(e.at(-1), t);
          if (1 === e.length && !r2 && !s2) return void (this._canUseFastPath = true);
          this._canUseFastPath = false;
          let i2 = 0;
          r2 && (this._numTempSurfacesRequired = 1, this._steps.push(C33.New(C33.Gfx.EffectChain.Step.PreDraw, this, -1, 1)), i2 = 1);
          for (let t2 = 0, a2 = e.length; t2 < a2; ++t2) if (0 !== t2 || r2) {
            let e2 = 1 === i2 ? 2 : 1;
            t2 !== a2 - 1 || s2 || (e2 = 0), this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, e2), this._steps.push(C33.New(C33.Gfx.EffectChain.Step.Bounce, this, i2, e2, t2)), i2 = e2;
          } else this._numTempSurfacesRequired = 1, this._steps.push(C33.New(C33.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, t2)), i2 = 1;
          s2 && this._steps.push(C33.New(C33.Gfx.EffectChain.Step.PostDraw, this, i2, 0));
        }
        _ShouldPreDraw(e, t) {
          return !!(t.forcePreDraw || e.MustPreDraw() || t.is3D && !e.Supports3DDirectRendering() || e.UsesDepth() && !this._useFullSurface || 0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical) || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() && (t.isRotatedOrNegativeSizeInstance || t.isSourceTextureRotated) || e.UsesAnySrcRectOrPixelSize() && t.isSourceTextureRotated : e.BlendsBackground() && !this._useCopyTextureBackgroundSampling && t.isRotatedOrNegativeSizeInstance);
        }
        _ShouldPostDraw(e, t) {
          return !!t.forcePostDraw || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() || e.UsesCrossSampling() : (e.BlendsBackground() || e.UsesCrossSampling()) && this._UseRenderTargetBackgroundSampling());
        }
        _ShouldUseCopyTextureBackgroundSampling(e) {
          return e.IsWebGPU() && this._isAnyShaderBackgroundBlending && !this._isAnyShaderCrossSampling;
        }
        Render(e, t, r2) {
          e.IsWebGPU() && null === t && (t = e.GetBackbufferRenderTarget()), this._destRenderTarget = t, this._contentObject = r2.contentObject || null, this._contextObject = r2.contextObject || null, this._blendMode = r2.blendMode || 0, this._devicePixelRatio = r2.devicePixelRatio || 1, this._layerScale = r2.layerScale || 1, this._layerAngle = r2.layerAngle || 0, this._time = "number" == typeof r2.time ? r2.time : this._manager.GetTime(), this._didChangeTransform = false, e.ResetDidChangeTransformFlag(), this._isAnyShaderAnimated && this._Redraw();
          let s2 = false;
          if (this._UseCopyTextureBackgroundSampling() && (this._CalculateDrawSizeAndRectangles(e, r2), s2 = true, this._backTex = this._manager._GetWebGPUBackTexture(e, this._drawWidth, this._drawHeight), tempRect.copy(this._drawSurfaceRect), tempRect.roundOuter(), e.IsWebGPU() && e._MaybeDoPendingClearRenderPass(this._destRenderTarget), e.CopyTextureToTexture(this._destRenderTarget.GetTexture(), this._backTex, tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height())), this._canUseFastPath) this._Render_FastPath(e, r2);
          else if (s2 || this._CalculateDrawSizeAndRectangles(e, r2), 0 !== this._rcTexOriginal.width() || 0 !== this._rcTexOriginal.height()) {
            e.SetAlphaBlend(), e.ResetCullState(), e.ResetColor(), e.SetBaseZ(0), e.SetCurrentZ(0), this._cbDrawContentHook = r2.drawContentHook || null, this._compositOffX = r2.compositOffX || 0, this._compositOffY = r2.compositOffY || 0, this._compositRtWidth = r2.compositRtWidth || 0, this._compositRtHeight = r2.compositRtHeight || 0, this._updateOwnProjection = !!r2.updateOwnProjection, this._OnBeforeStartEffectChain(e), this._renderTargets[0] = t, this._renderTargets[1] = this._numTempSurfacesRequired >= 1 ? this._GetRenderTarget() : null, this._renderTargets[2] = 2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
            for (const t2 of this._steps) {
              const r3 = this._GetRenderTargetForId(t2.GetSrcTargetId()), s3 = this._GetRenderTargetForId(t2.GetDestTargetId());
              e.IsWebGPU() ? t2.Run_WebGPU(e, r3, s3) : t2.Run_WebGL(e, r3, s3);
            }
            e.SetTexture(null), this._renderTargets[1] && this._ReleaseRenderTarget(this._renderTargets[1]), this._renderTargets[2] && this._ReleaseRenderTarget(this._renderTargets[2]), this._renderTargets.fill(null), this._OnAfterEndEffectChain(e), this._destRenderTarget = null, this._backTex = null, this._contentObject = null, this._contextObject = null, this._cbDrawContentHook = null;
          }
        }
        _CalculateDrawSizeAndRectangles(e, t) {
          const [r2, s2] = this._manager.GetDrawSize(e);
          this._SetDrawSize(e, r2, s2), this._CalculateRectangles(t);
        }
        _SetDrawSize(e, t, r2) {
          if (t <= 0 || r2 <= 0) throw new Error("invalid draw size");
          this._drawWidth === t && this._drawHeight === r2 || this._CalculateDeviceTransformMatrices(e, t, r2, 0, 0, this._projectionMatrix, this._modelViewMatrix), this._drawWidth = t, this._drawHeight = r2;
        }
        _CalculateDeviceTransformMatrices(e, t, r2, s2, i2, a2, n) {
          const h = t / 2 + s2, c2 = r2 / 2 + i2;
          e.CalculatePerspectiveMatrix(a2, t / r2);
          const o2 = e.CalculateLookAtModelView2(h, c2, e.GetDefaultCameraZ(r2), h, c2, 0, r2);
          mat42.copy(n, o2);
        }
        _CalculateRectangles(e) {
          this._layoutRect.copy(e.layoutRect), e.drawSurfaceRect ? this._drawSurfaceRect.copy(e.drawSurfaceRect) : this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight), this._rcTexOriginal.copy(this._drawSurfaceRect), this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);
          const t = this._layerScale * this._devicePixelRatio;
          this._drawSurfaceRect.inflate(this._boxExtendHorizontal * t, this._boxExtendVertical * t), this._rcTexDest.copy(this._drawSurfaceRect), this._rcTexDest.divide(this._drawWidth, this._drawHeight), this._drawSurfaceRect.clampBoth(0, 0, this._drawWidth, this._drawHeight), this._rcTexBounce.copy(this._drawSurfaceRect), this._rcTexBounce.divide(this._drawWidth, this._drawHeight);
        }
        _OnBeforeStartEffectChain(e) {
          if (this._depthEnabledAtStart = e.IsDepthEnabled(), this._coplanarColorPassAtStart = e.IsCoplanarColorPass(), this._useFullSurface) e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true);
          else {
            if (tempRect.copy(this._drawSurfaceRect), e.IsWebGL()) {
              const e2 = this._layerScale * this._devicePixelRatio;
              tempRect.inflate(Math.max(this._boxExtendHorizontal, 1) * e2, Math.max(this._boxExtendVertical, 1) * e2), tempRect.roundOuter(), tempRect.clamp(0, 0, this._drawWidth, this._drawHeight);
            } else tempRect.roundOuter();
            e.SetScissorRect(tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height(), this._drawHeight);
          }
        }
        _OnAfterEffectChainDrawContent(e) {
          e.ResetColor(), this._useFullSurface || (this._coplanarColorPassAtStart && e.CoplanarRestoreStandardRendering(), e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true)), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(true);
        }
        _OnAfterEndEffectChain(e) {
          e.SetDepthSamplingEnabled(false), this._coplanarColorPassAtStart && e.CoplanarStartColorPass(), e.SetDepthEnabled(this._depthEnabledAtStart), this._useFullSurface || e.RemoveScissorRect(), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(false), this._didChangeTransform = e.DidChangeTransform();
        }
        _ClampRcTexDest() {
          this._rcTexDest.clamp(0, 0, 1, 1);
        }
        _GetRenderTargetForId(e) {
          return e < 0 ? null : this._renderTargets[e];
        }
        _GetRenderTarget() {
          return this._manager.GetRenderTarget(this);
        }
        _GetDestRenderTarget() {
          return this._destRenderTarget;
        }
        _ReleaseRenderTarget(e) {
          this._manager.ReleaseRenderTarget(e, this);
        }
        _GetShaderProgramAt(e) {
          return this._shaderProgramList[e];
        }
        _DrawContent(e) {
          this._cbDrawContentHook ? this._cbDrawContentHook(this, e, () => this._cbDrawContent(e, this)) : this._cbDrawContent(e, this), this._canUseFastPath || this._OnAfterEffectChainDrawContent(e);
        }
        _IsRenderTargetSameSizeAndOffset(e) {
          if (this._useFullSurface) return true;
          if (0 !== this._compositOffX || 0 !== this._compositOffY || 0 !== this._compositRtWidth || 0 !== this._compositRtHeight) return false;
          const [t, r2] = e.GetRenderTargetSize(e.GetRenderTarget());
          return t === this._drawWidth && r2 === this._drawHeight;
        }
        _SetDeviceTransform(e, t) {
          let r2 = this._projectionMatrix, s2 = this._modelViewMatrix;
          if (t && !this._IsRenderTargetSameSizeAndOffset(e)) {
            let t2, i2;
            r2 = tempMat4a, s2 = tempMat4b, 0 !== this._compositRtWidth && 0 !== this._compositRtHeight ? [t2, i2] = [this._compositRtWidth, this._compositRtHeight] : [t2, i2] = e.GetRenderTargetSize(e.GetRenderTarget()), this._CalculateDeviceTransformMatrices(e, t2, i2, this._compositOffX, this._compositOffY, r2, s2), this._useFullSurface || e.RemoveScissorRect();
          }
          e.SetProjectionMatrix(r2), e.SetModelViewMatrix(s2);
        }
        _Redraw() {
          this._manager.Redraw(this);
        }
        _GetShaderParameters(e, t) {
          return this._cbGetShaderParameters(this._shaderProgramIndices[e], t);
        }
        _SetProgramParameters(e, t) {
          let r2 = this._rcTexDest, s2 = this._rcTexBounce, i2 = this._rcTexOriginal;
          e.IsWebGL() && (tempRect2.copy(r2), tempRect2.flipAround(1), r2 = tempRect2, tempRect3.copy(s2), tempRect3.flipAround(1), s2 = tempRect3, tempRect4.copy(i2), tempRect4.flipAround(1), i2 = tempRect4), this._DoSetProgramParameters(e, t, s2, i2, r2, 1 / this._drawWidth, 1 / this._drawHeight);
        }
        _SetFirstBounceProgramParameters(e, t) {
          let r2 = this._rcTexBounce, s2 = this._rcTexOriginal, i2 = 1 / this._drawWidth, a2 = 1 / this._drawHeight;
          if (this._cbGetSourceTextureInfo) {
            let { srcTexRect: e2, srcWidth: t2, srcHeight: n2 } = this._cbGetSourceTextureInfo(this._contentObject);
            e2 || (tempRect.set(0, 0, 0, 0), e2 = tempRect), t2 || (t2 = this._drawWidth), n2 || (n2 = this._drawHeight), r2 = e2, s2 = e2, i2 = 1 / t2, a2 = 1 / n2;
          } else e.IsWebGL() && (tempRect3.copy(r2), tempRect3.flipAround(1), r2 = tempRect3, tempRect4.copy(s2), tempRect4.flipAround(1), s2 = tempRect4);
          let n = this._rcTexDest;
          e.IsWebGL() && (n = tempRect2, n.copy(this._rcTexDest), n.flipAround(1)), this._DoSetProgramParameters(e, t, r2, s2, n, i2, a2), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);
        }
        _GetBackTex(e) {
          return this._isAnyShaderBackgroundBlending ? e.IsWebGPU() ? this._UseCopyTextureBackgroundSampling() ? this._backTex : this._destRenderTarget.GetTexture() : this._destRenderTarget : null;
        }
        _DoSetProgramParameters(e, t, r2, s2, i2, a2, n) {
          e.SetProgramParameters(this._GetBackTex(e), i2, r2, s2, this._layoutRect, a2, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(t, e));
        }
        _Render_FastPath(e, t) {
          const r2 = this._shaderProgramList[0], s2 = e.IsDepthEnabled(), i2 = r2.UsesDepth();
          i2 && (e.SetDepthEnabled(false), e.SetDepthSamplingEnabled(true), this._rcTexDest.set(0, 0, 1, 1), this._rcTexOriginal.set(0, 0, 1, 1)), e.SetProgram(r2), e.SetBlendMode(this._blendMode), e.SetRenderTarget(this._destRenderTarget), e.ResetCullState();
          let a2 = 0, n = 1;
          if (this._rcTexOriginal.set(0, 0, 1, 1), r2.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {
            const { srcTexRect: e2, srcWidth: t2, srcHeight: r3 } = this._cbGetSourceTextureInfo(this._contentObject);
            e2 && this._rcTexOriginal.copy(e2), a2 = Number.isFinite(t2) ? 1 / t2 : 0, n = Number.isFinite(r3) ? 1 / r3 : 0;
          } else {
            const [t2, r3] = this._manager.GetDrawSize(e);
            a2 = 1 / t2, n = 1 / r3;
          }
          t.layoutRect ? this._layoutRect.copy(t.layoutRect) : this._layoutRect.set(0, 0, 0, 0), e.SetProgramParameters(this._GetBackTex(e), this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, a2, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(0, e)), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated), e.SetBaseZ(0), this._DrawContent(e), i2 && (e.SetDepthSamplingEnabled(false), e.SetDepthEnabled(s2));
        }
        _UseCopyTextureBackgroundSampling() {
          return this._useCopyTextureBackgroundSampling;
        }
        _UseRenderTargetBackgroundSampling() {
          return !this._useCopyTextureBackgroundSampling;
        }
        IsAnyShaderBackgroundBlending() {
          return this._isAnyShaderBackgroundBlending;
        }
        CanSkipCalculatingDrawSurfaceRect() {
          return !!this._canUseFastPath && !this._UseCopyTextureBackgroundSampling();
        }
        UseFullSurface() {
          return this._useFullSurface;
        }
        GetContentObject() {
          return this._contentObject;
        }
        GetContextObject() {
          return this._contextObject;
        }
        _GetBlendMode() {
          return this._blendMode;
        }
        _UpdateOwnProjection() {
          return this._updateOwnProjection;
        }
        DidChangeTransform() {
          return this._didChangeTransform;
        }
        _GetDrawSurfaceRect() {
          return this._drawSurfaceRect;
        }
        _GetRcTexBounce() {
          return this._rcTexBounce;
        }
        _ShouldInvalidateRenderTargets() {
          return this._invalidateRenderTargets;
        }
        async DebugLogRenderTargetContents(e, t, r2) {
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.EffectChain.Step = class {
        constructor(t, e, r2, s2 = -1) {
          this._effectChain = t, this._srcTargetId = e, this._destTargetId = r2, this._index = s2;
        }
        GetEffectChain() {
          return this._effectChain;
        }
        GetSrcTargetId() {
          return this._srcTargetId;
        }
        GetDestTargetId() {
          return this._destTargetId;
        }
        GetIndex() {
          return this._index;
        }
        GetShaderProgram() {
          return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex());
        }
        Run_WebGL(t, e, r2) {
        }
        Run_WebGPU(t, e, r2) {
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.EffectChain.Step.PreDraw = class extends C33.Gfx.EffectChain.Step {
        constructor(e, t, a2, n) {
          super(e, t, a2, n);
        }
        Run_WebGL(e, t, a2) {
          const n = this.GetEffectChain();
          e.SetAlphaBlend(), e.ResetCullState(), e.SetTextureFillMode(), e.SetRenderTarget(a2, n._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), n._DrawContent(e), n._ClampRcTexDest();
        }
        Run_WebGPU(e, t, a2) {
          const n = this.GetEffectChain();
          e.SetAlphaBlend(), e.ResetCullState(), e.SetTextureFillMode(), e.SetRenderTarget(a2, false), e.ClearRgba(0, 0, 0, 0), n._DrawContent(e), n._ClampRcTexDest();
        }
      };
    }
    {
      const C33 = self.C3, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad);
      C33.Gfx.EffectChain.Step.PostDraw = class extends C33.Gfx.EffectChain.Step {
        constructor(e, t, r2, a2) {
          super(e, t, r2, a2);
        }
        Run_WebGL(e, t, r2) {
          const a2 = this.GetEffectChain();
          e.SetTextureFillMode(), e.SetRenderTarget(r2), a2._SetDeviceTransform(e, true), e.SetBlendMode(a2._GetBlendMode()), e.SetTexture(t.GetTexture()), tempQuad.setFromRect(a2._GetDrawSurfaceRect()), tempRect.copy(a2._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a2._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t);
        }
        Run_WebGPU(e, t, r2) {
          const a2 = this.GetEffectChain();
          e.SetTextureFillMode(), e.SetRenderTarget(r2, false), a2._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a2._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a2._SetDeviceTransform(e, true), tempQuad.setFromRect(a2._GetDrawSurfaceRect())), e.SetBackTexture(null), e.SetBlendMode(a2._GetBlendMode()), e.SetTexture(t.GetTexture()), a2.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a2._GetRcTexBounce());
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.EffectChain.Step.FirstBounce = class extends C33.Gfx.EffectChain.Step {
        constructor(e, t, r2, a2) {
          super(e, t, r2, a2);
        }
        Run_WebGL(e, t, r2) {
          const a2 = this.GetEffectChain();
          e.SetRenderTarget(r2, a2._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a2._SetFirstBounceProgramParameters(e, this.GetIndex()), a2._DrawContent(e), a2._ClampRcTexDest();
        }
        Run_WebGPU(e, t, r2) {
          const a2 = this.GetEffectChain();
          e.SetRenderTarget(r2, false), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a2._SetFirstBounceProgramParameters(e, this.GetIndex()), a2._DrawContent(e), a2._ClampRcTexDest();
        }
      };
    }
    {
      const C33 = self.C3, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad);
      C33.Gfx.EffectChain.Step.Bounce = class extends C33.Gfx.EffectChain.Step {
        constructor(e, t, r2, a2) {
          super(e, t, r2, a2);
        }
        Run_WebGL(e, t, r2) {
          const a2 = this.GetEffectChain();
          e.SetRenderTarget(r2);
          const d2 = 0 === this.GetDestTargetId();
          d2 ? e.SetBlendMode(a2._GetBlendMode()) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend()), e.SetProgram(this.GetShaderProgram()), a2._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t.GetTexture()), a2._SetDeviceTransform(e, d2), tempQuad.setFromRect(a2._GetDrawSurfaceRect()), tempRect.copy(a2._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a2._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t);
        }
        Run_WebGPU(e, t, r2) {
          const a2 = this.GetEffectChain();
          e.SetRenderTarget(r2, false);
          0 === this.GetDestTargetId() ? (e.SetBlendMode(a2._GetBlendMode()), e.SetBackTexture(null), a2._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a2._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a2._SetDeviceTransform(e, true), tempQuad.setFromRect(a2._GetDrawSurfaceRect()))) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), tempQuad.setFromRect(a2._GetRcTexBounce())), e.SetProgram(this.GetShaderProgram()), a2._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t.GetTexture()), a2.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a2._GetRcTexBounce());
        }
      };
    }
    {
      let SortZOrderList2 = function(e, t) {
        const r2 = e[0] - t[0];
        if (0 !== r2) return r2;
        return e[1] - t[1];
      };
      SortZOrderList = SortZOrderList2;
      const C33 = self.C3, C3X = self.C3X;
      let runtime = null;
      const keysDownByKey = /* @__PURE__ */ new Set();
      const tempZOrderList = [], tempInstances = [];
      let didWarnInAlertPolyfill = false, didWarnFpsDeprecated = false, didWarnCreateWorkerDeprecated = false;
      const VALID_FRAMERATE_MODES = /* @__PURE__ */ new Set(["vsync", "unlimited-tick", "unlimited-frame"]);
      self.IRuntime = class {
        constructor(e) {
          runtime = e, Object.defineProperties(this, { assets: { value: runtime.GetAssetManager().GetIAssetManager(), writable: false }, collisions: { value: runtime.GetCollisionEngine().GetICollisionEngine(), writable: false }, objects: { value: {}, writable: false }, globalVars: { value: {}, writable: false }, projectName: { value: runtime.GetProjectName(), writable: false }, projectVersion: { value: runtime.GetProjectVersion(), writable: false }, projectId: { value: runtime.GetAppId(), writable: false }, projectUniqueId: { value: runtime.GetProjectUniqueId(), writable: false }, exportDate: { value: new Date(runtime.GetExportTimestamp()), writable: false }, storage: { value: new self.IStorage(runtime), writable: false }, isInWorker: { value: runtime.IsInWorker(), writable: false }, viewportWidth: { value: runtime.GetOriginalViewportWidth(), writable: false }, viewportHeight: { value: runtime.GetOriginalViewportHeight(), writable: false }, sampling: { value: runtime.GetSampling(), writable: false }, isPixelRoundingEnabled: { value: runtime.IsPixelRoundingEnabled(), writable: false }, platformInfo: { value: new self.IPlatformInfo(e), writable: false }, sdk: { value: new self.ISDKUtils(e), writable: false } }), runtime.UserScriptDispatcher().addEventListener("keydown", (e2) => {
            keysDownByKey.has(e2["key"]) ? e2.stopPropagation() : keysDownByKey.add(e2["key"]);
          }), runtime.UserScriptDispatcher().addEventListener("keyup", (e2) => keysDownByKey.delete(e2["key"])), runtime.Dispatcher().addEventListener("window-blur", () => keysDownByKey.clear()), runtime.IsInWorker() && (self["alert"] = (e2) => (didWarnInAlertPolyfill || (didWarnInAlertPolyfill = true, console.warn("[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.")), this.alert(e2)));
        }
        _InitObjects(e) {
          Object.defineProperties(this.objects, e);
        }
        _InitGlobalVars(e) {
          Object.defineProperties(this.globalVars, e);
        }
        addEventListener(e, t) {
          runtime.UserScriptDispatcher().addEventListener(e, t);
        }
        removeEventListener(e, t) {
          runtime.UserScriptDispatcher().removeEventListener(e, t);
        }
        callFunction(e, ...t) {
          C3X.RequireString(e);
          const r2 = runtime.GetEventSheetManager(), n = r2.GetFunctionBlockByName(e);
          if (!n) throw new Error(`cannot find function name '${e}'`);
          if (!n.IsEnabled()) return n.GetDefaultReturnValue();
          if (t.length < n.GetFunctionParameterCount()) throw new Error(`not enough function parameters passed for '${e}' (${t.length} passed, ${n.GetFunctionParameterCount()} expected)`);
          const i2 = n.GetEventBlock();
          let a2 = i2.GetSolModifiersIncludingParents();
          const o2 = r2.GetCurrentEvent();
          if (o2) {
            a2 = a2.slice(0);
            const e2 = new Set(a2);
            for (const t2 of o2.GetSolModifiersIncludingParents()) e2.has(t2) || (a2.push(t2), e2.add(t2));
            for (const t2 of r2.GetDynamicSolModifiersSet()) e2.has(t2) || (a2.push(t2), e2.add(t2));
          }
          return i2.RunAsExpressionFunctionCall(a2, n.IsCopyPicked(), n.GetReturnType(), n.GetDefaultReturnValue(), ...t);
        }
        setReturnValue(e) {
          const t = runtime.GetEventStack().GetCurrentExpFuncStackFrame();
          if (!t) throw new Error("not in a function which returns a value");
          switch (t.GetFunctionReturnType()) {
            case 1:
              "number" == typeof e && t.SetFunctionReturnValue(e);
              break;
            case 2:
              "string" == typeof e && t.SetFunctionReturnValue(e);
              break;
            case 3:
              "number" != typeof e && "string" != typeof e || t.SetFunctionReturnValue(e);
          }
        }
        signal(e) {
          C3X.RequireString(e), runtime.GetEventSheetManager().Signal(e);
        }
        waitForSignal(e) {
          return C3X.RequireString(e), runtime.GetEventSheetManager().WaitForSignal(e);
        }
        getViewportSize() {
          return [runtime.GetOriginalViewportWidth(), runtime.GetOriginalViewportHeight()];
        }
        get isSuspended() {
          return runtime.IsSuspended();
        }
        get dt() {
          return runtime.GetDt();
        }
        get dtRaw() {
          return runtime.GetDtRaw();
        }
        get gameTime() {
          return runtime.GetGameTime();
        }
        get tickCount() {
          return runtime.GetTickCount();
        }
        get wallTime() {
          return runtime.GetWallTime();
        }
        get timeScale() {
          return runtime.GetTimeScale();
        }
        set timeScale(e) {
          C3X.RequireFiniteNumber(e), runtime.SetTimeScale(e);
        }
        get fps() {
          return didWarnFpsDeprecated || (console.warn("IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead."), didWarnFpsDeprecated = true), runtime.GetFramesPerSecond();
        }
        get framesPerSecond() {
          return runtime.GetFramesPerSecond();
        }
        get ticksPerSecond() {
          return runtime.GetTicksPerSecond();
        }
        get cpuUtilisation() {
          return runtime.GetMainThreadTime();
        }
        get gpuUtilisation() {
          return runtime.GetGPUUtilisation();
        }
        get framerateMode() {
          return runtime.GetFramerateMode();
        }
        set framerateMode(e) {
          if (!VALID_FRAMERATE_MODES.has(e)) throw new Error("invalid framerate mode");
          runtime._SetFramerateMode(e);
        }
        get minDt() {
          return runtime.GetMinDt();
        }
        set minDt(e) {
          C3X.RequireFiniteNumber(e), runtime.SetMinDt(e);
        }
        get maxDt() {
          return runtime.GetMaxDt();
        }
        set maxDt(e) {
          runtime.SetMaxDt(e);
        }
        get loadingProgress() {
          return runtime.GetAssetManager().GetLoadProgress();
        }
        get imageLoadingProgress() {
          return runtime.GetAssetManager().GetImageLoadProgress();
        }
        random() {
          return runtime.Random();
        }
        get layout() {
          const e = runtime.GetMainRunningLayout();
          if (!e) throw new Error("no layout is running - make sure a layout is loaded before accessing");
          return e.GetILayout();
        }
        getLayout(e) {
          const t = runtime.GetLayoutManager();
          let r2 = null;
          if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
          if (r2 = t.GetLayout(e), !r2) throw new Error("invalid layout");
          return r2.GetILayout();
        }
        getAllLayouts() {
          return runtime.GetLayoutManager().GetAllLayouts().map((e) => e.GetILayout());
        }
        goToLayout(e) {
          const t = runtime.GetLayoutManager();
          let r2 = null;
          if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
          if (r2 = t.GetLayout(e), !r2) throw new Error("invalid layout");
          t.IsPendingChangeMainLayout() || t.ChangeMainLayout(r2);
        }
        get keyboard() {
          const e = runtime._GetCommonScriptInterfaces().keyboard;
          if (!e) throw new Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
          return e;
        }
        get mouse() {
          const e = runtime._GetCommonScriptInterfaces().mouse;
          if (!e) throw new Error("runtime.mouse used but Mouse object missing - add it to your project first");
          return e;
        }
        get touch() {
          const e = runtime._GetCommonScriptInterfaces().touch;
          if (!e) throw new Error("runtime.touch used but Touch object missing - add it to your project first");
          return e;
        }
        get timelineController() {
          const e = runtime._GetCommonScriptInterfaces().timelineController;
          if (!e) throw new Error("runtime.timelineController used but Timeline Controller object missing - add it to your project first");
          return e;
        }
        get renderer() {
          return runtime.GetCanvasManager().GetIRenderer();
        }
        invokeDownload(e, t) {
          C3X.RequireString(e), C3X.RequireString(t), runtime.InvokeDownload(e, t);
        }
        getInstanceByUid(e) {
          C3X.RequireFiniteNumber(e);
          const t = runtime.GetInstanceByUID(e);
          return t ? t.GetInterfaceClass() : null;
        }
        sortZOrder(e, t) {
          C3X.RequireFunction(t);
          const r2 = runtime.GetCurrentLayout();
          for (const t2 of e) {
            const e2 = runtime._UnwrapIWorldInstance(t2), r3 = e2.GetWorldInfo();
            tempZOrderList.push([r3.GetLayer().GetIndex(), r3.GetZIndex()]), tempInstances.push(e2);
          }
          if (0 === tempZOrderList.length) return;
          tempZOrderList.sort(SortZOrderList2), tempInstances.sort((e2, r3) => t(e2.GetInterfaceClass(), r3.GetInterfaceClass()));
          let n = false;
          for (let e2 = 0, t2 = tempZOrderList.length; e2 < t2; ++e2) {
            const t3 = tempInstances[e2], i2 = r2.GetLayerByIndex(tempZOrderList[e2][0]), a2 = tempZOrderList[e2][1], o2 = i2._GetInstances();
            o2[a2] !== t3 && (o2[a2] = t3, t3.GetWorldInfo()._SetLayer(i2, true), i2.SetZIndicesChanged(t3), n = true);
          }
          n && runtime.UpdateRender(), C33.clearArray(tempZOrderList), C33.clearArray(tempInstances);
        }
        async createWorker(e, t) {
          didWarnCreateWorkerDeprecated || (console.warn("IRuntime.createWorker() is deprecated. All modern browsers now support nested workers so this method is no longer needed."), didWarnCreateWorkerDeprecated = true);
          const r2 = new MessageChannel(), n = r2.port1, i2 = r2.port2;
          return await runtime.PostComponentMessageToDOMAsync("runtime", "script-create-worker", { "url": e, "opts": t, "port2": i2 }, [i2]), n;
        }
        alert(e) {
          return runtime.PostComponentMessageToDOMAsync("runtime", "alert", { "message": e + (runtime.IsInWorker() ? " [via Web Worker]" : "") });
        }
        getHTMLLayer(e) {
          return C3X.RequireFiniteNumber(e), runtime._GetHTMLLayerWrapElement(e);
        }
        addLoadPromise(e) {
          runtime.AddLoadPromise(e);
        }
        async saveCanvasImage(e, t, r2) {
          C3X.RequireOptionalString(e), C3X.RequireOptionalNumber(t), C3X.RequireOptionalInstanceOf(r2, DOMRect), r2 || (r2 = new DOMRect(0, 0, 0, 0));
          const n = runtime.GetCanvasManager();
          if (!n) return;
          runtime.UpdateRender();
          const i2 = await n.SnapshotCanvas(e || "image/png", t, r2.x, r2.y, r2.width, r2.height);
          return await runtime.TriggerAsync(C33.Plugins.System.Cnds.OnCanvasSnapshot, null), i2;
        }
      };
    }
    var SortZOrderList;
    {
      const C33 = self.C3, C3X = self.C3X;
      let assetManager = null;
      self.IAssetManager = class {
        constructor(e) {
          assetManager = e, Object.defineProperties(this, { isWebMOpusSupported: { value: true, writable: false } });
        }
        loadImageAsset(e) {
          const t = self.IImageInfo._Unwrap(e);
          if (!t) throw new Error("invalid IImageInfo");
          t.LoadAsset(assetManager.GetRuntime());
        }
        fetchText(e) {
          return assetManager.FetchText(e);
        }
        fetchJson(e) {
          return assetManager.FetchJson(e);
        }
        fetchBlob(e) {
          return assetManager.FetchBlob(e);
        }
        fetchArrayBuffer(e) {
          return assetManager.FetchArrayBuffer(e);
        }
        getProjectFileUrl(e) {
          return assetManager.GetProjectFileUrl(e);
        }
        getMediaFileUrl(e) {
          return "flat" === assetManager.GetFileStructure() && C33.IsRelativeURL(e) && (e = e.toLowerCase()), assetManager.GetMediaFileUrl(e);
        }
        get mediaFolder() {
          return assetManager.GetMediaSubfolder();
        }
        async decodeWebMOpus(e, t) {
          throw new Error("decodeWebMOpus() is no longer supported - use Web Audio's decodeAudioData() directly as all supported platforms now support WebM Opus");
        }
        loadScripts(...e) {
          return assetManager.LoadScripts(...e);
        }
        compileWebAssembly(e) {
          return assetManager.CompileWebAssembly(e);
        }
        loadStyleSheet(e) {
          return assetManager.LoadStyleSheet(e);
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      let collisionEngine = null;
      self.ICollisionEngine = class {
        constructor(n) {
          collisionEngine = n, Object.defineProperties(this, { runtime: { value: collisionEngine.GetRuntime(), writable: false } });
        }
        testOverlap(n, e) {
          const l2 = collisionEngine.GetRuntime(), i2 = l2._UnwrapIWorldInstance(n), t = l2._UnwrapIWorldInstance(e);
          return collisionEngine.TestOverlap(i2, t);
        }
        testOverlapAny(n, e) {
          const l2 = collisionEngine.GetRuntime(), i2 = l2._UnwrapIWorldInstance(n);
          for (const n2 of e) {
            const e2 = l2._UnwrapIWorldInstance(n2);
            if (collisionEngine.TestOverlap(i2, e2)) return n2;
          }
          return null;
        }
        testOverlapSolid(n) {
          const e = collisionEngine.GetRuntime()._UnwrapIWorldInstance(n), l2 = collisionEngine.TestOverlapSolid(e);
          return l2 ? l2.GetInterfaceClass() : null;
        }
        setCollisionCellSize(n, e) {
          if (C3X.RequireFiniteNumber(n), C3X.RequireFiniteNumber(e), n = Math.floor(n), e = Math.floor(e), n <= 0 || e <= 0) throw new Error("invalid cell size");
          collisionEngine.SetCollisionCellSize(n, e);
        }
        getCollisionCellSize() {
          return collisionEngine.GetCollisionCellSize();
        }
        getCollisionCandidates(n, e) {
          const l2 = collisionEngine.GetRuntime();
          let i2;
          i2 = Array.isArray(n) ? n.map((n2) => l2._UnwrapIObjectClass(n2)) : [l2._UnwrapIObjectClass(n)];
          const t = C33.Rect.FromObject(e), o2 = [];
          return collisionEngine.GetObjectClassesCollisionCandidates(null, i2, t, o2), o2.map((n2) => n2.GetInterfaceClass());
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      let runtime = null;
      const osMap = /* @__PURE__ */ new Map([["Windows", "windows"], ["macOS", "macos"], ["Linux", "linux"], ["Chrome OS", "chrome-os"], ["Android", "android"], ["iOS", "ios"]]), browserMap = /* @__PURE__ */ new Map([["Chrome", "chrome"], ["Chromium", "chromium"], ["Edge", "edge"], ["Opera", "opera"], ["NW.js", "nwjs"], ["Firefox", "firefox"], ["Safari", "safari"]]), browserEngineMap = /* @__PURE__ */ new Map([["Chromium", "chromium"], ["Gecko", "gecko"], ["WebKit", "webkit"]]);
      self.IPlatformInfo = class {
        constructor(e) {
          runtime = e, Object.defineProperties(this, { isMobile: { value: C33.Platform.IsMobile, writable: false }, os: { value: osMap.get(C33.Platform.OS) || "unknown", writable: false }, osVersion: { value: C33.Platform.OSVersion, writable: false }, browser: { value: browserMap.get(C33.Platform.Browser) || "unknown", writable: false }, browserVersion: { value: C33.Platform.BrowserVersion, writable: false }, browserEngine: { value: browserEngineMap.get(C33.Platform.BrowserEngine) || "unknown", writable: false } });
        }
        get exportType() {
          let e = runtime.GetExportType();
          return runtime.IsNWjs() ? e = "nwjs" : runtime.IsWindowsWebView2() ? e = "windows-webview2" : "cordova" === e ? e = "Android" === C33.Platform.OS ? "cordova-android" : "cordova-ios" : "playable-ad-single-file" !== e && "playable-ad-zip" !== e || (e = "playable-ad"), e;
        }
        get renderer() {
          return runtime.GetCanvasManager().GetRendererString();
        }
        get rendererDetail() {
          return runtime.GetCanvasManager().GetRendererDetailString();
        }
        get canvasClientX() {
          return runtime.GetCanvasManager().GetCanvasClientX();
        }
        get canvasClientY() {
          return runtime.GetCanvasManager().GetCanvasClientY();
        }
        get canvasCssWidth() {
          return runtime.GetCanvasManager().GetCssWidth();
        }
        get canvasCssHeight() {
          return runtime.GetCanvasManager().GetCssHeight();
        }
        get canvasDeviceWidth() {
          return runtime.GetCanvasManager().GetDeviceWidth();
        }
        get canvasDeviceHeight() {
          return runtime.GetCanvasManager().GetDeviceHeight();
        }
        get devicePixelRatio() {
          return runtime.GetDevicePixelRatio();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.IStorage = class {
        constructor(e) {
          this._storage = e._GetProjectStorage();
        }
        getItem(e) {
          return C3X.RequireString(e), this._storage.getItem(e);
        }
        setItem(e, t) {
          return C3X.RequireString(e), this._storage.setItem(e, t);
        }
        removeItem(e) {
          return C3X.RequireString(e), this._storage.removeItem(e);
        }
        clear() {
          return this._storage.clear();
        }
        keys() {
          return this._storage.keys();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.IPlugin = class {
        #e;
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken);
          this.#e = e, Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, id: { value: e.GetID(), writable: false }, isSingleGlobal: { value: e.IsSingleGlobal(), writable: false }, isWorldType: { value: e.IsWorldType(), writable: false }, isHTMLElementType: { value: e.IsHTMLElementType(), writable: false }, isRotatable: { value: e.IsRotatable(), writable: false }, hasEffects: { value: e.HasEffects(), writable: false }, is3d: { value: e.Is3D(), writable: false }, supportsHierarchies: { value: e.SupportsSceneGraph(), writable: false }, supportsMesh: { value: e.SupportsMesh(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
        }
        static getByConstructor(e) {
          if (!e) return null;
          const t = C33.AddonManager.GetPluginByConstructorFunction(e);
          return t ? t.GetIPlugin() : null;
        }
        getSingleGlobalObjectType() {
          return this.#e.GetSingleGlobalObjectClass().GetIObjectClass();
        }
        getSingleGlobalInstance() {
          return this.#e.GetSingleGlobalInstance().GetInterfaceClass();
        }
      };
    }
    {
      const C33 = globalThis.C3, C3X = globalThis.C3X, internalApiToken = C33._GetInternalAPIToken();
      globalThis.IObjectClass = class {
        #e;
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken);
          this.#e = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
        }
        addEventListener(e, t) {
          C3X.RequireString(e), C3X.RequireFunction(t), this.#e.UserScriptDispatcher().addEventListener(e, t);
        }
        removeEventListener(e, t) {
          C3X.RequireString(e), C3X.RequireFunction(t), this.#e.UserScriptDispatcher().removeEventListener(e, t);
        }
        getAllInstances() {
          return [...this.instances()];
        }
        getFirstInstance() {
          return C33.first(this.instances());
        }
        getPickedInstances() {
          return [...this.pickedInstances()];
        }
        getFirstPickedInstance() {
          return C33.first(this.pickedInstances());
        }
        getPairedInstance(e) {
          const t = this.#e, n = t.GetRuntime()._UnwrapIInstance(e), i2 = t.GetPairedInstance(n);
          return i2 ? i2.GetInterfaceClass() : null;
        }
        *instances() {
          for (const e of this.#e.instancesIncludingPendingCreate()) yield e.GetInterfaceClass();
        }
        *pickedInstances() {
          for (const e of this.#e.GetCurrentSol().GetInstances()) yield e.GetInterfaceClass();
        }
      };
    }
    {
      const C33 = globalThis.C3, C3X = globalThis.C3X, internalApiToken = C33._GetInternalAPIToken();
      globalThis.IObjectType = class extends globalThis.IObjectClass {
        #e;
        constructor() {
          super();
          const e = C33.AddonManager._GetInitObject2(internalApiToken);
          this.#e = e;
        }
        setInstanceClass(e) {
          C3X.RequireFunction(e);
          const t = this.#e;
          if (t.GetInstanceCount() > 0) throw new Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
          t._SetUserScriptInstanceClass(e);
        }
        createInstance(e, t, n, a2, s2) {
          if (C3X.RequireNumber(t), C3X.RequireNumber(n), "number" != typeof e && "string" != typeof e) throw new TypeError("invalid layer parameter");
          const r2 = this.#e, i2 = r2.GetRuntime(), l2 = i2.GetMainRunningLayout().GetLayer(e);
          if (!l2) throw new Error("invalid layer");
          const c2 = i2.CreateInstance(r2, l2, t, n, a2, s2);
          a2 && l2.SortAndAddInstancesByZIndex(c2);
          const o2 = i2.GetEventSheetManager();
          return o2.BlockFlushingInstances(true), c2._TriggerOnCreatedOnSelfAndRelated(), o2.BlockFlushingInstances(false), o2.IsInEventEngine() || i2.GetLayoutManager().IsEndingLayout() || i2.FlushPendingInstances(), c2.GetInterfaceClass();
        }
        getAllFamilies() {
          return this.#e.GetFamilies().map((e) => e.GetIObjectClass());
        }
        *families() {
          for (const e of this.#e.GetFamilies()) yield e.GetIObjectClass();
        }
        isInFamily(e) {
          return C3X.RequireInstanceOf(e, globalThis.IFamily), e.hasObjectType(this);
        }
      };
    }
    {
      const C33 = globalThis.C3, C3X = globalThis.C3X, IObjectType = globalThis.IObjectType, internalApiToken = C33._GetInternalAPIToken();
      globalThis.IFamily = class extends globalThis.IObjectClass {
        #e;
        constructor() {
          super();
          const e = C33.AddonManager._GetInitObject2(internalApiToken);
          this.#e = e;
        }
        getAllObjectTypes() {
          return this.#e.GetFamilyMembers().map((e) => e.GetIObjectClass());
        }
        *objectTypes() {
          for (const e of this.#e.GetFamilyMembers()) yield e.GetIObjectClass();
        }
        hasObjectType(e) {
          C3X.RequireInstanceOf(e, IObjectType);
          const t = this.#e, s2 = t.GetRuntime()._UnwrapIObjectClass(e);
          return t.FamilyHasMember(s2);
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, VALID_WHERE_STRINGS = ["above", "below", "top-sublayer", "bottom-sublayer"];
      self.ILayout = class {
        #e;
        constructor(e) {
          this.#e = e;
          const t = [], r2 = e.GetEffectList(), i2 = r2.GetAllEffectTypes().length;
          for (let e2 = 0; e2 < i2; ++e2) t.push(new self.IEffectInstance(r2, e2));
          Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, name: { value: e.GetName(), writable: false }, index: { value: e.GetIndex(), writable: false }, effects: { value: t, writable: false } });
        }
        addEventListener(e, t) {
          C3X.RequireString(e), C3X.RequireFunction(t), this.#e.UserScriptDispatcher().addEventListener(e, t);
        }
        removeEventListener(e, t) {
          C3X.RequireString(e), C3X.RequireFunction(t), this.#e.UserScriptDispatcher().removeEventListener(e, t);
        }
        get width() {
          return this.#e.GetWidth();
        }
        set width(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetWidth(e);
        }
        get height() {
          return this.#e.GetHeight();
        }
        set height(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetHeight(e);
        }
        setSize(e, t) {
          C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t);
          const r2 = this.#e;
          r2.SetWidth(e), r2.SetHeight(t);
        }
        getSize() {
          const e = this.#e;
          return [e.GetWidth(), e.GetHeight()];
        }
        set scale(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetScale(e);
        }
        get scale() {
          return this.#e.GetScale();
        }
        set angle(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetAngle(e);
        }
        get angle() {
          return this.#e.GetAngle();
        }
        set scrollX(e) {
          C3X.RequireNumber(e), this.#e.SetScrollX(e);
        }
        get scrollX() {
          return this.#e.GetScrollX();
        }
        set scrollY(e) {
          C3X.RequireNumber(e), this.#e.SetScrollY(e);
        }
        get scrollY() {
          return this.#e.GetScrollY();
        }
        scrollTo(e, t) {
          C3X.RequireNumber(e), C3X.RequireNumber(t);
          const r2 = this.#e;
          r2.SetScrollX(e), r2.SetScrollY(t);
        }
        getScrollPosition() {
          const e = this.#e;
          return [e.GetScrollX(), e.GetScrollY()];
        }
        get isUnboundedScrolling() {
          return this.#e.IsUnboundedScrolling();
        }
        getLayer(e) {
          const t = this.#e;
          let r2 = null;
          if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
          return r2 = t.GetLayer(e), r2 ? r2.GetILayer() : null;
        }
        getAllLayers() {
          return this.#e.GetLayers().map((e) => e.GetILayer());
        }
        *allLayers() {
          for (const e of this.#e.allLayers()) yield e.GetILayer();
        }
        addLayer(e, t, r2) {
          const i2 = this.#e, n = self.ILayer;
          C3X.RequireString(e), C3X.RequireOptionalInstanceOf(t, n);
          const s2 = t ? i2.GetRuntime()._UnwrapScriptInterface(t) : null, a2 = VALID_WHERE_STRINGS.indexOf(r2);
          if (a2 < 0) throw new Error("invalid location");
          i2.AddLayer(e, s2, a2);
        }
        moveLayer(e, t, r2) {
          const i2 = this.#e, n = i2.GetRuntime(), s2 = self.ILayer;
          C3X.RequireInstanceOf(e, s2);
          const a2 = n._UnwrapScriptInterface(e);
          if (!a2) throw new Error("invalid layer");
          C3X.RequireOptionalInstanceOf(t, s2);
          const o2 = t ? n._UnwrapScriptInterface(t) : null, l2 = VALID_WHERE_STRINGS.indexOf(r2);
          if (l2 < 0) throw new Error("invalid location");
          i2.MoveLayer(a2, o2, l2);
        }
        removeLayer(e) {
          const t = this.#e, r2 = self.ILayer;
          C3X.RequireInstanceOf(e, r2);
          const i2 = t.GetRuntime()._UnwrapScriptInterface(e);
          if (!i2) throw new Error("invalid layer");
          const n = i2.GetRuntime();
          t.RemoveLayer(i2), n.GetEventSheetManager().IsInEventEngine() || n.FlushPendingInstances();
        }
        removeAllDynamicLayers() {
          const e = this.#e, t = e.GetRuntime();
          e.RemoveAllDynamicLayers(), t.GetEventSheetManager().IsInEventEngine() || t.FlushPendingInstances();
        }
        setVanishingPoint(e, t) {
          C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t), this.#e.SetVanishingPointXY(e, t);
        }
        getVanishingPoint() {
          return this.#e.GetVanishingPoint();
        }
        set projection(e) {
          C3X.RequireString(e);
          const t = this.#e;
          if ("perspective" === e) t.SetPerspectiveProjection();
          else {
            if ("orthographic" !== e) throw new Error("invalid projection");
            t.SetOrthographicProjection();
          }
        }
        get projection() {
          return this.#e.IsOrthographicProjection() ? "orthographic" : "perspective";
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), VALID_RENDERING_MODES = /* @__PURE__ */ new Set(["2d", "3d"]), tempColor = C33.New(C33.Color);
      self.ILayer = class {
        #e;
        constructor(e) {
          this.#e = e;
          const t = [], r2 = e.GetEffectList(), i2 = r2.GetAllEffectTypes().length;
          for (let e2 = 0; e2 < i2; ++e2) t.push(new self.IEffectInstance(r2, e2));
          Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, name: { value: e.GetName(), writable: false }, layout: { value: e.GetLayout().GetILayout(), writable: false }, effects: { value: t, writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
        }
        addEventListener(e, t) {
          this.#e.UserScriptDispatcher().addEventListener(e, t);
        }
        removeEventListener(e, t) {
          this.#e.UserScriptDispatcher().removeEventListener(e, t);
        }
        get parentLayer() {
          const e = this.#e.GetParentLayer();
          return e ? e.GetILayer() : null;
        }
        *parentLayers() {
          for (const e of this.#e.parentLayers()) yield e.GetILayer();
        }
        *subLayers() {
          for (const e of this.#e.GetSubLayers()) yield e.GetILayer();
        }
        *allSubLayers() {
          for (const e of this.#e.GetSubLayers()) for (const t of e.selfAndAllSubLayers()) yield t.GetILayer();
        }
        get index() {
          return this.#e.GetIndex();
        }
        get isVisible() {
          return this.#e._IsVisibleFlagSet();
        }
        set isVisible(e) {
          this.#e.SetVisible(e);
        }
        get isSelfAndParentsVisible() {
          return this.#e.IsVisible();
        }
        get isInteractive() {
          return this.#e.IsInteractive();
        }
        set isInteractive(e) {
          this.#e.SetInteractive(e);
        }
        get isHTMLElementsLayer() {
          return this.#e.IsHTMLElementsLayer();
        }
        set isHTMLElementsLayer(e) {
          this.#e.SetIsHTMLElementsLayer(!!e);
        }
        get isSelfAndParentsInteractive() {
          return this.#e.IsSelfAndParentsInteractive();
        }
        get opacity() {
          return this.#e.GetOpacity();
        }
        set opacity(e) {
          e = C33.clamp(+e, 0, 1), isNaN(e) || this.#e.SetOpacity(e);
        }
        set scale(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetOwnScale(e);
        }
        get scale() {
          return this.#e.GetOwnScale();
        }
        set scaleRate(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetScaleRate(e);
        }
        get scaleRate() {
          return this.#e.GetScaleRate();
        }
        set angle(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetAngle(e);
        }
        get angle() {
          return this.#e.GetOwnAngle();
        }
        set parallaxX(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetParallaxX(e);
        }
        get parallaxX() {
          return this.#e.GetParallaxX();
        }
        set parallaxY(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetParallaxY(e);
        }
        get parallaxY() {
          return this.#e.GetParallaxY();
        }
        set zElevation(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetZElevation(e);
        }
        get zElevation() {
          return this.#e.GetZElevation();
        }
        set renderingMode(e) {
          if (!VALID_RENDERING_MODES.has(e)) throw TypeError("invalid rendering mode");
          this.#e.SetRenderAs3D("3d" === e);
        }
        get renderingMode() {
          return this.#e.IsRenderAs3D() ? "3d" : "2d";
        }
        set isTransparent(e) {
          this.#e.SetTransparent(e);
        }
        get isTransparent() {
          return this.#e.IsTransparent();
        }
        set isForceOwnTexture(e) {
          this.#e.SetForceOwnTexture(e);
        }
        get isForceOwnTexture() {
          return this.#e.IsForceOwnTexture();
        }
        set blendMode(e) {
          C3X.RequireString(e);
          const t = BLEND_MODE_TO_INDEX.get(e);
          if ("number" != typeof t) throw new Error("invalid blend mode");
          this.#e.SetBlendMode(t);
        }
        get blendMode() {
          return INDEX_TO_BLEND_MODE.get(this.#e.GetBlendMode());
        }
        set backgroundColor(e) {
          if (C3X.RequireArray(e), e.length < 3) throw new Error("expected 3 elements");
          tempColor.setRgb(e[0], e[1], e[2]);
          const t = this.#e, r2 = t.GetBackgroundColor();
          r2.equalsIgnoringAlpha(tempColor) || (r2.copyRgb(tempColor), t.GetRuntime().UpdateRender());
        }
        get backgroundColor() {
          const e = this.#e.GetBackgroundColor();
          return [e.getR(), e.getG(), e.getB()];
        }
        set scrollX(e) {
          C3X.RequireNumber(e);
          const t = this.#e;
          t.SetOwnScrollPositionEnabled(true), t.SetScrollX(e);
        }
        get scrollX() {
          return this.#e.GetScrollX();
        }
        set scrollY(e) {
          C3X.RequireNumber(e);
          const t = this.#e;
          t.SetOwnScrollPositionEnabled(true), t.SetScrollY(e);
        }
        get scrollY() {
          return this.#e.GetScrollY();
        }
        scrollTo(e, t) {
          C3X.RequireNumber(e), C3X.RequireNumber(t);
          const r2 = this.#e;
          r2.SetOwnScrollPositionEnabled(true), r2.SetScrollX(e), r2.SetScrollY(t);
        }
        getScrollPosition() {
          const e = this.#e;
          return [e.GetScrollX(), e.GetScrollY()];
        }
        restoreScrollPosition() {
          this.#e.SetOwnScrollPositionEnabled(false);
        }
        getViewport() {
          return this.#e.GetViewport().toDOMRect();
        }
        cssPxToLayer(e, t, r2 = 0) {
          C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r2);
          const i2 = this.#e, a2 = i2.GetRuntime();
          return i2.CanvasCssToLayer(e - a2.GetCanvasClientX(), t - a2.GetCanvasClientY(), r2);
        }
        layerToCssPx(e, t, r2 = 0) {
          C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r2);
          const i2 = this.#e, a2 = i2.GetRuntime(), [s2, n] = i2.LayerToCanvasCss(e, t, r2);
          return [s2 + a2.GetCanvasClientX(), n + a2.GetCanvasClientY()];
        }
        drawSurfaceToLayer(e, t, r2 = 0) {
          return C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r2), this.#e.DrawSurfaceToLayer(e, t, r2);
        }
        layerToDrawSurface(e, t, r2 = 0) {
          return C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r2), this.#e.LayerToDrawSurface(e, t, r2);
        }
        get renderScale() {
          return this.#e.GetRenderScale();
        }
      };
    }
    {
      let GetDispatcher2 = function(e) {
        let t = dispatchers.get(e);
        return t || (t = C33.New(C33.Event.Dispatcher), dispatchers.set(e, t), t);
      };
      GetDispatcher = GetDispatcher2;
      const C33 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.IInstance = class {
        #e;
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken);
          this.#e = e;
          const t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, objectType: { value: e.GetObjectClass().GetIObjectClass(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } };
          e._GetInstVarsScriptDescriptor(t), e._GetBehaviorsScriptDescriptor(t), Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e);
        }
        static _GetInitInst() {
          return C33.AddonManager._GetInitObject();
        }
        _release() {
          const e = dispatchers.get(this);
          e && (e.Release(), dispatchers.delete(this));
        }
        addEventListener(e, t, i2) {
          C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher2(this).addEventListener(e, t, i2);
        }
        removeEventListener(e, t, i2) {
          C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher2(this).removeEventListener(e, t, i2);
        }
        dispatchEvent(e) {
          GetDispatcher2(this).dispatchEvent(e);
        }
        destroy() {
          const e = this.#e, t = e.GetRuntime();
          t.DestroyInstance(e), t.GetEventSheetManager().IsInEventEngine() || t.GetLayoutManager().IsEndingLayout() || t.GetEventSheetManager().IsFlushingBlocked() || t.FlushPendingInstances();
        }
        getOtherContainerInstances() {
          const e = this.#e.GetSiblings();
          return e ? e.map((e2) => e2.GetInterfaceClass()) : [];
        }
        *otherContainerInstances() {
          const e = this.#e;
          if (e.IsInContainer()) for (const t of e.siblings()) yield t.GetInterfaceClass();
        }
        get uid() {
          return this.#e.GetUID();
        }
        get iid() {
          return this.#e.GetIID();
        }
        get templateName() {
          return this.#e.GetTemplateName();
        }
        set timeScale(e) {
          C3X.RequireFiniteNumber(e), this.#e.SetTimeScale(e);
        }
        get timeScale() {
          return this.#e.GetActiveTimeScale();
        }
        restoreTimeScale() {
          this.#e.RestoreTimeScale();
        }
        get dt() {
          const e = this.#e;
          return e.GetRuntime().GetDt(e);
        }
        hasTags(...e) {
          C3X.RequireArray(e);
          const t = new Set(e), i2 = this.#e.GetTagsSet();
          return t.isSubsetOf(i2);
        }
        setAllTags(e) {
          C3X.RequireInstanceOf(e, Set), this.#e.SetTagsSet(e);
        }
        getAllTags() {
          return new Set(this.#e.GetTagsSet());
        }
        signal(e) {
          C3X.RequireString(e);
          const t = this.#e;
          t.GetRuntime().GetEventSheetManager().InstanceSignal(t, e);
        }
        waitForSignal(e) {
          C3X.RequireString(e);
          const t = this.#e;
          return t.GetRuntime().GetEventSheetManager().WaitForInstanceSignal(t, e);
        }
      };
    }
    var GetDispatcher;
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.ISDKInstanceBase = class extends self.IInstance {
        #e;
        #t = false;
        #n = null;
        #i = false;
        #r = null;
        #s;
        #o;
        constructor(e) {
          super(), this.#e = C33.AddonManager._GetInitObject2(internalApiToken), this.#t = false, this.#n = null, this.#i = false, this.#r = null, this.#s = e?.domComponentId, this.#o = e?.wrapperComponentId;
        }
        _release() {
          this._setTicking(false), this._setTicking2(false), super._release();
        }
        _getInitProperties() {
          return C33.AddonManager._GetInitProperties();
        }
        _trigger(e) {
          const t = this.#e;
          t.GetRuntime().Trigger(e, t);
        }
        _triggerAsync(e) {
          const t = this.#e;
          return t.GetRuntime().TriggerAsync(e, t);
        }
        _addDOMMessageHandler(e, t) {
          if (C3X.RequireString(e), C3X.RequireFunction(t), !this.#s) throw new Error("no DOM component id set");
          this.#e.GetRuntime().AddDOMComponentMessageHandler(this.#s, e, t);
        }
        _addDOMMessageHandlers(e) {
          C3X.RequireArray(e);
          for (const [t, n] of e) this._addDOMMessageHandler(t, n);
        }
        _postToDOM(e, t) {
          if (C3X.RequireString(e), !this.#s) throw new Error("no DOM component id set");
          this.#e.GetRuntime().PostComponentMessageToDOM(this.#s, e, t);
        }
        _postToDOMAsync(e, t) {
          if (C3X.RequireString(e), !this.#s) throw new Error("no DOM component id set");
          return this.#e.GetRuntime().PostComponentMessageToDOMAsync(this.#s, e, t);
        }
        _postToDOMMaybeSync(e, t) {
          if (!this.#e.GetRuntime().IsInWorker()) return window["c3_runtimeInterface"]["_OnMessageFromRuntime"]({ "type": "event", "component": this.#s, "handler": e, "data": t, "responseId": null });
          this._postToDOM(e, t);
        }
        _setTicking(e) {
          if (e = !!e, this.#t === e) return;
          this.#t = e;
          const t = this.#e.GetRuntime();
          if (e) {
            if (!this.#n) if (this.#e.GetRuntime().IsDebug()) {
              const e2 = globalThis.C3Debugger, t2 = this.plugin;
              this.#n = () => {
                const n = performance.now();
                this._tick(), e2.AddIndividualPluginTickTime(t2, performance.now() - n);
              };
            } else this.#n = () => this._tick();
            t.Dispatcher().addEventListener("tick", this.#n);
          } else t.Dispatcher().removeEventListener("tick", this.#n);
        }
        _isTicking() {
          return this.#t;
        }
        _tick() {
        }
        _setTicking2(e) {
          if (e = !!e, this.#i === e) return;
          this.#i = e;
          const t = this.#e.GetRuntime();
          if (e) {
            if (!this.#r) if (this.#e.GetRuntime().IsDebug()) {
              const e2 = globalThis.C3Debugger, t2 = this.plugin;
              this.#r = () => {
                const n = performance.now();
                this._tick2(), e2.AddIndividualPluginTickTime(t2, performance.now() - n);
              };
            } else this.#r = () => this._tick2();
            t.Dispatcher().addEventListener("tick2", this.#r);
          } else t.Dispatcher().removeEventListener("tick2", this.#r);
        }
        _isTicking2() {
          return this.#i;
        }
        _tick2() {
        }
        _getDebuggerProperties() {
          return [];
        }
        _saveToJson() {
          return null;
        }
        _loadFromJson(e) {
        }
        _isWrapperExtensionAvailable() {
          if (!this.#o) throw new Error("no wrapper component id set");
          return this.#e.GetRuntime().HasWrapperComponentId(this.#o);
        }
        _addWrapperExtensionMessageHandler(e, t) {
          if (C3X.RequireString(e), C3X.RequireFunction(t), !this.#o) throw new Error("no wrapper component id set");
          this.#e.GetRuntime().AddWrapperExtensionMessageHandler(this.#o, e, t);
        }
        _addWrapperMessageHandlers(e) {
          C3X.RequireArray(e);
          for (const [t, n] of e) this._addWrapperExtensionMessageHandler(t, n);
        }
        _sendWrapperExtensionMessage(e, t) {
          if (!this.#o) throw new Error("no wrapper component id set");
          this.runtime.sdk.sendWrapperExtensionMessage(this.#o, e, t);
        }
        _sendWrapperExtensionMessageAsync(e, t) {
          if (!this.#o) throw new Error("no wrapper component id set");
          return this.runtime.sdk.sendWrapperExtensionMessageAsync(this.#o, e, t);
        }
      };
    }
    {
      let MakeIWorldInstanceClass2 = function(e) {
        return class t extends e {
          #e;
          #t;
          constructor(e2) {
            super(e2);
            const t2 = C33.AddonManager._GetInitObject2(internalApiToken), i2 = t2.GetWorldInfo();
            this.#e = t2, this.#t = i2, map.set(this, t2);
            const n = [], r2 = i2.GetInstanceEffectList();
            if (r2) {
              const e3 = i2.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
              for (let t3 = 0; t3 < e3; ++t3) n.push(new self.IEffectInstance(r2, t3));
            }
            const s2 = { effects: { value: n, writable: false } };
            Object.defineProperties(this, s2);
          }
          get layout() {
            return this.#t.GetLayout().GetILayout();
          }
          get layer() {
            return this.#t.GetLayer().GetILayer();
          }
          get x() {
            return this.#t.GetX();
          }
          set x(e2) {
            e2 = +e2;
            const t2 = this.#t;
            isNaN(e2) || t2.GetX() === e2 || (t2.SetX(e2), t2.SetBboxChanged());
          }
          get y() {
            return this.#t.GetY();
          }
          set y(e2) {
            e2 = +e2;
            const t2 = this.#t;
            isNaN(e2) || t2.GetY() === e2 || (t2.SetY(e2), t2.SetBboxChanged());
          }
          setPosition(e2, t2) {
            e2 = +e2, t2 = +t2;
            const i2 = this.#t;
            isNaN(e2) || isNaN(t2) || i2.GetX() === e2 && i2.GetY() === t2 || (i2.SetXY(e2, t2), i2.SetBboxChanged());
          }
          getPosition() {
            const e2 = this.#t;
            return [e2.GetX(), e2.GetY()];
          }
          offsetPosition(e2, t2) {
            if (e2 = +e2, t2 = +t2, isNaN(e2) || isNaN(t2) || 0 === e2 && 0 === t2) return;
            const i2 = this.#t;
            i2.OffsetXY(e2, t2), i2.SetBboxChanged();
          }
          set originX(e2) {
            e2 = +e2;
            const t2 = this.#t;
            isNaN(e2) || t2.GetOriginX() === e2 || (t2.SetOriginX(e2), t2.SetBboxChanged());
          }
          get originX() {
            return this.#t.GetOriginX();
          }
          set originY(e2) {
            e2 = +e2;
            const t2 = this.#t;
            isNaN(e2) || t2.GetOriginY() === e2 || (t2.SetOriginY(e2), t2.SetBboxChanged());
          }
          get originY() {
            return this.#t.GetOriginY();
          }
          setOrigin(e2, t2) {
            e2 = +e2, t2 = +t2;
            const i2 = this.#t;
            isNaN(e2) || isNaN(t2) || i2.GetOriginX() === e2 && i2.GetOriginY() === t2 || (i2.SetOriginX(e2), i2.SetOriginY(t2), i2.SetBboxChanged());
          }
          getOrigin() {
            const e2 = this.#t;
            return [e2.GetOriginX(), e2.GetOriginY()];
          }
          get zElevation() {
            return this.#t.GetZElevation();
          }
          set zElevation(e2) {
            e2 = +e2;
            const t2 = this.#e, i2 = this.#t;
            isNaN(e2) || i2.GetZElevation() === e2 || (i2.SetZElevation(e2), t2.GetRuntime().UpdateRender());
          }
          get totalZElevation() {
            return this.#t.GetTotalZElevation();
          }
          get width() {
            return this.#t.GetWidth();
          }
          set width(e2) {
            e2 = +e2;
            const t2 = this.#t;
            isNaN(e2) || t2.GetWidth() === e2 || (t2.SetWidth(e2), t2.SetBboxChanged());
          }
          get height() {
            return this.#t.GetHeight();
          }
          set height(e2) {
            e2 = +e2;
            const t2 = this.#t;
            isNaN(e2) || t2.GetHeight() === e2 || (t2.SetHeight(e2), t2.SetBboxChanged());
          }
          setSize(e2, t2) {
            e2 = +e2, t2 = +t2;
            const i2 = this.#t;
            isNaN(e2) || isNaN(t2) || i2.GetWidth() === e2 && i2.GetHeight() === t2 || (i2.SetSize(e2, t2), i2.SetBboxChanged());
          }
          getSize() {
            const e2 = this.#t;
            return [e2.GetWidth(), e2.GetHeight()];
          }
          get angle() {
            return this.#t.GetAngle();
          }
          set angle(e2) {
            e2 = C33.clampAngle(+e2);
            const t2 = this.#t;
            isNaN(e2) || t2.GetAngle() === e2 || (t2.SetAngle(e2), t2.SetBboxChanged());
          }
          get angleDegrees() {
            return C33.toDegrees(this.angle);
          }
          set angleDegrees(e2) {
            this.angle = C33.toRadians(e2);
          }
          getBoundingBox(e2) {
            return e2 ? (this.#t.CalculateBbox(tempRect, tempQuad, false), tempRect.toDOMRect()) : this.#t.GetBoundingBox().toDOMRect();
          }
          getBoundingQuad(e2) {
            return e2 ? (this.#t.CalculateBbox(tempRect, tempQuad, false), tempQuad.toDOMQuad()) : this.#t.GetBoundingQuad().toDOMQuad();
          }
          isOnScreen() {
            return this.#t.IsInViewport2();
          }
          get isVisible() {
            return this.#t.IsVisible();
          }
          set isVisible(e2) {
            e2 = !!e2;
            const t2 = this.#e, i2 = this.#t;
            i2.IsVisible() !== e2 && (i2.SetVisible(e2), t2.GetRuntime().UpdateRender());
          }
          get opacity() {
            return this.#t.GetOpacity();
          }
          set opacity(e2) {
            e2 = C33.clamp(+e2, 0, 1);
            const t2 = this.#e, i2 = this.#t;
            isNaN(e2) || i2.GetOpacity() === e2 || (i2.SetOpacity(e2), t2.GetRuntime().UpdateRender());
          }
          set colorRgb(e2) {
            if (C3X.RequireArray(e2), e2.length < 3) throw new Error("expected 3 elements");
            tempColor.setRgb(e2[0], e2[1], e2[2]);
            const t2 = this.#e, i2 = this.#t;
            i2.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (i2.SetUnpremultipliedColor(tempColor), t2.GetRuntime().UpdateRender());
          }
          get colorRgb() {
            const e2 = this.#t.GetUnpremultipliedColor();
            return [e2.getR(), e2.getG(), e2.getB()];
          }
          set blendMode(e2) {
            C3X.RequireString(e2);
            const t2 = BLEND_MODE_TO_INDEX.get(e2);
            if ("number" != typeof t2) throw new Error("invalid blend mode");
            const i2 = this.#e;
            this.#t.SetBlendMode(t2), i2.GetRuntime().UpdateRender();
          }
          get blendMode() {
            return INDEX_TO_BLEND_MODE.get(this.#t.GetBlendMode());
          }
          moveToTop() {
            this.#t.ZOrderMoveToTop();
          }
          moveToBottom() {
            this.#t.ZOrderMoveToBottom();
          }
          moveToLayer(e2) {
            C3X.RequireInstanceOf(e2, ILayer);
            const t2 = this.#e, i2 = t2.GetRuntime()._UnwrapScriptInterface(e2);
            if (!i2) throw new Error("invalid layer");
            t2.GetWorldInfo().ZOrderMoveToLayer(i2);
          }
          moveAdjacentToInstance(e2, i2) {
            C3X.RequireInstanceOf(e2, t), this.#t.ZOrderMoveAdjacentToInstance(map.get(e2), i2);
          }
          get zIndex() {
            return this.#t.GetZIndex();
          }
          get isCollisionEnabled() {
            return this.#t.IsCollisionEnabled();
          }
          set isCollisionEnabled(e2) {
            this.#t.SetCollisionEnabled(!!e2);
          }
          containsPoint(e2, t2) {
            return C3X.RequireNumber(e2), C3X.RequireNumber(t2), this.#t.ContainsPoint(+e2, +t2);
          }
          testOverlap(e2) {
            C3X.RequireInstanceOf(e2, t);
            const i2 = this.#e, n = map.get(e2);
            return i2.GetRuntime().GetCollisionEngine().TestOverlap(i2, n);
          }
          testOverlapSolid() {
            const e2 = this.#e, t2 = e2.GetRuntime().GetCollisionEngine().TestOverlapSolid(e2);
            return t2 ? t2.GetInterfaceClass() : null;
          }
          getParent() {
            const e2 = this.#e.GetParent();
            return e2 ? e2.GetInterfaceClass() : null;
          }
          getTopParent() {
            const e2 = this.#e.GetTopParent();
            return e2 ? e2.GetInterfaceClass() : null;
          }
          *parents() {
            for (const e2 of this.#e.parents()) yield e2.GetInterfaceClass();
          }
          getChildCount() {
            return this.#e.GetChildCount();
          }
          getChildAt(e2) {
            const t2 = this.#e.GetChildAt(e2);
            return t2 ? t2.GetInterfaceClass() : null;
          }
          *children() {
            for (const e2 of this.#e.children()) yield e2.GetInterfaceClass();
          }
          *allChildren() {
            for (const e2 of this.#e.allChildren()) yield e2.GetInterfaceClass();
          }
          addChild(e2, i2) {
            C3X.RequireInstanceOf(e2, t), C3X.RequireOptionalObject(i2), i2 || (i2 = {});
            const n = this.#e, r2 = map.get(e2);
            n.AddChild(r2, i2);
          }
          removeChild(e2) {
            C3X.RequireInstanceOf(e2, t);
            const i2 = this.#e, n = map.get(e2);
            i2.RemoveChild(n);
          }
          removeFromParent() {
            const e2 = this.#e;
            if (!e2.HasParent()) return;
            e2.GetParent().RemoveChild(e2);
          }
          getHierarchyOpts() {
            const e2 = this.#t;
            return { transformX: e2.GetTransformWithParentX(), transformY: e2.GetTransformWithParentY(), transformWidth: e2.GetTransformWithParentWidth(), transformHeight: e2.GetTransformWithParentHeight(), transformAngle: e2.GetTransformWithParentAngle(), transformZElevation: e2.GetTransformWithParentZElevation(), transformOpacity: e2.GetTransformWithParentOpacity(), transformVisibility: e2.GetTransformWithParentVisibility(), destroyWithParent: e2.GetDestroyWithParent() };
          }
          createMesh(e2, t2) {
            C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t2), this.#t.CreateMesh(e2, t2);
          }
          releaseMesh() {
            const e2 = this.#t;
            e2.ReleaseMesh(), e2.SetBboxChanged();
          }
          setMeshPoint(e2, t2, i2) {
            C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t2), C3X.RequireObject(i2);
            const n = this.#t;
            n.SetMeshPoint(e2, t2, i2) && n.SetBboxChanged();
          }
          getMeshPoint(e2, t2) {
            let i2 = NaN, n = NaN, r2 = NaN, s2 = NaN, a2 = NaN;
            const o2 = this.#t;
            if (o2.HasMesh()) {
              const l2 = o2.GetSourceMesh().GetMeshPointAt(e2, t2);
              null !== l2 && (i2 = l2.GetX(), n = l2.GetY(), r2 = l2.GetZElevation(), s2 = l2.GetU(), a2 = l2.GetV());
            }
            return { x: i2, y: n, zElevation: r2, u: s2, v: a2 };
          }
          getMeshSize() {
            const e2 = this.#t;
            if (!e2.HasMesh()) return [0, 0];
            const t2 = e2.GetSourceMesh();
            return [t2.GetHSize(), t2.GetVSize()];
          }
        };
      };
      MakeIWorldInstanceClass = MakeIWorldInstanceClass2;
      const C33 = self.C3, C3X = self.C3X, IInstance = self.IInstance, ILayer = self.ILayer, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad), map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken(), BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), tempColor = C33.New(C33.Color);
      self.IWorldInstance = MakeIWorldInstanceClass2(self.IInstance), self.IWorldInstanceSDKBase = MakeIWorldInstanceClass2(self.ISDKInstanceBase);
    }
    var MakeIWorldInstanceClass;
    {
      const C33 = self.C3, C3X = self.C3X;
      self.IDOMInstance = class extends self.IWorldInstance {
        #e;
        constructor() {
          super(), this.#e = self.IInstance._GetInitInst();
        }
        getElement() {
          return this.#e.GetSdkInstance()._GetElementInDOMMode();
        }
        focus() {
          this.#e.GetSdkInstance().FocusElement();
        }
        blur() {
          this.#e.GetSdkInstance().BlurElement();
        }
        setCssStyle(e, t) {
          C3X.RequireString(e), this.#e.GetSdkInstance().SetElementCSSStyle(e, t);
        }
      };
    }
    {
      let GetDispatcher2 = function(e) {
        let t = dispatchers.get(e);
        return t || (t = C33.New(C33.Event.Dispatcher), dispatchers.set(e, t), t);
      };
      GetDispatcher = GetDispatcher2;
      const C33 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.IBehaviorInstance = class {
        #e;
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken);
          this.#e = e;
          const t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, behaviorType: { value: e.GetBehaviorType().GetIBehaviorType(), writable: false } };
          Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e);
        }
        static _GetInitInst() {
          return C33.AddonManager._GetInitObject();
        }
        get instance() {
          return this.#e.GetObjectInstance().GetInterfaceClass();
        }
        _release() {
          const e = dispatchers.get(this);
          e && (e.Release(), dispatchers.delete(this));
        }
        addEventListener(e, t, i2) {
          C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher2(this).addEventListener(e, t, i2);
        }
        removeEventListener(e, t, i2) {
          C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher2(this).removeEventListener(e, t, i2);
        }
        dispatchEvent(e) {
          GetDispatcher2(this).dispatchEvent(e);
        }
      };
    }
    var GetDispatcher;
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.IBehaviorType = class {
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken), t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, name: { value: e.GetName(), writable: false } };
          Object.defineProperties(this, t);
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.IBehavior = class {
        #t;
        constructor() {
          const t = C33.AddonManager._GetInitObject2(internalApiToken);
          this.#t = t;
          const e = { runtime: { value: t.GetRuntime().GetIRuntime(), writable: false }, id: { value: t.GetID(), writable: false } };
          Object.defineProperties(this, e), t.GetRuntime()._MapScriptInterface(this, t);
        }
        getAllInstances() {
          return this.#t.GetInstances().map((t) => t.GetInterfaceClass());
        }
        static getByConstructor(t) {
          if (!t) return null;
          const e = C33.AddonManager.GetBehaviorByConstructorFunction(t);
          return e ? e.GetIBehavior() : null;
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, tempColor = C33.New(C33.Color);
      self.IEffectInstance = class {
        #e;
        constructor(e, t) {
          this.#e = e;
          const i2 = { index: { value: t, writable: false } };
          Object.defineProperties(this, i2);
        }
        get name() {
          return this.#e.GetAllEffectTypes()[this.index].GetName();
        }
        get isActive() {
          return this.#e.IsEffectIndexActive(this.index);
        }
        set isActive(e) {
          e = !!e;
          const t = this.#e;
          t.IsEffectIndexActive(this.index) !== e && (t.SetEffectIndexActive(this.index, e), t.UpdateActiveEffects(), t.GetRuntime().UpdateRender());
        }
        setParameter(e, t) {
          C3X.RequireFiniteNumber(e), e = Math.floor(+e);
          const i2 = this.#e, r2 = i2.GetEffectParameter(this.index, e);
          if (null === r2) throw new RangeError("invalid index");
          if (r2 instanceof C33.Color) {
            if (!Array.isArray(t) || t.length < 3) throw new TypeError("expected array with 3 elements");
            tempColor.setRgb(t[0], t[1], t[2]), t = tempColor;
          } else if ("number" != typeof t) throw new TypeError("expected number");
          i2.SetEffectParameter(this.index, e, t) && i2.IsEffectIndexActive(this.index) && i2.GetRuntime().UpdateRender();
        }
        getParameter(e) {
          C3X.RequireFiniteNumber(e), e = Math.floor(+e);
          const t = this.#e.GetEffectParameter(this.index, e);
          if (null === t) throw new RangeError("invalid index");
          return t instanceof C33.Color ? [t.getR(), t.getG(), t.getB()] : t;
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.IAnimation = class {
        #e;
        constructor(e) {
          this.#e = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false } });
        }
        get speed() {
          return this.#e.GetSpeed();
        }
        get isLooping() {
          return this.#e.IsLooping();
        }
        get repeatCount() {
          return this.#e.GetRepeatCount();
        }
        get repeatTo() {
          return this.#e.GetRepeatTo();
        }
        get isPingPong() {
          return this.#e.IsPingPong();
        }
        get frameCount() {
          return this.#e.GetFrameCount();
        }
        getFrames() {
          return this.#e.GetFrames().map((e) => e.GetIAnimationFrame());
        }
        *frames() {
          for (const e of this.#e.GetFrames()) yield e.GetIAnimationFrame();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.IImageInfo = class {
        #t;
        constructor(t) {
          this.#t = t;
        }
        static _Unwrap(t) {
          return t.#t;
        }
        get width() {
          return this.#t.GetWidth();
        }
        get height() {
          return this.#t.GetHeight();
        }
        getSize() {
          const t = this.#t;
          return [t.GetWidth(), t.GetHeight()];
        }
        getTexture(t) {
          return t.getTextureForImageInfo(this);
        }
        getTexRect() {
          return this.#t.GetTexRect().toDOMRect();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.IAnimationFrame = class extends self.IImageInfo {
        #t;
        constructor(t) {
          super(t.GetImageInfo()), this.#t = t, Object.defineProperties(this, { duration: { value: t.GetDuration(), writable: false }, originX: { value: t.GetOriginX(), writable: false }, originY: { value: t.GetOriginY(), writable: false } });
        }
        getOrigin() {
          const t = this.#t;
          return [t.GetOriginX(), t.GetOriginY()];
        }
        getImagePointCount() {
          return this.#t.GetImagePointCount();
        }
        getImagePointX(t) {
          return this.getImagePoint(t)[0];
        }
        getImagePointY(t) {
          return this.getImagePoint(t)[1];
        }
        getImagePoint(t) {
          const e = this.#t;
          let i2 = null;
          if ("number" == typeof t) i2 = e.GetImagePointByIndex(Math.floor(t));
          else {
            if ("string" != typeof t) throw new TypeError("expected string or number");
            i2 = e.GetImagePointByName(t);
          }
          return i2 ? [i2.GetX(), i2.GetY()] : this.getOrigin();
        }
        getPolyPointCount() {
          const t = this.#t.GetCollisionPoly();
          return t ? t.pointCount() : 0;
        }
        getPolyPointX(t) {
          return this.getPolyPoint(t)[0];
        }
        getPolyPointY(t) {
          return this.getPolyPoint(t)[1];
        }
        getPolyPoint(t) {
          C3X.RequireFiniteNumber(t), t = Math.floor(t);
          const e = this.#t.GetCollisionPoly();
          if (!e || t < 0 || t >= e.pointCount()) return [0, 0];
          const i2 = e.pointsArr();
          return [i2[2 * t], i2[2 * t + 1]];
        }
        get tag() {
          return this.#t.GetTag();
        }
      };
    }
    {
      let GetTimelineState2 = function(e) {
        const t = map.get(e);
        if (t.IsReleased()) throw new Error("timeline/tween was released and is no longer valid");
        return t;
      };
      GetTimelineState = GetTimelineState2;
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
      self.ITimelineStateBase = class {
        constructor(e) {
          map.set(this, e), e.GetRuntime()._MapScriptInterface(this, e);
        }
        pause() {
          GetTimelineState2(this).Stop();
        }
        resume() {
          GetTimelineState2(this).Resume();
        }
        stop() {
          GetTimelineState2(this).Reset();
        }
        hasTags(e) {
          return GetTimelineState2(this).HasTags(e);
        }
        set time(e) {
          C3X.RequireFiniteNumber(e), GetTimelineState2(this).SetTime(e);
        }
        get time() {
          return GetTimelineState2(this).GetTime();
        }
        set totalTime(e) {
          C3X.RequireFiniteNumber(e), GetTimelineState2(this).SetTotalTime(e);
        }
        get totalTime() {
          return GetTimelineState2(this).GetTotalTime();
        }
        set isLooping(e) {
          GetTimelineState2(this).SetLoop(!!e);
        }
        get isLooping() {
          return GetTimelineState2(this).GetLoop();
        }
        set isPingPong(e) {
          GetTimelineState2(this).SetPingPong(!!e);
        }
        get isPingPong() {
          return GetTimelineState2(this).GetPingPong();
        }
        set playbackRate(e) {
          C3X.RequireFiniteNumber(e), GetTimelineState2(this).SetPlaybackRate(e);
        }
        get playbackRate() {
          return GetTimelineState2(this).GetPlaybackRate();
        }
        get progress() {
          const e = GetTimelineState2(this);
          return e.GetTime() / e.GetTotalTime();
        }
        get tags() {
          return GetTimelineState2(this).GetTags();
        }
        get finished() {
          return GetTimelineState2(this).GetPlayPromise();
        }
        get isPlaying() {
          return GetTimelineState2(this).IsPlaying();
        }
        get isPaused() {
          return GetTimelineState2(this).IsPaused();
        }
        get isReleased() {
          return map.get(this).IsReleased();
        }
      };
    }
    var GetTimelineState;
    {
      let GetTimelineState2 = function(e) {
        const t = map.get(e);
        if (t.IsReleased()) throw new Error("timeline was released and is no longer valid");
        return t;
      };
      GetTimelineState = GetTimelineState2;
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
      let easeToIndexFunc = null;
      self.ITimelineState = class extends self.ITimelineStateBase {
        constructor(e) {
          super(e), map.set(this, e);
          const t = { name: { value: e.GetName(), writable: false } };
          Object.defineProperties(this, t);
        }
      };
    }
    var GetTimelineState;
    {
      let GetTweenState2 = function(e) {
        const t = map.get(e);
        if (t.IsReleased()) throw new Error("tween was released and is no longer valid");
        return t;
      };
      GetTweenState = GetTweenState2;
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), behInstMap = /* @__PURE__ */ new WeakMap();
      let easeToIndexFunc = null;
      self.ITweenState = class extends self.ITimelineStateBase {
        constructor(e, t, n) {
          super(e), easeToIndexFunc || (easeToIndexFunc = n.easeToIndexFunc), map.set(this, e), t && behInstMap.set(this, t);
        }
        stop() {
          const e = GetTweenState2(this);
          behInstMap.get(this).ReleaseTween(e);
        }
        setEase(e) {
          C3X.RequireString(e);
          const t = self.Ease.GetEaseFromIndex(easeToIndexFunc(e));
          GetTweenState2(this).SetEase(t);
        }
        get instance() {
          const e = GetTweenState2(this).GetInstance();
          return e ? e.GetInterfaceClass() : null;
        }
        get isDestroyOnComplete() {
          return GetTweenState2(this).GetDestroyInstanceOnComplete();
        }
        set isDestroyOnComplete(e) {
          GetTweenState2(this).SetDestroyInstanceOnComplete(!!e);
        }
        get value() {
          const e = GetTweenState2(this);
          if ("value" !== e.GetId()) throw new Error("not a value tween");
          return e.GetPropertyTrack("value").GetSourceAdapterValue();
        }
      };
    }
    var GetTweenState;
    {
      const C33 = self.C3, C3X = self.C3X;
      self.ISDKPluginBase = class extends self.IPlugin {
        constructor() {
          super();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.ISDKDOMPluginBase = class extends self.ISDKPluginBase {
        #e;
        #n;
        #t = 0;
        #s = /* @__PURE__ */ new Map();
        constructor(e) {
          if (super(), this.#e = C33.AddonManager._GetInitObject2(internalApiToken), !e?.domComponentId) throw new Error("no DOM component ID specified");
          this.#n = e.domComponentId, this._addElementMessageHandler("elem-focused", (e2) => e2._onElemFocused()), this._addElementMessageHandler("elem-blurred", (e2) => {
            e2 && e2._onElemBlurred();
          });
        }
        _addElement(e) {
          const n = this.#t++;
          return this.#s.set(n, e), n;
        }
        _removeElement(e) {
          this.#s.delete(e);
        }
        _addElementMessageHandler(e, n) {
          this.#e.GetRuntime().AddDOMComponentMessageHandler(this.#n, e, (e2) => {
            const t = this.#s.get(e2["elementId"]);
            n(t, e2);
          });
        }
        _addElementMessageHandlers(e) {
          C3X.RequireArray(e);
          for (const [n, t] of e) this._addElementMessageHandlers(n, t);
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.ISDKObjectTypeBase = class extends self.IObjectType {
        #e;
        constructor() {
          super(), this.#e = C33.AddonManager._GetInitObject2(internalApiToken);
        }
        _onCreate() {
        }
        getImageInfo() {
          return this.#e.GetImageInfo().GetIImageInfo();
        }
        _loadTextures(e) {
        }
        _releaseTextures(e) {
        }
        _onDynamicTextureLoadComplete() {
        }
        _preloadTexturesWithInstances(e) {
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.ISDKWorldInstanceBase = class extends self.IWorldInstanceSDKBase {
        #e;
        #r = null;
        #t = null;
        constructor(e) {
          super(e), this.#e = C33.AddonManager._GetInitObject2(internalApiToken);
        }
        _release() {
          if (super._release(), this.#r) {
            const e = this.#e.GetRuntime().Dispatcher();
            e.removeEventListener("renderercontextlost", this.#r), e.removeEventListener("renderercontextrestored", this.#t), this.#r = null, this.#t = null;
          }
        }
        _handleRendererContextLoss() {
          if (this.#r) return;
          this.#r = () => this._onRendererContextLost(), this.#t = () => this._onRendererContextRestored();
          const e = this.#e.GetRuntime().Dispatcher();
          e.addEventListener("renderercontextlost", this.#r), e.addEventListener("renderercontextrestored", this.#t);
        }
        _onRendererContextLost() {
        }
        _onRendererContextRestored() {
        }
        _draw(e) {
        }
        _rendersToOwnZPlane() {
          return true;
        }
        _mustPreDraw() {
          return false;
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, tempRect = C33.New(C33.Rect), map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.ISDKDOMInstanceBase = class extends self.ISDKWorldInstanceBase {
        #e = -1;
        #t = true;
        #s = false;
        #i = false;
        #n = -0.2;
        #o = C33.New(C33.Rect, 0, 0, -1, -1);
        #l = 0;
        #a = 0;
        #h = -1;
        #d = -1;
        #m = false;
        constructor(e) {
          if (!e?.domComponentId) throw new Error("no DOM component ID specified");
          super(e);
          const t = C33.AddonManager._GetInitObject2(internalApiToken);
          map.set(this, t), this.#e = this.plugin._addElement(this);
          const s2 = t.GetRuntime().GetCanvasManager();
          this.#l = s2.GetLastWidth(), this.#a = s2.GetLastHeight(), this._setTicking(true);
        }
        _release() {
          super._release(), this.plugin._removeElement(this.#e), this._postToDOMElement("destroy"), this.#e = -1, map.delete(this);
        }
        _getElementInDOMMode() {
          if (map.get(this).GetRuntime().IsInWorker()) throw new Error("not valid in worker mode");
          return this._postToDOMElementMaybeSync("get-element");
        }
        _postToDOMElement(e, t) {
          t || (t = {}), t["elementId"] = this.#e, this._postToDOM(e, t);
        }
        _postToDOMElementMaybeSync(e, t) {
          return t || (t = {}), t["elementId"] = this.#e, this._postToDOMMaybeSync(e, t);
        }
        _postToDOMElementAsync(e, t) {
          return t || (t = {}), t["elementId"] = this.#e, this._postToDOMAsync(e, t);
        }
        _createElement(e) {
          e || (e = {});
          const t = map.get(this).GetWorldInfo();
          e["elementId"] = this.#e, e["isVisible"] = t.IsVisible(), e["htmlIndex"] = t.GetLayer().GetHTMLIndex(), e["htmlZIndex"] = t.GetHTMLZIndex(), Object.assign(e, this._getElementState()), this.#t = !!e["isVisible"], this._postToDOMMaybeSync("create", e), this._updatePosition(true);
        }
        setElementVisible(e) {
          e = !!e, this.#t !== e && (this.#t = e, this._postToDOMElement("set-visible", { "isVisible": e }));
        }
        _tick() {
          this._updatePosition(false);
        }
        _shouldPreserveElement() {
          const e = map.get(this).GetRuntime().GetCanvasManager().GetFullscreenMode();
          return "Android" === C33.Platform.OS && ("scale-inner" === e || "scale-outer" === e || "crop" === e);
        }
        _updatePosition(e) {
          const t = map.get(this);
          if (t.IsDestroyed()) return;
          const s2 = t.GetWorldInfo(), i2 = s2.GetLayer(), n = s2.GetBoundingBox();
          let [o2, l2] = i2.LayerToCanvasCss(n.getLeft(), n.getTop()), [a2, h] = i2.LayerToCanvasCss(n.getRight(), n.getBottom());
          const d2 = t.GetRuntime().GetCanvasManager(), m = d2.GetCssWidth(), r2 = d2.GetCssHeight();
          if (!s2.IsVisible() || !i2.IsVisible()) return void this.setElementVisible(false);
          if (!this._shouldPreserveElement() && (a2 <= 0 || h <= 0 || o2 >= m || l2 >= r2)) return void this.setElementVisible(false);
          tempRect.set(o2, l2, a2, h);
          const c2 = d2.GetLastWidth(), p = d2.GetLastHeight(), u = i2.GetHTMLIndex(), M = s2.GetHTMLZIndex();
          if (!e && tempRect.equals(this.#o) && this.#l === c2 && this.#a === p && this.#h === u && this.#d === M) return void this.setElementVisible(true);
          this.#o.copy(tempRect), this.#l = c2, this.#a = p, this.#h = u, this.#d = M, this.setElementVisible(true);
          let I = null;
          this.#i && (I = i2.GetDisplayScale() + this.#n), this._postToDOMElement("update-position", { "left": Math.round(this.#o.getLeft()), "top": Math.round(this.#o.getTop()), "width": Math.round(this.#o.width()), "height": Math.round(this.#o.height()), "htmlIndex": u, "htmlZIndex": M, "fontSize": I });
        }
        focusElement() {
          this._postToDOMElementMaybeSync("focus", { "focus": true });
        }
        blurElement() {
          this._postToDOMElementMaybeSync("focus", { "focus": false });
        }
        _onElemFocused() {
          this.#s = true;
        }
        _onElemBlurred() {
          this.#s = false;
        }
        isElementFocused() {
          return this.#s;
        }
        setElementCSSStyle(e, t) {
          this.postToDOMElement("set-css-style", { "prop": C33.CSSToCamelCase(e), "val": t });
        }
        setElementAttribute(e, t) {
          this.postToDOMElement("set-attribute", { "name": e, "val": t });
        }
        removeElementAttribute(e) {
          this.postToDOMElement("remove-attribute", { "name": e });
        }
        _updateElementState() {
          this.#m || (this.#m = true, Promise.resolve().then(() => {
            this.#m = false, this._postToDOMElement("update-state", this._getElementState());
          }));
        }
        _getElementState() {
        }
        _getElementId() {
          return this.#e;
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.ISDKBehaviorBase = class extends self.IBehavior {
        constructor() {
          super();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.ISDKBehaviorTypeBase = class extends globalThis.IBehaviorType {
        constructor() {
          super();
        }
        _onCreate() {
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.ISDKBehaviorInstanceBase = class extends self.IBehaviorInstance {
        #i = false;
        #t = false;
        #e = false;
        constructor() {
          super(), map.set(this, C33.AddonManager._GetInitObject2(internalApiToken));
        }
        _release() {
          super._release(), this._setTicking(false), this._setTicking2(false), this._setPostTicking(false), map.delete(this);
        }
        _getInitProperties() {
          return C33.AddonManager._GetInitProperties();
        }
        _postCreate() {
        }
        _trigger(i2) {
          const t = map.get(this);
          t.GetRuntime().Trigger(i2, t.GetObjectInstance(), t.GetBehaviorType());
        }
        _triggerAsync(i2) {
          const t = map.get(this);
          return t.GetRuntime().TriggerAsync(i2, t.GetObjectInstance(), t.GetBehaviorType());
        }
        _setTicking(i2) {
          if (i2 = !!i2, this.#i === i2) return;
          this.#i = i2;
          const t = map.get(this).GetRuntime();
          i2 ? t._AddBehInstToTick(this) : t._RemoveBehInstToTick(this);
        }
        _isTicking() {
          return this.#i;
        }
        _tick() {
        }
        _setTicking2(i2) {
          if (i2 = !!i2, this.#t === i2) return;
          this.#t = i2;
          const t = map.get(this).GetRuntime();
          i2 ? t._AddBehInstToTick2(this) : t._RemoveBehInstToTick2(this);
        }
        _isTicking2() {
          return this.#t;
        }
        _tick2() {
        }
        _setPostTicking(i2) {
          if (i2 = !!i2, this.#e === i2) return;
          this.#e = i2;
          const t = map.get(this).GetRuntime();
          i2 ? t._AddBehInstToPostTick(this) : t._RemoveBehInstToPostTick(this);
        }
        _isPostTicking() {
          return this.#e;
        }
        _postTick() {
        }
        _getDebuggerProperties() {
          return [];
        }
        _saveToJson() {
          return null;
        }
        _loadFromJson(i2) {
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      let runtime = null;
      self.ISDKUtils = class {
        constructor(e) {
          runtime = e;
        }
        addLoadPromise(e) {
          runtime.AddLoadPromise(e);
        }
        sendWrapperExtensionMessage(e, n, t) {
          C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t), runtime.SendWrapperExtensionMessage(e, n, t);
        }
        sendWrapperExtensionMessageAsync(e, n, t) {
          return C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t), runtime.SendWrapperExtensionMessageAsync(e, n, t);
        }
        createLoopingConditionContext(e) {
          return C3X.RequireOptionalString(e), new self.ILoopingConditionContext(runtime, e);
        }
        set isAutoSuspendEnabled(e) {
          runtime._SetAutoSuspendEnabled(!!e);
        }
        get isAutoSuspendEnabled() {
          return runtime._IsAutoSuspendEnabled();
        }
        setSuspended(e) {
          runtime.SetSuspended(!!e);
        }
        getObjectClassBySid(e) {
          C3X.RequireNumber(e);
          const n = runtime.GetObjectClassBySID(e);
          return n ? n.GetIObjectClass() : null;
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.ILoopingConditionContext = class {
        #e;
        #t;
        #o;
        #n;
        #s;
        #r;
        constructor(e, t) {
          this.#e = e;
          const o2 = e.GetEventSheetManager(), n = e.GetCurrentEvent();
          this.#t = n, this.#o = n.GetSolModifiers();
          const s2 = e.GetEventStack();
          this.#n = s2.GetCurrentStackFrame(), this.#s = s2.Push(n);
          const r2 = o2.GetLoopStack().Push();
          this.#r = r2, t && r2.SetName(t), e.SetDebuggingEnabled(false);
        }
        retrigger() {
          const e = this.#e.GetEventSheetManager(), t = this.#o, o2 = this.#r;
          e.PushCopySol(t), this.#t.Retrigger(this.#n, this.#s), e.PopSol(t), o2.SetIndex(o2.GetIndex() + 1);
        }
        get isStopped() {
          return this.#r.IsStopped();
        }
        release() {
          const e = this.#e, t = e.GetEventStack(), o2 = e.GetEventSheetManager().GetLoopStack();
          e.SetDebuggingEnabled(true), o2.Pop(), t.Pop();
        }
      };
    }
    {
      let IsStaticTextureDataType2 = function(e) {
        return e instanceof ImageBitmap || "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas;
      };
      IsStaticTextureDataType = IsStaticTextureDataType2;
      const C33 = self.C3, C3X = self.C3X;
      let renderer = null, runtime = null;
      const CULL_MODE_ARR = ["none", "back", "front"], FRONT_FACE_WINDING_ARR = ["cw", "ccw"];
      self.IRenderer = class {
        constructor(e, r2) {
          runtime = e, renderer = r2;
        }
        setAlphaBlendMode() {
          renderer.SetAlphaBlend();
        }
        setBlendMode(e) {
          renderer.SetNamedBlendMode(e);
        }
        setColorFillMode() {
          renderer.SetColorFillMode();
        }
        setTextureFillMode() {
          renderer.SetTextureFillMode();
        }
        setSmoothLineFillMode() {
          renderer.SetSmoothLineFillMode();
        }
        setColor(e) {
          renderer.SetColorRgba(e[0], e[1], e[2], e[3]);
        }
        setColorRgba(e, r2, n, t) {
          renderer.SetColorRgba(e, r2, n, t);
        }
        resetColor() {
          renderer.ResetColor();
        }
        setOpacity(e) {
          renderer.SetOpacity(e);
        }
        setCurrentZ(e) {
          renderer.SetCurrentZ(e);
        }
        getCurrentZ() {
          return renderer.GetCurrentZ();
        }
        setCullFaceMode(e) {
          const r2 = CULL_MODE_ARR.indexOf(e);
          if (-1 === r2) throw new Error("invalid cull mode");
          renderer.SetCullFaceMode(r2);
        }
        getCullFaceMode() {
          return CULL_MODE_ARR[renderer.GetCullFaceMode()];
        }
        setFrontFaceWinding(e) {
          const r2 = FRONT_FACE_WINDING_ARR.indexOf(e);
          if (-1 === r2) throw new Error("invalid front face winding");
          renderer.SetFrontFaceWinding(r2);
        }
        getFrontFaceWinding() {
          return renderer.GetFrontFaceWinding();
        }
        rect(e) {
          renderer.Rect2(e.left, e.top, e.right, e.bottom);
        }
        rect2(e, r2, n, t) {
          renderer.Rect2(e, r2, n, t);
        }
        quad(e) {
          renderer.Quad(C33.Quad.fromDOMQuad(e));
        }
        quad2(e, r2, n, t, a2, d2, i2, o2) {
          renderer.Quad2(e, r2, n, t, a2, d2, i2, o2);
        }
        quad3(e, r2) {
          renderer.Quad3(C33.Quad.fromDOMQuad(e), C33.Rect.fromDOMRect(r2));
        }
        quad4(e, r2) {
          renderer.Quad4(C33.Quad.fromDOMQuad(e), C33.Quad.fromDOMQuad(r2));
        }
        quad5(e, r2, n) {
          renderer.Quad5(C33.Quad.fromDOMQuad(e), C33.Quad.fromDOMQuad(r2), n);
        }
        quad3D(e, r2, n, t, a2, d2, i2, o2, u, l2, c2, s2, p) {
          renderer.Quad3D(e, r2, n, t, a2, d2, i2, o2, u, l2, c2, s2, C33.Rect.fromDOMRect(p));
        }
        quad3D2(e, r2, n, t, a2, d2, i2, o2, u, l2, c2, s2, p) {
          renderer.Quad3D2(e, r2, n, t, a2, d2, i2, o2, u, l2, c2, s2, C33.Quad.fromDOMQuad(p));
        }
        quad3D3(e, r2, n, t, a2, d2, i2, o2, u, l2, c2, s2, p, f2) {
          renderer.Quad3D3(e, r2, n, t, a2, d2, i2, o2, u, l2, c2, s2, C33.Quad.fromDOMQuad(p), f2);
        }
        drawMesh(e, r2, n, t) {
          renderer.DrawMesh(e, r2, n, t);
        }
        convexPoly(e) {
          renderer.ConvexPoly(e);
        }
        line(e, r2, n, t) {
          renderer.Line(e, r2, n, t);
        }
        texturedLine(e, r2, n, t, a2, d2) {
          renderer.TexturedLine(e, r2, n, t, a2, d2);
        }
        lineRect(e, r2, n, t) {
          renderer.LineRect(e, r2, n, t);
        }
        lineRect2(e) {
          renderer.LineRect2(C33.Rect.fromDOMRect(e));
        }
        lineQuad(e) {
          renderer.LineQuad(C33.Quad.fromDOMQuad(e));
        }
        pushLineWidth(e) {
          renderer.PushLineWidth(e);
        }
        popLineWidth() {
          renderer.PopLineWidth();
        }
        pushLineCap(e) {
          renderer.PushLineCap(e);
        }
        popLineCap() {
          renderer.PopLineCap();
        }
        setTexture(e) {
          C3X.RequireOptionalInstanceOf(e, self.ITexture);
          const r2 = e ? runtime._UnwrapScriptInterface(e) : null;
          renderer.SetTexture(r2);
        }
        loadTextureForImageInfo(e, r2) {
          const n = self.IImageInfo._Unwrap(e);
          if (!n) throw new Error("invalid IImageInfo");
          return n.LoadStaticTexture(renderer, { wrapX: r2?.wrapX ?? "clamp-to-edge", wrapY: r2?.wrapY ?? "clamp-to-edge", sampling: r2?.sampling ?? "trilinear", mipMap: r2?.mipMap ?? true });
        }
        releaseTextureForImageInfo(e) {
          const r2 = self.IImageInfo._Unwrap(e);
          if (!r2) throw new Error("invalid IImageInfo");
          r2.ReleaseTexture();
        }
        getTextureForImageInfo(e) {
          const r2 = self.IImageInfo._Unwrap(e);
          if (!r2) throw new Error("invalid IImageInfo");
          const n = r2.GetTexture();
          return self.ITexture.GetInterface(runtime, n);
        }
        createStaticTexture(e, r2) {
          if (!IsStaticTextureDataType2(e)) throw new TypeError("invalid texture data");
          const n = renderer.CreateStaticTexture(e, { wrapX: r2?.wrapX ?? "clamp-to-edge", wrapY: r2?.wrapY ?? "clamp-to-edge", sampling: r2?.sampling ?? "trilinear", mipMap: r2?.mipMap ?? true });
          return self.ITexture.GetInterface(runtime, n);
        }
        createDynamicTexture(e, r2, n) {
          C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(r2);
          const t = renderer.CreateDynamicTexture(e, r2, { wrapX: n?.wrapX ?? "clamp-to-edge", wrapY: n?.wrapY ?? "clamp-to-edge", sampling: n?.sampling ?? "trilinear", mipMap: n?.mipMap ?? true });
          return self.ITexture.GetInterface(runtime, t);
        }
        updateTexture(e, r2, n) {
          C3X.RequireInstanceOf(r2, self.ITexture);
          const t = runtime._UnwrapScriptInterface(r2);
          renderer.UpdateTexture(e, t, { premultiplyAlpha: n?.premultiplyAlpha ?? true });
        }
        deleteTexture(e) {
          C3X.RequireInstanceOf(e, self.ITexture);
          const r2 = runtime._UnwrapScriptInterface(e);
          renderer.DeleteTexture(r2);
        }
        createRendererText() {
          const e = renderer.CreateRendererText();
          return new self.IRendererText(runtime, e);
        }
        setDeviceTransform() {
          runtime.GetCanvasManager().SetDeviceTransform(renderer);
        }
        setLayerTransform(e) {
          C3X.RequireInstanceOf(e, globalThis.ILayer);
          runtime._UnwrapScriptInterface(e)._SetTransform(renderer);
        }
      };
    }
    var IsStaticTextureDataType;
    {
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), reverseMap = /* @__PURE__ */ new WeakMap();
      self.ITexture = class {
        constructor(e, t) {
          map.set(this, { runtime: e, texture: t }), reverseMap.set(t, this), e._MapScriptInterface(this, t), Object.defineProperties(this, { width: { value: t.GetWidth(), writable: false }, height: { value: t.GetHeight(), writable: false } });
        }
        static GetInterface(e, t) {
          if (!t) return null;
          const r2 = reverseMap.get(t);
          return r2 || new self.ITexture(e, t);
        }
      };
    }
    {
      let getActual2 = function(t) {
        return map.get(t).rendererText;
      };
      getActual = getActual2;
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
      self.IRendererText = class {
        constructor(t, e) {
          map.set(this, { runtime: t, rendererText: e }), t._MapScriptInterface(this, e);
        }
        release() {
          getActual2(this).Release();
        }
        set fontFace(t) {
          C3X.RequireString(t), getActual2(this).SetFontName(t);
        }
        get fontFace() {
          return getActual2(this).GetFontName();
        }
        set sizePt(t) {
          C3X.RequireFiniteNumber(t), getActual2(this).SetFontSize(t);
        }
        get sizePt() {
          return getActual2(this).GetFontSize();
        }
        set lineHeight(t) {
          C3X.RequireFiniteNumber(t), getActual2(this).SetLineHeight(t);
        }
        get lineHeight() {
          return getActual2(this).GetLineHeight();
        }
        set isBold(t) {
          getActual2(this).SetBold(t);
        }
        get isBold() {
          return getActual2(this).IsBold();
        }
        set isItalic(t) {
          getActual2(this).SetItalic(t);
        }
        get isItalic() {
          return getActual2(this).IsItalic();
        }
        setColor(t) {
          C3X.RequireArray(t), this.setColorRgb(t[0], t[1], t[2]);
        }
        setColorRgb(t, e, i2) {
          getActual2(this).SetColorRgb(t, e, i2);
        }
        setCssColor(t) {
          C3X.RequireString(t), getActual2(this).SetColor(t);
        }
        set horizontalAlign(t) {
          getActual2(this).SetHorizontalAlignment(t);
        }
        get horizontalAlign() {
          return getActual2(this).GetHorizontalAlignment();
        }
        set verticalAlign(t) {
          getActual2(this).SetVerticalAlignment(t);
        }
        get verticalAlign() {
          return getActual2(this).GetVerticalAlignment();
        }
        set wordWrapMode(t) {
          getActual2(this).SetWordWrapMode(t);
        }
        get wordWrapMode() {
          return getActual2(this).GetWordWrapMode();
        }
        set textDirection(t) {
          getActual2(this).SetTextDirection(t);
        }
        get textDirection() {
          return getActual2(this).GetTextDirection();
        }
        set text(t) {
          C3X.RequireString(t), getActual2(this).SetText(t);
        }
        get text() {
          return getActual2(this).GetText();
        }
        setSize(t, e, i2) {
          C3X.RequireFiniteNumber(t), C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(i2), getActual2(this).SetSize(t, e, i2);
        }
        getTexture() {
          const { runtime: t, rendererText: e } = map.get(this), i2 = e.GetTexture();
          return self.ITexture.GetInterface(t, i2);
        }
        getTexRect() {
          return getActual2(this).GetTexRect().toDOMRect();
        }
        setTextureUpdateCallback(t) {
          C3X.RequireFunction(t), getActual2(this).ontextureupdate = t;
        }
        releaseTexture() {
          getActual2(this).ReleaseTexture();
        }
        get textWidth() {
          return getActual2(this).GetTextWidth();
        }
        get textHeight() {
          return getActual2(this).GetTextHeight();
        }
      };
    }
    var getActual;
    {
      let GetTypeFromFileExtension2 = function(e) {
        if (!e) return "";
        const t = e.split(".");
        if (t.length < 2) return "";
        const i2 = t.at(-1).toLowerCase();
        return EXT_TO_TYPE.get(i2) || "";
      }, AddScript2 = function(e) {
        return new Promise((t, i2) => {
          const s2 = document.createElement("script");
          s2.onload = t, s2.onerror = i2, s2.async = false, s2.type = "module", s2.src = e, document.head.appendChild(s2);
        });
      };
      GetTypeFromFileExtension = GetTypeFromFileExtension2, AddScript = AddScript2;
      const C33 = self.C3, VALID_LOAD_POLICIES = /* @__PURE__ */ new Set(["local", "remote"]), EXT_TO_TYPE = /* @__PURE__ */ new Map([["mp4", "video/mp4"], ["webm", "video/webm"], ["m4a", "audio/mp4"], ["mp3", "audio/mpeg"], ["js", "application/javascript"], ["wasm", "application/wasm"], ["svg", "image/svg+xml"], ["html", "text/html"]]);
      C33.AssetManager = class extends C33.DefendedBase {
        constructor(e, t) {
          super();
          const i2 = t["exportType"];
          this._runtime = e, this._fileStructure = "folders", this._cordovaBlobUrlCache = /* @__PURE__ */ new Map(), this._isCordova = "cordova" === i2, this._isiOSCordova = !!t["isiOSCordova"], this._isFileProtocol = !!t["isFileProtocol"], this._swClientId = t["swClientId"], this._supportedAudioFormats = t["supportedAudioFormats"] || {}, this._audioFiles = /* @__PURE__ */ new Map(), this._preloadSounds = false, this._scriptSubfolder = t["scriptFolder"], this._mediaSubfolder = "", this._fontsSubfolder = "", this._iconsSubfolder = "", this._fileMap = t["fileMap"] || /* @__PURE__ */ new Map(), this._fileMapBlobUrls = /* @__PURE__ */ new Map();
          const s2 = "html5" === i2 || "scirra-arcade" === i2 || "instant-games" === i2;
          this._defaultLoadPolicy = s2 ? "remote" : "local", this._imageAssetsMap = /* @__PURE__ */ new Map(), this._webFonts = [], this._loadPromises = [], this._hasFinishedInitialLoad = false, this._totalAssetSizeToLoad = 0, this._assetSizeLoaded = 0, this._lastLoadProgress = 0, this._hasHadErrorLoading = false, this._loadingRateLimiter = C33.New(C33.RateLimiter, () => this._FireLoadingProgressEvent(), 50), this._localPromiseThrottle = C33.New(C33.PromiseThrottle, Math.max(C33.hardwareConcurrency, 8)), this._remotePromiseThrottle = C33.New(C33.PromiseThrottle, 20), this._iAssetManager = new self.IAssetManager(this);
        }
        Release() {
          for (const e of this._imageAssetsMap.values()) e.Release();
          this._imageAssetsMap.clear(), C33.clearArray(this._loadPromises), this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        _SetFileStructure(e) {
          this._fileStructure = e;
        }
        GetFileStructure() {
          return this._fileStructure;
        }
        GetScriptSubfolder() {
          return this._scriptSubfolder;
        }
        _SetMediaSubfolder(e) {
          this._mediaSubfolder = e;
        }
        GetMediaSubfolder() {
          return this._mediaSubfolder;
        }
        _SetFontsSubfolder(e) {
          this._fontsSubfolder = e;
        }
        GetFontsSubfolder() {
          return this._fontsSubfolder;
        }
        _SetIconsSubfolder(e) {
          this._iconsSubfolder = e;
        }
        GetIconsSubfolder() {
          return this._iconsSubfolder;
        }
        IsFileProtocol() {
          return this._isFileProtocol;
        }
        FetchBlob(e, t) {
          return t = t || this._defaultLoadPolicy, C33.IsRelativeURL(e) ? ("flat" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(e) : "playable-ad-single-file" === this._runtime.GetExportType() ? self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e) : "local" === t ? this._localPromiseThrottle.Add(() => C33.FetchBlob(e)) : this._remotePromiseThrottle.Add(() => C33.FetchBlob(e))) : C33.FetchBlob(e);
        }
        FetchArrayBuffer(e) {
          return C33.IsRelativeURL(e) ? ("flat" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(e) : "playable-ad-single-file" === this._runtime.GetExportType() ? C33.BlobToArrayBuffer(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : "local" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add(() => C33.FetchArrayBuffer(e)) : this._remotePromiseThrottle.Add(() => C33.FetchArrayBuffer(e))) : C33.FetchArrayBuffer(e);
        }
        FetchText(e) {
          return C33.IsRelativeURL(e) ? ("flat" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(e) : "playable-ad-single-file" === this._runtime.GetExportType() ? C33.BlobToString(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : "local" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add(() => C33.FetchText(e)) : this._remotePromiseThrottle.Add(() => C33.FetchText(e))) : C33.FetchText(e);
        }
        async FetchJson(e) {
          const t = await this.FetchText(e);
          return JSON.parse(t);
        }
        _CordovaFetchLocalFileAs(e, t) {
          return "flat" === this._fileStructure && (e = e.toLowerCase()), this._runtime.PostComponentMessageToDOMAsync("runtime", "cordova-fetch-local-file", { "filename": e, "as": t });
        }
        CordovaFetchLocalFileAsText(e) {
          return this._CordovaFetchLocalFileAs(e, "text");
        }
        async CordovaFetchLocalFileAsBlob(e) {
          const t = await this._CordovaFetchLocalFileAs(e, "buffer"), i2 = GetTypeFromFileExtension2(e);
          return new Blob([t], { "type": i2 });
        }
        async CordovaFetchLocalFileAsBlobURL(e) {
          "flat" === this._fileStructure && (e = e.toLowerCase());
          let t = this._cordovaBlobUrlCache.get(e);
          if (t) return t;
          const i2 = await this.CordovaFetchLocalFileAsBlob(e);
          return t = URL.createObjectURL(i2), this._cordovaBlobUrlCache.set(e, t), t;
        }
        CordovaFetchLocalFileAsArrayBuffer(e) {
          return this._CordovaFetchLocalFileAs(e, "buffer");
        }
        GetMediaFileUrl(e) {
          "flat" === this._fileStructure && (e = e.toLowerCase());
          let t = this._mediaSubfolder + e;
          return "Gecko" === C33.Platform.BrowserEngine && "preview" === this._runtime.GetExportType() && (t = this._GetLocalBlobURLFromFileMap(t)), t;
        }
        GetProjectFileUrl(e) {
          return C33.IsAbsoluteURL(e) ? Promise.resolve(e) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(e) : "playable-ad-single-file" === this._runtime.GetExportType() ? URL.createObjectURL(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : ("flat" === this._fileStructure && (e = e.toLowerCase()), Promise.resolve(e));
        }
        GetProjectFileIframeUrl(e) {
          if (C33.IsAbsoluteURL(e) || "preview" !== this._runtime.GetExportType() || !this._swClientId || !e) return e;
          try {
            const t = new URL(e, location.href);
            return t.searchParams.set("__c3_client_id", this._swClientId), t.toString();
          } catch (t) {
            return console.warn("Invalid iframe URL: " + e), e;
          }
        }
        LoadProjectFileUrl(e) {
          return this.GetProjectFileUrl(e);
        }
        _GetImageAssetKey(e, t) {
          return (t ? "true" : "false") + "|" + e;
        }
        LoadImage(e) {
          const t = !!e.isTiled;
          if (e.loadPolicy && !VALID_LOAD_POLICIES.has(e.loadPolicy)) throw new Error("invalid load policy");
          const i2 = this._GetImageAssetKey(e.url, t);
          let s2 = this._imageAssetsMap.get(i2);
          return s2 || (s2 = C33.New(C33.ImageAsset, this, { url: e.url, size: e.size || 0, loadPolicy: e.loadPolicy || this._defaultLoadPolicy, isTiled: t }), this._imageAssetsMap.set(i2, s2), this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += s2.GetSize(), this._loadPromises.push(s2.Load().then(() => this._AddLoadedSize(s2.GetSize())))), s2);
        }
        _ReleaseImageAsset(e) {
          const t = this._GetImageAssetKey(e.GetURL(), e.IsTiled());
          this._imageAssetsMap.delete(t);
        }
        async WaitForAllToLoad() {
          try {
            await Promise.all(this._loadPromises), this._lastLoadProgress = 1;
          } catch (e) {
            console.error("Error loading: ", e), this._hasHadErrorLoading = true, this._FireLoadingProgressEvent();
          }
        }
        SetInitialLoadFinished() {
          this._hasFinishedInitialLoad = true;
        }
        HasHadErrorLoading() {
          return this._hasHadErrorLoading;
        }
        _AddLoadedSize(e) {
          this._assetSizeLoaded += e, this._loadingRateLimiter.Call();
        }
        _FireLoadingProgressEvent() {
          const e = C33.New(C33.Event, "loadingprogress");
          this._lastLoadProgress = C33.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1), e.progress = this._lastLoadProgress, this._runtime.Dispatcher().dispatchEvent(e), this._runtime.DispatchUserScriptEvent(C33.New(C33.Event, "loadingprogress"));
        }
        GetLoadProgress() {
          return this._lastLoadProgress;
        }
        GetImageLoadProgress() {
          return this._runtime.GetSystemPlugin().GetImageLoadingProgress();
        }
        _SetWebFonts(e) {
          C33.shallowAssignArray(this._webFonts, e), this._webFonts.length && this._loadPromises.push(this._LoadWebFonts());
        }
        async _LoadWebFonts() {
          const e = [], t = [];
          for (const [i2, s2, o2] of this._webFonts) this._totalAssetSizeToLoad += o2, e.push(this._LoadWebFont(i2, s2, t).then(() => this._AddLoadedSize(o2)));
          await Promise.all(e), this._runtime.IsInWorker() && t.length > 0 && await this._runtime.PostComponentMessageToDOMAsync("runtime", "load-webfonts", { "webfonts": t });
        }
        async _LoadWebFont(e, t, i2) {
          try {
            let s2 = await this.GetProjectFileUrl(t);
            "Gecko" === C33.Platform.BrowserEngine && (e = `'${e}'`), ("Gecko" === C33.Platform.BrowserEngine && "preview" === this._runtime.GetExportType() || "playable-ad-single-file" === this._runtime.GetExportType()) && (s2 = this._GetLocalBlobURLFromFileMap(s2));
            const o2 = new FontFace(e, `url('${s2}')`);
            this._runtime.IsInWorker() ? self.fonts.add(o2) : document.fonts.add(o2), await o2.load(), this._runtime.IsInWorker() && i2.push({ name: e, url: s2 });
          } catch (t2) {
            console.warn(`[C3 runtime] Failed to load web font '${e}': `, t2);
          }
        }
        IsAudioFormatSupported(e) {
          return !!this._supportedAudioFormats[e];
        }
        _SetAudioFiles(e, t) {
          this._preloadSounds = !!t;
          for (const [t2, i2, s2] of e) this._audioFiles.set(t2, { fileName: t2, formats: i2.map((e2) => ({ type: e2[0], fileExtension: e2[1], fullName: t2 + e2[1], fileSize: e2[2] })), isMusic: s2 });
        }
        GetPreferredAudioFile(e) {
          "flat" === this._fileStructure && (e = e.toLowerCase());
          const t = this._audioFiles.get(e);
          if (!t) return null;
          let i2 = null;
          for (const e2 of t.formats) if (i2 || "audio/webm; codecs=opus" !== e2.type || (i2 = e2), this.IsAudioFormatSupported(e2.type)) return e2;
          return i2;
        }
        GetProjectAudioFileUrl(e) {
          const t = this.GetPreferredAudioFile(e);
          return t ? { url: this.GetMediaFileUrl(t.fullName), type: t.type } : null;
        }
        GetAudioToPreload() {
          if (this._preloadSounds) {
            const e = [];
            for (const t of this._audioFiles.values()) {
              if (t.isMusic) continue;
              const i2 = this.GetPreferredAudioFile(t.fileName);
              i2 && e.push({ originalUrl: t.fileName, url: this.GetMediaFileUrl(i2.fullName), type: i2.type, fileSize: i2.fileSize });
            }
            return e;
          }
          return [];
        }
        _GetLocalBlobFromFileMap(e) {
          return "preview" === this._runtime.GetExportType() && (e = new URL(e, location.href).toString()), this._fileMap.get(e) || null;
        }
        _GetLocalBlobURLFromFileMap(e) {
          let t = this._fileMapBlobUrls.get(e);
          if (t) return t;
          const i2 = this._GetLocalBlobFromFileMap(e);
          return i2 ? (t = URL.createObjectURL(i2), this._fileMapBlobUrls.set(e, t), t) : e;
        }
        GetIAssetManager() {
          return this._iAssetManager;
        }
        async LoadScripts(...e) {
          const t = await Promise.all(e.map((e2) => this.GetProjectFileUrl(e2)));
          if (this._runtime.IsInWorker()) if (1 === e.length) {
            const t2 = e[0];
            await import((C33.IsRelativeURL(t2) ? "./" : "") + t2);
          } else {
            const t2 = e.map((e2) => `import "${C33.IsRelativeURL(e2) ? "./" : ""}${e2}";`).join("\n"), i2 = URL.createObjectURL(new Blob([t2], { type: "application/javascript" }));
            await import(i2);
          }
          else await Promise.all(t.map((e2) => AddScript2(e2)));
        }
        async CompileWebAssembly(e) {
          if (WebAssembly.compileStreaming) {
            const t = await this.GetProjectFileUrl(e);
            return await WebAssembly.compileStreaming(fetch(t));
          }
          {
            const t = await C33.FetchArrayBuffer(e);
            return await WebAssembly.compile(t);
          }
        }
        async LoadStyleSheet(e) {
          const t = await this.GetProjectFileUrl(e);
          return await this._runtime.PostComponentMessageToDOMAsync("runtime", "add-stylesheet", { "url": t });
        }
      };
    }
    var GetTypeFromFileExtension;
    var AddScript;
    {
      const C33 = self.C3;
      C33.Asset = class extends C33.DefendedBase {
        constructor(s2, i2) {
          super(), this._assetManager = s2, this._runtime = s2.GetRuntime(), this._url = i2.url || "", this._size = i2.size, this._loadPolicy = i2.loadPolicy, this._blob = i2.blob || null, this._isLoaded = !!this._blob, this._loadPromise = null;
        }
        Release() {
          this._loadPromise = null, this._assetManager = null, this._runtime = null, this._blob = null;
        }
        GetURL() {
          return this._url;
        }
        GetSize() {
          return this._size;
        }
        Load() {
          return "local" === this._loadPolicy || this._blob ? (this._isLoaded = true, Promise.resolve()) : (this._loadPromise || (this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then((s2) => (this._isLoaded = true, this._loadPromise = null, this._blob = s2, s2)).catch((s2) => {
            console.error("Error loading resource: ", s2), this._loadPromise = null;
          })), this._loadPromise);
        }
        IsLoaded() {
          return this._isLoaded;
        }
        GetBlob() {
          return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy);
        }
      };
    }
    {
      const C33 = self.C3, promiseThrottle = new C33.PromiseThrottle(), allImageAssets = /* @__PURE__ */ new Set();
      C33.ImageAsset = class extends C33.Asset {
        constructor(e, t) {
          super(e, t), this._texturePromise = null, this._webglTexture = null, this._refCount = 0, this._imageWidth = -1, this._imageHeight = -1, this._isTiled = !!t.isTiled, allImageAssets.add(this);
        }
        Release() {
          if (0 !== this._refCount) throw new Error("released image asset which still has texture references");
          this._assetManager._ReleaseImageAsset(this), this._texturePromise = null, allImageAssets.delete(this), super.Release();
        }
        static OnRendererContextLost() {
          for (const e of allImageAssets) e._texturePromise = null, e._webglTexture = null, e._refCount = 0;
        }
        LoadStaticTexture(e, t) {
          return t = t || {}, this._refCount++, this._webglTexture ? Promise.resolve(this._webglTexture) : (this._texturePromise || (t.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy(), this._texturePromise = this._DoLoadStaticTexture(e, t)), this._texturePromise);
        }
        async _DoLoadStaticTexture(e, t) {
          try {
            const s2 = await this.GetBlob();
            return 0 === this._refCount ? (this._texturePromise = null, null) : await promiseThrottle.Add(async () => {
              const r2 = await e.CreateStaticTextureAsync(s2, t);
              return this._texturePromise = null, 0 === this._refCount ? (e.DeleteTexture(r2), null) : (this._webglTexture = r2, this._imageWidth = r2.GetWidth(), this._imageHeight = r2.GetHeight(), this._webglTexture);
            });
          } catch (e2) {
            throw console.error("Failed to load texture: ", e2), e2;
          }
        }
        ReleaseTexture() {
          if (this._refCount <= 0) throw new Error("texture released too many times");
          if (this._refCount--, 0 === this._refCount && this._webglTexture) {
            this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture), this._webglTexture = null;
          }
        }
        GetRefCount() {
          return this._refCount;
        }
        GetTexture() {
          return this._webglTexture;
        }
        GetWidth() {
          return this._imageWidth;
        }
        GetHeight() {
          return this._imageHeight;
        }
        IsTiled() {
          return this._isTiled;
        }
        async LoadToDrawable() {
          const e = await this.GetBlob();
          return C33.Supports.ImageBitmap ? await createImageBitmap(e) : await C33.BlobToImage(e);
        }
      };
    }
    {
      let SortByInstLastCachedZIndex2 = function(e, s2) {
        return e.GetWorldInfo()._GetLastCachedZIndex() - s2.GetWorldInfo()._GetLastCachedZIndex();
      };
      SortByInstLastCachedZIndex = SortByInstLastCachedZIndex2;
      const C33 = self.C3, assert = self.assert;
      C33.RenderCell = class extends C33.DefendedBase {
        constructor(e, s2, n) {
          super(), this._grid = e, this._x = s2, this._y = n, this._instances = [], this._isSorted = true, this._pendingRemoval = /* @__PURE__ */ new Set(), this._isAnyPendingRemoval = false;
        }
        Release() {
          C33.clearArray(this._instances), this._pendingRemoval.clear(), this._grid = null;
        }
        Reset() {
          C33.clearArray(this._instances), this._isSorted = true, this._pendingRemoval.clear(), this._isAnyPendingRemoval = false;
        }
        SetChanged() {
          this._isSorted = false;
        }
        IsEmpty() {
          return !this._instances.length || !(this._instances.length > this._pendingRemoval.size) && (this._FlushPending(), true);
        }
        Insert(e) {
          if (this._pendingRemoval.has(e)) return this._pendingRemoval.delete(e), void (0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = false));
          this._instances.push(e), this._isSorted = 1 === this._instances.length;
        }
        Remove(e) {
          this._pendingRemoval.add(e), this._isAnyPendingRemoval = true, this._pendingRemoval.size >= 50 && this._FlushPending();
        }
        _FlushPending() {
          this._isAnyPendingRemoval && (this._instances.length !== this._pendingRemoval.size ? (C33.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = false) : this.Reset());
        }
        _EnsureSorted() {
          this._isSorted || (this._instances.sort(SortByInstLastCachedZIndex2), this._isSorted = true);
        }
        Dump(e) {
          this._FlushPending(), this._EnsureSorted(), this._instances.length && e.push(this._instances);
        }
      };
    }
    var SortByInstLastCachedZIndex;
    {
      const C33 = self.C3;
      C33.RenderGrid = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._cellWidth = e, this._cellHeight = t, this._cells = C33.New(C33.PairMap);
        }
        Release() {
          this._cells.Release(), this._cells = null;
        }
        GetCell(e, t, l2) {
          let o2 = this._cells.Get(e, t);
          return o2 || (l2 ? (o2 = C33.New(C33.RenderCell, this, e, t), this._cells.Set(e, t, o2), o2) : null);
        }
        XToCell(e) {
          return Math.floor(e / this._cellWidth);
        }
        YToCell(e) {
          return Math.floor(e / this._cellHeight);
        }
        Update(e, t, l2) {
          if (t) for (let o2 = t.getLeft(), s2 = t.getRight(); o2 <= s2; ++o2) for (let s3 = t.getTop(), i2 = t.getBottom(); s3 <= i2; ++s3) {
            if (l2 && l2.containsPoint(o2, s3)) continue;
            const t2 = this.GetCell(o2, s3, false);
            t2 && (t2.Remove(e), t2.IsEmpty() && this._cells.Delete(o2, s3));
          }
          if (l2) for (let o2 = l2.getLeft(), s2 = l2.getRight(); o2 <= s2; ++o2) for (let s3 = l2.getTop(), i2 = l2.getBottom(); s3 <= i2; ++s3) t && t.containsPoint(o2, s3) || this.GetCell(o2, s3, true).Insert(e);
        }
        QueryRange(e, t) {
          let l2 = this.XToCell(e.getLeft());
          const o2 = this.YToCell(e.getTop()), s2 = this.XToCell(e.getRight()), i2 = this.YToCell(e.getBottom());
          for (; l2 <= s2; ++l2) for (let e2 = o2; e2 <= i2; ++e2) {
            const o3 = this.GetCell(l2, e2, false);
            o3 && o3.Dump(t);
          }
        }
        MarkRangeChanged(e) {
          let t = e.getLeft();
          const l2 = e.getTop(), o2 = e.getRight(), s2 = e.getBottom();
          for (; t <= o2; ++t) for (let e2 = l2; e2 <= s2; ++e2) {
            const l3 = this.GetCell(t, e2, false);
            l3 && l3.SetChanged();
          }
        }
      };
    }
    {
      let SortByInstLastCachedZIndex2 = function(e, t) {
        return e.GetWorldInfo()._GetLastCachedZIndex() - t.GetWorldInfo()._GetLastCachedZIndex();
      }, SortByInstZElevation2 = function(e, t) {
        return e.GetWorldInfo().GetZElevation() - t.GetWorldInfo().GetZElevation();
      };
      SortByInstLastCachedZIndex = SortByInstLastCachedZIndex2, SortByInstZElevation = SortByInstZElevation2;
      const C33 = self.C3, assert = self.assert, tmpRect = new C33.Rect(), tmpQuad = new C33.Quad(), renderCellArr = [], tmpDestRect = new C33.Rect(), tmpSrcRect = new C33.Rect(), glMatrix = self.glMatrix, vec32 = glMatrix.vec3, vec42 = glMatrix.vec4, mat42 = glMatrix.mat4, tempMat4 = mat42.create(), tempVec3 = vec32.create(), tempVec4 = vec42.create(), camVector = vec32.create(), lookVector = vec32.create(), upVector = vec32.create(), tempVec2 = C33.New(C33.Vector2), tempRect = C33.New(C33.Rect);
      const tempInstanceList1 = [], tempInstanceList2 = [], tempInstancesByCameraDist = [], DEFAULT_LAYER_OPTIONS = { name: "", sid: -1, isDynamic: false, isVisible: true, isInteractive: true, isHTMLElementsLayer: false, backgroundColor: [1, 1, 1, 1], isTransparent: true, parallax: [1, 1], opacity: 1, isForceOwnTexture: false, renderAs3d: false, useCameraDistanceDrawOrder: false, useRenderCells: false, scaleRate: 1, blendMode: 0, zElevation: 0, initialInstancesData: [], effectListData: [], subLayersData: [] }, allInitialGlobalInstances = /* @__PURE__ */ new Map(), on_global_instance_destroy = (e) => {
        if (!e.instance.GetObjectClass().IsGlobal()) return;
        const t = e.instance.GetUID();
        allInitialGlobalInstances.has(t) && (allInitialGlobalInstances.delete(t), allInitialGlobalInstances.size || e.instance.GetRuntime().Dispatcher().removeEventListener("instancedestroy", on_global_instance_destroy));
      };
      C33.Layer = class extends C33.DefendedBase {
        constructor(e, t, s2) {
          super(), s2 = Object.assign({}, DEFAULT_LAYER_OPTIONS, s2), this._layout = e, this._runtime = e.GetRuntime(), this._parentLayer = t, this._name = s2.name, this._index = -1, this._isHTMLElementsLayer = !!s2.isHTMLElementsLayer, this._htmlIndex = -1, this._sid = s2.sid, this._isDynamic = !!s2.isDynamic, this._isVisible = !!s2.isVisible, this._isInteractive = !!s2.isInteractive, this._backgroundColor = C33.New(C33.Color), this._backgroundColor.setFromJSON(s2.backgroundColor), this._isTransparent = !!s2.isTransparent, this._parallaxX = s2.parallax[0], this._parallaxY = s2.parallax[1], this._color = C33.New(C33.Color, 1, 1, 1, s2.opacity), this._premultipliedColor = C33.New(C33.Color), this._isForceOwnTexture = !!s2.isForceOwnTexture, this._renderAs3d = !!s2.renderAs3d, this._useCameraDistanceDrawOrder = !!s2.useCameraDistanceDrawOrder, this._useRenderCells = !!s2.useRenderCells, this._scaleRate = s2.scaleRate, this._blendMode = s2.blendMode, this._curRenderTarget = null, this._scale = 1, this._zElevation = s2.zElevation, this._angle = 0, this._scrollX = 0, this._scrollY = 0, this._hasOwnScrollPosition = false, this._viewport = C33.New(C33.Rect), this._viewportZ0 = C33.New(C33.Rect), this._viewport3D = C33.New(C33.Rect), this._isViewportChanged = true, this._projectionMatrix = mat42.create(), this._isProjectionMatrixChanged = true, this._modelViewMatrix = mat42.create(), this._isMVMatrixChanged = true, this._viewFrustum = C33.New(C33.Gfx.ViewFrustum), this._isViewFrustumChanged = true, this._startupInitialInstances = [], this._initialInstancesData = s2.initialInstancesData, this._initialInstances = [], this._createdGlobalUids = [], this._initialUIDsToInstanceData = /* @__PURE__ */ new Map(), this._instances = [], this._zIndicesUpToDate = false, this._htmlZIndicesUpToDate = false, this._anyInstanceZElevated = false;
          const a2 = this._runtime.GetCanvasManager();
          this._effectList = C33.New(C33.EffectList, this, s2.effectListData), this._effectChain = C33.New(C33.Gfx.EffectChain, a2.GetEffectChainManager(), { drawContent: (e2, t2) => {
            const s3 = t2.GetContentObject(), i2 = s3.GetRenderTarget();
            e2.SetColor(s3.GetPremultipliedColor()), e2.DrawRenderTarget(i2), e2.InvalidateRenderTarget(i2), a2.ReleaseAdditionalRenderTarget(i2);
          }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasDefaultColor = true, this._renderGrid = null, this._lastRenderList = [], this._isRenderListUpToDate = false, this._lastRenderCells = C33.New(C33.Rect, 0, 0, -1, -1), this._curRenderCells = C33.New(C33.Rect, 0, 0, -1, -1), this._iLayer = new self.ILayer(this), this._userScriptDispatcher = C33.New(C33.Event.Dispatcher), this._UpdatePremultipliedColor(), this.UsesRenderCells() && (this._renderGrid = C33.New(C33.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight())), this._subLayers = s2.subLayersData.map((e2) => C33.Layer.CreateFromExportData(this._layout, this, e2));
        }
        _InitInitialInstances() {
          for (const e of this._initialInstancesData) {
            const t = this._runtime.GetObjectClassByIndex(e[1]);
            this._layout._AddInitialObjectClass(t), t.GetDefaultInstanceData() || (t.SetDefaultInstanceData(e), t._SetDefaultLayerIndex(this._index)), this._initialInstances.push(e), this._initialUIDsToInstanceData.set(e[2], e);
          }
          C33.shallowAssignArray(this._startupInitialInstances, this._initialInstances), this._initialInstancesData = null;
        }
        static CreateFromExportData(e, t, s2) {
          return C33.New(C33.Layer, e, t, { name: s2[0], sid: s2[2], isVisible: s2[3], isInteractive: s2[13], isHTMLElementsLayer: s2[19], backgroundColor: s2[4].map((e2) => e2 / 255), isTransparent: s2[5], parallax: [s2[6], s2[7]], opacity: s2[8], isForceOwnTexture: s2[9], renderAs3d: s2[17], useCameraDistanceDrawOrder: s2[18], useRenderCells: s2[10], scaleRate: s2[11], blendMode: s2[12], zElevation: s2[16], initialInstancesData: s2[14], effectListData: s2[15], subLayersData: s2[20] });
        }
        Release() {
          for (const e of this._subLayers) e.Release();
          C33.clearArray(this._subLayers);
          for (const e of this._instances) this._runtime.DestroyInstance(e);
          C33.clearArray(this._instances), this._effectList.Release(), this._effectList = null, this._effectChain.Release(), this._effectChain = null, this._iLayer = null, this._parentLayer = null, this._layout = null, this._runtime = null;
        }
        WasReleased() {
          return !this._layout;
        }
        GetInitialInstanceData(e) {
          return this._initialUIDsToInstanceData.get(e);
        }
        CreateInitialInstances(e) {
          const t = this._layout.IsFirstVisit(), s2 = this._initialInstances;
          let a2 = 0;
          for (let i2 = 0, r2 = s2.length; i2 < r2; ++i2) {
            const r3 = s2[i2], n = this._runtime.GetObjectClassByIndex(r3[1]);
            let l2 = true;
            if (!n.HasPersistBehavior() || t) if (n.IsGlobal() && allInitialGlobalInstances.has(r3[2])) l2 = false;
            else {
              const t2 = this._runtime.CreateInstanceFromData(r3, this, true);
              e.push(t2), n.IsGlobal() && (allInitialGlobalInstances.size || this._runtime.Dispatcher().addEventListener("instancedestroy", on_global_instance_destroy), allInitialGlobalInstances.set(t2.GetUID(), t2), l2 = false, this._createdGlobalUids.push(t2.GetUID()));
            }
            l2 && (s2[a2] = s2[i2], ++a2);
          }
          C33.truncateArray(s2, a2), this._runtime.FlushPendingInstances(), this.SetZIndicesChanged();
        }
        _AddInstance(e, t) {
          if (!e.GetPlugin().IsWorldType()) throw new Error("instance is not of world type");
          const s2 = e.GetWorldInfo();
          if (s2.GetLayer() !== this) throw new Error("instance added to wrong layer");
          this._instances.push(e), 0 !== s2.GetZElevation() && (this._anyInstanceZElevated = true), t && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged(), this.SetZIndicesChanged(e);
        }
        _MaybeAddInstance(e) {
          this._instances.includes(e) || (this._instances.push(e), 0 !== e.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e));
        }
        _PrependInstance(e, t) {
          const s2 = e.GetWorldInfo();
          if (s2.GetLayer() !== this) throw new Error("instance added to wrong layer");
          this._instances.unshift(e), 0 !== s2.GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e), t && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged();
        }
        _RemoveInstance(e, t) {
          const s2 = this._instances.indexOf(e);
          s2 < 0 || (t && this.UsesRenderCells() && e.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(s2, 1), this.SetZIndicesChanged(e), this._MaybeResetAnyInstanceZElevatedFlag());
        }
        _SetAnyInstanceZElevated() {
          this._anyInstanceZElevated = true;
        }
        _MaybeResetAnyInstanceZElevatedFlag() {
          0 === this._instances.length && (this._anyInstanceZElevated = false);
        }
        _SortInstancesByLastCachedZIndex(e) {
          if (e) {
            const e2 = /* @__PURE__ */ new Set();
            for (const t2 of this._instances) {
              const s2 = t2.GetWorldInfo()._GetLastCachedZIndex();
              s2 >= 0 && e2.add(s2);
            }
            let t = -1;
            for (const s2 of this._instances) {
              const a2 = s2.GetWorldInfo();
              if (!(a2._GetLastCachedZIndex() >= 0)) {
                for (++t; e2.has(t); ) ++t;
                a2._SetZIndex(t);
              }
            }
          }
          this._instances.sort(SortByInstLastCachedZIndex2);
        }
        _Start() {
        }
        _End() {
          for (const e of this._instances) e.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(e);
          this._runtime.FlushPendingInstances(), C33.clearArray(this._instances), this._anyInstanceZElevated = false, this.SetZIndicesChanged();
        }
        RecreateInitialObjects(e, t, s2, a2, i2, r2) {
          const n = this._runtime.GetEventSheetManager(), l2 = this._runtime.GetAllObjectClasses(), o2 = e.IsFamily(), h = [];
          for (const c2 of this._initialInstances) {
            const d2 = c2[0], _ = d2[0], u = d2[1];
            if (!t.containsPoint(_, u)) continue;
            const G = l2[c2[1]];
            if (G !== e) {
              if (!o2) continue;
              if (!e.FamilyHasMember(G)) continue;
            }
            let p = i2;
            if (!p) {
              const e2 = this._runtime.GetCurrentLayout();
              this.GetLayout() === e2 ? p = this : (p = e2.GetLayerByName(this.GetName()), p || (p = e2.GetLayerByIndex(this.GetIndex())));
            }
            const f2 = this._runtime.CreateInstanceFromData(c2, p, false, void 0, void 0, false, r2, void 0, r2);
            r2 && p.SortAndAddInstancesByZIndex(f2);
            const I = f2.GetWorldInfo();
            I.OffsetXY(s2, a2), I.SetBboxChanged(), n.BlockFlushingInstances(true), f2._TriggerOnCreatedOnSelfAndRelated(), n.BlockFlushingInstances(false), h.push(f2);
          }
          return h;
        }
        GetInstanceCount() {
          return this._instances.length;
        }
        GetLayout() {
          return this._layout;
        }
        GetName() {
          return this._name;
        }
        _SetIndex(e) {
          this._index = e;
        }
        GetIndex() {
          return this._index;
        }
        _SetHTMLIndex(e) {
          this._htmlIndex = e;
        }
        GetHTMLIndex() {
          return this._htmlIndex;
        }
        IsHTMLElementsLayer() {
          return this._isHTMLElementsLayer;
        }
        SetIsHTMLElementsLayer(e) {
          e = !!e, this._isHTMLElementsLayer !== e && (this._isHTMLElementsLayer = e, this._layout._ReindexAndUpdateAllLayers(), this._runtime.UpdateRender());
        }
        _GetSiblingIndex() {
          let e = -1;
          const t = this.GetParentLayer();
          return e = t ? t.GetSubLayers().indexOf(this) : this.GetLayout()._GetRootLayers().indexOf(this), e;
        }
        GetSID() {
          return this._sid;
        }
        GetRuntime() {
          return this._runtime;
        }
        IsDynamic() {
          return this._isDynamic;
        }
        HasAnyDynamicParentLayer() {
          for (const e of this.parentLayers()) if (e.IsDynamic()) return true;
          return false;
        }
        GetDevicePixelRatio() {
          return this._runtime.GetDevicePixelRatio();
        }
        GetEffectList() {
          return this._effectList;
        }
        GetEffectChain() {
          return this._MaybeRebuildEffectChainSteps(), this._effectChain;
        }
        _MaybeRebuildEffectChainSteps() {
          const e = this.HasDefaultColor();
          if (!this._needsRebuildEffectChainSteps && e === this._wasDefaultColor && !this._effectChain.NeedsRebuild()) return;
          const t = this.GetEffectList().GetActiveEffectTypes();
          this._effectChain.BuildSteps(t.map((e2) => e2.GetShaderProgram()), { indexMap: t.map((e2) => e2.GetIndex()), forcePreDraw: !e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasDefaultColor = e;
        }
        UpdateActiveEffects() {
          this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;
        }
        UsesRenderCells() {
          return this._useRenderCells && !this._useCameraDistanceDrawOrder;
        }
        GetRenderGrid() {
          return this._renderGrid;
        }
        SetRenderListStale() {
          this._isRenderListUpToDate = false;
        }
        IsVisible() {
          for (const e of this.selfAndParentLayers()) if (!e._IsVisibleFlagSet()) return false;
          return true;
        }
        _IsVisibleFlagSet() {
          return this._isVisible;
        }
        SetVisible(e) {
          e = !!e, this._isVisible !== e && (this._isVisible = e, this._runtime.UpdateRender());
        }
        SetInteractive(e) {
          this._isInteractive = !!e;
        }
        IsInteractive() {
          return this._isInteractive;
        }
        IsSelfAndParentsInteractive() {
          for (const e of this.selfAndParentLayers()) if (!e.IsInteractive()) return false;
          return true;
        }
        SetOwnScrollPositionEnabled(e) {
          if (e = !!e, this._hasOwnScrollPosition !== e) {
            if (this._hasOwnScrollPosition = e, e) {
              const e2 = this.GetLayout();
              this._scrollX = e2.GetScrollX(), this._scrollY = e2.GetScrollY();
            }
            this._SetMVMatrixChanged(), this._runtime.UpdateRender();
          }
        }
        IsOwnScrollPositionEnabled() {
          return this._hasOwnScrollPosition;
        }
        SetScrollX(e) {
          const t = this.GetLayout(), s2 = t.GetScrollLeftBound(), a2 = t.GetScrollRightBound();
          e > a2 && (e = a2), e < s2 && (e = s2), this._scrollX !== e && (this._scrollX = e, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()));
        }
        SetScrollY(e) {
          const t = this.GetLayout(), s2 = t.GetScrollTopBound(), a2 = t.GetScrollBottomBound();
          e > a2 && (e = a2), e < s2 && (e = s2), this._scrollY !== e && (this._scrollY = e, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()));
        }
        GetScrollX() {
          return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX();
        }
        GetScrollY() {
          return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY();
        }
        GetViewport() {
          return this._MaybeUpdateViewport(), this._viewport;
        }
        _GetViewportZ0() {
          return this._MaybeUpdateViewport(), this._viewportZ0;
        }
        GetViewport3D() {
          return this._MaybeUpdateViewport(), this._viewport3D;
        }
        _GetVanishingPoint() {
          return this.GetLayout().GetVanishingPoint();
        }
        GetDefaultCameraZ(e) {
          return this._runtime.GetDefaultCameraZ(e);
        }
        GetViewportForZ(e, t) {
          const s2 = this._GetViewportZ0();
          if (0 === e) t.copy(s2);
          else {
            let a2 = s2.midX(), i2 = s2.midY();
            const r2 = this.Get2DScaleFactorToZ(e), n = s2.width() / r2, l2 = s2.height() / r2, [o2, h] = this._GetVanishingPoint();
            if (0.5 !== o2 || 0.5 !== h) {
              const t2 = this.Get2DCameraZ(), s3 = this._runtime, r3 = this.GetDefaultCameraZ() / t2;
              let n2 = (o2 - 0.5) * s3.GetViewportWidth() / r3, l3 = (h - 0.5) * s3.GetViewportHeight() / r3;
              const c2 = this.GetAngle();
              0 !== c2 && (tempVec2.set(n2, l3), tempVec2.rotate(c2), n2 = tempVec2.getX(), l3 = tempVec2.getY());
              const d2 = C33.unlerp(t2, 0, e);
              a2 += C33.lerp(n2, 0, d2), i2 += C33.lerp(l3, 0, d2);
            }
            t.set(a2 - n / 2, i2 - l2 / 2, a2 + n / 2, i2 + l2 / 2);
          }
        }
        GetOpacity() {
          return this._color.getA();
        }
        SetOpacity(e) {
          e = C33.clamp(e, 0, 1), this._color.getA() !== e && (this._color.setA(e), this._UpdatePremultipliedColor(), this._runtime.UpdateRender());
        }
        _UpdatePremultipliedColor() {
          this._premultipliedColor.copy(this._color), this._premultipliedColor.premultiply();
        }
        GetPremultipliedColor() {
          return this._premultipliedColor;
        }
        HasDefaultColor() {
          return this._color.equalsRgba(1, 1, 1, 1);
        }
        GetScaleRate() {
          return this._scaleRate;
        }
        SetScaleRate(e) {
          this._scaleRate !== e && (this._scaleRate = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        GetParallaxX() {
          return this._parallaxX;
        }
        GetParallaxY() {
          return this._parallaxY;
        }
        SetParallax(e, t) {
          this._parallaxX === e && this._parallaxY === t || (this._parallaxX = e, this._parallaxY = t, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        SetParallaxX(e) {
          this.SetParallax(e, this.GetParallaxY());
        }
        SetParallaxY(e) {
          this.SetParallax(this.GetParallaxX(), e);
        }
        SetZElevation(e) {
          this._zElevation !== e && (this._zElevation = e, this._runtime.UpdateRender());
        }
        GetZElevation() {
          return this._zElevation;
        }
        SetAngle(e) {
          e = C33.clampAngle(e), this._angle !== e && (this._angle = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        GetAngle() {
          return C33.clampAngle(this._layout.GetAngle() + this._angle);
        }
        GetOwnAngle() {
          return this._angle;
        }
        HasInstances() {
          return this._instances.length > 0;
        }
        _GetInstances() {
          return this._instances;
        }
        _GetInstancesInDrawOrder() {
          return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (C33.shallowAssignArray(tempInstancesByCameraDist, this._GetInstances()), tempInstancesByCameraDist.sort((e, t) => this._SortInstancesByCameraDistance(e, t)), tempInstancesByCameraDist) : this._GetInstances();
        }
        _AppendAllInstancesIncludingSubLayersInDrawOrder(e) {
          C33.appendArray(e, this._GetInstancesInDrawOrder());
          for (const t of this._subLayers) t.IsVisible() && t.GetOpacity() > 0 && t._AppendAllInstancesIncludingSubLayersInDrawOrder(e);
        }
        _SortInstancesByCameraDistance(e, t) {
          const s2 = this.GetLayout().Get3DCameraPosition(), a2 = s2[0], i2 = s2[1], r2 = s2[2], n = e.GetWorldInfo(), l2 = t.GetWorldInfo(), o2 = n.GetX() - a2, h = n.GetY() - i2, c2 = n.GetZElevation() - r2, d2 = l2.GetX() - a2, _ = l2.GetY() - i2, u = l2.GetZElevation() - r2;
          return d2 * d2 + _ * _ + u * u - (o2 * o2 + h * h + c2 * c2);
        }
        GetBackgroundColor() {
          return this._backgroundColor;
        }
        IsTransparent() {
          return this._isTransparent;
        }
        SetTransparent(e) {
          e = !!e, this._isTransparent !== e && (this._isTransparent = e, this._runtime.UpdateRender());
        }
        IsForceOwnTexture() {
          return this._isForceOwnTexture;
        }
        SetForceOwnTexture(e) {
          e = !!e, this._isForceOwnTexture !== e && (this._isForceOwnTexture = e, this._runtime.UpdateRender());
        }
        SetRenderAs3D(e) {
          e = !!e, this._renderAs3d !== e && (this._renderAs3d = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        IsRenderAs3D() {
          return this._renderAs3d;
        }
        RendersIn2DMode() {
          return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d;
        }
        RendersIn3DMode() {
          return !this.RendersIn2DMode();
        }
        Has3DCamera() {
          return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled();
        }
        SelfAndAllSubLayersHave3DCamera() {
          if (!this.Has3DCamera()) return false;
          for (const e of this._subLayers) if (!e.SelfAndAllSubLayersHave3DCamera()) return false;
          return true;
        }
        SetBlendMode(e) {
          this._blendMode !== e && (this._blendMode = e, this._runtime.UpdateRender());
        }
        GetBlendMode() {
          return this._blendMode;
        }
        IsRootLayer() {
          return !this._parentLayer;
        }
        GetParentLayer() {
          return this._parentLayer;
        }
        _SetParentLayer(e) {
          this._parentLayer = e;
        }
        GetSubLayers() {
          return this._subLayers;
        }
        HasAnySubLayers() {
          return this._subLayers.length > 0;
        }
        _AddSubLayer(e, t = true) {
          t ? this._subLayers.push(e) : this._subLayers.unshift(e);
        }
        _InsertSubLayer(e, t, s2) {
          let a2 = this._subLayers.indexOf(t);
          if (-1 === a2) throw new Error("cannot find layer to insert by");
          s2 && ++a2, this._subLayers.splice(a2, 0, e);
        }
        _RemoveSubLayer(e) {
          const t = this._subLayers.indexOf(e);
          if (-1 === t) throw new Error("cannot find layer to remove");
          this._subLayers.splice(t, 1);
        }
        HasAnyVisibleSubLayer() {
          for (const e of this._subLayers) if (e.ShouldDraw()) return true;
          return false;
        }
        *selfAndAllSubLayers() {
          for (const e of this._subLayers) yield* e.selfAndAllSubLayers();
          yield this;
        }
        *parentLayers() {
          let e = this.GetParentLayer();
          for (; e; ) yield e, e = e.GetParentLayer();
        }
        *selfAndParentLayers() {
          yield this, yield* this.parentLayers();
        }
        HasParentLayer(e) {
          for (const t of this.parentLayers()) if (t === e) return true;
          return false;
        }
        IsTransformCompatibleWith(e) {
          return this === e || this._parallaxX === e._parallaxX && this._parallaxY === e._parallaxY && this._scale === e._scale && this._scaleRate === e._scaleRate && this._angle === e._angle && this.GetScrollX() === e.GetScrollX() && this.GetScrollY() === e.GetScrollY();
        }
        SaveTransform() {
          return { "parallaxX": this.GetParallaxX(), "parallaxY": this.GetParallaxY(), "scale": this.GetOwnScale(), "scaleRate": this.GetScaleRate(), "angle": this.GetOwnAngle(), "hasOwnScroll": this.IsOwnScrollPositionEnabled(), "scrollX": this.GetScrollX(), "scrollY": this.GetScrollY() };
        }
        RestoreTransform(e) {
          this.SetParallax(e["parallaxX"], e["parallaxY"]), this.SetOwnScale(e["scale"]), this.SetScaleRate(e["scaleRate"]), this.SetAngle(e["angle"]), this.SetOwnScrollPositionEnabled(e["hasOwnScroll"]), this.SetScrollX(e["scrollX"]), this.SetScrollY(e["scrollY"]), this._MaybeUpdateViewport();
        }
        _RemoveAllInstancesInSet(e) {
          if (0 === e.size) return;
          C33.arrayRemoveAllInSet(this._instances, e) > 0 && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged());
        }
        SetZIndicesChanged(e) {
          this._zIndicesUpToDate = false, this._isRenderListUpToDate = false, e && !e.GetObjectClass().GetPlugin().IsHTMLElementType() || (this._htmlZIndicesUpToDate = false);
        }
        _UpdateZIndices() {
          if (!this._zIndicesUpToDate) {
            if (this._instances.sort(SortByInstZElevation2), this.UsesRenderCells()) for (let e = 0, t = this._instances.length; e < t; ++e) {
              const t2 = this._instances[e].GetWorldInfo();
              t2._SetZIndex(e), this._renderGrid.MarkRangeChanged(t2.GetRenderCellRange());
            }
            else for (let e = 0, t = this._instances.length; e < t; ++e) this._instances[e].GetWorldInfo()._SetZIndex(e);
            this._zIndicesUpToDate = true;
          }
        }
        _UpdateHTMLZIndices() {
          if (this._htmlZIndicesUpToDate) return;
          const e = this._layout.GetRootLayersForHTMLLayer(this.GetHTMLIndex()).map((e2) => [...e2.selfAndAllSubLayers()]).flat();
          let t = 0;
          for (const s2 of e) {
            for (const e2 of s2._GetInstances()) e2.GetObjectClass().GetPlugin().IsHTMLElementType() && e2.GetWorldInfo()._SetHTMLZIndex(t++);
            s2._SetHTMLZIndicesUpToDate();
          }
        }
        _SetHTMLZIndicesUpToDate() {
          this._htmlZIndicesUpToDate = true;
        }
        _GetHTMLLayerDOMState() {
          return { "isVisible": this.IsVisible(), "opacity": this.GetOpacity(), "isInteractive": this.IsInteractive() };
        }
        MoveInstanceAdjacent(e, t, s2) {
          const a2 = e.GetWorldInfo(), i2 = t.GetWorldInfo();
          if (a2.GetLayer() !== this || i2.GetLayer() !== this) throw new Error("can't arrange Z order unless both objects on this layer");
          const r2 = a2.GetZIndex();
          let n = i2.GetZIndex();
          return r2 !== n + (s2 ? 1 : -1) && (C33.arrayRemove(this._instances, r2), r2 < n && n--, s2 && n++, n === this._instances.length ? this._instances.push(e) : this._instances.splice(n, 0, e), this.SetZIndicesChanged(e), true);
        }
        _MergeSortedZArrays(e, t) {
          const s2 = [];
          let a2 = 0, i2 = 0, r2 = e.length, n = t.length;
          for (; a2 < r2 && i2 < n; ) {
            const r3 = e[a2], n2 = t[i2];
            r3.GetWorldInfo()._GetLastCachedZIndex() < n2.GetWorldInfo()._GetLastCachedZIndex() ? (s2.push(r3), ++a2) : (s2.push(n2), ++i2);
          }
          for (; a2 < r2; ++a2) s2.push(e[a2]);
          for (; i2 < n; ++i2) s2.push(t[i2]);
          return s2;
        }
        _MergeAllSortedZArrays_pass(e) {
          const t = [], s2 = e.length;
          for (let a2 = 0; a2 < s2 - 1; a2 += 2) {
            const s3 = e[a2], i2 = e[a2 + 1];
            t.push(this._MergeSortedZArrays(s3, i2));
          }
          return s2 % 2 == 1 && t.push(e[s2 - 1]), t;
        }
        _MergeAllSortedZArrays(e) {
          for (; e.length > 1; ) e = this._MergeAllSortedZArrays_pass(e);
          return e[0];
        }
        _GetRenderCellInstancesToDraw() {
          return this._UpdateZIndices(), C33.clearArray(renderCellArr), this._renderGrid.QueryRange(this.GetViewport(), renderCellArr), renderCellArr.length ? 1 === renderCellArr.length ? renderCellArr[0] : this._MergeAllSortedZArrays(renderCellArr) : [];
        }
        ShouldDraw() {
          return this.IsVisible() && this.GetOpacity() > 0 && this._DrawsAnyContentInSelfOrSubLayers();
        }
        _DrawsAnyContentInSelfOrSubLayers() {
          if (this.HasInstances() || !this.IsTransparent() || this._userScriptDispatcher.HasAnyHandlerFor("beforedraw") || this._userScriptDispatcher.HasAnyHandlerFor("afterdraw")) return true;
          for (const e of this._subLayers) if (e._DrawsAnyContentInSelfOrSubLayers()) return true;
          return false;
        }
        UsesOwnTexture() {
          return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect();
        }
        SelfOrAnySubLayerUsesOwnTexture() {
          if (this.UsesOwnTexture()) return true;
          for (const e of this._subLayers) if (e.SelfOrAnySubLayerUsesOwnTexture()) return true;
          return false;
        }
        GetRenderTarget() {
          return this._curRenderTarget;
        }
        Get2DScaleFactorToZ(e) {
          if (this._layout.IsOrthographicProjection()) return 1;
          {
            const t = this.Get3DCameraZ();
            return t / (t - e);
          }
        }
        GetResolutionScaleFactorToZ(e) {
          const t = this._runtime.GetRenderScale();
          if (this._layout.IsOrthographicProjection()) return t;
          {
            const s2 = this.Get3DCameraZ();
            return this.GetDefaultCameraZ() / Math.abs(s2 - e) * t;
          }
        }
        _SetMVMatrixChanged() {
          this._isMVMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;
        }
        _GetModelViewMatrix(e) {
          return this._isMVMatrixChanged && (this._CalculateModelViewMatrix(e, this._modelViewMatrix, 0, 0, null), this._isMVMatrixChanged = false), this._modelViewMatrix;
        }
        Get2DCameraZ(e) {
          return this.GetDefaultCameraZ(e) / this.GetNormalScale();
        }
        Get3DCameraZ() {
          return this.Has3DCamera() ? this.GetLayout().Get3DCameraPosition()[2] : this.Get2DCameraZ();
        }
        GetCameraPosition() {
          if (this.Has3DCamera()) {
            const e = this.GetLayout().Get3DCameraPosition();
            return [e[0], e[1], e[2]];
          }
          return this._Get2DCameraPosition();
        }
        _Get2DCameraPosition(e = 0, t = 0, s2 = 0) {
          const a2 = this._runtime, i2 = this.GetLayout(), r2 = a2.GetParallaxXOrigin(), n = a2.GetParallaxYOrigin();
          let l2 = (this.GetScrollX() - r2) * this._parallaxX + r2, o2 = (this.GetScrollY() - n) * this._parallaxY + n;
          a2.IsPixelRoundingEnabled() && (l2 = Math.round(l2), o2 = Math.round(o2));
          let h = l2 + e, c2 = o2 + t;
          const d2 = i2.IsOrthographicProjection() ? this.GetDefaultCameraZ(s2) : this.Get2DCameraZ(s2), [_, u] = this._GetVanishingPoint();
          if (0.5 !== _ || 0.5 !== u) {
            const e2 = this.GetDefaultCameraZ(s2) / d2;
            let t2 = (_ - 0.5) * a2.GetViewportWidth() / e2, i3 = (u - 0.5) * a2.GetViewportHeight() / e2;
            const r3 = this.GetAngle();
            0 !== r3 && (tempVec2.set(t2, i3), tempVec2.rotate(r3), t2 = tempVec2.getX(), i3 = tempVec2.getY()), h += t2, c2 += i3;
          }
          return [h, c2, d2];
        }
        _CalculateModelViewMatrix(e, t, s2, a2, i2) {
          const r2 = this._runtime, n = this.GetLayout();
          if (this.Has3DCamera()) {
            vec32.copy(camVector, n.Get3DCameraPosition()), vec32.copy(lookVector, n.Get3DCameraLookAt()), vec32.copy(upVector, n.Get3DCameraUpVector());
            const e2 = r2.GetParallaxXOrigin(), t2 = r2.GetParallaxYOrigin(), s3 = lookVector[0] - camVector[0], a3 = lookVector[1] - camVector[1], i3 = lookVector[2] - camVector[2];
            camVector[0] = (camVector[0] - e2) * this._parallaxX + e2, camVector[1] = (camVector[1] - t2) * this._parallaxY + t2, camVector[2] *= Math.max(this._parallaxX, this._parallaxY), lookVector[0] = camVector[0] + s3, lookVector[1] = camVector[1] + a3, lookVector[2] = camVector[2] + i3;
          } else {
            const [e2, t2, r3] = this._Get2DCameraPosition(s2, a2, i2);
            vec32.set(camVector, e2, t2, r3), vec32.set(lookVector, e2, t2, r3 - 100);
            const n2 = this.GetAngle();
            0 === n2 ? vec32.set(upVector, 0, 1, 0) : vec32.set(upVector, Math.sin(n2), Math.cos(n2), 0);
          }
          e.CalculateLookAtModelView(t, camVector, lookVector, upVector, i2 || r2.GetViewportHeight());
        }
        _SetProjectionMatrixChanged() {
          this._isProjectionMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;
        }
        _GetProjectionMatrix(e) {
          return this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(e), this._isProjectionMatrixChanged = false), this._projectionMatrix;
        }
        _CalculateProjectionMatrix(e) {
          const t = this._runtime.GetCanvasManager(), [s2, a2] = this._GetVanishingPoint();
          if (this._layout.IsOrthographicProjection()) e.CalculateOrthographicMatrix(this._projectionMatrix, t.GetDrawWidth(), t.GetDrawHeight());
          else if (0.5 === s2 && 0.5 === a2) mat42.copy(this._projectionMatrix, t.GetDefaultProjectionMatrix());
          else {
            const i2 = t.GetDrawWidth(), r2 = t.GetDrawHeight();
            e.CalculatePerspectiveMatrix(this._projectionMatrix, i2 / r2, s2, a2);
          }
        }
        _SetTransform(e, t = true, s2 = 0, a2 = 0, i2 = 0) {
          t && e.SetProjectionMatrix(this._GetProjectionMatrix(e));
          let r2 = null;
          0 === s2 && 0 === a2 && 0 === i2 ? r2 = this._GetModelViewMatrix(e) : (this._CalculateModelViewMatrix(e, tempMat4, s2, a2, i2), r2 = tempMat4), e.SetModelViewMatrix(r2);
        }
        PrepareForDraw(e) {
          this._SetTransform(e), e.SetBaseZ(this.GetZElevation());
        }
        _MaybeStartWebGLProfiling(e) {
          let t = null;
          if (e.IsWebGL() && this._runtime.IsGPUProfiling()) {
            const s2 = this._runtime.GetCanvasManager().GetLayerTimingsBuffer(this);
            s2 && (t = s2.AddTimeElapsedQuery(), e.StartQuery(t));
          }
          return t;
        }
        _MaybeStartWebGPUProfiling(e) {
          if (e.IsWebGPU() && this._runtime.IsGPUProfiling()) {
            const t = 2 * (this.GetIndex() + 1);
            e.StartMeasuringRenderPassTime(t, t + 1);
          }
        }
        _FireDrawEvent(e, t) {
          if (this._userScriptDispatcher.HasAnyHandlerFor(t)) {
            e.SetTextureFillMode(), e.SetTexture(null), e.SetAlphaBlend(), e.ResetCullState(), e.SetColorRgba(1, 1, 1, 1), e.SetBaseZ(this.GetZElevation()), e.SetCurrentZ(0);
            const s2 = new C33.Event(t);
            s2.renderer = this._runtime.GetCanvasManager().GetIRenderer(), this.DispatchUserScriptEvent(s2);
          }
        }
        Draw(e, t, s2) {
          const a2 = this._runtime.GetCanvasManager(), i2 = this.UsesOwnTexture();
          let r2 = null;
          const n = this._MaybeStartWebGLProfiling(e);
          if (this._MaybeStartWebGPUProfiling(e), i2) {
            const t2 = { sampling: this._runtime.GetSampling(), isSampled: true, canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };
            "low" === a2.GetCurrentFullscreenScalingQuality() && (t2.width = a2.GetDrawWidth(), t2.height = a2.GetDrawHeight()), r2 = this._runtime.GetAdditionalRenderTarget(t2), this._curRenderTarget = r2, e.SetRenderTarget(r2), this.IsTransparent() && e.ClearRgba(0, 0, 0, 0);
          } else this._curRenderTarget = t, e.SetRenderTarget(t);
          if (this.IsTransparent() || e.Clear(this._backgroundColor), this._layout._DrawLayerList(e, this._curRenderTarget, this._subLayers, i2 && this.IsTransparent()), this._MaybeStartWebGPUProfiling(e), this._SetTransform(e), e.SetBaseZ(this.GetZElevation()), e.SetDepthEnabled(this.RendersIn3DMode()), this._FireDrawEvent(e, "beforedraw"), this.GetNormalScale() > Number.EPSILON) {
            this._UpdateZIndices();
            const t2 = this.UsesRenderCells() && 0 === this.GetZElevation() && !this._anyInstanceZElevated;
            this.Has3DCamera() ? this._DrawInstances_3DCamera(e) : t2 ? this._DrawInstances_RenderCells(e) : this._DrawInstances(e, this._GetInstancesInDrawOrder());
          }
          this._FireDrawEvent(e, "afterdraw"), e.SetBaseZ(0), e.SetCurrentZ(0), i2 && (e.SetDepthEnabled(false), this._DrawLayerOwnTextureToRenderTarget(e, r2, t, s2)), n && e.EndQuery(n), this._curRenderTarget = null;
        }
        _DrawInstances(e, t) {
          const s2 = this.GetViewport(), a2 = this._curRenderTarget, i2 = this.GetLayout().IsOrthographicProjection(), r2 = this.GetLayout().HasVanishingPointOutsideViewport();
          let n = null;
          for (let l2 = 0, o2 = t.length; l2 < o2; ++l2) {
            const o3 = t[l2];
            if (o3 === n) continue;
            n = o3;
            const h = o3.GetWorldInfo();
            h.IsVisible() && h.IsInViewport(s2, r2, i2) && this._DrawInstanceMaybeWithEffects(o3, h, e, a2);
          }
        }
        _DrawInstances_3DCamera(e) {
          const t = this._curRenderTarget, s2 = this._GetViewFrustum(), a2 = tempInstanceList1, i2 = tempInstanceList2, r2 = this._GetInstancesInDrawOrder();
          for (let n = 0, l2 = r2.length; n < l2; ) {
            const o2 = r2[n], h = o2.GetWorldInfo();
            if (!h.IsVisible() || !h.IsInViewport3D(s2)) {
              ++n;
              continue;
            }
            (!o2.RendersToOwnZPlane() || h.GetDepth() > 0) && i2.push(o2);
            const c2 = o2.GetWorldInfo().GetTotalZElevation();
            a2.push(o2);
            let d2 = n + 1;
            for (; d2 < l2; ++d2) {
              const e2 = r2[d2], t2 = e2.GetWorldInfo();
              if (t2.IsVisible() && t2.IsInViewport3D(s2)) {
                if (t2.GetTotalZElevation() !== c2) break;
                e2.RendersToOwnZPlane() ? (t2.GetDepth() > 0 && i2.push(e2), a2.push(e2)) : i2.push(e2);
              }
            }
            if (1 !== a2.length || a2[0].MustMitigateZFighting()) {
              this._DrawCoplanarInstances_3DCamera(e, a2);
              for (let s3 = 0, a3 = i2.length; s3 < a3; ++s3) {
                const a4 = i2[s3], r3 = a4.GetWorldInfo();
                r3._SetDrawNonBackFacesOnly(true), this._DrawInstanceMaybeWithEffects(a4, r3, e, t), r3._SetDrawNonBackFacesOnly(false);
              }
            } else {
              this._DrawInstanceMaybeWithEffects(o2, h, e, t);
              for (let s3 = 0, a3 = i2.length; s3 < a3; ++s3) {
                const a4 = i2[s3];
                if (a4 === o2) continue;
                const r3 = a4.GetWorldInfo();
                r3.GetLayer()._DrawInstanceMaybeWithEffects(a4, r3, e, t);
              }
            }
            n = d2, C33.clearArray(a2), C33.clearArray(i2);
          }
        }
        _DrawCoplanarInstances_3DCamera(e, t) {
          const s2 = this._curRenderTarget;
          e.CoplanarStartStencilPass();
          for (let s3 = 0, a2 = t.length; s3 < a2; ++s3) {
            const a3 = t[s3], i2 = a3.GetWorldInfo();
            i2._SetDrawBackFaceOnly(true), this._DrawInstance(a3, i2, e);
          }
          e.CoplanarStartColorPass();
          for (let a2 = 0, i2 = t.length; a2 < i2; ++a2) {
            const i3 = t[a2], r2 = i3.GetWorldInfo();
            this._DrawInstanceMaybeWithEffects(i3, r2, e, s2), r2._SetDrawBackFaceOnly(false);
          }
          e.CoplanarRestoreStandardRendering();
        }
        _DrawInstances_RenderCells(e) {
          const t = this._renderGrid, s2 = this._curRenderCells, a2 = this._lastRenderCells, i2 = this.GetViewport();
          let r2;
          s2.set(t.XToCell(i2.getLeft()), t.YToCell(i2.getTop()), t.XToCell(i2.getRight()), t.YToCell(i2.getBottom())), this._isRenderListUpToDate && s2.equals(a2) ? r2 = this._lastRenderList : (r2 = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = true, a2.copy(s2)), this._DrawInstances(e, r2), r2 !== this._lastRenderList && C33.shallowAssignArray(this._lastRenderList, r2);
        }
        _DrawInstanceMaybeWithEffects(e, t, s2, a2) {
          t.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(e, t, s2, a2) : this._DrawInstance(e, t, s2);
        }
        _DrawInstance(e, t, s2) {
          const a2 = t.GetRendererStateGroup();
          s2.GetCurrentStateGroup() !== a2 && a2.Apply(), e.Draw(s2);
        }
        _DrawInstanceWithEffectsAndRestore(e, t, s2, a2) {
          this._DrawInstanceWithEffects(e, t, s2, a2, null) && this._SetTransform(s2);
        }
        _DrawInstanceWithEffects(e, t, s2, a2, i2) {
          const r2 = t.GetInstanceEffectList().GetEffectChain();
          return r2.Render(s2, a2, { contentObject: e, blendMode: t.GetBlendMode(), devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), time: e.GetInstanceGameTime(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: t.GetBoundingBox(), drawSurfaceRect: r2.CanSkipCalculatingDrawSurfaceRect() ? null : this._InstanceBoxToDrawSurface(t), drawContentHook: i2 && i2.drawContentHook, compositOffX: i2 && i2.compositOffX, compositOffY: i2 && i2.compositOffY, compositRtWidth: i2 && i2.compositRtWidth, compositRtHeight: i2 && i2.compositRtHeight, updateOwnProjection: i2 && i2.updateOwnProjection }), s2.SetBaseZ(this.GetZElevation()), r2.DidChangeTransform();
        }
        _DrawLayerOwnTextureToRenderTarget(e, t, s2, a2) {
          const i2 = this._effectList.GetActiveEffectTypes(), r2 = this._runtime;
          0 === i2.length ? (e.SetRenderTarget(s2), e.SetTextureFillMode(), a2 && 0 === this._blendMode && this.HasDefaultColor() ? e.CopyRenderTarget(t) : (e.SetBlendMode(this._blendMode), e.SetColor(this._premultipliedColor), e.DrawRenderTarget(t)), e.InvalidateRenderTarget(t), r2.ReleaseAdditionalRenderTarget(t)) : this.GetEffectChain().Render(e, s2, { contentObject: this, blendMode: this.GetBlendMode(), devicePixelRatio: r2.GetEffectDevicePixelRatioParam(), layerScale: r2.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: this.GetViewport(), drawSurfaceRect: null, invalidateRenderTargets: true });
        }
        GetOwnScale() {
          return this._scale;
        }
        SetOwnScale(e) {
          this._scale !== e && (this._scale = e, this._layout.BoundScrolling(), this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        GetRenderScale() {
          return this.GetNormalScale() * this._runtime.GetRenderScale();
        }
        GetDisplayScale() {
          return this.GetNormalScale() * this._runtime.GetDisplayScale();
        }
        GetNormalScale() {
          return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1;
        }
        _MaybeUpdateViewport() {
          if (!this._isViewportChanged) return;
          this._isViewportChanged = false;
          const e = this._runtime.GetParallaxXOrigin(), t = this._runtime.GetParallaxYOrigin(), s2 = (this.GetScrollX() - e) * this._parallaxX + e, a2 = (this.GetScrollY() - t) * this._parallaxY + t, i2 = this.GetNormalScale(), r2 = this._runtime.GetViewportWidth() / i2, n = this._runtime.GetViewportHeight() / i2;
          let l2 = s2 - r2 / 2, o2 = a2 - n / 2;
          this._runtime.IsPixelRoundingEnabled() && (l2 = Math.round(l2), o2 = Math.round(o2));
          const h = this._viewportZ0;
          h.set(l2, o2, l2 + r2, o2 + n);
          const c2 = this.GetAngle();
          0 !== c2 && (tmpRect.copy(h), tmpRect.offset(-h.midX(), -h.midY()), tmpQuad.setFromRotatedRect(tmpRect, c2), tmpQuad.getBoundingBox(tmpRect), tmpRect.offset(h.midX(), h.midY()), h.copy(tmpRect));
          const d2 = this._zElevation;
          this.GetViewportForZ(d2, this._viewport), this.Has3DCamera() ? this.CalculateViewport3D(d2, this._viewport3D) : this._viewport3D.copy(this._viewport);
        }
        CalculateViewport3D(e, t) {
          const s2 = this._runtime.GetCanvasManager(), a2 = s2.GetCssWidth(), i2 = s2.GetCssHeight(), [r2, n] = this.CanvasCssToLayer(0, 0, e), [l2, o2] = this.CanvasCssToLayer(a2, 0, e), [h, c2] = this.CanvasCssToLayer(a2, i2, e), [d2, _] = this.CanvasCssToLayer(0, i2, e);
          let u = Math.min(r2, l2, h, d2), G = Math.min(n, o2, c2, _), p = Math.max(r2, l2, h, d2), f2 = Math.max(n, o2, c2, _);
          isFinite(u) || (u = -1 / 0), isFinite(G) || (G = -1 / 0), isFinite(p) || (p = 1 / 0), isFinite(f2) || (f2 = 1 / 0), t.set(u, G, p, f2);
        }
        CanvasCssToLayer(e, t, s2 = 0) {
          return this._CanvasToLayer(e, t, s2, this.GetDisplayScale());
        }
        DrawSurfaceToLayer(e, t, s2 = 0) {
          return this._CanvasToLayer(e, t, s2, this.GetRenderScale() * this.GetDevicePixelRatio());
        }
        _CanvasToLayer(e, t, s2, a2) {
          const i2 = this._runtime, r2 = i2.GetRenderer(), n = this.GetNormalScale(), l2 = i2.GetViewportWidth() / n, o2 = i2.GetViewportHeight() / n, h = tempVec4;
          vec42.set(h, 0, 0, l2, o2), e /= a2, t = h[3] - t / a2;
          const c2 = this._GetProjectionMatrix(r2), d2 = this._GetModelViewMatrix(r2), _ = tempVec3;
          return C33.Gfx.UnprojectScreenToWorldZ(e, t, s2, d2, c2, h, _) ? [_[0], _[1]] : [NaN, NaN];
        }
        CanvasCssToLayer_DefaultTransform(e, t) {
          const s2 = this._scale, a2 = this._scaleRate, i2 = this._parallaxX, r2 = this._parallaxY, n = this._angle, l2 = this.Has3DCamera();
          l2 && this.GetLayout().Set3DCameraEnabled(false), this._scale = 1, this._scaleRate = 1, this._parallaxX = 1, this._parallaxY = 1, this._angle = 0, this._SetMVMatrixChanged();
          const o2 = this.CanvasCssToLayer(e, t);
          return this._scale = s2, this._scaleRate = a2, this._parallaxX = i2, this._parallaxY = r2, this._angle = n, this._SetMVMatrixChanged(), l2 && this.GetLayout().Set3DCameraEnabled(true), o2;
        }
        LayerToCanvasCss(e, t, s2 = 0) {
          return this._LayerToCanvas(e, t, s2, this.GetDisplayScale());
        }
        LayerToDrawSurface(e, t, s2 = 0) {
          return this._LayerToCanvas(e, t, s2, this.GetRenderScale() * this.GetDevicePixelRatio());
        }
        _LayerToCanvas(e, t, s2, a2) {
          const i2 = this._runtime, r2 = i2.GetRenderer(), n = this.GetNormalScale(), l2 = i2.GetViewportWidth() / n, o2 = i2.GetViewportHeight() / n, h = tempVec4;
          vec42.set(h, 0, 0, l2, o2);
          const c2 = this._GetProjectionMatrix(r2), d2 = this._GetModelViewMatrix(r2), _ = tempVec3;
          return C33.Gfx.Project(e, t, s2, d2, c2, h, _) ? [_[0] * a2, (h[3] - _[1]) * a2] : [NaN, NaN];
        }
        _GetLayerToDrawSurfaceScale(e, t) {
          return e *= this.GetRenderScale() * this.GetDevicePixelRatio(), 0 !== t && (e *= this.Get2DScaleFactorToZ(t)), e;
        }
        _InstanceBoxToDrawSurface(e) {
          const t = e.GetBoundingBox(), s2 = e.GetTotalZElevation(), a2 = e.GetDepth(), i2 = s2 + a2, r2 = t.getLeft(), n = t.getTop(), l2 = t.getRight(), o2 = t.getBottom();
          if (this.Has3DCamera()) {
            if (this._IsPointBehindNearPlane(r2, n, s2) || this._IsPointBehindNearPlane(l2, n, s2) || this._IsPointBehindNearPlane(l2, o2, s2) || this._IsPointBehindNearPlane(r2, o2, s2)) return null;
            if (a2 > 0 && (this._IsPointBehindNearPlane(r2, n, i2) || this._IsPointBehindNearPlane(l2, n, i2) || this._IsPointBehindNearPlane(l2, o2, i2) || this._IsPointBehindNearPlane(r2, o2, i2))) return null;
          } else if (i2 >= this.Get2DCameraZ()) return null;
          let [h, c2] = this.LayerToDrawSurface(r2, n, s2), [d2, _] = this.LayerToDrawSurface(l2, o2, s2);
          if (0 !== this.GetAngle() || a2 > 0 || this.Has3DCamera()) {
            const [e2, t2] = this.LayerToDrawSurface(l2, n, s2), [u, G] = this.LayerToDrawSurface(r2, o2, s2);
            if (a2 > 0) {
              const [s3, a3] = this.LayerToDrawSurface(r2, n, i2), [p, f2] = this.LayerToDrawSurface(l2, n, i2), [I, C] = this.LayerToDrawSurface(l2, o2, i2), [m, y] = this.LayerToDrawSurface(r2, o2, i2);
              let S = Math.min(h, d2, e2, u, s3, p, I, m);
              d2 = Math.max(h, d2, e2, u, s3, p, I, m), h = S, S = Math.min(c2, _, t2, G, a3, f2, C, y), _ = Math.max(c2, _, t2, G, a3, f2, C, y), c2 = S;
            } else {
              let s3 = Math.min(h, d2, e2, u);
              d2 = Math.max(h, d2, e2, u), h = s3, s3 = Math.min(c2, _, t2, G), _ = Math.max(c2, _, t2, G), c2 = s3;
            }
          }
          return tmpRect.set(h, c2, d2, _), tmpRect;
        }
        _GetViewFrustum() {
          return this._isViewFrustumChanged && (this._UpdateViewFrustum(), this._isViewFrustumChanged = false), this._viewFrustum;
        }
        _UpdateViewFrustum() {
          const e = this._runtime.GetRenderer(), t = this._GetProjectionMatrix(e), s2 = this._GetModelViewMatrix(e);
          this._viewFrustum.CalculatePlanes(s2, t);
        }
        _IsPointBehindNearPlane(e, t, s2) {
          return this._GetViewFrustum().IsBehindNearPlane(e, t, s2);
        }
        _SaveToJson() {
          return { "d": this.IsDynamic(), "s": this.GetOwnScale(), "a": this.GetOwnAngle(), "v": this._IsVisibleFlagSet(), "i": this.IsInteractive(), "html": this.IsHTMLElementsLayer(), "bc": this._backgroundColor.toJSON(), "t": this.IsTransparent(), "sx": this._scrollX, "sy": this._scrollY, "hosp": this._hasOwnScrollPosition, "px": this.GetParallaxX(), "py": this.GetParallaxY(), "c": this._color.toJSON(), "sr": this.GetScaleRate(), "fx": this._effectList.SaveToJson(), "cg": this._createdGlobalUids };
        }
        _LoadFromJson(e) {
          this._isDynamic = !!e["d"], this._scale = e["s"], this._angle = e["a"], this._isVisible = !!e["v"], this._isInteractive = !e.hasOwnProperty("i") || e["i"], this._isHTMLElementsLayer = !!e["html"], this._backgroundColor.setFromJSON(e["bc"]), this._isTransparent = !!e["t"], e.hasOwnProperty("sx") && (this._scrollX = e["sx"]), e.hasOwnProperty("sy") && (this._scrollY = e["sy"]), e.hasOwnProperty("hosp") && (this._hasOwnScrollPosition = !!e["hosp"]), this._parallaxX = e["px"], this._parallaxY = e["py"], this._color.setFromJSON(e["c"]), this._UpdatePremultipliedColor(), this._scaleRate = e["sr"], C33.shallowAssignArray(this._createdGlobalUids, e["cg"]), C33.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
          const t = new Set(this._createdGlobalUids);
          let s2 = 0;
          for (let e2 = 0, a2 = this._initialInstances.length; e2 < a2; ++e2) t.has(this._initialInstances[e2][2]) || (this._initialInstances[s2] = this._initialInstances[e2], ++s2);
          C33.truncateArray(this._initialInstances, s2), this._effectList.LoadFromJson(e["fx"]), this._needsRebuildEffectChainSteps = true;
        }
        _LoadFromJsonAfterInstances() {
          this._SortInstancesByLastCachedZIndex(false), this.SetZIndicesChanged(), this._SetMVMatrixChanged(), this._SetProjectionMatrixChanged();
        }
        GetILayer() {
          return this._iLayer;
        }
        UserScriptDispatcher() {
          return this._userScriptDispatcher;
        }
        DispatchUserScriptEvent(e) {
          e.layer = this.GetILayer(), this._userScriptDispatcher.dispatchEvent(e);
        }
        SortAndAddInstancesByZIndex(e, t = false, s2 = false) {
          if (this._instances.includes(e)) return t && this._instances.sort((e2, t2) => (e2.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t2.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), void (s2 && this._instances.forEach((e2, t2) => e2.GetWorldInfo()._SetZIndex(t2)));
          if (e.HasChildren()) {
            const t2 = [...e.allChildren()];
            t2.push(e), t2.sort((e2, t3) => (e2.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t3.GetWorldInfo().GetSceneGraphZIndex() ?? 0));
            for (const e2 of t2) if (e2.IsInContainer()) for (const s3 of e2.siblings()) {
              if (t2.includes(s3)) continue;
              const e3 = [...s3.allChildren()];
              e3.push(s3), e3.sort((e4, t3) => (e4.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t3.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), e3 && e3.length && t2.splice(t2.length, 0, ...e3);
            }
            for (const e2 of t2) e2.GetPlugin().IsWorldType() && this._AddInstance(e2, true);
            s2 && this._instances.forEach((e2, t3) => e2.GetWorldInfo()._SetZIndex(t3));
          } else {
            if (e.GetPlugin().IsWorldType() && this._AddInstance(e, true), !e.IsInContainer()) return void (s2 && this._instances.forEach((e2, t2) => e2.GetWorldInfo()._SetZIndex(t2)));
            for (const t2 of e.siblings()) {
              const e2 = [...t2.allChildren()];
              if (e2.push(t2), e2.sort((e3, t3) => (e3.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t3.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), e2 && e2.length) for (const t3 of e2) t3.GetPlugin().IsWorldType() && this._AddInstance(t3, true);
            }
            s2 && this._instances.forEach((e2, t2) => e2.GetWorldInfo()._SetZIndex(t2));
          }
        }
      };
    }
    var SortByInstLastCachedZIndex;
    var SortByInstZElevation;
    {
      let vec3EqualsXYZ2 = function(e, t, s2, r2) {
        return e[0] === Math.fround(t) && e[1] === Math.fround(s2) && e[2] === Math.fround(r2);
      }, MaybePrepareLayerDraw2 = function(e, t) {
        lastLayerPreparedForDrawing !== e && (e.PrepareForDraw(t), lastLayerPreparedForDrawing = e);
      };
      vec3EqualsXYZ = vec3EqualsXYZ2, MaybePrepareLayerDraw = MaybePrepareLayerDraw2;
      const C33 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, tempDestRect = C33.New(C33.Rect), tempSrcRect = C33.New(C33.Rect), tempLayoutRect = C33.New(C33.Rect), tempColor = C33.New(C33.Color), glMatrix = self.glMatrix, vec32 = glMatrix.vec3, tempRender3dList = [], tempInstanceList1 = [], tempInstanceList2 = [], tempInstanceList3 = [];
      let lastLayerPreparedForDrawing = null;
      C33.Layout = class extends C33.DefendedBase {
        constructor(e, t, s2) {
          super(), this._layoutManager = e, this._runtime = e.GetRuntime(), this._name = s2[0], this._originalWidth = s2[1], this._originalHeight = s2[2], this._width = s2[1], this._height = s2[2], this._isUnboundedScrolling = !!s2[3], this._isOrthographicProjection = !!s2[4], this._vanishingPointX = s2[5], this._vanishingPointY = s2[6], this._eventSheetName = s2[7], this._eventSheet = null, this._sid = s2[8], this._index = t, this._scrollX = 0, this._scrollY = 0, this._scale = 1, this._angle = 0, this._initialObjectClasses = /* @__PURE__ */ new Set(), this._textureLoadedTypes = /* @__PURE__ */ new Set(), this._textureLoadPendingPromises = /* @__PURE__ */ new Set(), this._createdInstances = [], this._createdPersistedInstances = [], this._createdPersistedInstancesToDataMap = /* @__PURE__ */ new Map(), this._createdPersistedIndexToInstanceMap = /* @__PURE__ */ new Map(), this._initialNonWorld = [], this._is3dCameraEnabled = false, this._cam3dposition = vec32.create(), this._cam3dlook = vec32.create(), this._cam3dup = vec32.create(), this._rootLayers = [], this._allLayersFlat = [], this._layersByName = /* @__PURE__ */ new Map(), this._layersBySid = /* @__PURE__ */ new Map(), this._pendingSetHTMLLayerCount = -1;
          const r2 = this._runtime.GetCanvasManager();
          this._effectList = C33.New(C33.EffectList, this, s2[11]), this._effectChain = C33.New(C33.Gfx.EffectChain, r2.GetEffectChainManager(), { drawContent: (e2, t2) => {
            const s3 = t2.GetContentObject().GetRenderTarget();
            e2.ResetColor(), e2.DrawRenderTarget(s3), e2.InvalidateRenderTarget(s3), r2.ReleaseAdditionalRenderTarget(s3);
          }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasFullScreenQualityLow = false, this._curRenderTarget = null, this._persistData = {}, this._persistedIntances = /* @__PURE__ */ new Map(), this._isFirstVisit = true, this._iLayout = new self.ILayout(this), this._userScriptDispatcher = C33.New(C33.Event.Dispatcher);
          for (const e2 of s2[9]) this._rootLayers.push(C33.Layer.CreateFromExportData(this, null, e2));
          this._ReindexLayers();
          for (const e2 of this.allLayers()) e2._InitInitialInstances();
          for (const e2 of s2[10]) {
            const t2 = this._runtime.GetObjectClassByIndex(e2[1]);
            if (!t2) throw new Error("missing nonworld object class");
            t2.GetDefaultInstanceData() || t2.SetDefaultInstanceData(e2), this._initialNonWorld.push(e2), this._AddInitialObjectClass(t2);
          }
        }
        Release() {
          for (const e of this._allLayersFlat) e.Release();
          C33.clearArray(this._allLayersFlat), this._textureLoadPendingPromises.clear(), this._eventSheet = null, this._layoutManager = null, this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetName() {
          return this._name;
        }
        GetSID() {
          return this._sid;
        }
        GetIndex() {
          return this._index;
        }
        GetEffectList() {
          return this._effectList;
        }
        GetEffectChain() {
          return this._MaybeRebuildEffectChainSteps(), this._effectChain;
        }
        _MaybeRebuildEffectChainSteps() {
          const e = "low" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();
          if (!this._needsRebuildEffectChainSteps && this._wasFullScreenQualityLow === e && !this._effectChain.NeedsRebuild()) return;
          const t = this.GetEffectList().GetActiveEffectTypes();
          this._effectChain.BuildSteps(t.map((e2) => e2.GetShaderProgram()), { indexMap: t.map((e2) => e2.GetIndex()), forcePostDraw: e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasFullScreenQualityLow = e;
        }
        UpdateActiveEffects() {
          this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;
        }
        GetMinLayerScale() {
          let e = this._allLayersFlat[0].GetNormalScale();
          for (let t = 1, s2 = this._allLayersFlat.length; t < s2; ++t) {
            const s3 = this._allLayersFlat[t];
            0 === s3.GetParallaxX() && 0 === s3.GetParallaxY() || (e = Math.min(e, s3.GetNormalScale()));
          }
          return e;
        }
        _GetScrollBoundMarginHorizontal() {
          return 0.5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale();
        }
        _GetScrollBoundMarginVertical() {
          return 0.5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale();
        }
        GetScrollLeftBound() {
          return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginHorizontal();
        }
        GetScrollRightBound() {
          return this.IsUnboundedScrolling() ? 1 / 0 : this.GetWidth() - this._GetScrollBoundMarginHorizontal();
        }
        GetScrollTopBound() {
          return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginVertical();
        }
        GetScrollBottomBound() {
          return this.IsUnboundedScrolling() ? 1 / 0 : this.GetHeight() - this._GetScrollBoundMarginVertical();
        }
        SetScrollX(e) {
          const t = this.GetScrollLeftBound(), s2 = this.GetScrollRightBound();
          e > s2 && (e = s2), e < t && (e = t), this._scrollX !== e && (this._scrollX = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        GetScrollX() {
          return this._scrollX;
        }
        SetScrollY(e) {
          const t = this.GetScrollTopBound(), s2 = this.GetScrollBottomBound();
          e > s2 && (e = s2), e < t && (e = t), this._scrollY !== e && (this._scrollY = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        GetScrollY() {
          return this._scrollY;
        }
        IsUnboundedScrolling() {
          return this._isUnboundedScrolling;
        }
        BoundScrolling() {
          this.SetScrollX(this.GetScrollX()), this.SetScrollY(this.GetScrollY());
          for (const e of this._allLayersFlat) e.IsOwnScrollPositionEnabled() && (e.SetScrollX(e.GetScrollX()), e.SetScrollY(e.GetScrollY()));
        }
        SetVanishingPointXY(e, t) {
          this._vanishingPointX === e && this._vanishingPointY === t || (this._vanishingPointX = e, this._vanishingPointY = t, this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender()));
        }
        GetVanishingPointX() {
          return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointX;
        }
        GetVanishingPointY() {
          return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointY;
        }
        GetVanishingPoint() {
          return [this.GetVanishingPointX(), this.GetVanishingPointY()];
        }
        HasVanishingPointOutsideViewport() {
          const e = this.GetVanishingPointX(), t = this.GetVanishingPointY();
          return e < 0 || e > 1 || t < 0 || t > 1;
        }
        SetPerspectiveProjection() {
          this._isOrthographicProjection && (this._isOrthographicProjection = false, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        SetOrthographicProjection() {
          this._isOrthographicProjection || (this._isOrthographicProjection = true, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        IsOrthographicProjection() {
          return this._isOrthographicProjection;
        }
        IsPerspectiveProjection() {
          return !this.IsOrthographicProjection();
        }
        Set3DCameraEnabled(e) {
          e = !!e, this._is3dCameraEnabled !== e && (this._is3dCameraEnabled = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        Is3DCameraEnabled() {
          return this._is3dCameraEnabled;
        }
        Set3DCameraOrientation(e, t, s2, r2, a2, n, i2, o2, l2) {
          vec3EqualsXYZ2(this._cam3dposition, e, t, s2) && vec3EqualsXYZ2(this._cam3dlook, r2, a2, n) && vec3EqualsXYZ2(this._cam3dup, i2, o2, l2) || (vec32.set(this._cam3dposition, e, t, s2), vec32.set(this._cam3dlook, r2, a2, n), vec32.set(this._cam3dup, i2, o2, l2), this.Set3DCameraChanged());
        }
        Set3DCameraChanged() {
          this._SetAllLayersMVChanged(), this._runtime.UpdateRender();
        }
        Get3DCameraPosition() {
          return this._cam3dposition;
        }
        Get3DCameraLookAt() {
          return this._cam3dlook;
        }
        Get3DCameraUpVector() {
          return this._cam3dup;
        }
        GetScale() {
          return this._scale;
        }
        SetScale(e) {
          this._scale !== e && (this._scale = e, this._SetAllLayersMVChanged(), this.BoundScrolling(), this._runtime.UpdateRender());
        }
        SetAngle(e) {
          e = C33.clampAngle(e), this._angle !== e && (this._angle = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        GetAngle() {
          return this._angle;
        }
        GetWidth() {
          return this._width;
        }
        SetWidth(e) {
          !isFinite(e) || e < 1 || (this._width = e);
        }
        GetHeight() {
          return this._height;
        }
        SetHeight(e) {
          !isFinite(e) || e < 1 || (this._height = e);
        }
        GetEventSheet() {
          return this._eventSheet;
        }
        _GetRootLayers() {
          return this._rootLayers;
        }
        *allLayers() {
          for (const e of this._rootLayers) yield* e.selfAndAllSubLayers();
        }
        GetLayers() {
          return this._allLayersFlat;
        }
        GetLayerCount() {
          return this._allLayersFlat.length;
        }
        GetLayer(e) {
          return "number" == typeof e ? this.GetLayerByIndex(e) : this.GetLayerByName(e.toString());
        }
        GetLayerByIndex(e) {
          return e = C33.clamp(Math.floor(e), 0, this._allLayersFlat.length - 1), this._allLayersFlat[e];
        }
        GetLayerByName(e) {
          return this._layersByName.get(e.toLowerCase()) || null;
        }
        HasLayerByName(e) {
          return !!this.GetLayerByName(e);
        }
        GetLayerBySID(e) {
          return this._layersBySid.get(e) || null;
        }
        _SetAllLayersProjectionChanged() {
          for (const e of this._allLayersFlat) e._SetProjectionMatrixChanged();
        }
        _SetAllLayersMVChanged() {
          for (const e of this._allLayersFlat) e._SetMVMatrixChanged();
        }
        AddLayer(e, t, s2) {
          if (this.HasLayerByName(e)) throw new Error(`layer name '${e}' already in use`);
          if (!t && s2 < 2) throw new Error("invalid insert position");
          const r2 = s2 >= 2 ? t : t.GetParentLayer(), a2 = C33.New(C33.Layer, this, r2, { name: e, sid: Math.floor(1e15 * Math.random()), isDynamic: true });
          this._InsertLayer(a2, t, s2), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
        }
        MoveLayer(e, t, s2) {
          if (!t && s2 < 2) throw new Error("invalid insert position");
          e === t && s2 < 2 || (this._RemoveLayer(e), this._InsertLayer(e, t, s2), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers());
        }
        RemoveLayer(e) {
          if (this._RemoveLayer(e)) {
            const t = this._runtime.GetEventSheetManager();
            t.BlockFlushingInstances(true), e.Release(), t.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
          }
        }
        RemoveAllDynamicLayers() {
          const e = /* @__PURE__ */ new Set();
          for (const t2 of this.allLayers()) t2.IsDynamic() && !t2.HasAnyDynamicParentLayer() && e.add(t2);
          if (0 === e.size) return;
          const t = this._runtime.GetEventSheetManager();
          t.BlockFlushingInstances(true);
          for (const t2 of e) this._RemoveLayer(t2), t2.Release();
          t.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
        }
        _InsertLayer(e, t, s2) {
          if (s2 >= 2) if (t) {
            if (t === e || t.HasParentLayer(e)) throw new Error(`cannot move layer '${e.GetName()}' to sub-layer of itself`);
            t._AddSubLayer(e, 2 === s2), e._SetParentLayer(t);
          } else 2 === s2 ? this._rootLayers.push(e) : this._rootLayers.unshift(e), e._SetParentLayer(null);
          else {
            const r2 = t.GetParentLayer();
            if (r2) {
              if (t.HasParentLayer(e)) throw new Error(`cannot move layer '${e.GetName()}' to sub-layer of itself`);
              r2._InsertSubLayer(e, t, 0 === s2), e._SetParentLayer(r2);
            } else {
              let r3 = this._rootLayers.indexOf(t);
              if (-1 === r3) throw new Error("cannot find layer to insert by");
              0 === s2 && ++r3, this._rootLayers.splice(r3, 0, e), e._SetParentLayer(null);
            }
          }
        }
        _RemoveLayer(e) {
          const t = e.GetParentLayer();
          if (t) return t._RemoveSubLayer(e), true;
          if (this._rootLayers.length > 1) {
            const t2 = this._rootLayers.indexOf(e);
            if (-1 === t2) throw new Error("cannot find layer to remove");
            return this._rootLayers.splice(t2, 1), true;
          }
          return false;
        }
        _ReindexLayers() {
          this._allLayersFlat = [...this.allLayers()], this._layersByName.clear(), this._layersBySid.clear();
          for (let e = 0, t = this._allLayersFlat.length; e < t; ++e) {
            const t2 = this._allLayersFlat[e];
            t2._SetIndex(e), this._layersByName.set(t2.GetName().toLowerCase(), t2), this._layersBySid.set(t2.GetSID(), t2);
          }
        }
        _ReindexHTMLLayers() {
          let e = 0;
          for (const t of this._rootLayers) {
            for (const s2 of t.selfAndAllSubLayers()) s2._SetHTMLIndex(e);
            t.IsHTMLElementsLayer() && e++;
          }
        }
        GetHTMLLayerCount() {
          return this._rootLayers.at(-1).GetHTMLIndex() + 1;
        }
        async _ReindexAndUpdateAllLayers() {
          this._ReindexLayers(), this._ReindexHTMLLayers(), this._pendingSetHTMLLayerCount = this.GetHTMLLayerCount();
        }
        _GetPendingSetHTMLLayerCount() {
          return this._pendingSetHTMLLayerCount;
        }
        _ResetPendingHTMLLayerCount() {
          this._pendingSetHTMLLayerCount = -1;
        }
        GetRootLayersForHTMLLayer(e) {
          const t = [];
          for (const s2 of this._rootLayers) {
            const r2 = s2.GetHTMLIndex();
            if (r2 === e) t.push(s2);
            else if (r2 > e) break;
          }
          return t;
        }
        SaveTransform() {
          return { "scrollX": this.GetScrollX(), "scrollY": this.GetScrollY(), "scale": this.GetScale(), "angle": this.GetAngle(), "vpX": this.GetVanishingPointX(), "vpY": this.GetVanishingPointY() };
        }
        RestoreTransform(e) {
          this.SetScrollX(e["scrollX"]), this.SetScrollY(e["scrollY"]), this.SetScale(e["scale"]), this.SetAngle(e["angle"]), this.SetVanishingPointXY(e["vpX"], e["vpY"]);
        }
        GetLayoutBackgroundColor() {
          let e = this._rootLayers.filter((e2) => e2.ShouldDraw())[0];
          for (; e; ) {
            if (!e.IsTransparent()) return tempColor.copyRgb(e.GetBackgroundColor()), tempColor.setA(1), tempColor;
            if (e.UsesOwnTexture()) return tempColor.setRgba(0, 0, 0, 0), tempColor;
            e = e.GetSubLayers().filter((e2) => e2.ShouldDraw())[0];
          }
          return tempColor.setRgba(0, 0, 0, 0), tempColor;
        }
        IsFirstVisit() {
          return this._isFirstVisit;
        }
        _GetInitialObjectClasses() {
          return [...this._initialObjectClasses];
        }
        _AddInitialObjectClass(e) {
          if (e.IsInContainer()) for (const t of e.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(t);
          else this._initialObjectClasses.add(e);
        }
        _GetTextureLoadedObjectTypes() {
          return [...this._textureLoadedTypes];
        }
        _Load(e, t) {
          if (e === this || !t) return Promise.resolve();
          e && (C33.CopySet(this._textureLoadedTypes, e._textureLoadedTypes), e._textureLoadedTypes.clear());
          const s2 = [];
          for (const e2 of this._initialObjectClasses) this._textureLoadedTypes.has(e2) || (s2.push(e2.LoadTextures(t)), this._textureLoadedTypes.add(e2));
          return Promise.all(s2);
        }
        async MaybeLoadTexturesFor(e) {
          if (e.IsFamily()) throw new Error("cannot load textures for family");
          const t = this._runtime.GetRenderer();
          if (!t || t.IsContextLost() || this._textureLoadedTypes.has(e)) return;
          this._textureLoadedTypes.add(e);
          const s2 = e.LoadTextures(t);
          this._AddPendingTextureLoadPromise(s2), await s2, e.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender();
        }
        _AddPendingTextureLoadPromise(e) {
          this._textureLoadPendingPromises.add(e), e.then(() => this._textureLoadPendingPromises.delete(e)).catch(() => this._textureLoadPendingPromises.delete(e));
        }
        WaitForPendingTextureLoadsToComplete() {
          return Promise.all([...this._textureLoadPendingPromises]);
        }
        MaybeUnloadTexturesFor(e) {
          if (e.IsFamily() || e.GetInstanceCount() > 0) throw new Error("cannot unload textures");
          const t = this._runtime.GetRenderer();
          t && this._textureLoadedTypes.has(e) && (this._textureLoadedTypes.delete(e), e.ReleaseTextures(t));
        }
        _Unload(e, t) {
          if (e !== this && t) for (const t2 of this._textureLoadedTypes) t2.IsGlobal() || e._initialObjectClasses.has(t2) || (t2.ReleaseTextures(), this._textureLoadedTypes.delete(t2));
        }
        _OnRendererContextLost() {
          this._textureLoadedTypes.clear();
        }
        async _StartRunning(e) {
          const t = this._runtime, s2 = this._layoutManager, r2 = t.GetEventSheetManager();
          this._eventSheetName && (this._eventSheet = r2.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes()), s2._SetMainRunningLayout(this), this._width = this._originalWidth, this._height = this._originalHeight, this._scrollX = t.GetOriginalViewportWidth() / 2, this._scrollY = t.GetOriginalViewportHeight() / 2, this.BoundScrolling(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._ReindexHTMLLayers(), await this._runtime.GetCanvasManager().SetHTMLLayerCount(this.GetHTMLLayerCount(), true), this._MoveGlobalObjectsToThisLayout(e), this._runtime.SetUsingCreatePromises(true), this._CreateInitialInstances(), this._isFirstVisit || this._CreatePersistedInstances(), this._CreateAndLinkContainerInstances(this._createdInstances), this._CreateAndLinkContainerInstances(this._createdPersistedInstances), this._CreateInitialNonWorldInstances(), s2.ClearPendingChangeLayout(), t.FlushPendingInstances(), this._runtime.SetUsingCreatePromises(false);
          const a2 = this._runtime.GetCreatePromises();
          if (await Promise.all(a2), C33.clearArray(a2), !t.IsLoadingState()) {
            for (const e2 of this._createdInstances) e2.SetupInitialSceneGraphConnections();
            for (const e2 of this._createdPersistedInstances) e2.SetupPersistedSceneGraphConnections(this._createdPersistedInstancesToDataMap, this._createdPersistedIndexToInstanceMap);
            for (const [e2, t2] of Object.entries(this._persistData)) {
              const s3 = this._runtime.GetObjectClassBySID(parseInt(e2, 10));
              s3 && !s3.IsFamily() && s3.HasPersistBehavior() && C33.clearArray(t2);
            }
            for (const e2 of this._createdInstances) e2._TriggerOnCreated();
            for (const e2 of this._createdPersistedInstances) e2._TriggerOnCreated();
            for (const e2 of this._createdInstances) e2.HasParent() || e2._OnHierarchyReady();
            for (const e2 of this._createdPersistedInstances) e2.HasParent() || e2._OnHierarchyReady();
          }
          C33.clearArray(this._createdInstances), C33.clearArray(this._createdPersistedInstances), this._createdPersistedInstancesToDataMap.clear(), this._createdPersistedIndexToInstanceMap.clear(), await Promise.all([...this._initialObjectClasses].map((e2) => e2.PreloadTexturesWithInstances(this._runtime.GetRenderer()))), e && (t.Dispatcher().dispatchEvent(new C33.Event("beforefirstlayoutstart")), await t.DispatchUserScriptEventAsyncWait(new C33.Event("beforeprojectstart"))), await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event("beforeanylayoutstart")), t.Dispatcher().dispatchEvent(new C33.Event("beforelayoutstart")), await this.DispatchUserScriptEventAsyncWait(new C33.Event("beforelayoutstart")), t.IsLoadingState() || await t.TriggerAsync(C33.Plugins.System.Cnds.OnLayoutStart, null, null), t.Dispatcher().dispatchEvent(new C33.Event("afterlayoutstart")), await this.DispatchUserScriptEventAsyncWait(new C33.Event("afterlayoutstart")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event("afteranylayoutstart")), e && (t.Dispatcher().dispatchEvent(new C33.Event("afterfirstlayoutstart")), await t.DispatchUserScriptEventAsyncWait(new C33.Event("afterprojectstart"))), r2._RunQueuedTriggers(s2), await this.WaitForPendingTextureLoadsToComplete(), this._isFirstVisit = false;
        }
        _MoveGlobalObjectsToThisLayout(e) {
          for (const e2 of this._runtime.GetAllObjectClasses()) if (!e2.IsFamily() && e2.IsWorldType()) for (const t of e2.GetInstances()) {
            const e3 = t.GetWorldInfo(), s2 = e3.GetLayer(), r2 = C33.clamp(s2.GetIndex(), 0, this._allLayersFlat.length - 1), a2 = this._allLayersFlat[r2];
            e3._SetLayer(a2, true), a2._MaybeAddInstance(t);
          }
          if (!e) for (const e2 of this._allLayersFlat) e2._SortInstancesByLastCachedZIndex(false);
        }
        _CreateInitialInstances() {
          for (const e of this._allLayersFlat) e.CreateInitialInstances(this._createdInstances), e._Start();
        }
        _CreatePersistedInstances() {
          let e = false;
          for (const [t, s2] of Object.entries(this._persistData)) {
            const r2 = this._runtime.GetObjectClassBySID(parseInt(t, 10));
            if (r2 && !r2.IsFamily() && r2.HasPersistBehavior()) for (const t2 of s2) {
              let s3 = null;
              if (r2.IsWorldType() && (s3 = t2.hasOwnProperty("instJson") ? this.GetLayerBySID(t2["instJson"]["w"]["l"]) : this.GetLayerBySID(t2["w"]["l"]), !s3)) continue;
              const a2 = this._runtime.CreateInstanceFromData(r2, s3, false, 0, 0, true);
              t2.hasOwnProperty("instJson") ? a2.LoadFromJson(t2["instJson"]) : a2.LoadFromJson(t2), e = true, this._createdPersistedInstances.push(a2), t2.hasOwnProperty("instJson") && (this._createdPersistedInstancesToDataMap.set(a2, t2), this._createdPersistedIndexToInstanceMap.set(t2["index"], a2));
            }
          }
          for (const e2 of this._allLayersFlat) e2._SortInstancesByLastCachedZIndex(true), e2.SetZIndicesChanged();
          e && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap());
        }
        _CreateAndLinkContainerInstances(e) {
          for (const t of e) {
            if (!t.IsInContainer()) continue;
            const s2 = t.GetWorldInfo(), r2 = t.GetIID();
            for (const a2 of t.GetObjectClass().GetContainer().objectTypes()) {
              if (a2 === t.GetObjectClass()) continue;
              const n = a2.GetInstances();
              if (n.length > r2) t._AddSibling(n[r2]);
              else {
                let r3;
                r3 = s2 ? this._runtime.CreateInstanceFromData(a2, s2.GetLayer(), true, s2.GetX(), s2.GetY(), true) : this._runtime.CreateInstanceFromData(a2, null, true, 0, 0, true), this._runtime.FlushPendingInstances(), a2._UpdateIIDs(), t._AddSibling(r3), e.push(r3);
              }
            }
          }
        }
        _CreateInitialNonWorldInstances() {
          for (const e of this._initialNonWorld) {
            this._runtime.GetObjectClassByIndex(e[1]).IsInContainer() || this._runtime.CreateInstanceFromData(e, null, true);
          }
        }
        _CreateGlobalNonWorlds() {
          const e = [], t = this._initialNonWorld;
          let s2 = 0;
          for (let r2 = 0, a2 = t.length; r2 < a2; ++r2) {
            const a3 = t[r2], n = this._runtime.GetObjectClassByIndex(a3[1]);
            n.IsGlobal() ? n.IsInContainer() && n.GetContainer().HasAnyWorldType() || e.push(this._runtime.CreateInstanceFromData(a3, null, true)) : (t[s2] = a3, ++s2);
          }
          C33.truncateArray(t, s2), this._runtime.FlushPendingInstances(), this._CreateAndLinkContainerInstances(e);
        }
        RecreateInitialObjects(e, t, s2, r2, a2, n, i2) {
          if (s2) return s2.RecreateInitialObjects(e, t, a2, n, r2, i2);
          {
            const s3 = [];
            for (const o2 of this._allLayersFlat) s3.push(o2.RecreateInitialObjects(e, t, a2, n, r2, i2));
            return s3.flat();
          }
        }
        async _StopRunning() {
          const e = this._layoutManager;
          this._runtime.IsLoadingState() || (await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event("beforeanylayoutend")), await this.DispatchUserScriptEventAsyncWait(new C33.Event("beforelayoutend")), await this._runtime.TriggerAsync(C33.Plugins.System.Cnds.OnLayoutEnd, null, null), await this.DispatchUserScriptEventAsyncWait(new C33.Event("afterlayoutend")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event("afteranylayoutend"))), e.SetIsEndingLayout(true), this._runtime.GetEventSheetManager().ClearAllScheduledWaits(), this._isFirstVisit || this._SavePersistData();
          for (const e2 of this._allLayersFlat) e2._End();
          for (const e2 of this._runtime.GetAllObjectClasses()) if (!(e2.IsGlobal() || e2.IsWorldType() || e2.GetPlugin().IsSingleGlobal() || e2.IsFamily())) {
            for (const t of e2.GetInstances()) this._runtime.DestroyInstance(t);
            this._runtime.FlushPendingInstances();
          }
          e.SetIsEndingLayout(false), e.GetMainRunningLayout() === this && e._SetMainRunningLayout(null);
        }
        _SaveInstanceToPersist(e, t) {
          const s2 = e.GetObjectClass().GetSID().toString();
          this._persistData.hasOwnProperty(s2) || (this._persistData[s2] = []);
          const r2 = this._persistData[s2], a2 = { "index": t, "instJson": e.SaveToJson(), "sceneGraphJson": { "children": [] } };
          r2.push(a2), this._persistedIntances.set(e, a2);
        }
        _SaveSceneGraphInfoToPersist(e) {
          const t = this._persistedIntances.get(e);
          for (const s2 of e.GetChildren()) {
            const e2 = this._persistedIntances.get(s2);
            e2 && t["sceneGraphJson"]["children"].push({ "index": e2["index"], "flags": C33.SceneGraphInfo._GetFlagsNumber(s2.GetWorldInfo()) });
          }
        }
        _SavePersistData() {
          this._persistedIntances.clear();
          let e = 0;
          for (const t of this._allLayersFlat) {
            t._UpdateZIndices();
            for (const s2 of t._GetInstances()) {
              const t2 = s2.GetObjectClass();
              !t2.IsGlobal() && t2.HasPersistBehavior() && (this._SaveInstanceToPersist(s2, e), e++);
            }
          }
          for (const e2 of this._allLayersFlat) for (const t of e2._GetInstances()) {
            const e3 = t.GetObjectClass();
            !e3.IsGlobal() && e3.HasPersistBehavior() && this._SaveSceneGraphInfoToPersist(t);
          }
          this._persistedIntances.clear();
        }
        ResetPersistData() {
          this._persistData = {}, this._isFirstVisit = true;
        }
        GetRenderTarget() {
          return this._curRenderTarget;
        }
        UsesOwnTexture() {
          const e = this._runtime, t = e.GetRenderer().IsWebGL();
          return "low" === e.GetCanvasManager().GetCurrentFullscreenScalingQuality() || t && e.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect() || t && e.Uses3DFeatures();
        }
        _MaybeStartDrawToOwnTexture(e) {
          const t = this._runtime.GetCanvasManager();
          if (this.UsesOwnTexture()) {
            e.SetRenderTarget(null), e.ClearRgba(0, 0, 0, 0);
            const s2 = { sampling: this._runtime.GetSampling(), isSampled: e.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect(), canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };
            "low" === t.GetCurrentFullscreenScalingQuality() && (s2.width = t.GetDrawWidth(), s2.height = t.GetDrawHeight()), this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(s2);
          } else this._curRenderTarget = null;
        }
        _MaybeCopyOwnTextureToBackbuffer(e) {
          this._runtime._NeedsHTMLLayerCompositing(e) && (e.SetDepthEnabled(false), e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(this._curRenderTarget));
        }
        _MaybeEndDrawToOwnTexture(e) {
          this.UsesOwnTexture() && (e.SetDepthEnabled(false), this._DrawLayoutOwnTextureToRenderTarget(e, this._curRenderTarget));
        }
        DrawMain(e) {
          e.SetRenderTarget(this._curRenderTarget), e.Clear(this.GetLayoutBackgroundColor()), this._runtime.Uses3DFeatures() && e.ClearDepth();
          const t = this.GetRootLayersForHTMLLayer(0);
          this._DrawLayerList(e, this._curRenderTarget, t, true), e.IsWebGPU() && e.StartMeasuringRenderPassTime(0, 1), this._MaybeEndDrawToOwnTexture(e), this._curRenderTarget = null;
        }
        DrawForHTMLLayerIndex(e, t) {
          let s2 = null;
          this._runtime._NeedsHTMLLayerCompositing(e) && (s2 = this._curRenderTarget), e.SetRenderTarget(s2), e.ClearRgba(0, 0, 0, 0), this._runtime.Uses3DFeatures() && e.ClearDepth();
          const r2 = this.GetRootLayersForHTMLLayer(t);
          this._DrawLayerList(e, s2, r2, true), this._MaybeCopyOwnTextureToBackbuffer(e), e.EndBatch(), this._runtime.GetCanvasManager().BlitMainCanvasToHTMLLayerCanvas(t);
        }
        _DrawLayerList(e, t, s2, r2) {
          const a2 = s2.filter((e2) => e2.ShouldDraw());
          for (let s3 = 0, n = a2.length; s3 < n; ) {
            const i2 = a2[s3];
            if (i2.SelfAndAllSubLayersHave3DCamera() && !i2.SelfOrAnySubLayerUsesOwnTexture()) {
              tempRender3dList.push(i2);
              for (let e2 = s3 + 1; e2 < n; ++e2) {
                const t2 = a2[e2];
                if (!t2.SelfAndAllSubLayersHave3DCamera() || t2.SelfOrAnySubLayerUsesOwnTexture()) break;
                tempRender3dList.push(a2[e2]);
              }
              if (tempRender3dList.length >= 2 || 1 === tempRender3dList.length && tempRender3dList[0].HasAnyVisibleSubLayer()) {
                this._Draw3DLayers(e, t, tempRender3dList), s3 += tempRender3dList.length, C33.clearArray(tempRender3dList);
                continue;
              }
              C33.clearArray(tempRender3dList);
            }
            i2.Draw(e, t, r2 && 0 === s3), ++s3;
          }
        }
        _DrawLayoutOwnTextureToRenderTarget(e, t) {
          const s2 = this._effectList.GetActiveEffectTypes(), r2 = this._runtime;
          0 === s2.length ? (e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(t), e.InvalidateRenderTarget(t), r2.ReleaseAdditionalRenderTarget(t)) : (tempLayoutRect.set(0, 0, r2.GetViewportWidth(), r2.GetViewportHeight()), this.GetEffectChain().Render(e, null, { contentObject: this, blendMode: 3, devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(), layerAngle: this.GetAngle(), layoutRect: tempLayoutRect, drawSurfaceRect: null, invalidateRenderTargets: true }));
        }
        _Draw3DLayers(e, t, s2) {
          const r2 = s2[0], a2 = r2._MaybeStartWebGLProfiling(e);
          r2._MaybeStartWebGPUProfiling(e), s2[0].IsTransparent() || (tempColor.copyRgb(s2[0].GetBackgroundColor()), tempColor.setA(1), e.Clear(tempColor)), e.SetDepthEnabled(true);
          const n = tempInstanceList1, i2 = tempInstanceList2, o2 = tempInstanceList3;
          for (const t2 of s2) t2._UpdateZIndices(), t2._AppendAllInstancesIncludingSubLayersInDrawOrder(n), t2._FireDrawEvent(e, "beforedraw");
          for (let s3 = 0, r3 = n.length; s3 < r3; ) {
            const a3 = n[s3], l2 = a3.GetWorldInfo(), h = l2.GetLayer();
            if (!l2.IsVisible() || !l2.IsInViewport3D(h._GetViewFrustum())) {
              ++s3;
              continue;
            }
            (!a3.RendersToOwnZPlane() || l2.GetDepth() > 0) && o2.push(a3);
            const c2 = a3.GetWorldInfo().GetTotalZElevation();
            i2.push(a3);
            let d2 = s3 + 1;
            for (; d2 < r3; ++d2) {
              const e2 = n[d2], t2 = e2.GetWorldInfo();
              if (t2.IsVisible() && t2.IsInViewport3D(t2.GetLayer()._GetViewFrustum())) {
                if (t2.GetTotalZElevation() !== c2) break;
                e2.RendersToOwnZPlane() ? (t2.GetDepth() > 0 && o2.push(e2), i2.push(e2)) : o2.push(e2);
              }
            }
            if (1 !== i2.length || i2[0].MustMitigateZFighting()) {
              this._Draw3DLayersCoplanarInstances(e, t, i2);
              for (let s4 = 0, r4 = o2.length; s4 < r4; ++s4) {
                const r5 = o2[s4], a4 = r5.GetWorldInfo(), n2 = a4.GetLayer();
                a4._SetDrawNonBackFacesOnly(true), MaybePrepareLayerDraw2(n2, e), n2._DrawInstanceMaybeWithEffects(r5, a4, e, t), a4._SetDrawNonBackFacesOnly(false);
              }
            } else {
              MaybePrepareLayerDraw2(h, e), h._DrawInstanceMaybeWithEffects(a3, l2, e, t);
              for (let s4 = 0, r4 = o2.length; s4 < r4; ++s4) {
                const r5 = o2[s4];
                if (r5 === a3) continue;
                const n2 = r5.GetWorldInfo(), i3 = n2.GetLayer();
                MaybePrepareLayerDraw2(i3, e), i3._DrawInstanceMaybeWithEffects(r5, n2, e, t);
              }
            }
            s3 = d2, C33.clearArray(i2), C33.clearArray(o2);
          }
          for (const t2 of s2) t2._FireDrawEvent(e, "afterdraw");
          a2 && e.EndQuery(a2), C33.clearArray(n), lastLayerPreparedForDrawing = null;
        }
        _Draw3DLayersCoplanarInstances(e, t, s2) {
          e.CoplanarStartStencilPass();
          for (let t2 = 0, r2 = s2.length; t2 < r2; ++t2) {
            const r3 = s2[t2], a2 = r3.GetWorldInfo(), n = a2.GetLayer();
            a2._SetDrawBackFaceOnly(true), MaybePrepareLayerDraw2(n, e), n._DrawInstance(r3, a2, e);
          }
          e.CoplanarStartColorPass();
          for (let r2 = 0, a2 = s2.length; r2 < a2; ++r2) {
            const a3 = s2[r2], n = a3.GetWorldInfo(), i2 = n.GetLayer();
            MaybePrepareLayerDraw2(i2, e), i2._DrawInstanceMaybeWithEffects(a3, n, e, t), n._SetDrawBackFaceOnly(false);
          }
          e.CoplanarRestoreStandardRendering();
        }
        _SaveToJson() {
          const e = { "sx": this.GetScrollX(), "sy": this.GetScrollY(), "s": this.GetScale(), "a": this.GetAngle(), "w": this.GetWidth(), "h": this.GetHeight(), "ortho": this.IsOrthographicProjection(), "vpX": this.GetVanishingPointX(), "vpY": this.GetVanishingPointY(), "fv": this._isFirstVisit, "persist": this._persistData, "fx": this._effectList.SaveToJson(), "layers": {}, "dynamicLayers": [] };
          for (const t of this._allLayersFlat) if (t.IsDynamic()) {
            const s2 = t.GetParentLayer();
            e["dynamicLayers"].push({ "sid": t.GetSID(), "name": t.GetName(), "parentSid": s2 ? s2.GetSID() : null, "siblingIndex": t._GetSiblingIndex(), "data": t._SaveToJson() });
          } else e["layers"][t.GetSID().toString()] = t._SaveToJson();
          return e;
        }
        _LoadFromJson(e) {
          this._scrollX = e["sx"], this._scrollY = e["sy"], this._scale = e["s"], this._angle = e["a"], this._width = e["w"], this._height = e["h"], this._isOrthographicProjection = !!e["ortho"], e.hasOwnProperty("vpX") && (this._vanishingPointX = e["vpX"]), e.hasOwnProperty("vpY") && (this._vanishingPointY = e["vpY"]), this._isFirstVisit = !!e["fv"], this._persistData = e["persist"], this._effectList.LoadFromJson(e["fx"]), this._needsRebuildEffectChainSteps = true;
          for (const [t, s2] of Object.entries(e["layers"])) {
            const e2 = parseInt(t, 10), r2 = this.GetLayerBySID(e2);
            r2 && r2._LoadFromJson(s2);
          }
          if (e.hasOwnProperty("dynamicLayers")) {
            this.RemoveAllDynamicLayers(), this._runtime.FlushPendingInstances();
            const t = /* @__PURE__ */ new Map(), s2 = e["dynamicLayers"];
            for (let e2 = s2.length - 1; e2 >= 0; --e2) {
              const r2 = s2[e2], a2 = r2["sid"], n = r2["name"], i2 = r2["parentSid"], o2 = r2["siblingIndex"], l2 = r2["data"];
              if (this._ReindexLayers(), this.HasLayerByName(n) || this.GetLayerBySID(a2)) continue;
              let h, c2;
              if (null === i2) h = null, c2 = this._rootLayers;
              else {
                if (h = this.GetLayerBySID(i2), !h) continue;
                c2 = h.GetSubLayers();
              }
              const d2 = C33.New(C33.Layer, this, h, { name: n, sid: a2, isDynamic: true });
              c2.push(d2);
              let _ = t.get(c2);
              _ || (_ = [], t.set(c2, _)), _.push({ layer: d2, siblingIndex: o2 }), d2._LoadFromJson(l2);
            }
            for (const [e2, s3] of t) {
              s3.sort((e3, t2) => e3.siblingIndex - t2.siblingIndex);
              for (const t2 of s3) {
                const s4 = t2.layer, r2 = t2.siblingIndex;
                let a2 = e2.indexOf(s4);
                e2.splice(a2, 1), e2.splice(r2, 0, s4);
              }
            }
          }
          this._ReindexAndUpdateAllLayers(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged();
        }
        GetILayout() {
          return this._iLayout;
        }
        UserScriptDispatcher() {
          return this._userScriptDispatcher;
        }
        DispatchUserScriptEvent(e) {
          e.layout = this.GetILayout();
          const t = this._runtime, s2 = t.IsDebug() && !t.GetEventSheetManager().IsInEventEngine();
          s2 && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), s2 && C3Debugger.AddScriptTime();
        }
        DispatchUserScriptEventAsyncWait(e) {
          return e.layout = this.GetILayout(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);
        }
        DispatchRuntimeUserScriptEventAsyncWait(e) {
          return e.layout = this.GetILayout(), this._runtime.DispatchUserScriptEventAsyncWait(e);
        }
        _LogLayerTree() {
          this._LogLayerList(this._rootLayers);
        }
        _LogLayerList(e, t = 0) {
          const s2 = e.slice(0);
          s2.reverse();
          for (const e2 of s2) console.log(`${"	".repeat(t)}- ${e2.GetName()}`), this._LogLayerList(e2.GetSubLayers(), t + 1);
        }
      };
    }
    var vec3EqualsXYZ;
    var MaybePrepareLayerDraw;
    {
      const C33 = self.C3;
      C33.LayoutManager = class extends C33.DefendedBase {
        #t;
        #n = [];
        #u = /* @__PURE__ */ new Map();
        #a = /* @__PURE__ */ new Map();
        #i = null;
        #e = [];
        #s = null;
        #o = 0;
        #y = null;
        constructor(t) {
          super(), this.#t = t;
        }
        Release() {
          this.#t = null, this.#i = null, this.#s = null, this.#y = null, C33.clearArray(this.#n), this.#u.clear(), this.#a.clear(), C33.clearArray(this.#e);
        }
        Create(t) {
          const n = C33.New(C33.Layout, this, this.#n.length, t);
          this.#n.push(n), this.#u.set(n.GetName().toLowerCase(), n), this.#a.set(n.GetSID(), n);
        }
        GetRuntime() {
          return this.#t;
        }
        SetFirstLayout(t) {
          this.#s = t;
        }
        GetFirstLayout() {
          if (this.#s) return this.#s;
          if (this.#n.length) return this.#n[0];
          throw new Error("no first layout");
        }
        GetLayoutByName(t) {
          return this.#u.get(t.toLowerCase()) || null;
        }
        GetLayoutBySID(t) {
          return this.#a.get(t) || null;
        }
        GetLayoutByIndex(t) {
          return t = C33.clamp(Math.floor(t), 0, this.#n.length - 1), this.#n[t];
        }
        GetLayout(t) {
          return "number" == typeof t ? this.GetLayoutByIndex(t) : this.GetLayoutByName(t.toString());
        }
        GetAllLayouts() {
          return this.#n;
        }
        _SetMainRunningLayout(t) {
          this.#i = t;
        }
        GetMainRunningLayout() {
          return this.#i;
        }
        _AddRunningSubLayout(t) {
          if (this.#e.includes(t)) throw new Error("layout already running");
          this.#e.push(t);
        }
        _RemoveRunningSubLayout(t) {
          const n = this.#e.indexOf(t);
          if (-1 === n) throw new Error("layout not running");
          this.#e.splice(n, 1);
        }
        *runningLayouts() {
          this.#i && (yield this.#i), this.#e.length && (yield* this.#e);
        }
        IsLayoutRunning(t) {
          return this.#i === t || this.#e.includes(t);
        }
        SetIsEndingLayout(t) {
          if (t) this.#o++;
          else {
            if (this.#o <= 0) throw new Error("already unset");
            this.#o--;
          }
        }
        IsEndingLayout() {
          return this.#o > 0;
        }
        ChangeMainLayout(t) {
          this.#y = t;
        }
        ClearPendingChangeLayout() {
          this.#y = null;
        }
        IsPendingChangeMainLayout() {
          return !!this.#y;
        }
        GetPendingChangeMainLayout() {
          return this.#y;
        }
        SetAllLayerProjectionChanged() {
          const t = this.GetMainRunningLayout();
          t && t._SetAllLayersProjectionChanged();
        }
        SetAllLayerMVChanged() {
          const t = this.GetMainRunningLayout();
          t && t._SetAllLayersMVChanged();
        }
      };
    }
    {
      const C33 = self.C3, NAMES_REGEXP = new RegExp("<(.+?)>", "g");
      C33.TimelineManager = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e, this._timelineDataManager = C33.New(C33.TimelineDataManager), this._pluginInstance = null, this._timelines = [], this._timelinesByName = /* @__PURE__ */ new Map(), this._objectClassToTimelineMap = /* @__PURE__ */ new Map(), this._timelinesCreatedByTemplate = /* @__PURE__ */ new Map(), this._scheduledTimelines = [], this._playingTimelines = [], this._markedForRemovalTimelines = [], this._hasRuntimeListeners = false, this._changingLayout = false, this._isTickingTimelines = false, this._tickFunc = () => this._OnTick(), this._tick2Func = () => this._OnTick2(), this._beforeLayoutChange = () => this._OnBeforeChangeLayout(), this._layoutChange = () => this._OnAfterChangeLayout(), this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance), this._beforeLoad = (e2) => this._OnBeforeLoad(), this._afterLoad = (e2) => this._OnAfterLoad(), this._afterLayoutStart = (e2) => this._OnAfterLayoutStart(), this._destroyedWhileLoadingState = [], this._renderChange = 0;
        }
        Release() {
          this.RemoveRuntimeListeners(), this._tickFunc = null, this._tick2Func = null, this._beforeLayoutChange = null, this._layoutChange = null, this._instanceDestroy = null, this._afterLoad = null;
          for (const e of this._timelines) e.Stop(), e.Release();
          C33.clearArray(this._timelines), this._timelines = null, this._timelineDataManager.Release(), this._timelineDataManager = null, C33.clearArray(this._scheduledTimelines), this._scheduledTimelines = null, C33.clearArray(this._playingTimelines), this._playingTimelines = null, C33.clearArray(this._markedForRemovalTimelines), this._markedForRemovalTimelines = null, this._timelinesByName.clear(), this._timelinesByName = null, this._objectClassToTimelineMap.clear(), this._objectClassToTimelineMap = null, this._timelinesCreatedByTemplate.clear(), this._timelinesCreatedByTemplate = null, C33.clearArray(this._destroyedWhileLoadingState), this._destroyedWhileLoadingState = null, this._runtime = null;
        }
        AddRuntimeListeners() {
          const e = this._runtime.Dispatcher();
          e.addEventListener("pretick", this._tickFunc), e.addEventListener("tick2", this._tick2Func), e.addEventListener("beforelayoutchange", this._beforeLayoutChange), e.addEventListener("layoutchange", this._layoutChange), e.addEventListener("instancedestroy", this._instanceDestroy), e.addEventListener("beforeload", this._beforeLoad), e.addEventListener("afterload", this._afterLoad), e.addEventListener("afterlayoutstart", this._afterLayoutStart);
        }
        RemoveRuntimeListeners() {
          const e = this._runtime.Dispatcher();
          e.removeEventListener("pretick", this._tickFunc), e.removeEventListener("tick2", this._tick2Func), e.removeEventListener("beforelayoutchange", this._beforeLayoutChange), e.removeEventListener("layoutchange", this._layoutChange), e.removeEventListener("instancedestroy", this._instanceDestroy), e.removeEventListener("beforeload", this._beforeLoad), e.removeEventListener("afterload", this._afterLoad), e.removeEventListener("afterlayoutstart", this._afterLayoutStart);
        }
        Create(e) {
          this._timelineDataManager.Add(e);
          const i2 = C33.TimelineState.CreateInitial(e, this);
          this.Add(i2), this.SetTimelineObjectClassesToMap(i2), this._timelinesCreatedByTemplate.set(i2.GetName(), 0);
        }
        CreateFromTemplate(e) {
          const i2 = this.GetTimelineDataManager(), t = e.GetTemplateName(), s2 = i2.Get(t), n = C33.TimelineState.CreateFromTemplate(`${t}:${this._timelinesCreatedByTemplate.get(t)}`, s2, this);
          return this._IncreaseTemplateTimelinesCount(t), this.Add(n), n;
        }
        _IncreaseTemplateTimelinesCount(e) {
          this._timelinesCreatedByTemplate.set(e, this._timelinesCreatedByTemplate.get(e) + 1);
        }
        _SetCreatedTemplateTimelinesCount() {
          for (const e of this._timelines) {
            if (e.IsTemplate()) continue;
            const i2 = e.GetTemplateName();
            this._IncreaseTemplateTimelinesCount(i2);
          }
        }
        _ClearCreatedTemplateTimelinesCount() {
          for (const e of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(e, 0);
        }
        Add(e) {
          this._timelines.push(e), this._timelinesByName.set(e.GetName().toLowerCase(), e);
        }
        Remove(e) {
          e.Removed(), e.IsTemplate() || (C33.arrayFindRemove(this._timelines, e), C33.arrayFindRemove(this._scheduledTimelines, e), C33.arrayFindRemove(this._playingTimelines, e), C33.arrayFindRemove(this._markedForRemovalTimelines, e), this._timelinesByName.delete(e.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(e), e.IsReleased() || e.Release());
        }
        Trigger(e) {
          this._runtime.Trigger(e, this._pluginInstance, null);
        }
        GetRuntime() {
          return this._runtime;
        }
        GetTimelineDataManager() {
          return this._timelineDataManager;
        }
        SetPluginInstance(e) {
          this._pluginInstance = e;
        }
        GetPluginInstance() {
          return this._pluginInstance;
        }
        *GetTimelines() {
          for (const e of this._timelines) yield e;
        }
        *GetPlayingTimelines() {
          for (const e of this._playingTimelines) yield e;
        }
        SetTimelineObjectClassToMap(e, i2) {
          this._objectClassToTimelineMap.has(e) || this._objectClassToTimelineMap.set(e, /* @__PURE__ */ new Set()), this._objectClassToTimelineMap.get(e).add(i2);
        }
        SetTimelineObjectClassesToMap(e) {
          for (const i2 of e.GetObjectClasses()) this.SetTimelineObjectClassToMap(i2, e);
        }
        RemoveTimelineFromObjectClassMap(e) {
          for (const [i2, t] of this._objectClassToTimelineMap.entries()) t.has(e) && (t.delete(e), 0 === t.size && this._objectClassToTimelineMap.delete(i2));
        }
        GetTimelinesForObjectClass(e) {
          if (this._objectClassToTimelineMap.has(e)) return this._objectClassToTimelineMap.get(e);
        }
        GetTimelineOfTemplateForInstances(e, i2) {
          if (i2) for (const t of this._timelines) {
            if (i2.every((e2) => t.HasTrackInstance(e2.instance, e2.trackId)) && t.GetName().includes(e.GetName())) return t;
          }
        }
        GetTimelineByName(e) {
          return this._timelinesByName.get(e.toLowerCase()) || null;
        }
        GetScheduledOrPlayingTimelineByName(e) {
          for (const i2 of this._scheduledTimelines) if (i2.GetName() === e) return i2;
          for (const i2 of this._playingTimelines) if (i2.GetName() === e) return i2;
          return null;
        }
        *GetTimelinesByName(e) {
          if (NAMES_REGEXP.test(e)) {
            let i2;
            NAMES_REGEXP.lastIndex = 0;
            const t = /* @__PURE__ */ new Set();
            do {
              if (i2 = NAMES_REGEXP.exec(e), i2) {
                const e2 = i2[1].split(",");
                for (const i3 of e2) t.add(i3);
              }
            } while (i2);
            for (const e2 of t.values()) {
              const i3 = this.GetTimelineByName(e2);
              i3 && (yield i3);
            }
            t.clear();
          } else {
            const i2 = this.GetTimelineByName(e);
            i2 && (yield i2);
          }
        }
        *GetTimelinesByTags(e) {
          for (const i2 of this._timelines) i2.HasTags(e) && (yield i2);
        }
        AddScheduledTimeline(e) {
          this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e), this._MaybeEnableRuntimeListeners();
        }
        RemovePlayingTimeline(e) {
          C33.arrayFindRemove(this._playingTimelines, e), this._MaybeDisableRuntimeListeners();
        }
        ScheduleTimeline(e) {
          this._playingTimelines.includes(e) ? (e.SetPlaying(true), e.SetScheduled(false), e.SetMarkedForRemoval(false)) : (e.SetPlaying(false), e.SetScheduled(true), e.SetMarkedForRemoval(false), this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e)), this._MaybeEnableRuntimeListeners();
        }
        DeScheduleTimeline(e) {
          e.SetPlaying(false), e.SetScheduled(false), e.ResolvePlayPromise(), C33.arrayFindRemove(this._scheduledTimelines, e), this._MaybeDisableRuntimeListeners();
        }
        CompleteTimeline(e) {
          e.SetPlaying(false), e.SetScheduled(false), this._playingTimelines.includes(e) && (e.SetMarkedForRemoval(true), this._markedForRemovalTimelines.push(e), C33.arrayFindRemove(this._playingTimelines, e)), this._scheduledTimelines.includes(e) && e.SetMarkedForRemoval(true);
        }
        CompleteTimelineBeforeChangeOfLayout(e) {
          e.SetPlaying(false), e.SetScheduled(false), e.SetMarkedForRemoval(false), e.SetPlaybackRate(1), C33.arrayFindRemove(this._playingTimelines, e);
        }
        CompleteTimelineAndResolve(e) {
          this.CompleteTimeline(e), e.ResolvePlayPromise();
        }
        _OnTick() {
          const e = this.GetRuntime();
          if (e.IsLoadingState()) return;
          if (!this._hasRuntimeListeners) return;
          if (this._changingLayout) return;
          let i2 = 0;
          for (e.IsDebug() && (i2 = performance.now()), this._isTickingTimelines = true; this._scheduledTimelines.length; ) {
            const e2 = this._scheduledTimelines.pop();
            e2.IsMarkedForRemoval() ? (e2.SetInitialStateForce(), this._markedForRemovalTimelines.push(e2)) : (e2.SetInitialState(), this._playingTimelines.push(e2)), 0 !== e2.GetRenderChange() && (this._renderChange = 1);
          }
          const t = this._runtime._GetDtFast(), s2 = this._runtime.GetDt1(), n = this._runtime.GetTimeScale();
          for (let e2 = this._playingTimelines.length - 1; e2 >= 0; e2--) {
            const i3 = this._playingTimelines[e2];
            i3 && i3.Tick(t, n, s2);
          }
          this._isTickingTimelines = false, e.IsDebug() && globalThis.C3Debugger.AddTweensAndTimelinesTime(performance.now() - i2), 0 !== this._renderChange && e.UpdateRender();
        }
        _OnTick2() {
          const e = this.GetRuntime();
          if (e.IsLoadingState()) return;
          if (!this._hasRuntimeListeners) return;
          if (this._changingLayout) return;
          let i2, t = 0;
          e.IsDebug() && (t = performance.now());
          for (let e2 = 0, t2 = this._markedForRemovalTimelines.length; e2 < t2; e2++) {
            const t3 = this._markedForRemovalTimelines[e2];
            i2 || (i2 = /* @__PURE__ */ new Set()), t3.Removed(), this._MaybeExecuteTimelineFinishTriggers(t3), i2.add(t3);
          }
          if (i2) {
            C33.arrayRemoveAllInSet(this._markedForRemovalTimelines, i2), this._renderChange = 0;
            for (let e2 = 0, i3 = this._playingTimelines.length; e2 < i3; e2++) if (0 !== this._playingTimelines[e2].GetRenderChange()) {
              this._renderChange = 1;
              break;
            }
          }
          this._MaybeDisableRuntimeListeners(), e.IsDebug() && globalThis.C3Debugger.AddTweensAndTimelinesTime(performance.now() - t);
        }
        _MaybeExecuteTimelineFinishTriggers(e) {
          e.IsReleased() || e.HasValidTracks() && e.IsComplete() && e.InitialStateSet() && e.FinishTriggers();
        }
        _MaybeEnableRuntimeListeners() {
          this._hasRuntimeListeners || (this._hasRuntimeListeners = true);
        }
        _MaybeDisableRuntimeListeners() {
          this._markedForRemovalTimelines.length || this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = false);
        }
        _OnBeforeChangeLayout() {
          for (this._changingLayout = true; this._scheduledTimelines.length; ) this.DeScheduleTimeline(this._scheduledTimelines.pop());
          const e = /* @__PURE__ */ new Set();
          for (const i2 of this._playingTimelines) {
            i2._OnBeforeChangeLayout() && (i2.Removed(), e.add(i2));
          }
          C33.arrayRemoveAllInSet(this._playingTimelines, e), e.clear();
          for (const i2 of this._markedForRemovalTimelines) {
            i2._OnBeforeChangeLayout() && (i2.Removed(), e.add(i2));
          }
          C33.arrayRemoveAllInSet(this._markedForRemovalTimelines, e), this._MaybeDisableRuntimeListeners();
          for (const e2 of this._timelines) e2.CleanCaches();
        }
        _OnAfterChangeLayout() {
          this._changingLayout = false;
        }
        _OnInstanceDestroy(e) {
          const i2 = e.GetObjectClass(), t = this.GetTimelinesForObjectClass(i2);
          if (t) if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(e);
          else for (const e2 of t) e2.IsTemplate() || (e2.IsReleased() ? this.Remove(e2) : e2.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(e2), this.Remove(e2)));
        }
        _OnBeforeLoad() {
          for (const e of this._scheduledTimelines.map((e2) => e2)) this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e);
          for (const e of this._playingTimelines.map((e2) => e2)) this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e);
        }
        _OnAfterLoad() {
          for (const e of this._destroyedWhileLoadingState) this._OnInstanceDestroy(e);
          C33.clearArray(this._destroyedWhileLoadingState);
          for (const e of this._timelines) e._OnAfterLoad();
        }
        _OnAfterLayoutStart() {
          const e = this._runtime.GetLayoutManager().GetMainRunningLayout();
          if (e) for (const i2 of this._timelines) {
            const t = i2.GetStartOnLayout();
            t && (e.GetName() === t && this.ScheduleTimeline(i2));
          }
        }
        _SaveToJson() {
          return { "timelinesJson": this._SaveTimelinesToJson(), "scheduledTimelinesJson": this._SaveScheduledTimelinesToJson(), "playingTimelinesJson": this._SavePlayingTimelinesToJson(), "markedForRemovalTimelinesJson": this._SaveMarkedForRemovalTimelinesToJson(), "hasRuntimeListeners": this._hasRuntimeListeners, "changingLayout": this._changingLayout, "isTickingTimelines": this._isTickingTimelines };
        }
        _LoadFromJson(e) {
          e && (this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(e["timelinesJson"]), this._LoadScheduledTimelinesFromJson(e["scheduledTimelinesJson"]), this._LoadPlayingTimelinesFromJson(e["playingTimelinesJson"]), this._LoadMarkedForRemovalTimelinesFromJson(e["markedForRemovalTimelinesJson"]), this._hasRuntimeListeners = !e["hasRuntimeListeners"], this._changingLayout = !!e["changingLayout"], this._isTickingTimelines = !!e["isTickingTimelines"], this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners());
        }
        _SaveTimelinesToJson() {
          return this._timelines.map((e) => e._SaveToJson());
        }
        _LoadTimelinesFromJson(e) {
          for (const i2 of e) {
            let e2 = this.GetTimelineByName(i2["name"]);
            if (e2) e2._LoadFromJson(i2);
            else {
              const t = this._GetTemplateNameFromJson(i2);
              if (!t) continue;
              const s2 = this.GetTimelineByName(t);
              e2 = this.CreateFromTemplate(s2), e2._LoadFromJson(i2);
            }
            e2.HasTracks() || this.Remove(e2);
          }
        }
        _GetTemplateNameFromJson(e) {
          const i2 = e["name"].split(":");
          return i2 && 2 === i2.length ? i2[0] : null;
        }
        _SaveScheduledTimelinesToJson() {
          return this._SaveTimelines(this._scheduledTimelines);
        }
        _LoadScheduledTimelinesFromJson(e) {
          this._LoadTimelines(e, this._scheduledTimelines);
        }
        _SavePlayingTimelinesToJson() {
          return this._SaveTimelines(this._playingTimelines);
        }
        _LoadPlayingTimelinesFromJson(e) {
          this._LoadTimelines(e, this._playingTimelines);
        }
        _SaveMarkedForRemovalTimelinesToJson() {
          return this._SaveTimelines(this._markedForRemovalTimelines);
        }
        _LoadMarkedForRemovalTimelinesFromJson(e) {
          this._LoadTimelines(e, this._markedForRemovalTimelines);
        }
        _IsTimelineInJson(e, i2) {
          if (!i2) return false;
          for (const t of i2) if (t === e.GetName()) return true;
          return false;
        }
        _SaveTimelines(e) {
          return e.map((e2) => e2.GetName());
        }
        _LoadTimelines(e, i2) {
          const t = /* @__PURE__ */ new Set();
          for (const s2 of i2) this._IsTimelineInJson(s2, e) || t.add(s2);
          if (C33.arrayRemoveAllInSet(i2, t), e) {
            const t2 = (e2) => (i3) => i3.GetName() === e2;
            for (const s2 of e) {
              const e2 = this.GetTimelineByName(s2);
              if (e2) {
                i2.find(t2(s2)) || i2.push(e2);
              }
            }
          }
        }
      };
    }
    {
      const C33 = self.C3, STEPS = 100, LENGTH_STEP_SIZE = 0.01, BEZIER_STEP_SIZE = 25, REFINE_ITERATIONS = 20, LOOKUP_STEPS_FROM_LAST = 5, TANGENT_RESULT = [0, 0], MAP_RESULT = [0, 0], SHORT_PROJECTION_RESULT = [0, 0], PROJECTION_RESULT = [0, 0, 0, 0, 0], REFINE_LUT = new Array(4), REFINE_LUT_OBJECTS = [{ x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }], REFINE_RESULT = { x: 0, y: 0, t: 0, distance: 0 };
      C33.TimelineInfo = class {
        constructor(t, i2) {
          this._initialized = false, this._timeline = t, this._segments = [];
          let e = null;
          if (e = i2 ? this._timeline.GetTrackById(i2) : C33.first(this._timeline.GetTracks()), !e) return;
          const s2 = e.GetPropertyTrack("offsetX"), _ = e.GetPropertyTrack("offsetY");
          if (!s2 || !_) return;
          this._xTrack = s2, this._yTrack = _;
          const h = s2.GetPropertyKeyframeDataItemArrayIncludingDisabled(), n = _.GetPropertyKeyframeDataItemArrayIncludingDisabled();
          for (let t2 = 1, i3 = Math.min(h.length, n.length); t2 < i3; ++t2) {
            const i4 = h[t2], e2 = (i4.GetNext(), i4.GetPrevious()), s3 = n[t2], _2 = (s3.GetNext(), s3.GetPrevious());
            e2 && "cubic-bezier" === e2.GetPathMode() && _2 && "cubic-bezier" === _2.GetPathMode() ? this._segments.push(C33.New(C33.TimelineCubicBezierSegmentInfo, e2, _2, i4, s3, this._segments.length)) : (e2 && "line" === e2.GetPathMode() && _2 && _2.GetPathMode(), this._segments.push(C33.New(C33.TimelineLineSegmentInfo, i4, s3, this._segments.length)));
          }
          this._initialized = true;
        }
        Release() {
          for (const t of this._segments) t.Release();
          C33.clearArray(this._segments), this._segments = null, this._timeline = null, this._xTrack = null, this._yTrack = null;
        }
        WasInitialized() {
          return this._initialized;
        }
        segments() {
          return this._segments;
        }
        SetOrigin(t) {
          const i2 = "relative" === this._xTrack.GetResultMode() ? t.GetX() : 0, e = "relative" === this._yTrack.GetResultMode() ? t.GetY() : 0;
          for (const t2 of this._segments) t2.SetOrigin(i2, e);
        }
        Project(t, i2, e) {
          let s2 = NaN, _ = this._segments.length;
          for (let e2 = 0; e2 < _; e2++) {
            const _2 = this._segments[e2];
            if ("cubic-bezier" === _2.GetType()) {
              const e3 = _2.Project(t, i2);
              (isNaN(s2) || e3[3] < s2) && (s2 = e3[3], SHORT_PROJECTION_RESULT[0] = e3[2], SHORT_PROJECTION_RESULT[1] = _2.GetIndex());
            }
          }
          return SHORT_PROJECTION_RESULT;
        }
        ProjectWithOptions(t, i2, e) {
          const s2 = e.tRange;
          C33.IsFiniteNumber(s2[0]) || (s2[0] = 0), C33.IsFiniteNumber(s2[1]) || (s2[1] = 1);
          let _ = NaN, h = this._segments.length;
          for (let e2 = 0; e2 < h; e2++) {
            const h2 = this._segments[e2];
            if ("cubic-bezier" === h2.GetType()) {
              const e3 = h2.ProjectWithRange(t, i2, s2);
              (isNaN(_) || e3[3] < _) && (_ = e3[3], SHORT_PROJECTION_RESULT[0] = e3[2], SHORT_PROJECTION_RESULT[1] = h2.GetIndex());
            }
          }
          return SHORT_PROJECTION_RESULT;
        }
        Tangent(t, i2) {
          return this._segments[i2].Tangent(t);
        }
        TangentAngle(t, i2) {
          return this._segments[i2].TangentAngle(t);
        }
      }, C33.TimelineCubicBezierSegmentInfo = class {
        constructor(t, i2, e, s2, _) {
          this._index = _;
          const h = t.GetAddOn("cubic-bezier"), n = e.GetAddOn("cubic-bezier"), r2 = i2.GetAddOn("cubic-bezier"), a2 = s2.GetAddOn("cubic-bezier");
          this._aX = t.GetValueWithResultMode(), this._aY = i2.GetValueWithResultMode(), this._bX = t.GetValueWithResultMode() + h.GetStartAnchor(), this._bY = i2.GetValueWithResultMode() + r2.GetStartAnchor(), this._cX = e.GetValueWithResultMode() + n.GetEndAnchor(), this._cY = s2.GetValueWithResultMode() + a2.GetEndAnchor(), this._dX = e.GetValueWithResultMode(), this._dY = s2.GetValueWithResultMode(), this._aXO = 0, this._aYO = 0, this._bXO = 0, this._bYO = 0, this._cXO = 0, this._cYO = 0, this._dXO = 0, this._dYO = 0, this._d0x = 0, this._d0y = 0, this._d1x = 0, this._d1y = 0, this._d2x = 0, this._d2y = 0, this._x1Factor = 0, this._x2Factor = 0, this._x3Factor = 0, this._y1Factor = 0, this._y2Factor = 0, this._y3Factor = 0, this._lutIndex = NaN, this._initialized = false, this._len = 100, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._length = 0, this._lut = [], this._lutObjects = [];
          for (let t2 = 0; t2 < 100; t2++) this._lutObjects.push({ x: 0, y: 0, t: 0, distance: 0 });
          this._CalculateLength();
        }
        Release() {
          C33.clearArray(this._arcLengths), this._arcLengths = null, C33.clearArray(this._lut), this._lut = null, C33.clearArray(this._lutObjects), this._lutObjects = null;
        }
        GetType() {
          return "cubic-bezier";
        }
        GetIndex() {
          return this._index;
        }
        GetStepCount() {
          return Math.floor(this._length / 25);
        }
        GetStepIncrement() {
          return 1 / this.GetStepCount();
        }
        SetOrigin(t, i2) {
          this._originX = t, this._originY = i2, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._CalculateLength(), this._aXO = this._aX + this._originX, this._aYO = this._aY + this._originY, this._bXO = this._bX + this._originX, this._bYO = this._bY + this._originY, this._cXO = this._cX + this._originX, this._cYO = this._cY + this._originY, this._dXO = this._dX + this._originX, this._dYO = this._dY + this._originY, this._d0x = 3 * (this._bXO - this._aXO), this._d0y = 3 * (this._bYO - this._aYO), this._d1x = 3 * (this._cXO - this._bXO), this._d1y = 3 * (this._cYO - this._bYO), this._d2x = 3 * (this._dXO - this._cXO), this._d2y = 3 * (this._dYO - this._cYO), this._x1Factor = 3 * (this._bXO - this._aXO), this._x2Factor = 3 * (this._aXO + this._cXO - 2 * this._bXO), this._x3Factor = this._dXO - this._aXO + 3 * (this._bXO - this._cXO), this._y1Factor = 3 * (this._bYO - this._aYO), this._y2Factor = 3 * (this._aYO + this._cYO - 2 * this._bYO), this._y3Factor = this._dYO - this._aYO + 3 * (this._bYO - this._cYO);
        }
        Map(t) {
          if (!this._initialized) return NaN;
          const i2 = this._Map(t);
          return MAP_RESULT[0] = this._X(i2), MAP_RESULT[1] = this._Y(i2), MAP_RESULT;
        }
        Project(t, i2) {
          const e = this._GenerateLUT(100), s2 = this._FindClosestFromLUT(t, i2, e), _ = this._RefineProjection(t, i2, e, s2);
          return PROJECTION_RESULT[0] = _.x, PROJECTION_RESULT[1] = _.y, PROJECTION_RESULT[2] = _.t, PROJECTION_RESULT[3] = _.distance, PROJECTION_RESULT;
        }
        ProjectWithRange(t, i2, e) {
          const s2 = this._GenerateLUT(100), _ = this._FindClosestFromLUTWithRange(t, i2, s2, e), h = this._RefineProjection(t, i2, s2, _);
          return PROJECTION_RESULT[0] = h.x, PROJECTION_RESULT[1] = h.y, PROJECTION_RESULT[2] = h.t, PROJECTION_RESULT[3] = h.distance, PROJECTION_RESULT;
        }
        Tangent(t) {
          const i2 = 1 - t, e = i2 * i2, s2 = 2 * i2 * t, _ = t * t, h = e * this._d0x + s2 * this._d1x + _ * this._d2x, n = e * this._d0y + s2 * this._d1y + _ * this._d2y, r2 = C33.hypot2DFast(h, n);
          return TANGENT_RESULT[0] = h / r2, TANGENT_RESULT[1] = n / r2, TANGENT_RESULT;
        }
        TangentAngle(t) {
          const i2 = 1 - t, e = i2 * i2, s2 = 2 * i2 * t, _ = t * t, h = e * this._d0x + s2 * this._d1x + _ * this._d2x, n = e * this._d0y + s2 * this._d1y + _ * this._d2y;
          return Math.atan2(n, h);
        }
        _Map(t) {
          if (!this._initialized) return;
          let i2 = t * this._arcLengths[this._len], e = 0, s2 = this._len, _ = 0;
          for (; e < s2; ) _ = e + ((s2 - e) / 2 | 0), this._arcLengths[_] < i2 ? e = _ + 1 : s2 = _;
          this._arcLengths[_] > i2 && _--;
          const h = this._arcLengths[_];
          return h === i2 ? _ / this._len : (_ + (i2 - h) / (this._arcLengths[_ + 1] - h)) / this._len;
        }
        _X(t) {
          return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(t, this._aX + this._originX, this._bX + this._originX, this._cX + this._originX, this._dX + this._originX) : NaN;
        }
        _Y(t) {
          return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(t, this._aY + this._originY, this._bY + this._originY, this._cY + this._originY, this._dY + this._originY) : NaN;
        }
        _GenerateLUT(t) {
          if (t = t || 100, this._lut.length >= t) return this._lut;
          this._lut = new Array(t), t++;
          for (let i2 = 0; i2 < t - 1; i2++) {
            const e = i2 / (t - 1), s2 = e ** 2, _ = e ** 3, h = this._x1Factor * e, n = this._x2Factor * s2, r2 = this._x3Factor * _, a2 = this._y1Factor * e, c2 = this._y2Factor * s2, l2 = this._y3Factor * _, o2 = this._aXO + h + n + r2, d2 = this._aYO + a2 + c2 + l2;
            this._lutObjects[i2].x = o2, this._lutObjects[i2].y = d2, this._lutObjects[i2].t = e, this._lutObjects[i2].distance = 0, this._lut[i2] = this._lutObjects[i2];
          }
          return this._lut;
        }
        _FindClosestFromLUT(t, i2, e, s2 = null, _ = Number.MAX_SAFE_INTEGER) {
          let h = 0;
          if (isNaN(this._lutIndex)) for (let s3 = 0; s3 < 100; s3++) {
            const n = e[s3], r2 = n.x - t, a2 = n.y - i2;
            n.distance = r2 * r2 + a2 * a2, n.distance < _ && (_ = n.distance, h = s3);
          }
          else {
            for (let s3 = this._lutIndex; s3 < this._lutIndex + 5 && !(s3 >= e.length); s3++) {
              const n = e[s3], r2 = n.x - t, a2 = n.y - i2;
              n.distance = r2 * r2 + a2 * a2, n.distance < _ && (_ = n.distance, h = s3);
            }
            for (let s3 = this._lutIndex; s3 > this._lutIndex - 5 && !(s3 < 0); s3--) {
              const n = e[s3], r2 = n.x - t, a2 = n.y - i2;
              n.distance = r2 * r2 + a2 * a2, n.distance < _ && (_ = n.distance, h = s3);
            }
          }
          return this._lutIndex = h, h;
        }
        _FindClosestFromLUTWithRange(t, i2, e, s2, _ = Number.MAX_SAFE_INTEGER) {
          let h = 0;
          if (isNaN(this._lutIndex)) for (let n = 0; n < 100; n++) {
            const r2 = e[n], a2 = r2.x - t, c2 = r2.y - i2;
            r2.distance = a2 * a2 + c2 * c2, r2.t >= s2[0] && r2.t <= s2[1] && r2.distance < _ && (_ = r2.distance, h = n);
          }
          else {
            for (let n = this._lutIndex; n < this._lutIndex + 5 && !(n >= e.length); n++) {
              const r2 = e[n], a2 = r2.x - t, c2 = r2.y - i2;
              r2.distance = a2 * a2 + c2 * c2, r2.t >= s2[0] && r2.t <= s2[1] && r2.distance < _ && (_ = r2.distance, h = n);
            }
            for (let n = this._lutIndex; n > this._lutIndex - 5 && !(n < 0); n--) {
              const r2 = e[n], a2 = r2.x - t, c2 = r2.y - i2;
              r2.distance = a2 * a2 + c2 * c2, r2.t >= s2[0] && r2.t <= s2[1] && r2.distance < _ && (_ = r2.distance, h = n);
            }
          }
          return this._lutIndex = h, h;
        }
        _RefineProjection(t, i2, e, s2) {
          let _ = e[s2], h = 1, n = Number.MAX_SAFE_INTEGER;
          t: do {
            const h2 = e.length;
            let r2 = 0 === s2 ? 0 : s2 - 1, a2 = s2 === h2 - 1 ? h2 - 1 : s2 + 1, c2 = e[r2].t, l2 = (e[a2].t - c2) / 4;
            if (l2 < 1e-3) break;
            REFINE_LUT[0] = e[r2];
            for (let e2 = 1; e2 <= 2; e2++) {
              const h3 = c2 + e2 * l2, r3 = h3 ** 2, a3 = h3 ** 3, o2 = this._x1Factor * h3, d2 = this._x2Factor * r3, u = this._x3Factor * a3, O = this._y1Factor * h3, T = this._y2Factor * r3, E = this._y3Factor * a3, R = this._aXO + o2 + d2 + u, g = this._aYO + O + T + E, N = R - t, I = g - i2, S = N * N + I * I;
              if (S < n) {
                n = S, s2 = e2, REFINE_RESULT.x = R, REFINE_RESULT.y = g, REFINE_RESULT.t = h3, REFINE_RESULT.distance = S, _ = REFINE_RESULT;
                break t;
              }
              const x = REFINE_LUT_OBJECTS[e2 - 1];
              x.x = R, x.y = g, x.t = h3, x.distance = S, REFINE_LUT[e2] = x;
            }
            REFINE_LUT[3] = e[a2], e = REFINE_LUT;
          } while (h++ < 20);
          return _;
        }
        _CalculateLength() {
          this._initialized = true;
          let t = this._X(0), i2 = this._Y(0), e = 0;
          for (let s2 = 1; s2 <= this._len; s2++) {
            const _ = this._X(0.01 * s2), h = this._Y(0.01 * s2), n = t - _, r2 = i2 - h;
            e += C33.hypot2DFast(n, r2), this._arcLengths[s2] = e, t = _, i2 = h;
          }
          this._length = e;
        }
      }, C33.TimelineLineSegmentInfo = class {
        constructor(t, i2, e) {
          this._index = e, this._targetX = t.GetValueWithResultMode(), this._targetY = i2.GetValueWithResultMode(), this._originX = 0, this._originY = 0;
        }
        Release() {
        }
        GetType() {
          return "line";
        }
        GetIndex() {
          return this._index;
        }
        SetOrigin(t, i2) {
          this._originX = t, this._originY = i2;
        }
        GetX() {
          return this._targetX + this._originX;
        }
        GetY() {
          return this._targetY + this._originY;
        }
      };
    }
    {
      const C33 = self.C3, PING_PONG_BEGIN = 0, PING_PONG_END = 1;
      C33.TimelineState = class extends C33.DefendedBase {
        constructor(t, e, i2) {
          super(), this._runtime = i2.GetRuntime(), this._timelineManager = i2, this._timelineDataItem = e, this._name = t, this._tracks = [], this._tracksLength = 0, this._beforeAndAfterTracks = null, this._beforeAndAfterTracksLength = 0, this.CreateTrackStates(), this._playPromise = null, this._playResolve = null, this._playheadTime = 0, this._overshoot = 0, this._playbackRate = 1, this._pingPongState = 0, this._resumePingPongState = -1, this._currentRepeatCount = 1, this._isPlaying = false, this._isScheduled = false, this._initialStateSet = false, this._complete = true, this._released = false, this._markedForRemoval = false, this._completedTick = -1, this._implicitPause = false, this._isTemplate = false, this._finishedTriggers = false, this._firstTick = false, this._lastDelta = NaN, this._tags = [""], this._stringTags = "", this._tagsChanged = false, this._renderChange = 0, this._hasNestedContent = 0, this._stoppedKeyframeDataItem = null, this._iTimelineState = null;
        }
        static CreateInitial(t, e) {
          const i2 = e.GetTimelineDataManager(), s2 = i2.GetNameId(), a2 = i2.Get(t[s2]), n = C33.New(C33.TimelineState, t[s2], a2, e);
          return n.SetIsTemplate(true), n;
        }
        static CreateFromTemplate(t, e, i2) {
          return C33.New(C33.TimelineState, t, e, i2);
        }
        Release() {
          if (this.IsReleased()) return;
          const t = this._runtime.Dispatcher();
          this._timelineManager.DeScheduleTimeline(this), this._timelineManager.CompleteTimelineAndResolve(this);
          for (const t2 of this._tracks) t2.Release();
          C33.clearArray(this._tracks), this._tracks = null, this._runtime = null, this._timelineManager = null, this._timelineDataItem = null, this._released = true, this._playPromise = null, this._playResolve = null, this.FireReleaseEvent(t);
        }
        FireReleaseEvent(t) {
          const e = C33.New(C33.Event, "timelinestatereleased");
          e.timelineState = this, t.dispatchEvent(e);
        }
        GetType() {
          return 0;
        }
        CreateTrackStates() {
          for (const t of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracksLength = this._tracks.push(C33.TrackState.Create(this, t));
        }
        GetTimelineManager() {
          return this._timelineManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetTracks() {
          return this._tracks;
        }
        GetSimilarPropertyTracks(t, e, i2, s2) {
          if (!this._hasNestedContent) return;
          let a2;
          for (let n = 0; n < this._tracks.length; n++) {
            let r2 = this._tracks[n];
            if (t !== r2.GetInstance()) continue;
            const h = r2.GetPropertyTrack(i2);
            h && (e.constructor === h.GetSourceAdapter().constructor && h.GetResultMode() === s2.GetResultMode() && (a2 || (a2 = []), a2.push(h)));
          }
          return a2;
        }
        HasTracks() {
          return !!this._tracks.length;
        }
        GetTrackById(t) {
          for (const e of this._tracks) if (C33.equalsNoCase(e.GetId(), t)) return e;
          return null;
        }
        GetTrackByName(t) {
          for (const e of this._tracks) if (!e.IsInstanceTrack() && C33.equalsNoCase(e.GetName(), t)) return e;
          return null;
        }
        SetName(t) {
          this._name = t;
        }
        GetName() {
          return this._name;
        }
        GetTimelineDataItem() {
          return this._timelineDataItem;
        }
        GetTemplateName() {
          return this._timelineDataItem.GetName();
        }
        GetTotalTime() {
          return this._timelineDataItem.GetTotalTime();
        }
        SetTotalTime(t) {
          this._timelineDataItem.SetTotalTime(t);
        }
        GetStep() {
          return this._timelineDataItem.GetStep();
        }
        SetStep(t) {
          this._timelineDataItem.SetStep(t);
        }
        GetInterpolationMode() {
          return this._timelineDataItem.GetInterpolationMode();
        }
        SetInterpolationMode(t) {
          this._timelineDataItem.SetInterpolationMode(t);
        }
        GetResultMode() {
          return this._timelineDataItem.GetResultMode();
        }
        SetResultMode(t) {
          this._timelineDataItem.GetResultMode(t);
        }
        SetEase(t) {
          for (const e of this.GetTracks()) e.SetEase(t);
        }
        GetLoop() {
          return this._timelineDataItem.GetLoop();
        }
        SetLoop(t) {
          return this._timelineDataItem.SetLoop(t);
        }
        GetPingPong() {
          return this._timelineDataItem.GetPingPong();
        }
        SetPingPong(t) {
          return this._timelineDataItem.SetPingPong(t);
        }
        GetRepeatCount() {
          return this._timelineDataItem.GetRepeatCount();
        }
        SetRepeatCount(t) {
          return this._timelineDataItem.SetRepeatCount(t);
        }
        SetPlaybackRate(t) {
          return this._playbackRate = t;
        }
        GetPlaybackRate() {
          return this._playbackRate;
        }
        GetStartOnLayout() {
          return this._timelineDataItem.GetStartOnLayout();
        }
        GetTransformWithSceneGraph() {
          return this._timelineDataItem.GetTransformWithSceneGraph();
        }
        GetUseSystemTimescale() {
          return this._timelineDataItem.GetUseSystemTimescale();
        }
        GetPingPongState() {
          return this._pingPongState;
        }
        IsForwardPlayBack() {
          return !this.IsPlaying() || this._playbackRate > 0;
        }
        GetPlayPromise() {
          return this._playPromise || (this._playPromise = new Promise((t) => {
            this._playResolve = t;
          })), this._playPromise;
        }
        ResolvePlayPromise() {
          this._playPromise && (this._playResolve(), this._playPromise = null, this._playResolve = null);
        }
        SetTags(t) {
          this._tags = C33.TimelineState._GetTagArray(t), this._tagsChanged = true;
        }
        GetTags() {
          return this._tags;
        }
        GetStringTags() {
          return this._tagsChanged && (this._stringTags = this._tags.join(" ")), this._tagsChanged = false, this._stringTags;
        }
        HasTags(t) {
          if (!this._tags) return false;
          if (!this._tags.length) return false;
          const e = C33.TimelineState._GetTagArray(t);
          return !!e && (!!e.length && e.every(C33.TimelineState._HasTag, this));
        }
        OnStarted() {
          C33.Plugins.Timeline && this.constructor === C33.TimelineState && (C33.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineStarted), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineStartedByName), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineStartedByTags), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnAnyTimelineStarted), C33.Plugins.Timeline.Cnds.PopTriggerTimeline());
        }
        OnCompleted() {
          this._completedTick = this._runtime.GetTickCount();
        }
        FinishTriggers() {
          this._finishedTriggers || (this._finishedTriggers = true, C33.Plugins.Timeline && this.constructor === C33.TimelineState && (C33.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineFinishedByName), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnAnyTimelineFinished), C33.Plugins.Timeline.Cnds.PopTriggerTimeline()));
        }
        SetPlaying(t) {
          this._isPlaying = t;
        }
        IsCompletedTick() {
          return this._completedTick === this._runtime.GetTickCount();
        }
        IsPlaying(t = false) {
          return !!this.IsCompletedTick() || (!(!this.IsScheduled() || t) || this._isPlaying);
        }
        _IsPlaying() {
          return this.IsPlaying(true);
        }
        IsPaused() {
          return this._IsPaused();
        }
        _IsPaused() {
          return !this.IsReleased() && (!this.IsScheduled() && (!this._IsPlaying() && !this.IsComplete()));
        }
        SetScheduled(t) {
          this._isScheduled = t;
        }
        IsScheduled() {
          return this._isScheduled;
        }
        SetComplete(t) {
          this._complete = t;
          const e = this.GetLoop(), i2 = this.GetPingPong();
          if (e || i2) {
            if (e && !i2) ;
            else if (!e && i2) {
              const t2 = this.GetTime();
              1 === this._pingPongState && (t2 <= 0 || t2 >= this.GetTotalTime()) && (this._complete = true);
            }
          } else {
            const t2 = this.GetTime();
            (t2 <= 0 || t2 >= this.GetTotalTime()) && (this._complete = true);
          }
        }
        IsComplete() {
          return this._complete;
        }
        IsReleased() {
          return this._released;
        }
        SetMarkedForRemoval(t) {
          this._markedForRemoval = t;
        }
        IsMarkedForRemoval() {
          return this._markedForRemoval;
        }
        SetImplicitPause(t) {
          this._implicitPause = t;
        }
        IsImplicitPause() {
          return this._implicitPause;
        }
        SetIsTemplate(t) {
          this._isTemplate = !!t;
        }
        IsTemplate() {
          return this._isTemplate;
        }
        InitialStateSet() {
          return this._initialStateSet;
        }
        GetTime() {
          return this._playheadTime;
        }
        SetTime(t) {
          const e = this.GetTime();
          this._SetTime(t), this.SetComplete(false), this.IsComplete() || this.SetImplicitPause(true), (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet) && (this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime()), this._SetUpdateStateBefore(), this._Interpolate(this.GetTime(), false, true, true, e), this._SetUpdateStateAfter(), this._renderChange && this.GetRuntime().UpdateRender(), this._OnSetTime();
        }
        _SetTime(t) {
          C33.IsFiniteNumber(t) || (t = this.GetTotalTime()), t < 0 ? this._playheadTime = 0 : t >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = t;
        }
        _SetTimeAndReset(t) {
          C33.IsFiniteNumber(t) || (t = this.GetTotalTime()), t < 0 ? this._playheadTime = 0 : t >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = t;
          for (const t2 of this._tracks) t2.SetResetState();
        }
        _OnSetTime() {
          C33.Plugins.Timeline && this.constructor === C33.TimelineState && (C33.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimeSetByTags), C33.Plugins.Timeline.Cnds.PopTriggerTimeline());
        }
        _CanResume() {
          if (this.GetLoop()) return true;
          if (this.GetPingPong() && 1 === this._pingPongState) {
            if (this.IsForwardPlayBack()) {
              if (this.GetTime() >= this.GetTotalTime()) return false;
            } else if (this.GetTime() <= 0) return false;
          } else if (!this.GetLoop() && !this.GetPingPong()) {
            if (this.IsForwardPlayBack()) {
              if (this.GetTime() >= this.GetTotalTime()) return false;
            } else if (this.GetTime() <= 0) return false;
          }
          return true;
        }
        Resume() {
          this.IsReleased() || this._CanResume() && this.Play(true);
        }
        Play(t = false) {
          return !this.IsReleased() && (!this.IsScheduled() && (this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : !this._IsPlaying() && (!!(this.IsComplete() || t || this.IsImplicitPause()) && this._ScheduleStoppedTimeline())));
        }
        _SchedulePlayingTimeline() {
          return this.SetImplicitPause(false), this._timelineManager.RemovePlayingTimeline(this), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;
        }
        _ScheduleStoppedTimeline() {
          return this.SetImplicitPause(false), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;
        }
        Stop(t = false) {
          this.IsReleased() || (this.SetComplete(t), this._timelineManager.CompleteTimeline(this), this.IsComplete() && this.ResolvePlayPromise());
        }
        Reset(t = true, e = false) {
          if (this.IsReleased()) return;
          if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this);
          if (this.IsComplete()) return;
          this.Stop(true), this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
          const i2 = this.GetTime();
          this._SetUpdateStateBefore(), e ? this._InterpolateBeforeChangeLayout(i2) : this._Interpolate(i2, false, false, true), t && this._OnSetTime(), this._SetUpdateStateAfter(), this._renderChange && t && this.GetRuntime().UpdateRender();
        }
        ResetBeforeChangeLayout() {
          this.Reset(false, true);
        }
        _InterpolateBeforeChangeLayout(t) {
          this._Interpolate(t, false, false, true, NaN, false, true);
        }
        _OnBeforeChangeLayout() {
          return !!this.IsReleased() || !(!this.GetRuntime().IsLoadingState() && this.HasValidGlobalTracks()) && (this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.GetRuntime().IsLoadingState() || this.ResetBeforeChangeLayout(), true);
        }
        SetInitialStateFromSetTime() {
          this.SetInitialState(true);
        }
        SetInitialStateForce() {
          this.SetInitialState(false, true), this.SetPlaying(false), this.SetScheduled(false);
        }
        SetInitialState(t = false, e = false) {
          if (!this.IsMarkedForRemoval() || e) if (t) {
            this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this._SetUpdateStateBefore();
            for (const t2 of this._tracks) t2.SetInitialState();
            this._SetUpdateStateAfter();
          } else if (this.SetPlaying(true), this.SetScheduled(false), this.OnStarted(), this.IsComplete()) {
            this._completedTick = -1, 0 !== this._pingPongState && (this._playbackRate = Math.abs(this._playbackRate)), this._pingPongState = 0, this._resumePingPongState = -1, this._currentRepeatCount = 1, this._complete = false, this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime()), this._SetUpdateStateBefore();
            for (const t2 of this._tracks) t2.SetInitialState();
            this._SetUpdateStateAfter();
          } else {
            -1 !== this._resumePingPongState && (this._pingPongState = this._resumePingPongState), this._firstTick = true, this._finishedTriggers = false, this._SetUpdateStateBefore();
            for (const t2 of this._tracks) t2.SetResumeState();
            this._SetUpdateStateAfter();
          }
        }
        GetRenderChange() {
          return this._renderChange;
        }
        _SetUpdateStateBefore() {
          this._hasNestedContent = 0;
          for (const t of this._tracks) t.IsNested() && (this._hasNestedContent = 1);
        }
        _SetUpdateStateAfter() {
          this._renderChange = 0;
          for (const t of this._tracks) t._SetUpdateState(), 0 === this._renderChange && 1 === t.GetRenderChange() && (this._renderChange = 1), this._beforeAndAfterTracks || 1 !== t.GetNeedsBeforeAndAfter() || (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []), this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(t));
        }
        Tick(t, e, i2) {
          if (this.GetUseSystemTimescale()) {
            if (0 === t && 0 === this._lastDelta) return;
            this._lastDelta = t, t = i2;
          } else {
            if (0 === i2 && 0 === this._lastDelta) return;
            this._lastDelta = i2, t = i2, e = 1;
          }
          const s2 = this._playheadTime + this._overshoot, a2 = s2 + t * e * this._playbackRate, n = this._timelineDataItem._totalTime;
          a2 < 0 ? (this._playheadTime = 0, this._overshoot = -a2) : a2 >= n ? (this._playheadTime = n, this._overshoot = this._playheadTime - a2) : (this._playheadTime = a2, this._overshoot = 0);
          let r2 = false, h = false;
          const l2 = this.GetLoop(), o2 = this.GetPingPong();
          let m;
          l2 || o2 ? l2 && !o2 ? this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTimeAndReset(0), h = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(n), h = true) : !l2 && o2 ? this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTime(n), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : r2 = true : 0 === this._pingPongState && (this._pingPongState = 1)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : r2 = true : 0 === this._pingPongState && (this._pingPongState = 1)) : l2 && o2 && (this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTime(n), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, this._pingPongState++, C33.wrap(this._pingPongState, 0, 2)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, this._pingPongState++, C33.wrap(this._pingPongState, 0, 2))) : this._playbackRate > 0 ? this._playheadTime >= n && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), h = true) : (this._SetTime(n), r2 = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(n), h = true) : (this._SetTime(0), r2 = true));
          const _ = this._tracksLength;
          if (r2) {
            for (m = 0; m < _; m++) this._tracks[m].SetEndState();
            return this.Stop(true), void this.OnCompleted();
          }
          const c2 = this._beforeAndAfterTracksLength;
          for (m = 0; m < c2; m++) this._beforeAndAfterTracks[m].BeforeInterpolate();
          if (1 === this._hasNestedContent) for (m = 0; m < _; m++) {
            const t2 = this._tracks[m], e2 = t2.GetStartOffset();
            this._playheadTime - e2 < 0 && s2 - e2 > 0 ? (this._playheadTime = e2 < 0 ? 0 : e2 >= n ? n : e2, t2.Interpolate(e2, true, false, h, this._firstTick, false)) : t2.Interpolate(this._playheadTime, true, false, h, this._firstTick, false);
          }
          else for (m = 0; m < _; m++) this._tracks[m].Interpolate(this._playheadTime, true, false, h, this._firstTick, false);
          if (!this.IsPlaying() && this._stoppedKeyframeDataItem) {
            const t2 = this._stoppedKeyframeDataItem.GetTime() + this._stoppedKeyframeDataItem.GetKeyframeData().GetTrackDataItem().GetStartOffset(), e2 = this._playheadTime - t2;
            this._playheadTime -= e2, 0 !== this._overshoot && (this._overshoot -= e2), this._stoppedKeyframeDataItem = null;
          }
          for (m = 0; m < c2; m++) this._beforeAndAfterTracks[m].AfterInterpolate();
          this._firstTick && (this._firstTick = false);
        }
        SetStoppedOnKeyframe(t) {
          this._stoppedKeyframeDataItem = t;
        }
        GetStoppedOnKeyframe() {
          return this._stoppedKeyframeDataItem;
        }
        _Interpolate(t, e = false, i2 = false, s2 = false, a2 = NaN, n = false, r2 = false) {
          for (const t2 of this._tracks) t2.BeforeInterpolate();
          for (const n2 of this._tracks) {
            let h = t;
            if ("number" == typeof a2 && !isNaN(a2)) {
              const t2 = this.GetTime() - n2.GetStartOffset(), e2 = a2 - n2.GetStartOffset();
              t2 < 0 && e2 > 0 && (h = n2.GetStartOffset(), this._SetTime(h));
            }
            n2.Interpolate(h, e, i2, s2, this._firstTick, r2);
          }
          for (const t2 of this._tracks) t2.AfterInterpolate();
          this._firstTick && n && (this._firstTick = false);
        }
        AddTrack() {
          const t = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), e = C33.TrackState.Create(this, t);
          return this._tracksLength = this._tracks.push(e), e;
        }
        Removed() {
          if (!this.IsReleased()) for (const t of this._tracks) t.TimelineRemoved();
        }
        CleanCaches() {
          for (const t of this._tracks) t.CleanCaches();
        }
        ClearTrackInstances() {
          for (const t of this._tracks) t.ClearInstance();
        }
        SetTrackInstance(t, e, i2) {
          if (e) {
            if ("number" == typeof i2 && i2 >= 0) {
              const t2 = this._tracks[i2];
              if (!t2) return;
              return t2.SetInstance(e), void this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);
            }
            for (const i3 of this._tracks) if (i3.IsInstanceTrack()) {
              if (t) {
                if (i3.GetId() !== t) continue;
                i3.SetInstance(e), this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);
                break;
              }
              if (!i3.HasInstance()) {
                i3.SetInstance(e), this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);
                break;
              }
            }
          }
        }
        HasTrackInstance(t, e) {
          for (const i2 of this._tracks) if (i2.IsInstanceTrack()) {
            if (e) {
              if (e === i2.GetId() && t === i2.GetInstance()) return true;
            } else if (t === i2.GetInstance()) return true;
          }
          return false;
        }
        HasValidTracks() {
          return this._tracks.some((t) => !t.IsInstanceTrack() || t.CanInstanceBeValid());
        }
        HasValidGlobalTracks() {
          return this._tracks.some((t) => {
            if (t.IsInstanceTrack()) {
              if (!t.CanInstanceBeValid()) return false;
              const e = t.GetObjectClass();
              return !!e && e.IsGlobal();
            }
            return false;
          });
        }
        GetPropertyTrack(t) {
          for (const e of this.GetTracks()) for (const i2 of e.GetPropertyTracks()) if (i2.GetPropertyName() === t) return i2;
        }
        GetTrackFromInstance(t) {
          for (const e of this._tracks) if (t === e.GetInstance()) return e;
          return null;
        }
        GetKeyframeWithTags(t) {
          let e = t ? t.split(" ") : [];
          const i2 = new Set(e.map((t2) => t2.toLowerCase().trim()));
          e = [...i2.values()];
          for (const t2 of this.GetTracks()) for (const i3 of t2.GetKeyframeDataItems()) {
            if (e.every((t3) => i3.HasTag(t3))) return i3;
          }
        }
        GetObjectClasses() {
          const t = [];
          for (const e of this.GetTracks()) t.push(e.GetObjectClass());
          return t.filter((t2) => t2);
        }
        _OnAfterLoad() {
          for (const t of this.GetTracks()) t._OnAfterLoad();
        }
        _SaveToJson() {
          return { "tracksJson": this._SaveTracksToJson(), "name": this._name, "playheadTime": this.GetTime(), "playbackRate": this._playbackRate, "pingPongState": this._pingPongState, "resumePingPongState": this._resumePingPongState, "currentRepeatCount": this._currentRepeatCount, "isPlaying": this._isPlaying, "isScheduled": this._isScheduled, "initialStateSet": this._initialStateSet, "finishedTriggers": this._finishedTriggers, "complete": this._complete, "released": this._released, "markedForRemoval": this._markedForRemoval, "completedTick": this._completedTick, "implicitPause": this._implicitPause, "isTemplate": this._isTemplate, "tags": this._tags.join(" "), "stringTags": this._stringTags, "tagsChanged": this._tagsChanged, "firstTick": this._firstTick };
        }
        _LoadFromJson(t) {
          t && (this._LoadTracksFromJson(t["tracksJson"]), this._name = t["name"], this._playheadTime = t["playheadTime"], this._playbackRate = t["playbackRate"], this._pingPongState = t["pingPongState"], this._resumePingPongState = t.hasOwnProperty("resumePingPongState") ? t["resumePingPongState"] : -1, this._currentRepeatCount = t["currentRepeatCount"], this._isPlaying = !!t["isPlaying"], this._isScheduled = !!t["isScheduled"], this._initialStateSet = !!t["initialStateSet"], this._finishedTriggers = !!t.hasOwnProperty("finishedTriggers") && !!t["finishedTriggers"], this._complete = !!t["complete"], this._released = !!t["released"], this._markedForRemoval = !!t["markedForRemoval"], this._completedTick = t["completedTick"], this._implicitPause = !!t["implicitPause"], this._isTemplate = !!t["isTemplate"], this._tags = t["tags"].split(" "), this._stringTags = t["stringTags"], this._tagsChanged = !!t["tagsChanged"], this._firstTick = !!t["firstTick"]);
        }
        _SaveTracksToJson() {
          return this._tracks.map((t) => t._SaveToJson());
        }
        _LoadTracksFromJson(t) {
          this.ClearTrackInstances(), t.forEach((t2, e) => {
            this._tracks[e]._LoadFromJson(t2);
          }), this._tracks.filter((t2) => t2.CanInstanceBeValid());
        }
        static _HasTag(t) {
          const e = this.GetTags();
          return "" === t ? 1 === e.length && "" === e[0] : e.map((t2) => t2.toLowerCase()).includes(t.toLowerCase());
        }
        static _GetTagArray(t) {
          if (C33.IsArray(t)) return t.slice(0);
          if (C33.IsString(t)) return t.split(" ");
          throw new Error("invalid tags");
        }
        GetITimelineState() {
          return this._iTimelineState || (this._iTimelineState = C33.New(self.ITimelineState, this)), this._iTimelineState;
        }
      };
    }
    {
      const C33 = self.C3, INSTANCE_TRACK = 0, VALUE_TRACK = 1, AUDIO_TRACK = 2;
      C33.TrackState = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._timeline = t, this._trackDataItem = e, this._trackData = e.GetTrackData(), this._instanceUid = NaN, this._objectClassIndex = NaN, this._instance = null, this._worldInfo = null, this._cleared = false, this._isNested = e.GetStartOffset() > 0, this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this._instanceUidToLoad = NaN, this._lastKeyframeDataItem = null, this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray(), this._propertyTracks = [], this.CreatePropertyTrackStates(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0;
        }
        static Create(t, e) {
          return C33.New(C33.TrackState, t, e);
        }
        Release() {
          this._keyframeDataItems = null;
          for (const t of this._propertyTracks) t.Release();
          C33.clearArray(this._propertyTracks), this._propertyTracks = null, this._timeline = null, this._instance = null, this._worldInfo = null, this._trackDataItem = null, this._lastKeyframeDataItem = null;
        }
        CreatePropertyTrackStates() {
          for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C33.PropertyTrackState.Create(this, t));
        }
        TimelineRemoved() {
          for (const t of this._propertyTracks) t.TimelineRemoved();
        }
        CleanCaches() {
          for (const t of this._propertyTracks) t.CleanCaches();
          this._instance = null, this._worldInfo = null;
        }
        GetTimeline() {
          return this._timeline;
        }
        GetRuntime() {
          return this._timeline.GetRuntime();
        }
        GetKeyframeDataItems() {
          return this._keyframeDataItems || (this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()), this._keyframeDataItems;
        }
        GetPropertyTracks() {
          return this._propertyTracks;
        }
        GetPropertyTrack(t) {
          for (let e = 0; e < this._propertyTracks.length; e++) {
            const a2 = this._propertyTracks[e];
            if (a2.GetPropertyName() === t) return a2;
          }
        }
        MaybeGetInstance() {
          this._instance || this.GetInstance();
        }
        IsInstanceValid() {
          return !!this._instance && !this._instance.IsDestroyed();
        }
        CanInstanceBeValid() {
          if (!this.IsInstanceTrack()) return false;
          const t = this.GetInstanceUID(), e = this.GetRuntime().GetInstanceByUID(t);
          return !!e && !e.IsDestroyed();
        }
        GetObjectClass() {
          if (!this.IsInstanceTrack()) return;
          const t = this.GetObjectClassIndex();
          return -1 !== t ? this.GetRuntime().GetObjectClassByIndex(t) : void 0;
        }
        GetTrackIndexInTimeline() {
          return this._timeline.GetTracks().indexOf(this);
        }
        ClearInstance() {
          this._instance = null, this._instanceUid = NaN, this._worldInfo = null, this._objectClassIndex = NaN, this._cleared = true;
        }
        HasInstance() {
          return !!this._instance;
        }
        GetInstance() {
          if (this._cleared) return;
          if (this._instance && this.IsInstanceValid()) return this._instance;
          const t = this.GetInstanceUID();
          return this._instance = this.GetRuntime().GetInstanceByUID(t), this._instance;
        }
        SetInstance(t) {
          if (this._cleared = false, this._instance !== t) {
            this.CleanCaches(), this._instance = t, this._objectClassIndex = t.GetObjectClass().GetIndex(), this._instanceUid = t.GetUID(), this._worldInfo = t.GetWorldInfo();
            for (const e of this.propertyTrackItems()) {
              const a2 = e.propertyTrack, s2 = e.sourceAdapter;
              switch (a2.GetSourceAdapterId()) {
                case "instance-variable": {
                  s2.GetEditorIndex();
                  const a3 = t.GetObjectClass(), r2 = a3.GetInstanceVariableIndexByName(e.name), i2 = a3.GetInstanceVariableName(r2), n = a3.GetInstanceVariableType(r2);
                  i2 === e.name && n === e.type && s2.UpdateInstanceVariableIndex(r2);
                  break;
                }
                case "behavior": {
                  const a3 = e.behaviorType, r2 = this.GetObjectClass(), i2 = t.GetObjectClass(), n = s2.GetBehaviorType(i2);
                  if (a3 && n) {
                    const t2 = a3.GetName();
                    r2.GetBehaviorIndexByName(t2), i2.GetBehaviorIndexByName(t2), s2.GetEditorIndex();
                    s2.UpdateBehaviorTypeSid(n.GetSID());
                  }
                  break;
                }
              }
            }
          }
        }
        *propertyTrackItems() {
          for (const t of this._propertyTracks) {
            const e = t.GetSourceAdapter(), a2 = this.GetObjectClass(), s2 = { propertyTrack: t, sourceAdapter: e };
            switch (t.GetSourceAdapterId()) {
              case "world-instance":
                s2.property = t.GetPropertyName();
                break;
              case "instance-variable": {
                const t2 = e.GetEditorIndex();
                s2.name = a2.GetInstanceVariableName(t2), s2.type = a2.GetInstanceVariableType(t2);
                break;
              }
              case "effect": {
                const t2 = a2.GetEffectList(), r2 = e.GetEffectType(t2);
                s2.effectType = r2;
                break;
              }
              case "behavior": {
                const t2 = e.GetBehaviorType(a2);
                s2.behaviorType = t2;
                break;
              }
              case "plugin":
                s2.plugin = a2.GetPlugin();
            }
            yield s2;
          }
        }
        GetWorldInfo() {
          if (this._worldInfo && this.IsInstanceValid()) return this._worldInfo;
          const t = this.GetInstance();
          return t && (this._worldInfo = t.GetWorldInfo()), this._worldInfo;
        }
        GetTrackDataItem() {
          return this._trackDataItem;
        }
        GetInstanceUID() {
          return isNaN(this._instanceUid) ? this._trackDataItem.GetInstanceUID() : this._instanceUid;
        }
        SetInstanceUID(t) {
          this._trackDataItem.SetInstanceUID(t);
        }
        GetInterpolationMode() {
          return this._trackDataItem.GetInterpolationMode();
        }
        SetInterpolationMode(t) {
          this._trackDataItem.SetInterpolationMode(t);
        }
        GetResultMode() {
          return this._trackDataItem.GetResultMode();
        }
        GetId() {
          return this._trackDataItem.GetId();
        }
        GetStartOffset() {
          return this._trackDataItem.GetStartOffset();
        }
        GetLocalTotalTime() {
          return this._trackDataItem.GetLocalTotalTime();
        }
        SetLocalTotalTime(t) {
          this._trackDataItem.SetLocalTotalTime(t);
        }
        SetResultMode(t) {
          this._trackDataItem.SetResultMode(t);
        }
        SetEase(t) {
          for (const e of this.GetKeyframeDataItems()) e.SetEase(t);
          for (const e of this.GetPropertyTracks()) e.SetEase(t);
        }
        GetEnable() {
          return this._trackDataItem.GetEnable();
        }
        SetEnable(t) {
          this._trackDataItem.SetEnable(t);
        }
        GetObjectClassIndex() {
          return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex;
        }
        SetObjectClassIndex(t) {
          this._trackDataItem.SetObjectClassIndex(t);
        }
        SetOriginalWidth(t) {
          this._trackDataItem.SetOriginalWidth(t);
        }
        GetOriginalWidth() {
          const t = this.GetInstance();
          if (t) {
            if (t.GetSdkInstance().IsOriginalSizeKnown()) return t.GetSdkInstance().GetOriginalWidth();
          }
          return this._trackDataItem.GetOriginalWidth();
        }
        SetOriginalHeight(t) {
          this._trackDataItem.SetOriginalHeight(t);
        }
        GetOriginalHeight() {
          const t = this.GetInstance();
          if (t) {
            if (t.GetSdkInstance().IsOriginalSizeKnown()) return t.GetSdkInstance().GetOriginalHeight();
          }
          return this._trackDataItem.GetOriginalHeight();
        }
        GetType() {
          return this._trackDataItem.GetType();
        }
        GetName() {
          return this._trackDataItem.GetName();
        }
        IsInstanceTrack() {
          return 0 === this.GetType();
        }
        IsValueTrack() {
          return 1 === this.GetType();
        }
        IsAudioTrack() {
          return 2 === this.GetType();
        }
        GetWorldInfoChange() {
          return this._worldInfoChange;
        }
        GetRenderChange() {
          return this._renderChange;
        }
        GetNeedsBeforeAndAfter() {
          return this._needsBeforeAndAfter;
        }
        IsNested() {
          return this._isNested;
        }
        SetResetState() {
          for (const t of this._propertyTracks) t.SetResetState();
        }
        SetInitialState() {
          if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
          const t = this.GetTimeline().IsForwardPlayBack(), e = t ? 0 : this.GetLocalTotalTime();
          for (const t2 of this._propertyTracks) t2.SetInitialState(e), 0 === this._worldInfoChange && 1 === t2.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === t2.GetRenderChange() && (this._renderChange = 1);
          this._needsBeforeAndAfter = 0;
          this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = t ? this._GetLastKeyFrameBeforeTime(e) : this._GetFirstKeyFrameAfterTime(e), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(e), this.OnInitialKeyframeReached(this._lastKeyframeDataItem);
        }
        SetResumeState() {
          if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
          const t = this._timeline.IsForwardPlayBack(), e = this._timeline.GetTime() - this.GetStartOffset();
          this._lastKeyframeDataItem = t ? this._GetLastKeyFrameBeforeTime(e) : this._GetFirstKeyFrameAfterTime(e);
          for (const t2 of this._propertyTracks) t2.SetResumeState(e);
        }
        SetEndState() {
          if (!this.GetTimeline().IsComplete() && (this.MaybeGetInstance(), (this.IsInstanceValid() || !this.IsInstanceTrack()) && !this._isNested)) {
            const t = this._timeline.GetTime();
            t >= this.GetStartOffset() + this.GetLocalTotalTime() ? this.Interpolate(this.GetLocalTotalTime(), true, false, true, false, false, true) : t <= 0 && this.Interpolate(0, true, false, true, false, false, true);
          }
        }
        _SetUpdateState() {
          for (let t = 0, e = this._propertyTracks.length; t < e; t++) {
            const e2 = this._propertyTracks[t];
            e2._SetUpdateState(), 0 === this._worldInfoChange && 1 === e2.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === e2.GetRenderChange() && (this._renderChange = 1);
          }
        }
        BeforeInterpolate() {
          const t = this._propertyTracks.length;
          for (let e = 0; e < t; e++) this._propertyTracks[e].BeforeInterpolate();
        }
        Interpolate(t, e = false, a2 = false, s2 = false, r2 = false, i2 = false, n = false) {
          this._instance || this.GetInstance();
          const o2 = this._instance && !this._instance.IsDestroyed(), h = 0 === this._trackDataItem._type;
          if ((o2 || !h) && !(i2 && h && this.GetObjectClass().IsGlobal() || (t -= this.GetStartOffset()) < 0)) {
            this.MaybeSetInitialStateOfNestedTrack(t, e), this.MaybeTriggerKeyframeReachedConditions(t, e, r2), !this.GetTimeline().IsPlaying() && this.GetTimeline().GetStoppedOnKeyframe() && (t = this.GetTimeline().GetStoppedOnKeyframe().GetTime());
            for (let e2 = 0, r3 = this._propertyTracks.length; e2 < r3; e2++) this._propertyTracks[e2].Interpolate(t, a2, s2, n);
            this.MaybeSetEndStateOfNestedTrack(t, e), 0 !== this._worldInfoChange && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged());
          }
        }
        AfterInterpolate() {
          const t = this._propertyTracks.length;
          for (let e = 0; e < t; e++) this._propertyTracks[e].AfterInterpolate();
        }
        MaybeSetInitialStateOfNestedTrack(t, e) {
          if (!e) return;
          if (!this._isNested) return;
          if (this._initialStateOfNestedSet) return;
          if (this.GetTimeline().IsForwardPlayBack()) {
            if (t < 0) return;
          } else if (t > this.GetLocalTotalTime()) return;
          for (const t2 of this._propertyTracks) t2.SetInitialState();
          this._initialStateOfNestedSet = true;
        }
        MaybeSetEndStateOfNestedTrack(t, e) {
          if (!e) return;
          if (!this._isNested) return;
          if (this._endStateOfNestedSet) return;
          if (this.GetTimeline().IsForwardPlayBack()) {
            if (t >= this.GetLocalTotalTime()) {
              for (const t2 of this._propertyTracks) t2.Interpolate(this.GetLocalTotalTime(), false, true);
              this._endStateOfNestedSet = true;
            }
          } else if (t <= 0) {
            for (const t2 of this._propertyTracks) t2.Interpolate(0, false, true);
            this._endStateOfNestedSet = true;
          }
        }
        MaybeTriggerKeyframeReachedConditions(t, e, a2) {
          if (a2) return;
          if (!e) return;
          if (!C33.Plugins.Timeline) return;
          const s2 = this.GetTimeline();
          if (s2.IsForwardPlayBack()) {
            const e2 = this._lastKeyframeDataItem.GetNext(), a3 = this._lastKeyframeDataItem.GetTime(), r2 = e2 ? e2.GetTime() : s2.GetTotalTime();
            (t <= a3 || t >= r2) && (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem), e2 && this.OnKeyframeReached(this._lastKeyframeDataItem));
          } else {
            if (!this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem)) return;
            this._lastKeyframeDataItem || (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem));
            const e2 = this._lastKeyframeDataItem.GetLast(), a3 = this._lastKeyframeDataItem.GetTime(), s3 = e2 ? e2.GetTime() : 0;
            (t >= a3 || t <= s3) && (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem), this._lastKeyframeDataItem && this.OnKeyframeReached(this._lastKeyframeDataItem));
          }
        }
        _GetLastKeyFrameBeforeTime(t) {
          const e = this._trackData.GetKeyFrameDataItemAtTime(t, this._trackDataItem);
          return e || this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem);
        }
        _GetFirstKeyFrameAfterTime(t) {
          const e = this._trackData.GetKeyFrameDataItemAtTime(t, this._trackDataItem);
          return e || this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem);
        }
        OnKeyframeReached(t, e = false) {
          if (!C33.Plugins.Timeline) return;
          const a2 = this.GetTimeline(), s2 = a2.GetTimelineManager();
          C33.Plugins.Timeline.Cnds.PushTriggerTimeline(a2), C33.Plugins.Timeline.Cnds.PushTriggerKeyframe(t), s2.Trigger(C33.Plugins.Timeline.Cnds.OnAnyKeyframeReached), s2.Trigger(C33.Plugins.Timeline.Cnds.OnKeyframeReached), a2.IsPlaying() || e || a2.SetStoppedOnKeyframe(t), C33.Plugins.Timeline.Cnds.PopTriggerTimeline(a2), C33.Plugins.Timeline.Cnds.PopTriggerKeyframe(t);
        }
        OnInitialKeyframeReached(t) {
          this.OnKeyframeReached(t, true);
        }
        AddKeyframe() {
          return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem();
        }
        AddPropertyTrack() {
          const t = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem(), e = C33.PropertyTrackState.Create(this, t);
          return this._propertyTracks.push(e), e;
        }
        DeleteKeyframes(t) {
          this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(t);
        }
        DeletePropertyKeyframes(t) {
          for (const e of this._propertyTracks) e.DeletePropertyKeyframes(t);
        }
        SaveState() {
          for (const t of this._propertyTracks) t.SaveState();
        }
        CompareInitialStateWithCurrent() {
          if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) for (const t of this._propertyTracks) t.CompareInitialStateWithCurrent();
        }
        CompareSaveStateWithCurrent() {
          if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
          let t = false;
          for (const e of this._propertyTracks) {
            const a2 = e.CompareSaveStateWithCurrent();
            !t && a2 && (t = true);
          }
          if (t) {
            const t2 = this.AddKeyframe();
            t2.SetTime(this.GetTimeline().GetTime()), t2.SetEase("noease"), t2.SetEnable(true), t2.SetTags("");
          }
        }
        _OnAfterLoad() {
          isNaN(this._instanceUidToLoad) || this._LoadInstanceFromJson(this._instanceUidToLoad), this._instanceUidToLoad = NaN;
        }
        _SaveToJson() {
          const t = this.GetInstance(), e = t ? t.GetUID() : this.GetInstanceUID();
          return { "propertyTracksJson": this._SavePropertyTracksToJson(), "lastKeyframeDataItemJson": this._SaveLastKeyframeDataItemToJson(), "initialStateOfNestedSet": this._initialStateOfNestedSet, "endStateOfNestedSet": this._endStateOfNestedSet, "instanceUid": e, "cleared": this._cleared };
        }
        _LoadFromJson(t) {
          if (t) {
            this._LoadPropertyTracksFromJson(t["propertyTracksJson"]), this._LoadLastKeyframeDataItemFromJson(t["lastKeyframeDataItemJson"]), this._instanceUidToLoad = t["instanceUid"], this._initialStateOfNestedSet = false, t.hasOwnProperty["initialStateOfNestedSet"] && (this._initialStateOfNestedSet = t["initialStateOfNestedSet"]), this._endStateOfNestedSet = false, t.hasOwnProperty["endStateOfNestedSet"] && (this._endStateOfNestedSet = t["endStateOfNestedSet"]), this._cleared = !!t.hasOwnProperty("cleared") && t["cleared"];
            for (const t2 of this._propertyTracks) 0 === this._worldInfoChange && 1 === t2.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === t2.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0, this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
          }
        }
        _SaveLastKeyframeDataItemToJson() {
          return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem);
        }
        _SavePropertyTracksToJson() {
          return this._propertyTracks.map((t) => t._SaveToJson());
        }
        _LoadPropertyTracksFromJson(t) {
          t.forEach((t2, e) => {
            this._propertyTracks[e]._LoadFromJson(t2);
          });
        }
        _LoadInstanceFromJson(t) {
          if (!C33.IsFiniteNumber(t)) return;
          const e = this.GetRuntime().GetInstanceByUID(t);
          if (!e) return;
          this.GetTimeline().SetTrackInstance(this._trackDataItem.GetId(), e, this.GetTrackIndexInTimeline());
        }
        _LoadLastKeyframeDataItemFromJson(t) {
          const e = this._trackDataItem.GetKeyframeData();
          this._lastKeyframeDataItem = e.GetKeyframeDataItemFromIndex(t);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PropertyTrackState = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._track = e, this._propertyTrackDataItem = t, this._propertyTrackData = t.GetPropertyTrackData(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0, this._sourceAdapter = this.GetSourceAdapter(), this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), this._lastPropertyKeyframeDataItem = null, this._absoluteValueObject = null;
        }
        static Create(e, t) {
          return C33.New(C33.PropertyTrackState, e, t);
        }
        Release() {
          this._track = null, this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter = null), this._propertyKeyframeDataItems = null, this._propertyTrackDataItem = null, this._propertyTrackData = null;
        }
        GetWorldInfoChange() {
          return this._worldInfoChange;
        }
        GetRenderChange() {
          return this._renderChange;
        }
        GetNeedsBeforeAndAfter() {
          return this._needsBeforeAndAfter;
        }
        HasAbsoluteValueObject() {
          return !!this._absoluteValueObject;
        }
        SetAbsoluteValueObject(e) {
          this._absoluteValueObject = e;
        }
        GetAbsoluteValueObject() {
          return this._absoluteValueObject;
        }
        GetTrack() {
          return this._track;
        }
        GetPropertyTrackDataItem() {
          return this._propertyTrackDataItem;
        }
        GetPropertyTrackData() {
          return this._propertyTrackData;
        }
        GetTimeline() {
          return this._track.GetTimeline();
        }
        GetRuntime() {
          return this._track.GetRuntime();
        }
        GetInstance() {
          return this._track.GetInstance();
        }
        GetSourceAdapter() {
          if (this._sourceAdapter) return this._sourceAdapter;
          let e;
          switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
            case "behavior":
              e = new C33.PropertyTrackState.BehaviorSourceAdapter(this);
              break;
            case "effect":
              e = new C33.PropertyTrackState.EffectSourceAdapter(this), this._renderChange = 1;
              break;
            case "instance-variable":
              e = new C33.PropertyTrackState.InstanceVariableSourceAdapter(this);
              break;
            case "plugin":
              e = new C33.PropertyTrackState.PluginSourceAdapter(this), this._renderChange = 1;
              break;
            case "world-instance":
              e = new C33.PropertyTrackState.PropertySourceAdapter(this), this._renderChange = 1, this._worldInfoChange = 1;
              break;
            case "value":
              e = new C33.PropertyTrackState.ValueSourceAdapter(this);
              break;
            case "audio":
              e = new C33.PropertyTrackState.AudioSourceAdapter(this);
          }
          return this._sourceAdapter = e, this._sourceAdapter;
        }
        GetSourceAdapterId() {
          return this._propertyTrackDataItem.GetSourceAdapterId();
        }
        SetSourceAdapterId(e) {
          this._propertyTrackDataItem.SetSourceAdapterId(e);
        }
        GetSourceAdapterArgs() {
          return this._propertyTrackDataItem.GetSourceAdapterArguments();
        }
        SetSourceAdapterArgs(e) {
          this._propertyTrackDataItem.SetSourceAdapterArguments(e);
        }
        GetSourceAdapterValue() {
          return this.GetSourceAdapter().GetValue();
        }
        GetPropertyName() {
          return this._propertyTrackDataItem.GetProperty();
        }
        SetPropertyName(e) {
          this._propertyTrackDataItem.SetProperty(e);
        }
        GetPropertyType() {
          return this._propertyTrackDataItem.GetType();
        }
        SetPropertyType(e) {
          this._propertyTrackDataItem.SetType(e);
        }
        GetPropertyKeyframeType() {
          return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType();
        }
        GetMin() {
          return this._propertyTrackDataItem.GetMin();
        }
        SetMin(e) {
          this._propertyTrackDataItem.SetMin(e);
        }
        GetMax() {
          return this._propertyTrackDataItem.GetMax();
        }
        SetMax(e) {
          this._propertyTrackDataItem.SetMax(e);
        }
        GetEnable() {
          return this._propertyTrackDataItem.GetEnable();
        }
        SetEnable(e) {
          this._propertyTrackDataItem.SetEnable(e);
        }
        GetInterpolationMode() {
          return this._propertyTrackDataItem.GetInterpolationMode();
        }
        SetInterpolationMode(e) {
          this._propertyTrackDataItem.SetInterpolationMode(e);
        }
        GetResultMode() {
          return this._propertyTrackDataItem.GetResultMode();
        }
        SetResultMode(e) {
          this._propertyTrackDataItem.SetResultMode(e);
        }
        SetEase(e) {
          for (const t of this.GetPropertyKeyframeDataItems()) t.SetEase(e);
        }
        CanHavePropertyKeyframes() {
          return this._propertyTrackDataItem.CanHavePropertyKeyframes();
        }
        GetPropertyKeyframeDataItems() {
          return this._propertyKeyframeDataItems || (this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()), this._propertyKeyframeDataItems;
        }
        GetPropertyKeyframeDataItemArrayIncludingDisabled() {
          return this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArrayIncludingDisabled();
        }
        GetPropertyKeyFrameDataItemAtTime(e) {
          return this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
        }
        GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e) {
          return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
        }
        GetPropertyKeyframeDataItemPairForTime(e) {
          let t, r2 = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
          return r2 ? t = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(e, this._propertyTrackDataItem) : (r2 = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), t = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem)), { start: r2, end: t };
        }
        *GetPropertyKeyframeValues() {
          for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetValueWithResultMode();
        }
        *GetPropertyKeyframeTimes() {
          for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetTime();
        }
        TimelineRemoved() {
          this.GetSourceAdapter().TimelineRemoved();
        }
        CleanCaches() {
          this.GetSourceAdapter().CleanCaches();
        }
        GetCurrentState() {
          return this.GetSourceAdapter().GetCurrentState();
        }
        SetResetState() {
          this.GetSourceAdapter().SetResetState();
        }
        SetInitialState(e) {
          this.GetSourceAdapter().SetInitialState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e), this._SetUpdateState();
        }
        SetResumeState(e) {
          this.GetSourceAdapter().SetResumeState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e);
        }
        _SetUpdateState() {
          const e = this.GetTrack();
          if (this._needsBeforeAndAfter = 0, e.IsInstanceTrack()) {
            const t = this.GetTimeline(), r2 = e.GetInstance(), a2 = this.GetSourceAdapter(), o2 = this.GetPropertyName();
            if (a2.MayNeedBeforeAndAfterInterpolate()) {
              const e2 = t.GetSimilarPropertyTracks(r2, a2, o2, this);
              e2 && e2.length && (this._needsBeforeAndAfter = 1);
            } else this._needsBeforeAndAfter = 0;
          }
        }
        _GetLastPropertyKeyFrameBeforeTime(e) {
          const t = this.GetTimeline(), r2 = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
          return r2 || (t.IsForwardPlayBack() ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem) : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem));
        }
        BeforeInterpolate() {
          this._sourceAdapter.BeforeInterpolate();
        }
        Interpolate(e, t = false, r2 = false, a2 = false) {
          let o2, s2, p = false;
          if (t) o2 = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
          else {
            if (this._lastPropertyKeyframeDataItem) {
              const t2 = this.GetTimeline(), r3 = this._lastPropertyKeyframeDataItem.GetNext(), a3 = this._lastPropertyKeyframeDataItem.GetTime(), o3 = r3 ? r3.GetTime() : t2.GetTotalTime();
              (e <= a3 || e >= o3) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p = true);
            } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p = true;
            o2 = this._lastPropertyKeyframeDataItem;
          }
          o2 && (s2 = o2.GetNext()), this._sourceAdapter.Interpolate(e, o2, s2, t, r2, a2, p);
        }
        GetInterpolatedValue(e) {
          if (this._lastPropertyKeyframeDataItem) {
            const t2 = this.GetTimeline(), r3 = this._lastPropertyKeyframeDataItem.GetNext(), a2 = this._lastPropertyKeyframeDataItem.GetTime(), o2 = r3 ? r3.GetTime() : t2.GetTotalTime();
            (e <= a2 || e >= o2) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem));
          } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
          const t = this._lastPropertyKeyframeDataItem, r2 = t.GetNext();
          return this._sourceAdapter.GetInterpolatedValue(e, t, r2);
        }
        GetInterpolatedValueFast(e, t, r2) {
          return this._sourceAdapter.GetInterpolatedValue(e, t, r2);
        }
        AfterInterpolate() {
          this._sourceAdapter.AfterInterpolate();
        }
        static GetStartPropertyKeyframeForTime(e, t) {
          const r2 = t.GetPropertyTrackDataItem();
          return t._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, r2);
        }
        static GetEndPropertyKeyframeForTime(e, t) {
          const r2 = t.GetPropertyTrackDataItem();
          return t._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, r2);
        }
        AddPropertyKeyframe() {
          const e = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
          return this._lastPropertyKeyframeDataItem = null, e;
        }
        DeletePropertyKeyframes(e) {
          this._lastPropertyKeyframeDataItem = null;
          this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(e);
        }
        SaveState() {
          this.GetSourceAdapter().SaveState();
        }
        CompareInitialStateWithCurrent() {
          if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
            const e = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem), t = this.GetSourceAdapter().GetCurrentState();
            e.SetAbsoluteValue(t);
          }
        }
        CompareSaveStateWithCurrent() {
          const e = this.GetSourceAdapter().CompareSaveStateWithCurrent();
          return e && this.AddPropertyKeyframeAtCurrentTime(), this.GetSourceAdapter().ClearSaveState(), e;
        }
        AddPropertyKeyframeAtCurrentTime() {
          const e = this.GetTimeline().GetTime(), t = this.GetSourceAdapter(), r2 = C33.PropertyTrackState.GetStartPropertyKeyframeForTime(e, this), a2 = this.AddPropertyKeyframe();
          a2.SetType(r2.GetType()), a2.SetTime(e), a2.SetEase(r2.GetEase()), a2.SetEnable(true), a2.SetValue(t.GetValueAtTime()), a2.SetAbsoluteValue(t.GetCurrentState());
        }
        _SaveToJson() {
          return { "sourceAdapterJson": this.GetSourceAdapter()._SaveToJson() };
        }
        _LoadFromJson(e) {
          e && this.GetSourceAdapter()._LoadFromJson(e["sourceAdapterJson"]);
        }
      };
    }
    {
      const C33 = self.C3, NS = C33.PropertyTrackState;
      NS.PropertySourceAdapter = class {
        constructor(e) {
          this._propertyTrack = e, this._propertyAdapter = null, this.GetPropertyAdapter();
        }
        Release() {
          this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null), this._propertyTrack = null;
        }
        MayNeedBeforeAndAfterInterpolate() {
          return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate();
        }
        GetPropertyTrack() {
          return this._propertyTrack;
        }
        TimelineRemoved() {
          this._propertyAdapter && this._propertyAdapter.TimelineRemoved();
        }
        CleanCaches() {
          this._propertyAdapter && this._propertyAdapter.CleanCaches();
        }
        GetPropertyAdapter() {
          return this._propertyAdapter || (this._propertyAdapter = this._CreatePropertyAdapter()), this._propertyAdapter;
        }
        GetEditorIndex() {
        }
        GetIndex() {
          return this.GetEditorIndex();
        }
        GetTarget() {
        }
        SetResetState() {
          this.GetPropertyAdapter().SetResetState();
        }
        SetInitialState() {
          this.GetPropertyAdapter().SetInitialState();
        }
        SetResumeState() {
          this.GetPropertyAdapter().SetResumeState();
        }
        BeforeInterpolate() {
          this._propertyAdapter.BeforeChangeProperty();
        }
        Interpolate(e, t, r2, p, a2, o2, n) {
          let s2;
          switch (this._propertyTrack.GetPropertyKeyframeType()) {
            case "numeric":
              s2 = NS.NumericTypeAdapter.Interpolate(e, t, r2, this._propertyTrack);
              break;
            case "angle":
              s2 = NS.AngleTypeAdapter.Interpolate(e, t, r2, this._propertyTrack);
              break;
            case "boolean":
              s2 = NS.BooleanTypeAdapter.Interpolate(e, t, r2, this._propertyTrack);
              break;
            case "color":
              s2 = NS.ColorTypeAdapter.Interpolate(e, t, r2, this._propertyTrack);
              break;
            case "text":
              s2 = NS.TextTypeAdapter.Interpolate(e, t, r2, this._propertyTrack);
          }
          this._propertyAdapter.ChangeProperty(e, s2, t, r2, p, a2, o2, n);
        }
        GetInterpolatedValue(e, t, r2) {
          switch (this._propertyTrack.GetPropertyKeyframeType()) {
            case "numeric":
              return NS.NumericTypeAdapter.Interpolate(e, t, r2, this._propertyTrack);
            case "angle":
              return NS.AngleTypeAdapter.Interpolate(e, t, r2, this._propertyTrack);
            case "boolean":
              return NS.BooleanTypeAdapter.Interpolate(e, t, r2, this._propertyTrack);
            case "color":
              return NS.ColorTypeAdapter.Interpolate(e, t, r2, this._propertyTrack);
            case "text":
              return NS.TextTypeAdapter.Interpolate(e, t, r2, this._propertyTrack);
          }
        }
        AfterInterpolate() {
          this._propertyAdapter.AfterChangeProperty();
        }
        SaveState() {
          this.GetPropertyAdapter().SetSaveState();
        }
        ClearSaveState() {
          this.GetPropertyAdapter().ClearSaveState();
        }
        GetCurrentState() {
          return this.GetPropertyAdapter().GetCurrentState();
        }
        CompareInitialStateWithCurrent() {
          return this.GetPropertyAdapter().CompareInitialStateWithCurrent();
        }
        CompareSaveStateWithCurrent() {
          return this.GetPropertyAdapter().CompareSaveStateWithCurrent();
        }
        GetValueAtTime() {
          const e = this._propertyTrack, t = e.GetTrack().GetTimeline().GetTime(), r2 = NS.GetStartPropertyKeyframeForTime(t, e), p = r2.GetNext();
          switch (e.GetPropertyKeyframeType()) {
            case "numeric":
              return NS.NumericTypeAdapter.Interpolate(t, r2, p, e);
            case "angle":
              return NS.AngleTypeAdapter.Interpolate(t, r2, p, e);
            case "boolean":
              return NS.BooleanTypeAdapter.Interpolate(t, r2, p, e);
            case "color":
              return NS.ColorTypeAdapter.Interpolate(t, r2, p, e);
            case "text":
              return NS.TextTypeAdapter.Interpolate(t, r2, p, e);
          }
        }
        _CreatePropertyAdapter() {
          const e = this._propertyTrack;
          switch (e.CanHavePropertyKeyframes() ? e.GetPropertyKeyframeType() : "") {
            case "combo":
            case "boolean":
            case "text":
            case "string":
              return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
            case "numeric":
            case "number":
            case "angle":
              return "combo" === this._propertyTrack.GetPropertyType() ? new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
            case "color":
            case "offsetColor":
              return new NS.PropertyInterpolationAdapter.ColorInterpolationAdapter(this);
            default:
              return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
          }
        }
        _SaveToJson() {
          return { "propertyAdapterJson": this.GetPropertyAdapter()._SaveToJson() };
        }
        _LoadFromJson(e) {
          e && this.GetPropertyAdapter()._LoadFromJson(e["propertyAdapterJson"]);
        }
      };
    }
    {
      const C33 = self.C3, INDEX = 0;
      class InstanceVariableSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
          super(e), this._updatedIndex = NaN;
        }
        GetEditorIndex() {
          return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
        }
        GetIndex() {
          return this._updatedIndex ? this._updatedIndex : super.GetIndex();
        }
        GetTarget() {
          return this._propertyTrack.GetTrack().GetInstance();
        }
        UpdateInstanceVariableIndex(e) {
          this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== e && (this._updatedIndex = e);
        }
        Interpolate(e, t, r2, a2, n, d2, p) {
          this.GetPropertyAdapter().CanChange(t.GetValue()) && super.Interpolate(e, t, r2, a2, n, d2, p);
        }
        GetInterpolatedValue(e, t, r2) {
          if (this.GetPropertyAdapter().CanChange(t.GetValue())) return super.GetInterpolatedValue(e, t, r2);
        }
        _SaveToJson() {
          return Object.assign(super._SaveToJson(), { "index": this._updatedIndex });
        }
        _LoadFromJson(e) {
          e && (super._LoadFromJson(e), this._updatedIndex = e["index"]);
        }
      }
      C33.PropertyTrackState.InstanceVariableSourceAdapter = InstanceVariableSourceAdapter;
    }
    {
      const C33 = self.C3, SID = 0, INDEX = 1, NAME = 2;
      class BehaviorSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
          super(e), this._sid = NaN;
        }
        GetEditorIndex() {
          return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1];
        }
        GetTarget() {
          const e = this._propertyTrack.GetPropertyTrackDataItem(), t = this._propertyTrack.GetTrack(), r2 = this._sid ? this._sid : e.GetSourceAdapterArguments()[0], a2 = t.GetInstance(), s2 = a2.GetBehaviorIndexBySID(r2);
          return a2.GetBehaviorInstances()[s2].GetSdkInstance();
        }
        GetBehaviorType(e) {
          const t = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2];
          return e.GetBehaviorTypeByName(t);
        }
        UpdateBehaviorTypeSid(e) {
          this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== e && (this._sid = e);
        }
        Interpolate(e, t, r2, a2, s2, o2, p) {
          const c2 = this._propertyTrack.GetTrack().GetInstance();
          this.GetBehaviorType(c2.GetObjectClass()) && super.Interpolate(e, t, r2, a2, s2, o2, p);
        }
        GetInterpolatedValue(e, t, r2) {
          const a2 = this._propertyTrack.GetTrack().GetInstance();
          if (this.GetBehaviorType(a2.GetObjectClass())) return super.GetInterpolatedValue(e, t, r2);
        }
        _SaveToJson() {
          return Object.assign(super._SaveToJson(), { "sid": this._sid });
        }
        _LoadFromJson(e) {
          e && (super._LoadFromJson(e), this._sid = e["sid"]);
        }
      }
      C33.PropertyTrackState.BehaviorSourceAdapter = BehaviorSourceAdapter;
    }
    {
      const C33 = self.C3, NAME = 0, INDEX = 1;
      class EffectSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
          super(e);
        }
        GetEditorIndex() {
          return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1];
        }
        GetTarget() {
          const e = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList(), t = e.GetEffectList(), r2 = this.GetEffectType(t).GetIndex();
          return e.IsEffectIndexActive(r2) ? e.GetEffectParametersForIndex(r2) : null;
        }
        GetEffectType(e) {
          const t = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
          return e.GetEffectTypeByName(t);
        }
        Interpolate(e, t, r2, c2, f2, a2, s2) {
          this._IsEffectActive() && super.Interpolate(e, t, r2, c2, f2, a2, s2);
        }
        GetInterpolatedValue(e, t, r2) {
          if (this._IsEffectActive()) return super.GetInterpolatedValue(e, t, r2);
        }
        _IsEffectActive() {
          const e = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList(), t = e.GetEffectList(), r2 = this.GetEffectType(t);
          if (!r2) return;
          const c2 = r2.GetIndex();
          return e.IsEffectIndexActive(c2);
        }
      }
      C33.PropertyTrackState.EffectSourceAdapter = EffectSourceAdapter;
    }
    {
      const C33 = self.C3, INDEX = 0;
      class PluginSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(t) {
          super(t);
        }
        GetEditorIndex() {
          return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
        }
        GetTarget() {
          return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance();
        }
        Interpolate(t, e, r2, n, a2, i2, s2) {
          const c2 = this._propertyTrack.GetTrack();
          c2.GetObjectClass().GetPlugin() === c2.GetInstance().GetObjectClass().GetPlugin() && super.Interpolate(t, e, r2, n, a2, i2, s2);
        }
        GetInterpolatedValue(t, e, r2) {
          const n = this._propertyTrack.GetTrack();
          if (n.GetObjectClass().GetPlugin() === n.GetInstance().GetObjectClass().GetPlugin()) return super.GetInterpolatedValue(t, e, r2);
        }
        GetOptionalCallbacks() {
          const t = this._propertyTrack.GetTrack(), e = t.GetObjectClass().GetPlugin();
          if (C33.Plugins.Sprite && e instanceof C33.Plugins.Sprite && ("initial-frame" === this._propertyTrack.GetPropertyName() || "initial-animation" === this._propertyTrack.GetPropertyName())) switch (this._propertyTrack.GetResultMode()) {
            case "relative":
              return { onFrameChange: (e2, r2, n, a2, i2) => {
                if (r2 !== a2) {
                  const n2 = a2 / r2, i3 = t.GetPropertyTrack("offsetWidth"), s2 = t.GetPropertyTrack("offsetScaleX");
                  if (i3 || s2) {
                    const c2 = i3?.GetSourceAdapter()?.GetPropertyAdapter(), o2 = s2?.GetSourceAdapter()?.GetPropertyAdapter();
                    if (e2.HasParent() && e2.GetTransformWithParentWidth()) o2 && o2.SetOriginalSizeProperty(a2), e2.SetWidth(this.GetNewWidth(a2, r2, e2, t, c2, o2));
                    else {
                      const r3 = a2 * ((e2._GetSceneGraphInfo()?._GetStartWidth() ?? this.GetInstanceOriginalWidth(e2, t)) / this.GetInstanceOriginalWidth(e2, t));
                      o2 && o2.SetOriginalSizeProperty(a2);
                      const i4 = c2?.GetChangeAccumulatorProperty() ?? 0, s3 = o2?.GetChangeAccumulatorProperty() ?? 0;
                      e2.SetWidth(r3 + (i4 + s3 * n2));
                    }
                  } else e2.SetWidth(e2.GetWidth() * n2);
                }
                if (n !== i2) {
                  const r3 = i2 / n, a3 = t.GetPropertyTrack("offsetHeight"), s2 = t.GetPropertyTrack("offsetScaleY");
                  if (a3 || s2) {
                    const c2 = a3?.GetSourceAdapter()?.GetPropertyAdapter(), o2 = s2?.GetSourceAdapter()?.GetPropertyAdapter();
                    if (e2.HasParent() && e2.GetTransformWithParentHeight()) o2 && o2.SetOriginalSizeProperty(i2), e2.SetHeight(this.GetNewHeight(i2, n, e2, t, c2, o2));
                    else {
                      const n2 = i2 * ((e2._GetSceneGraphInfo()?._GetStartHeight() ?? this.GetInstanceOriginalHeight(e2, t)) / this.GetInstanceOriginalHeight(e2, t));
                      o2 && o2.SetOriginalSizeProperty(i2);
                      const a4 = c2?.GetChangeAccumulatorProperty() ?? 0, s3 = o2?.GetChangeAccumulatorProperty() ?? 0;
                      e2.SetHeight(n2 + (a4 + s3 * r3));
                    }
                  } else e2.SetHeight(e2.GetHeight() * r3);
                }
              } };
            case "absolute":
              return null;
          }
        }
        GetLastPropertyKeyframeValue(t, e, r2, n = 0) {
          const a2 = e.GetTimeline().GetTrackFromInstance(t.GetInstance());
          if (!a2) return n;
          const i2 = a2.GetPropertyTrack(r2);
          if (!i2) return n;
          const s2 = i2.GetPropertyTrackDataItem().GetPropertyKeyframeData();
          if (!s2) return n;
          const c2 = s2.GetLastPropertyKeyframeDataItem();
          return c2 ? c2.GetValue() : n;
        }
        GetInstanceOriginalWidth(t, e) {
          const r2 = e.GetTimeline().GetTrackFromInstance(t.GetInstance());
          if (r2) return r2.GetOriginalWidth();
          const n = t.GetInstance().GetSdkInstance();
          return n.IsOriginalSizeKnown() ? n.GetOriginalWidth() : t._GetSceneGraphInfo()._GetStartWidth();
        }
        GetInstanceOriginalHeight(t, e) {
          const r2 = e.GetTimeline().GetTrackFromInstance(t.GetInstance());
          if (r2) return r2.GetOriginalHeight();
          const n = t.GetInstance().GetSdkInstance();
          return n.IsOriginalSizeKnown() ? n.GetOriginalHeight() : t._GetSceneGraphInfo()._GetStartHeight();
        }
        GetNewWidth(t, e, r2, n, a2, i2) {
          const s2 = r2._GetSceneGraphInfo()._GetStartWidth(), c2 = s2 / r2.GetParent()._GetSceneGraphInfo()._GetStartWidth();
          let o2 = 1;
          const G = i2?.GetAbsoluteScaleXOffsetProperty() ?? 0;
          if (0 !== G) {
            const t2 = s2 / this.GetInstanceOriginalWidth(r2, n);
            o2 = (t2 + G) / (0 === t2 ? Number.EPSILON : t2);
          }
          const p = s2 * (t / e);
          let l2 = a2?.GetAbsoluteWidthOffsetProperty() ?? 0;
          l2 += p - s2;
          const h = (s2 + l2) / (0 === s2 ? Number.EPSILON : s2);
          return r2.GetParent().GetWidth() * c2 * o2 * h;
        }
        GetNewHeight(t, e, r2, n, a2, i2) {
          const s2 = r2._GetSceneGraphInfo()._GetStartHeight(), c2 = s2 / r2.GetParent()._GetSceneGraphInfo()._GetStartHeight();
          let o2 = 1;
          const G = i2?.GetAbsoluteScaleYOffsetProperty() ?? 0;
          if (0 !== G) {
            const t2 = s2 / this.GetInstanceOriginalHeight(r2, n);
            o2 = (t2 + G) / (0 === t2 ? Number.EPSILON : t2);
          }
          const p = s2 * (t / e);
          let l2 = a2?.GetAbsoluteHeightOffsetProperty() ?? 0;
          l2 += p - s2;
          const h = (s2 + l2) / (0 === s2 ? Number.EPSILON : s2);
          return r2.GetParent().GetHeight() * c2 * o2 * h;
        }
      }
      C33.PropertyTrackState.PluginSourceAdapter = PluginSourceAdapter;
    }
    {
      const C33 = self.C3;
      class ValueSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(t) {
          super(t), this._value = 0, this._init = false;
        }
        MayNeedBeforeAndAfterInterpolate() {
          return false;
        }
        SetInitialState() {
          const t = this._propertyTrack.GetPropertyTrackData();
          let e = this._propertyTrack.GetPropertyTrackDataItem();
          e = t.GetFirstPropertyKeyframeDataItem(e), this._value = e.GetValueWithResultMode();
        }
        SetResumeState() {
        }
        GetValue() {
          return this._init || this._propertyTrack.Interpolate(0), this._value;
        }
        Interpolate(t, e, r2, a2, i2, o2, u) {
          this._value = C33.PropertyTrackState.NumericTypeAdapter.Interpolate(t, e, r2, this._propertyTrack), this._init = true;
        }
        SaveState() {
        }
        ClearSaveState() {
        }
        GetCurrentState() {
          return this._value;
        }
        CompareInitialStateWithCurrent() {
          return false;
        }
        CompareSaveStateWithCurrent() {
          return false;
        }
        _SaveToJson() {
          return { "value": this._value, "init": this._init };
        }
        _LoadFromJson(t) {
          t && (this._value = t["value"], this._init = !t.hasOwnProperty("init") || t["init"]);
        }
      }
      C33.PropertyTrackState.ValueSourceAdapter = ValueSourceAdapter;
    }
    {
      const C33 = self.C3, PROJECT_FILE = 0, PROJECT_FILE_NAME = 0, PROJECT_FILE_TYPE = 1, START_OFFSET = 1, AUDIO_DURATION = 2, AUDIO_TAG = 3;
      class AudioSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(t) {
          super(t), this._audioPlaybackStarted = false, this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = this._propertyTrack.GetTimeline(), this._track = this._propertyTrack.GetTrack(), this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs(), this._fileArgs = this._sourceAdapterArgs[0], this._startOffsetTime = this._sourceAdapterArgs[1], this._sourceAdapterArgs[3] ? this._audioTag = this._sourceAdapterArgs[3] : this._audioTag = Math.random().toString(36).slice(2), this._pauseTime = NaN, this._pauseVolume = NaN, this._volume = NaN, this._audioSource = null, this._Initialize();
        }
        Release() {
          super.Release(), this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = null, this._track = null, this._sourceAdapterArgs = null, this._fileArgs = null, this._audioSource = null;
        }
        _Initialize() {
          if (!self.C3.Plugins.Audio) return;
          const t = this._propertyTrack.GetRuntime().GetSingleGlobalObjectClassByCtor(self.C3.Plugins.Audio);
          t && (this._sdkInstance = t.GetSingleGlobalInstance().GetSdkInstance()), this._actions = self.C3.Plugins.Audio.Acts, this._expressions = self.C3.Plugins.Audio.Exps;
        }
        _MaybeSetAudioSource() {
          if (this._audioSource) return;
          const t = this._propertyTrack.GetTrack().GetPropertyTrack("audioSource");
          t && (this._audioSource = t.GetSourceAdapter());
        }
        _GetPauseVolume() {
          const t = this._propertyTrack.GetTrack().GetPropertyTrack("volume");
          return t ? t.GetSourceAdapter()._pauseVolume : this._pauseVolume;
        }
        TimelineRemoved() {
          super.TimelineRemoved(), this._audioPlaybackStarted = false, this._sdkInstance && (this._expressions && (this._pauseTime = this._expressions.PlaybackTime.call(this._sdkInstance, this._audioTag), this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)), this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag));
        }
        GetAudioTag() {
          return this._audioTag;
        }
        GetVolume() {
          return this._volume;
        }
        SetVolume(t) {
          this._volume = t;
        }
        SetInitialState() {
          super.SetInitialState(), this._pauseTime = NaN, this._audioPlaybackStarted = false;
        }
        SetResumeState() {
          super.SetResumeState();
          const t = this._propertyTrack.GetTimeline().GetTime();
          switch (this._pauseTime = t - this._startOffsetTime, this._propertyTrack.GetPropertyName()) {
            case "audioSource":
              break;
            case "volume":
              this._pauseVolume = this._propertyTrack.GetInterpolatedValue(t);
          }
          this._audioPlaybackStarted = false;
        }
        Interpolate(t, e, s2, i2, a2, o2, r2) {
          if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {
            case "audioSource": {
              if (!this._timeline.IsForwardPlayBack()) return;
              if (i2) return void (this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag));
              if (t < this._startOffsetTime) return void (this._audioPlaybackStarted = false);
              const e2 = this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag), s3 = this._timeline.GetPlaybackRate();
              if (s3 !== e2 && this._actions.SetPlaybackRate.call(this._sdkInstance, this._audioTag, s3), this._audioPlaybackStarted) return;
              if (!this._propertyTrack.GetTimeline().IsPlaying()) return;
              if (this._audioPlaybackStarted = true, isNaN(this._pauseTime)) {
                const e3 = self["performance"].now(), s4 = t - this._startOffsetTime;
                if ("suspended" === this._sdkInstance.GetAudioContextState()) return void (this._audioPlaybackStarted = false);
                const i3 = s4 + (self["performance"].now() - e3) / 1e3;
                if (this._actions) {
                  let t2 = this.GetVolume();
                  isNaN(t2) ? (this.SetVolume(0), t2 = 0) : this.SetVolume(t2), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, t2, this._audioTag, i3);
                }
              } else {
                const t2 = this._pauseTime;
                this._pauseTime = NaN;
                const e3 = this._GetPauseVolume();
                this._pauseVolume = NaN;
                if ("suspended" === this._sdkInstance.GetAudioContextState()) return void (this._audioPlaybackStarted = false);
                this._actions && (this.SetVolume(e3), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, e3, this._audioTag, t2));
              }
              break;
            }
            case "volume":
              this._MaybeSetAudioSource(), super.Interpolate(t, e, s2, i2, a2, o2, r2);
          }
        }
        GetInterpolatedValue(t, e, s2) {
          if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {
            case "audioSource":
              return;
            case "volume":
              return this._MaybeSetAudioSource(), super.GetInterpolatedValue(t, e, s2);
          }
        }
        Getter(t, e) {
          return this._audioSource ? this._audioSource.GetVolume() : 0;
        }
        Setter(t, e, s2, i2) {
          this._audioSource && this._audioSource.SetVolume(this.Getter() + e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());
        }
        AbsoluteSetter(t, e, s2) {
          this._audioSource && this._audioSource.SetVolume(e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());
        }
        DoesRounding() {
          return true;
        }
        _SaveToJson() {
          return { "audioPlaybackStarted": this._audioPlaybackStarted, "audioTag": this._audioTag, "pauseTime": this._pauseTime, "pauseVolume": this._pauseVolume, "volume": this._volume };
        }
        _LoadFromJson(t) {
          t && (this._audioPlaybackStarted = t["audioPlaybackStarted"], this._audioTag = t["audioTag"], this._pauseTime = t["pauseTime"], this._pauseVolume = t["pauseVolume"], this._volume = t["volume"], this._Initialize());
        }
      }
      C33.PropertyTrackState.AudioSourceAdapter = AudioSourceAdapter;
    }
    {
      const C33 = self.C3;
      C33.PropertyTrackState.PropertyInterpolationAdapter = class {
        constructor(t) {
          this._sourceAdapter = t, this._propertyTrack = t.GetPropertyTrack(), this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo(), this._property = this._propertyTrack.GetPropertyName(), this._firstAbsoluteUpdate = false, this._saveState = null, this._target = null;
        }
        Release() {
          this._sourceAdapter = null, this._propertyTrack = null, this._worldInfo = null, this._saveState = null, this._target = null;
        }
        MayNeedBeforeAndAfterInterpolate() {
          return false;
        }
        TimelineRemoved() {
        }
        CleanCaches() {
          this._worldInfo = null, this._saveState = null, this._target = null;
        }
        GetSourceAdapter() {
          return this._sourceAdapter;
        }
        GetPropertyTrack() {
          return this._propertyTrack;
        }
        GetWorldInfo() {
          return this._worldInfo || (this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()), this._worldInfo;
        }
        SetFirstAbsoluteUpdate(t) {
          this._firstAbsoluteUpdate = !!t;
        }
        GetFirstAbsoluteUpdate() {
          return this._firstAbsoluteUpdate;
        }
        SetResetState() {
        }
        SetInitialState() {
        }
        SetResumeState() {
        }
        SetSaveState() {
          this._saveState = this.GetCurrentState();
        }
        ClearSaveState() {
          this._saveState = null;
        }
        GetCurrentState() {
        }
        CompareInitialStateWithCurrent() {
        }
        CompareSaveStateWithCurrent() {
        }
        CanChange(t) {
          return typeof this._Getter() === typeof t;
        }
        BeforeChangeProperty() {
        }
        ChangeProperty(t, e, r2, a2, s2, o2, i2, n) {
        }
        AfterChangeProperty() {
        }
        _FirstKeyframeGetter() {
          return this._PickTimelinePlaybackMode(() => {
            const t = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(t);
          }, () => {
            const t = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(t);
          }).GetAbsoluteValue();
        }
        _CurrentKeyframeGetter() {
          const t = this._propertyTrack.GetTimeline().GetTime() - this._propertyTrack.GetTrack().GetStartOffset();
          return this._PickTimelinePlaybackMode(() => {
            const e = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, e);
          }, () => {
            const e = this._propertyTrack.GetPropertyTrackDataItem(), r2 = this._propertyTrack.GetPropertyTrackData(), a2 = r2.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t, e);
            return a2 || r2.GetLastPropertyKeyframeDataItem(e);
          }).GetAbsoluteValue();
        }
        _PickTimelinePlaybackMode(t, e) {
          return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? t() : e();
        }
        _PickResultMode(t, e) {
          return "relative" === this._propertyTrack.GetResultMode() ? t() : e();
        }
        _PickFirstAbsoluteUpdate(t, e) {
          return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(false), t()) : e();
        }
        _GetAbsoluteInitialValue(t) {
        }
        _GetIndex() {
          return this._sourceAdapter.GetIndex();
        }
        _GetTarget() {
          return this._target || (this._target = this._sourceAdapter.GetTarget()), this._target;
        }
        _PickSource(t, e, r2, a2, s2, o2) {
          switch (this._propertyTrack.GetSourceAdapterId()) {
            case "behavior":
              return t();
            case "effect":
              return e();
            case "instance-variable":
              return r2();
            case "plugin":
              return a2();
            case "world-instance":
              return s2();
            case "audio":
              return o2();
          }
        }
        _SaveToJson() {
          return { "firstAbsoluteUpdate": this._firstAbsoluteUpdate, "saveState": this._saveState };
        }
        _LoadFromJson(t) {
          t && (this._firstAbsoluteUpdate = t["firstAbsoluteUpdate"], this._saveState = t["saveState"]);
        }
        _GetPropertyKeyframeStubs(t, e = false) {
          const r2 = [];
          for (const a2 of t) {
            const t2 = a2.GetTrack().GetStartOffset();
            for (const s2 of a2.GetPropertyKeyframeDataItems()) e && 0 === s2.GetTime() ? r2.push({ time: t2 + s2.GetTime(), value: s2.GetAbsoluteValue() }) : e || r2.push({ time: t2 + s2.GetTime(), value: s2.GetAbsoluteValue() });
          }
          return r2.sort((t2, e2) => t2.time - e2.time);
        }
        _GetLastPropertyKeyframeStub(t, e, r2) {
          return this._GetPropertyKeyframeStubLowerThanPlayhead(e, r2);
        }
        _GetPropertyKeyframeStubLowerThanPlayhead(t, e) {
          for (let r2 = e.length - 1; r2 >= 0; r2--) {
            if (e[r2].time <= t) return e[r2];
          }
          return null;
        }
      };
    }
    {
      const C33 = self.C3, TMP_COLORS_MAP = /* @__PURE__ */ new Map(), TMP_COLOR = [0, 0, 0];
      class ColorInterpolationAdapter extends C33.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(e) {
          super(e);
        }
        SetResetState() {
        }
        SetInitialState() {
        }
        SetResumeState() {
        }
        GetCurrentState() {
          const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r2 = this._GetIndex();
          switch (e) {
            case "behavior":
            case "plugin":
              return this._ToColorArray(t.GetPropertyValueByIndex(r2));
            case "effect":
              return this._ToColorArray(t[r2]);
            case "world-instance":
              return this._ToColorArray(this._Getter());
          }
        }
        CompareInitialStateWithCurrent() {
          const e = this._FirstKeyframeGetter();
          return !this._CompareColors(e, this._Getter());
        }
        CompareSaveStateWithCurrent() {
          return !C33.IsNullOrUndefined(this._saveState) && !this._CompareColors(this._saveState, this._Getter());
        }
        _CompareColors(e, t) {
          return e = this._GetColorFromArray(e), t = this._GetColorFromArray(t), e.equalsIgnoringAlpha(t);
        }
        _FirstKeyframeGetter() {
          const e = super._FirstKeyframeGetter();
          return this._GetColorFromArray(e);
        }
        _CurrentKeyframeGetter() {
          const e = super._CurrentKeyframeGetter();
          return this._GetColorFromArray(e);
        }
        _GetAbsoluteInitialValue(e) {
        }
        _ToColorArray(e) {
          return C33.IsInstanceOf(e, C33.Color) ? e.toArray().slice(0, 3) : e.slice(0, 3);
        }
        _GetColorFromArray(e) {
          return C33.IsInstanceOf(e, C33.Color) ? e : new C33.Color(e[0], e[1], e[2], 1);
        }
        CanChange(e) {
          return true;
        }
        MayNeedBeforeAndAfterInterpolate() {
          return true;
        }
        BeforeChangeProperty() {
          const e = this._propertyTrack.GetTimeline(), t = this._propertyTrack.GetInstance(), r2 = this._propertyTrack.GetSourceAdapter(), o2 = e.GetSimilarPropertyTracks(t, r2, this._property, this._propertyTrack);
          if (o2 && o2.length > 1) {
            TMP_COLORS_MAP.has(t) || TMP_COLORS_MAP.set(t, /* @__PURE__ */ new Map());
            const e2 = TMP_COLORS_MAP.get(t), r3 = this._propertyTrack.GetSourceAdapterId();
            e2.has(r3) || e2.set(r3, /* @__PURE__ */ new Map());
            const o3 = e2.get(r3);
            o3.has(this._property) || o3.set(this._property, { used: false, color: new C33.Color(0, 0, 0, 1) });
          }
        }
        _GetTmpColor(e, t, r2) {
          const o2 = TMP_COLORS_MAP.get(e).get(t).get(r2);
          return o2.used = true, o2.color;
        }
        ChangeProperty(e, t, r2, o2, s2, a2, n, i2) {
          const p = this._propertyTrack.GetTimeline(), _ = this._propertyTrack.GetTrack(), c2 = this._propertyTrack.GetInstance(), l2 = this._propertyTrack.GetSourceAdapter(), h = this._propertyTrack.GetSourceAdapterId(), C = this._property, y = p.GetSimilarPropertyTracks(c2, l2, C, this._propertyTrack);
          if (y && y.length > 1) {
            const e2 = this._GetPropertyKeyframeStubs(y, true), r3 = this._GetLastPropertyKeyframeStub(p, p.GetTime(), e2);
            if (r3) {
              const e3 = _.GetStartOffset(), o3 = r3.time - e3;
              if (0 === o3) this._GetTmpColor(c2, h, this._property).addRgb(t[0], t[1], t[2]);
              else {
                if (o3 < 0) return;
                const e4 = t[0], r4 = t[1], s3 = t[2], a3 = this._propertyTrack.Interpolate(o3, false, true), n2 = C33.Color.DiffChannel(e4, a3[0]), i3 = C33.Color.DiffChannel(r4, a3[1]), p2 = C33.Color.DiffChannel(s3, a3[2]);
                this._GetTmpColor(c2, h, this._property).addRgb(n2, i3, p2);
              }
            }
          } else this._Setter(t[0], t[1], t[2]);
        }
        AfterChangeProperty() {
          const e = this._propertyTrack.GetInstance();
          if (!TMP_COLORS_MAP.has(e)) return;
          const t = TMP_COLORS_MAP.get(e), r2 = this._propertyTrack.GetSourceAdapterId();
          if (!t.has(r2)) return;
          const o2 = t.get(r2);
          if (!o2.has(this._property)) return;
          const s2 = o2.get(this._property), a2 = s2.used, n = s2.color;
          a2 && this._Setter(n.getR(), n.getG(), n.getB()), 0 === o2.size && t.delete(r2), 0 === t.size && TMP_COLORS_MAP.delete(e);
        }
        _Getter() {
          const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r2 = this._GetIndex();
          switch (e) {
            case "behavior":
            case "plugin":
              return this._GetColorFromArray(t.GetPropertyValueByIndex(r2));
            case "effect":
              return t[r2].clone();
            case "world-instance":
              return this.GetWorldInfo().GetUnpremultipliedColor().clone();
          }
        }
        _Setter(e, t, r2) {
          const o2 = this._propertyTrack.GetSourceAdapterId(), s2 = this._GetTarget(), a2 = this._GetIndex();
          switch (o2) {
            case "behavior":
            case "plugin":
              TMP_COLOR[0] = e, TMP_COLOR[1] = t, TMP_COLOR[2] = r2, s2.SetPropertyValueByIndex(a2, TMP_COLOR);
              break;
            case "effect":
              s2[a2].setRgb(e, t, r2);
              break;
            case "world-instance":
              this.GetWorldInfo().SetUnpremultipliedColorRGB(e, t, r2);
          }
        }
        _SaveToJson() {
        }
        _LoadFromJson(e) {
        }
      }
      C33.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = ColorInterpolationAdapter;
    }
    {
      const C33 = self.C3, NS = C33.PropertyTrackState;
      class NoInterpolationAdapter extends C33.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(e) {
          super(e);
        }
        SetResetState() {
        }
        SetInitialState() {
        }
        SetResumeState() {
        }
        GetCurrentState() {
          return this._Getter();
        }
        CompareInitialStateWithCurrent() {
          return this._FirstKeyframeGetter() !== this.GetCurrentState();
        }
        CompareSaveStateWithCurrent() {
          return !C33.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();
        }
        MayNeedBeforeAndAfterInterpolate() {
          return false;
        }
        ChangeProperty(e, t, r2, a2, n, i2, s2, o2) {
          const p = this._propertyTrack, c2 = p.GetTrack(), l2 = p.GetSourceAdapterId(), h = p.GetTimeline(), u = c2.GetInstance(), S = p.GetSourceAdapter(), G = this._property, d2 = h.GetSimilarPropertyTracks(u, S, G, p);
          if (d2 && d2.length > 1) {
            const r3 = this._GetPropertyKeyframeStubs(d2), a3 = e + c2.GetStartOffset(), n2 = this._GetLastPropertyKeyframeStub(h, a3, r3);
            n2 && (t = n2.value);
          }
          switch (p.GetPropertyKeyframeType()) {
            case "numeric":
              if (!NS.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l2)) return;
              break;
            case "angle":
              if (!NS.AngleTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l2)) return;
              break;
            case "boolean":
              if (!NS.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l2)) return;
              break;
            case "color":
              if (!NS.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l2)) return;
              break;
            case "text":
              if (!NS.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l2)) return;
          }
          this._Setter(t);
        }
        _Getter() {
          const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r2 = this._GetIndex();
          switch (e) {
            case "behavior":
            case "plugin":
              return t.GetPropertyValueByIndex(r2);
            case "effect":
              return t[r2];
            case "instance-variable":
              return t.GetInstanceVariableValue(r2);
          }
        }
        _Setter(e) {
          const t = this._propertyTrack.GetSourceAdapterId(), r2 = this._GetTarget(), a2 = this._GetIndex();
          switch (t) {
            case "behavior":
            case "plugin":
              r2.SetPropertyValueByIndex(a2, e);
              break;
            case "effect":
              r2[a2] = e;
              break;
            case "instance-variable":
              r2.SetInstanceVariableValue(a2, e);
          }
        }
      }
      C33.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = NoInterpolationAdapter;
    }
    {
      const C33 = self.C3, NS = C33.PropertyTrackState.PropertyInterpolationAdapter, INSTANCE_FUNC_MAP = /* @__PURE__ */ new Map(), add2 = (t, e, a2, r2, i2, s2 = false, o2 = null, n = null) => {
        INSTANCE_FUNC_MAP.set(t, { setter: e, absolute_setter: a2, getter: r2, round: i2, fRound: s2, init: o2, reset: n });
      }, get_original_size = (t, e) => {
        const a2 = e.GetTimeline().GetTrackFromInstance(t.GetInstance());
        if (a2) return a2.GetOriginalWidth();
        const r2 = t.GetInstance().GetSdkInstance();
        return r2.IsOriginalSizeKnown() ? r2.GetOriginalWidth() : t._GetSceneGraphInfo()._GetStartWidth();
      }, get_last_property_keyframe_value = (t, e, a2, r2 = 0) => {
        const i2 = e.GetTimeline().GetTrackFromInstance(t.GetInstance());
        if (!i2) return r2;
        const s2 = i2.GetPropertyTrack(a2);
        if (!s2) return r2;
        const o2 = s2.GetPropertyTrackDataItem().GetPropertyKeyframeData();
        if (!o2) return r2;
        const n = o2.GetLastPropertyKeyframeDataItem();
        return n ? n.GetValue() : r2;
      }, get_parents = (t) => {
        const e = [];
        let a2 = t.GetParent();
        for (; a2; ) e.push(a2), a2 = a2.GetParent();
        return e.reverse(), e;
      };
      add2("offsetX", (t, e, a2, r2) => {
        "relative" === r2._propertyTrack.GetResultMode() ? t.OffsetX(e, a2.GetTimeline().GetTransformWithSceneGraph()) : t.OffsetX(e);
      }, (t, e) => t.SetX(e), (t) => t.GetX(), true), add2("offsetY", (t, e, a2, r2) => {
        "relative" === r2._propertyTrack.GetResultMode() ? t.OffsetY(e, a2.GetTimeline().GetTransformWithSceneGraph()) : t.OffsetY(e);
      }, (t, e) => t.SetY(e), (t) => t.GetY(), true), add2("offsetWidth", (t, e, a2, r2, i2 = false, s2 = true) => {
        if (0 === e) return;
        const o2 = "relative" === r2._propertyTrack.GetResultMode(), n = 1 === r2._typeAdapter.GetType();
        if ((o2 || n) && t.HasParent() && t.GetTransformWithParentWidth()) {
          if (isNaN(r2._absoluteToFactor)) {
            const e2 = get_parents(t);
            let a4;
            if (n) {
              a4 = e2[e2.length - 1].GetWidth();
            } else {
              a4 = e2[e2.length - 1]._GetSceneGraphInfo()._GetStartWidth();
            }
            r2._absoluteToFactor = 0 === a4 ? Number.EPSILON : a4;
          }
          if (i2) return;
          r2._absoluteWidthOffset += e;
          const a3 = e / r2._absoluteToFactor;
          t.OffsetWidth(a3, s2), r2._changeAccumulator += a3;
        } else t.OffsetWidth(e), r2._changeAccumulator += e;
      }, (t, e) => t.SetWidth(e), (t) => t.GetWidth(), true, false, null, (t) => {
        t._changeAccumulator = 0, t._absoluteWidthOffset = 0;
      }), add2("offsetHeight", (t, e, a2, r2, i2 = false, s2 = true) => {
        if (0 === e) return;
        const o2 = "relative" === r2._propertyTrack.GetResultMode(), n = 1 === r2._typeAdapter.GetType();
        if ((o2 || n) && t.HasParent() && t.GetTransformWithParentHeight()) {
          if (isNaN(r2._absoluteToFactor)) {
            const e2 = get_parents(t);
            let a4;
            if (n) {
              a4 = e2[e2.length - 1].GetHeight();
            } else {
              a4 = e2[e2.length - 1]._GetSceneGraphInfo()._GetStartHeight();
            }
            r2._absoluteToFactor = 0 === a4 ? Number.EPSILON : a4;
          }
          if (i2) return;
          r2._absoluteHeightOffset += e;
          const a3 = e / r2._absoluteToFactor;
          t.OffsetHeight(a3, s2), r2._changeAccumulator += a3;
        } else t.OffsetHeight(e), r2._changeAccumulator += e;
      }, (t, e) => t.SetHeight(e), (t) => t.GetHeight(), true, false, null, (t) => {
        t._changeAccumulator = 0, t._absoluteHeightOffset = 0;
      }), add2("offsetAngle", (t, e, a2, r2, i2) => {
        t.OffsetAngle(e);
      }, (t, e) => t.SetAngle(e), (t) => t.GetAngle(), false, true), add2("offsetOpacity", (t, e, a2, r2, i2) => {
        e /= r2._opacityFactor ? r2._opacityFactor : 1;
        const s2 = t.GetOpacity() + e;
        if (0 === r2._clampAccumulator) s2 > 1 ? r2._clampAccumulator += s2 - 1 : s2 < 0 && (r2._clampAccumulator += s2), t.OffsetOpacity(e);
        else {
          const a3 = t.GetOpacity() + e;
          e > 0 && r2._clampAccumulator > 0 ? a3 > 1 && (r2._clampAccumulator += a3 - 1) : e > 0 && r2._clampAccumulator < 0 ? (r2._clampAccumulator += e, r2._clampAccumulator > 0 && (t.OffsetOpacity(r2._clampAccumulator), r2._clampAccumulator = 0)) : e < 0 && r2._clampAccumulator > 0 ? (r2._clampAccumulator += e, r2._clampAccumulator < 0 && (t.OffsetOpacity(r2._clampAccumulator), r2._clampAccumulator = 0)) : e < 0 && r2._clampAccumulator < 0 && a3 < 0 && (r2._clampAccumulator += a3);
        }
      }, (t, e) => {
        t.SetOpacity(e);
      }, (t) => t.GetOpacity(), false, true, (t, e, a2) => {
        switch (t._clampAccumulator = 0, t._propertyTrack.GetResultMode()) {
          case "relative": {
            t._propertyTrack.GetPropertyTrackData();
            const e2 = t._propertyTrack.GetPropertyTrackDataItem().GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
            let a3 = t.GetWorldInfo().GetOpacity(), r3 = a3;
            for (const i3 of e2) {
              const e3 = i3.GetTime();
              r3 = a3 + t._propertyTrack.GetInterpolatedValue(e3), r3 = C33.clamp(r3, 0, 1);
            }
            t._totalForewardOpacityDelta = a3 - r3, t._totalForewardOpacityDelta = Math.round(100 * (t._totalForewardOpacityDelta + Number.EPSILON)) / 100, r3 = a3;
            for (let a4 = e2.length - 1; a4 >= 0; a4--) {
              const i3 = e2[a4].GetTime();
              r3 -= t._propertyTrack.GetInterpolatedValue(i3), r3 = C33.clamp(r3, 0, 1);
            }
            t._totalBackwardOpacityDelta = r3, t._totalBackwardOpacityDelta = Math.round(100 * (t._totalBackwardOpacityDelta + Number.EPSILON)) / 100;
            break;
          }
        }
        const r2 = "relative" === t._propertyTrack.GetResultMode(), i2 = 1 === t._typeAdapter.GetType();
        if ((r2 || i2) && e.HasParent() && e.GetTransformWithParentOpacity()) {
          const r3 = get_parents(e);
          let i3 = r3[0]._GetSceneGraphInfo().GetStartOpacity();
          i3 += get_last_property_keyframe_value(r3[0], a2, "offsetOpacity");
          for (let t2 = 1; t2 < r3.length; t2++) i3 += get_last_property_keyframe_value(r3[t2], a2, "offsetOpacity");
          t._opacityFactor = 0 === i3 ? 1 : i3;
        }
      }, (t) => {
        switch (t._propertyTrack.GetResultMode()) {
          case "relative": {
            t._clampAccumulator = 0;
            const e = t.GetWorldInfo();
            let a2 = e.GetOpacity();
            a2 = Math.round(100 * (a2 + Number.EPSILON)) / 100, t._propertyTrack.GetTimeline().IsForwardPlayBack() ? (e.SetOpacity(a2 + t._totalForewardOpacityDelta), t._lastValue = 0) : (e.SetOpacity(a2 - t._totalBackwardOpacityDelta), t._lastValue = t.GetSourceAdapter().GetValueAtTime());
            break;
          }
        }
      }), add2("offsetOriginX", (t, e) => t.OffsetOriginX(e), (t, e) => t.SetOriginX(e), (t) => t.GetOriginX(), false), add2("offsetOriginY", (t, e) => t.OffsetOriginY(e), (t, e) => t.SetOriginY(e), (t) => t.GetOriginY(), false), add2("offsetZElevation", (t, e) => t.OffsetZElevation(e), (t, e) => t.SetZElevation(e), (t) => t.GetZElevation(), true), add2("offsetScaleX", (t, e, a2, r2) => {
        if (0 === e) return;
        const i2 = t.GetWidth() < 0 ? -1 : 1;
        if (r2._absoluteScaleXOffset += e, "relative" === r2._propertyTrack.GetResultMode() && t.HasParent() && t.GetTransformWithParentWidth()) {
          const s2 = get_last_property_keyframe_value(t, a2, "offsetWidth"), o2 = isNaN(r2._originalSize) ? a2.GetOriginalWidth() : r2._originalSize, n = (o2 + s2 / (t._GetSceneGraphInfo()._GetStartWidth() / o2)) * i2 * e;
          isNaN(r2._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetWidth").setter(t, 1, a2, r2, true);
          const l2 = n / r2._absoluteToFactor;
          t.OffsetWidth(l2, true), r2._changeAccumulator += l2;
        } else {
          const s2 = (isNaN(r2._originalSize) ? a2.GetOriginalWidth() : r2._originalSize) * i2 * e;
          t.OffsetWidth(s2), r2._changeAccumulator += s2;
        }
      }, (t, e, a2) => {
        t.SetWidth(a2.GetOriginalWidth() * e);
      }, (t, e) => {
        const a2 = t.GetWidth() < 0 ? -1 : 1;
        if (t.GetTransformWithParentWidth()) {
          const r2 = t.GetParent(), i2 = e.GetTimeline().GetTrackFromInstance(r2.GetInstance());
          let s2 = NaN;
          if (i2) s2 = r2.GetWidth() / i2.GetOriginalWidth();
          else {
            const t2 = r2.GetInstance().GetSdkInstance();
            s2 = t2.IsOriginalSizeKnown() ? r2.GetWidth() / t2.GetOriginalWidth() : 1;
          }
          return t.GetWidth() * a2 / (e.GetOriginalWidth() * s2);
        }
        return t.GetWidth() * a2 / e.GetOriginalWidth();
      }, false, false, null, (t) => {
        t._changeAccumulator = 0, t._originalSize = NaN, t._absoluteScaleXOffset = 0;
      }), add2("offsetScaleY", (t, e, a2, r2) => {
        if (0 === e) return;
        const i2 = t.GetHeight() < 0 ? -1 : 1;
        if (r2._absoluteScaleYOffset += e, "relative" === r2._propertyTrack.GetResultMode() && t.HasParent() && t.GetTransformWithParentHeight()) {
          const s2 = get_last_property_keyframe_value(t, a2, "offsetHeight"), o2 = isNaN(r2._originalSize) ? a2.GetOriginalHeight() : r2._originalSize, n = (o2 + s2 / (t._GetSceneGraphInfo()._GetStartHeight() / o2)) * i2 * e;
          isNaN(r2._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetHeight").setter(t, 1, a2, r2, true);
          const l2 = n / r2._absoluteToFactor;
          t.OffsetHeight(l2, true), r2._changeAccumulator += l2;
        } else {
          const s2 = (isNaN(r2._originalSize) ? a2.GetOriginalHeight() : r2._originalSize) * i2 * e;
          t.OffsetHeight(s2), r2._changeAccumulator += s2;
        }
      }, (t, e, a2) => {
        t.SetHeight(a2.GetOriginalHeight() * e);
      }, (t, e) => {
        const a2 = t.GetHeight() < 0 ? -1 : 1;
        if (t.GetTransformWithParentHeight()) {
          const r2 = t.GetParent(), i2 = e.GetTimeline().GetTrackFromInstance(r2.GetInstance());
          let s2 = NaN;
          if (i2) s2 = r2.GetHeight() / i2.GetOriginalHeight();
          else {
            const t2 = r2.GetInstance().GetSdkInstance();
            s2 = t2.IsOriginalSizeKnown() ? r2.GetHeight() / t2.GetOriginalHeight() : 1;
          }
          return t.GetHeight() * a2 / (e.GetOriginalHeight() * s2);
        }
        return t.GetHeight() * a2 / e.GetOriginalHeight();
      }, false, false, null, (t) => {
        t._changeAccumulator = 0, t._originalSize = NaN, t._absoluteScaleYOffset = 0;
      });
      class NumericInterpolationAdapter extends C33.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(t) {
          super(t), this._lastValue = 0, this._clampAccumulator = 0, this._totalForewardOpacityDelta = 0, this._totalBackwardOpacityDelta = 0, this._opacityFactor = NaN, this._absoluteToFactor = NaN, this._changeAccumulator = 0, this._originalSize = NaN, this._absoluteWidthOffset = 0, this._absoluteScaleXOffset = 0, this._absoluteHeightOffset = 0, this._absoluteScaleYOffset = 0, this._angleReflectMirrorOrFlip = void 0, this._angleReflectMirrorAndFlip = void 0, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, this._round = false, this._fRound = false, C33.IsInstanceOf(this._propertyTrack.GetTimeline(), C33.TweenState) ? this._typeAdapter = new C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
          const e = this._propertyTrack.GetPropertyName();
          switch (this._propertyTrack.GetSourceAdapterId()) {
            case "world-instance": {
              const t2 = INSTANCE_FUNC_MAP.get(e);
              this._instance_getter = t2.getter, this._instance_setter = t2.setter, this._instance_absolute_setter = t2.absolute_setter, this._round = t2.round, this._fRound = t2.fRound, this._init_action = t2.init, this._reset_action = t2.reset;
              break;
            }
            case "audio":
              this._source_adapter_getter = t.Getter, this._source_adapter_setter = t.Setter, this._source_adapter_absolute_setter = t.AbsoluteSetter, this._round = !!t.DoesRounding(), this._fRound = false;
          }
        }
        Release() {
          this._typeAdapter = null, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, super.Release();
        }
        MayNeedBeforeAndAfterInterpolate() {
          return this._typeAdapter.MayNeedBeforeAndAfterInterpolate();
        }
        GetLastValue() {
          return this._lastValue;
        }
        SetLastValue(t) {
          this._lastValue = t;
        }
        SetResetState() {
          this._reset_action && this._reset_action(this);
        }
        SetInitialState() {
          const t = this._typeAdapter.SetInitialState();
          if ("number" == typeof t && (this._lastValue = t), this._init_action) {
            const t2 = this.GetWorldInfo(), e = this._propertyTrack.GetTrack();
            this._init_action(this, t2, e);
          }
        }
        SetResumeState() {
          const t = this._typeAdapter.SetResumeState();
          "number" == typeof t && (this._lastValue = t);
        }
        GetCurrentState() {
          return this._Getter();
        }
        CompareInitialStateWithCurrent() {
          return this._FirstKeyframeGetter() !== this.GetCurrentState();
        }
        CompareSaveStateWithCurrent() {
          return !C33.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();
        }
        BeforeChangeProperty() {
          this._typeAdapter.BeforeChangeProperty();
        }
        ChangeProperty(t, e, a2, r2, i2, s2, o2, n) {
          return this._typeAdapter.ChangeProperty(t, e, a2, r2, i2, s2, o2, n);
        }
        AfterChangeProperty() {
          this._typeAdapter.AfterChangeProperty();
        }
        _Getter() {
          const t = this._GetTarget(), e = this._GetIndex(), a2 = this.GetWorldInfo(), r2 = this._propertyTrack.GetTrack();
          switch (this._propertyTrack.GetSourceAdapterId()) {
            case "behavior":
            case "plugin":
              return t.GetPropertyValueByIndex(e);
            case "effect":
              return t[e];
            case "instance-variable":
              return t.GetInstanceVariableValue(e);
            case "world-instance":
              return this._instance_getter(a2, r2);
            case "audio":
              return this._source_adapter_getter.call(this.GetSourceAdapter(), a2, r2);
          }
        }
        _Setter(t, e, a2, r2 = true) {
          const i2 = this._GetTarget(), s2 = this._GetIndex(), o2 = this.GetWorldInfo(), n = this._propertyTrack.GetTrack();
          switch (this._propertyTrack.GetSourceAdapterId()) {
            case "behavior":
              i2.OffsetPropertyValueByIndex(s2, t);
              break;
            case "effect":
              i2[s2] += t;
              break;
            case "instance-variable":
              i2.SetInstanceVariableOffset(s2, t);
              break;
            case "plugin":
              i2.OffsetPropertyValueByIndex(s2, t, this.GetSourceAdapter().GetOptionalCallbacks());
              break;
            case "world-instance":
              this._instance_setter(o2, t, n, this, false, r2);
              break;
            case "audio":
              this._source_adapter_setter.call(this.GetSourceAdapter(), o2, t, n, this);
          }
        }
        _SetterAbsolute(t, e, a2) {
          let r2 = this._propertyTrack.GetInterpolationMode();
          if (r2 = "default" === r2 ? "continuous" : r2, "discrete" === r2 && !e) return;
          if ("discrete" === r2 && a2) {
            const t2 = this._propertyTrack.GetTimeline().GetTime();
            if (!this._propertyTrack.GetPropertyKeyFrameDataItemAtTime(t2)) return;
          }
          const i2 = this._GetTarget(), s2 = this._GetIndex(), o2 = this.GetWorldInfo(), n = this._propertyTrack.GetTrack();
          switch (this._propertyTrack.GetSourceAdapterId()) {
            case "behavior":
              i2.SetPropertyValueByIndex(s2, t);
              break;
            case "effect":
              i2[s2] = t;
              break;
            case "instance-variable":
              i2.SetInstanceVariableValue(s2, t);
              break;
            case "plugin":
              i2.SetPropertyValueByIndex(s2, t, this.GetSourceAdapter().GetOptionalCallbacks());
              break;
            case "world-instance":
              this._instance_absolute_setter(o2, t, n);
              break;
            case "audio":
              this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), o2, t, n);
          }
        }
        _MaybeEnsureValue(t, e, a2, r2, i2, s2, o2, n) {
          this._typeAdapter._MaybeEnsureValue(t, e, a2, r2, i2, s2, o2, n);
        }
        _AddDelta(t, e, a2, r2, i2) {
          if ("angle" === this._propertyTrack.GetPropertyType()) t = C33.toDegrees(t);
          const s2 = (t.toString().split(".")[1] || "").length, o2 = this._Getter();
          let n;
          if (0 === s2) if (this._round) n = Math.round(o2);
          else if (this._fRound) if ("angle" === this._propertyTrack.GetPropertyType()) n = C33.toRadians(Math.round(C33.toDegrees(o2)));
          else n = Number(C33.toFixed(o2, 2));
          else n = o2;
          else n = this._round ? Number(C33.toFixed(o2, s2)) : (this._fRound, o2);
          switch (this._Setter(n - o2, e, a2, false), this._propertyTrack.GetPropertyName()) {
            case "offsetWidth":
            case "offsetScaleX": {
              const t2 = this.GetWorldInfo(), e2 = t2.GetWidth(), a3 = Number(C33.toFixed(e2, 2));
              t2.OffsetWidth(a3 - e2);
              break;
            }
            case "offsetHeight":
            case "offsetScaleY": {
              const t2 = this.GetWorldInfo(), e2 = t2.GetHeight(), a3 = Number(C33.toFixed(e2, 2));
              t2.OffsetHeight(a3 - e2);
              break;
            }
          }
        }
        _SaveToJson() {
          return Object.assign(super._SaveToJson(), { "v": this._lastValue, "a": this._clampAccumulator, "fod": this._totalForewardOpacityDelta, "bod": this._totalBackwardOpacityDelta, "of": this._opacityFactor, "sf": this._absoluteToFactor, "armorf": this._angleReflectMirrorOrFlip, "armandf": this._angleReflectMirrorAndFlip, "ca": this._changeAccumulator, "os": this._originalSize, "awo": this._absoluteWidthOffset, "aho": this._absoluteHeightOffset, "asxo": this._absoluteScaleXOffset, "asyo": this._absoluteScaleYOffset });
        }
        _LoadFromJson(t) {
          t && (super._LoadFromJson(t), this._lastValue = t["v"], this._clampAccumulator = t["a"], this._totalForewardOpacityDelta = C33.IsFiniteNumber(t["fod"]) ? t["fod"] : 0, this._totalBackwardOpacityDelta = C33.IsFiniteNumber(t["bod"]) ? t["bod"] : 0, this._opacityFactor = C33.IsFiniteNumber(t["of"]) ? t["of"] : NaN, this._absoluteToFactor = C33.IsFiniteNumber(t["sf"]) ? t["sf"] : NaN, this._angleReflectMirrorOrFlip = C33.IsFiniteNumber(t["armorf"]) ? t["armorf"] : void 0, this._angleReflectMirrorAndFlip = C33.IsFiniteNumber(t["armandf"]) ? t["armandf"] : void 0, this._changeAccumulator = C33.IsFiniteNumber(t["ca"]) ? t["ca"] : 0, this._originalSize = C33.IsFiniteNumber(t["os"]) ? t["os"] : NaN, this._absoluteWidthOffset = C33.IsFiniteNumber(t["awo"]) ? t["awo"] : 0, this._absoluteHeightOffset = C33.IsFiniteNumber(t["aho"]) ? t["aho"] : 0, this._absoluteScaleXOffset = C33.IsFiniteNumber(t["asxo"]) ? t["asxo"] : 0, this._absoluteScaleYOffset = C33.IsFiniteNumber(t["asyo"]) ? t["asyo"] : 0);
        }
        SetOriginalSizeProperty(t) {
          this._originalSize = t;
        }
        GetChangeAccumulatorProperty() {
          return this._changeAccumulator;
        }
        GetAbsoluteWidthOffsetProperty() {
          return this._absoluteWidthOffset;
        }
        GetAbsoluteHeightOffsetProperty() {
          return this._absoluteHeightOffset;
        }
        GetAbsoluteScaleXOffsetProperty() {
          return this._absoluteScaleXOffset;
        }
        GetAbsoluteScaleYOffsetProperty() {
          return this._absoluteScaleYOffset;
        }
      }
      C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = NumericInterpolationAdapter;
    }
    {
      const C33 = self.C3;
      class AbsoluteValueObject {
        constructor(e) {
          this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false, this._propertyTracks = e;
          for (let e2 = 0, t = this._propertyTracks.length; e2 < t; e2++) this._propertyTracks[e2].SetAbsoluteValueObject(this);
        }
        GetPropertyTracks() {
          return this._propertyTracks;
        }
        SetUsed() {
          this._used = true;
        }
        GetUsed() {
          return this._used;
        }
        SetValue(e) {
          this._value = e;
        }
        GetValue() {
          return this._value;
        }
        SetPropertyKeyframeReached(e) {
          this._propertyKeyframeReached = e;
        }
        GetPropertyKeyframeReached() {
          return this._propertyKeyframeReached;
        }
        SetEndState(e) {
          this._endState = e;
        }
        GetEndState() {
          return this._endState;
        }
        Reset() {
          this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false;
        }
      }
      class NumericInterpolationAdapterForTimeline {
        constructor(e) {
          this._numericInterpolationAdapter = e;
        }
        Release() {
          this._numericInterpolationAdapter = null;
        }
        GetType() {
          return 0;
        }
        SetInitialState() {
          const e = this._numericInterpolationAdapter;
          this._numericInterpolationAdapter.GetPropertyTrack();
          return e._PickResultMode(() => e._PickTimelinePlaybackMode(() => 0, () => e.GetSourceAdapter().GetValueAtTime()), () => {
          });
        }
        SetResumeState() {
        }
        MayNeedBeforeAndAfterInterpolate() {
          this._numericInterpolationAdapter;
          switch (this._numericInterpolationAdapter.GetPropertyTrack().GetResultMode()) {
            case "relative":
              return false;
            case "absolute":
              return true;
          }
        }
        BeforeChangeProperty() {
          this._numericInterpolationAdapter;
          const e = this._numericInterpolationAdapter.GetPropertyTrack(), t = e.GetPropertyName();
          switch (e.GetResultMode()) {
            case "relative":
              break;
            case "absolute":
              if (e.HasAbsoluteValueObject()) {
                e.GetAbsoluteValueObject().Reset();
              } else {
                const r2 = e.GetTimeline(), a2 = e.GetInstance(), s2 = e.GetSourceAdapter(), o2 = r2.GetSimilarPropertyTracks(a2, s2, t, e);
                o2 && o2.length > 1 && new AbsoluteValueObject(o2);
              }
          }
        }
        ChangeProperty(e, t, r2, a2, s2, o2, i2, n) {
          const l2 = this._numericInterpolationAdapter, u = this._numericInterpolationAdapter.GetPropertyTrack();
          switch (u.GetResultMode()) {
            case "relative": {
              const i3 = l2.GetLastValue();
              l2._Setter(t - i3, r2, a2), o2 && this._MaybeEnsureValue(e, r2, a2, s2, i3, t), l2.SetLastValue(t);
              break;
            }
            case "absolute": {
              const e2 = u.GetTimeline(), r3 = u.GetTrack();
              u.GetInstance(), u.GetSourceAdapter();
              if (u.HasAbsoluteValueObject()) {
                const a3 = u.GetAbsoluteValueObject(), s3 = a3.GetPropertyTracks(), o3 = l2._GetPropertyKeyframeStubs(s3, true), c2 = l2._GetLastPropertyKeyframeStub(e2, e2.GetTime(), o3);
                if (c2) {
                  const e3 = r3.GetStartOffset(), s4 = c2.time - e3;
                  if (0 === s4) a3.SetEndState(i2), a3.SetPropertyKeyframeReached(n), a3.SetUsed(), a3.SetValue(a3.GetValue() + t);
                  else {
                    if (s4 < 0) return;
                    const e4 = u.GetInterpolatedValue(s4);
                    a3.SetEndState(i2), a3.SetPropertyKeyframeReached(n), a3.SetUsed(), a3.SetValue(a3.GetValue() + (t - e4));
                  }
                }
              } else l2._SetterAbsolute(t, n, i2);
              break;
            }
          }
        }
        AfterChangeProperty() {
          const e = this._numericInterpolationAdapter, t = this._numericInterpolationAdapter.GetPropertyTrack();
          switch (t.GetResultMode()) {
            case "relative":
              break;
            case "absolute":
              if (t.HasAbsoluteValueObject()) {
                const r2 = t.GetAbsoluteValueObject();
                r2.GetUsed() && e._SetterAbsolute(r2.GetValue(), r2.GetPropertyKeyframeReached(), r2.GetEndState());
              }
          }
        }
        _MaybeEnsureValue(e, t, r2, a2, s2, o2) {
          const i2 = this._numericInterpolationAdapter;
          a2 || (t && e === t.GetTime() ? i2._AddDelta(t.GetValueWithResultMode(), t, r2) : r2 && e === r2.GetTime() ? i2._AddDelta(r2.GetValueWithResultMode(), t, r2) : o2 - s2 === 0 && i2._AddDelta(t.GetValueWithResultMode(), t, r2));
        }
      }
      C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = NumericInterpolationAdapterForTimeline;
    }
    {
      const C33 = self.C3;
      class NumericInterpolationAdapterForTween {
        constructor(e) {
          this._numericInterpolationAdapter = e;
        }
        Release() {
          this._numericInterpolationAdapter = null;
        }
        GetType() {
          return 1;
        }
        SetInitialState() {
          const e = this._numericInterpolationAdapter;
          return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._FirstKeyframeGetter());
        }
        SetResumeState() {
          const e = this._numericInterpolationAdapter;
          if (e._FirstKeyframeGetter() !== e._CurrentKeyframeGetter()) return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._CurrentKeyframeGetter());
        }
        MayNeedBeforeAndAfterInterpolate() {
          return false;
        }
        BeforeChangeProperty() {
        }
        ChangeProperty(e, t, r2, a2, n, i2, o2, l2) {
          const s2 = this._numericInterpolationAdapter, u = s2.GetLastValue();
          switch (s2.GetPropertyTrack().GetResultMode()) {
            case "relative":
              s2._Setter(t - u, r2, a2), i2 && this._MaybeEnsureValue(e, r2, a2, n, u, t, false, o2);
              break;
            case "absolute":
              s2.GetFirstAbsoluteUpdate() ? (s2.SetFirstAbsoluteUpdate(false), s2._Setter(u, r2, a2)) : 0 === e && 0 === s2.GetPropertyTrack().GetTimeline().GetTotalTime() ? s2._SetterAbsolute(t, true, false) : (s2._Setter(t - u, r2, a2), i2 && this._MaybeEnsureValue(e, r2, a2, n, u, t, this._ForceEndValue(), o2));
          }
          s2.SetLastValue(t);
        }
        AfterChangeProperty() {
        }
        _GetAbsoluteInitialValue(e) {
          return e - this._numericInterpolationAdapter.GetCurrentState();
        }
        _ForceEndValue() {
          const e = this._numericInterpolationAdapter, t = e.GetWorldInfo().GetInstance(), r2 = e.GetPropertyTrack().GetRuntime().GetTimelineManager();
          let a2 = 0;
          for (const e2 of r2.GetPlayingTimelines()) 0 === e2.GetType() ? e2.HasTrackInstance(t) && a2++ : 1 === e2.GetType() && e2.GetInstance() === t && a2++;
          return a2 <= 1;
        }
        _MaybeEnsureValue(e, t, r2, a2, n, i2, o2, l2) {
          const s2 = this._numericInterpolationAdapter;
          a2 ? t && e === t.GetTime() ? s2._AddDelta(t.GetValueWithResultMode(), t, r2, o2, l2) : r2 && e === r2.GetTime() ? s2._AddDelta(r2.GetValueWithResultMode(), t, r2, o2, l2) : r2 || s2._AddDelta(t.GetValueWithResultMode(), t, r2, o2, l2) : t && e === t.GetTime() ? s2._AddDelta(t.GetValueWithResultMode(), t, r2, o2, l2) : r2 && e === r2.GetTime() ? s2._AddDelta(r2.GetValueWithResultMode(), t, r2, o2, l2) : i2 - n === 0 && s2._AddDelta(t.GetValueWithResultMode(), t, r2, o2, l2);
        }
      }
      C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = NumericInterpolationAdapterForTween;
    }
    {
      const C33 = self.C3, Ease = self.Ease;
      C33.PropertyTrackState.NumericTypeAdapter = class {
        constructor() {
        }
        static WillChange(e, t, a2, r2) {
          let s2;
          switch (r2) {
            case "behavior":
            case "plugin":
              s2 = t.GetPropertyValueByIndex(e);
              break;
            case "effect":
              s2 = t[e];
              break;
            case "instance-variable":
              s2 = t.GetInstanceVariableValue(e);
          }
          return s2 !== a2;
        }
        static Interpolate(e, t, a2, r2) {
          if (!a2) {
            let e2 = r2.GetPropertyTrackDataItem();
            return e2 = r2.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode();
          }
          let s2 = r2.GetInterpolationMode();
          if ("default" === s2 && (s2 = "continuous"), "combo" === r2.GetPropertyType() && (s2 = "discrete"), "discrete" === s2) return t.GetValueWithResultMode();
          if ("continuous" === s2 || "step" === s2) {
            const n = r2.GetTimeline().GetStep();
            if ("step" === s2 && 0 !== n) {
              const t2 = 1 / n;
              e = Math.floor(e * t2) / t2;
            }
            const i2 = t.GetValueWithResultMode(), c2 = a2.GetValueWithResultMode(), o2 = t.GetAddOn("cubic-bezier"), l2 = a2.GetAddOn("cubic-bezier"), u = o2 && o2.GetStartEnable() && l2 && l2.GetEndEnable();
            if (!u && i2 === c2) return i2;
            const G = t.GetTime(), p = a2.GetTime();
            "step" === s2 && 0 !== n && (e = C33.clamp(e, G, p));
            const d2 = C33.normalize(e, G, p), b = t.GetEase();
            let f2;
            if (u) {
              const e2 = p - G;
              f2 = Ease.GetRuntimeEase(b)(e2 * d2, 0, 1, e2), f2 = Ease.GetRuntimeEase("cubicbezier")(f2, i2, i2 + o2.GetStartAnchor(), c2 + l2.GetEndAnchor(), c2);
            } else f2 = Ease.GetRuntimeEase(b)((p - G) * d2, i2, c2 - i2, p - G);
            return "integer" === r2.GetPropertyType() ? Math.floor(f2) : f2;
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PropertyTrackState.AngleTypeAdapter = class {
        constructor() {
        }
        static WillChange(e, t, a2, r2) {
          let s2;
          switch (r2) {
            case "behavior":
            case "plugin":
              s2 = t.GetPropertyValueByIndex(e);
              break;
            case "effect":
              s2 = t[e];
              break;
            case "instance-variable":
              s2 = t.GetInstanceVariableValue(e);
          }
          return s2 !== a2;
        }
        static Interpolate(e, t, a2, r2) {
          if (!a2) {
            let e2 = r2.GetPropertyTrackDataItem();
            return e2 = r2.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode();
          }
          let s2 = r2.GetInterpolationMode();
          if ("default" === s2 && (s2 = "continuous"), "combo" === r2.GetPropertyType() && (s2 = "discrete"), "discrete" === s2) return t.GetValueWithResultMode();
          if ("continuous" === s2 || "step" === s2) {
            const n = r2.GetTimeline().GetStep();
            if ("step" === s2 && 0 !== n) {
              const t2 = 1 / n;
              e = Math.floor(e * t2) / t2;
            }
            const i2 = t.GetTime(), o2 = a2.GetTime(), c2 = t.GetValueWithResultMode(), l2 = a2.GetValueWithResultMode();
            "step" === s2 && 0 !== n && (e = C33.clamp(e, i2, o2));
            const u = t.GetAddOn("angle");
            if (!u) {
              if (c2 === l2) return c2;
              const a3 = C33.normalize(e, i2, o2), r3 = self.Ease.GetRuntimeEase(t.GetEase());
              return C33.angleLerp(c2, l2, r3(a3, 0, 1, 1));
            }
            {
              const a3 = u.GetRevolutions();
              if (c2 === l2 && 0 === a3) return c2;
              const r3 = C33.normalize(e, i2, o2), s3 = self.Ease.GetRuntimeEase(t.GetEase())(r3, 0, 1, 1);
              switch (u.GetDirection()) {
                case "closest":
                  return C33.angleLerp(c2, l2, s3, a3);
                case "clockwise":
                  return C33.angleLerpClockwise(c2, l2, s3, a3);
                case "anti-clockwise":
                  return C33.angleLerpAntiClockwise(c2, l2, s3, a3);
              }
            }
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PropertyTrackState.BooleanTypeAdapter = class {
        constructor() {
        }
        static WillChange(e, t, a2, r2) {
          let c2;
          switch (r2) {
            case "behavior":
            case "plugin":
              c2 = t.GetPropertyValueByIndex(e);
              break;
            case "effect":
              c2 = t[e];
              break;
            case "instance-variable":
              c2 = t.GetInstanceVariableValue(e);
          }
          return !!c2 != !!a2;
        }
        static Interpolate(e, t, a2, r2) {
          if (!a2) {
            let e2 = r2.GetPropertyTrackDataItem();
            return e2 = r2.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode() ? 1 : 0;
          }
          return t.GetValueWithResultMode() ? 1 : 0;
        }
      };
    }
    {
      const C33 = self.C3, TEMP_COLOR_ARRAY = [0, 0, 0], TEMP_COLOR_ARRAY_2 = [0, 0, 0], TEMP_COLOR_ARRAY_3 = [0, 0, 0];
      C33.PropertyTrackState.ColorTypeAdapter = class {
        constructor() {
        }
        static WillChange(R, _, e, t) {
          let A;
          switch (t) {
            case "behavior":
            case "plugin":
              A = _.GetPropertyValueByIndex(R);
              break;
            case "effect":
              A = _[R];
              break;
            case "instance-variable":
              A = _.GetInstanceVariableValue(R);
          }
          return Array.isArray(e) ? (TEMP_COLOR_ARRAY[0] = e[0], TEMP_COLOR_ARRAY[1] = e[1], TEMP_COLOR_ARRAY[2] = e[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(e), TEMP_COLOR_ARRAY[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), Array.isArray(A) ? (TEMP_COLOR_ARRAY_2[0] = A[0], TEMP_COLOR_ARRAY_2[1] = A[1], TEMP_COLOR_ARRAY_2[2] = A[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(A), TEMP_COLOR_ARRAY_2[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY_2[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY_2[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0] || (TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1] || TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2]);
        }
        static Interpolate(R, _, e, t) {
          if (!e) {
            let R2 = t.GetPropertyTrackDataItem();
            R2 = t.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(R2);
            const _2 = R2.GetValueWithResultMode();
            return TEMP_COLOR_ARRAY[0] = _2[0], TEMP_COLOR_ARRAY[1] = _2[1], TEMP_COLOR_ARRAY[2] = _2[2], TEMP_COLOR_ARRAY;
          }
          let A = t.GetInterpolationMode();
          if ("default" === A && (A = "continuous"), "discrete" === A) {
            const R2 = _.GetValueWithResultMode();
            return TEMP_COLOR_ARRAY[0] = R2[0], TEMP_COLOR_ARRAY[1] = R2[1], TEMP_COLOR_ARRAY[2] = R2[2], TEMP_COLOR_ARRAY;
          }
          if ("continuous" === A || "step" === A) {
            const O = t.GetTimeline().GetStep();
            if ("step" === A && 0 !== O) {
              const _2 = 1 / O;
              R = Math.floor(R * _2) / _2;
            }
            const a2 = _.GetTime(), r2 = e.GetTime(), M = _.GetValueWithResultMode(), C = e.GetValueWithResultMode();
            "step" === A && 0 !== O && (R = C33.clamp(R, a2, r2));
            const T = C33.normalize(R, a2, r2), o2 = _.GetEase(), P = M[0], E = M[1], L = M[2], Y = C[0], s2 = C[1], l2 = C[2], i2 = self.Ease.GetRuntimeEase(o2), n = r2 - a2, c2 = n * T;
            return TEMP_COLOR_ARRAY[0] = P === Y ? P : i2(c2, P, Y - P, n), TEMP_COLOR_ARRAY[1] = E === s2 ? E : i2(c2, E, s2 - E, n), TEMP_COLOR_ARRAY[2] = L === l2 ? L : i2(c2, L, l2 - L, n), TEMP_COLOR_ARRAY;
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PropertyTrackState.TextTypeAdapter = class {
        constructor() {
        }
        static WillChange(e, t, a2, r2) {
          let c2;
          switch (r2) {
            case "behavior":
            case "plugin":
              c2 = t.GetPropertyValueByIndex(e);
              break;
            case "effect":
              c2 = t[e];
              break;
            case "instance-variable":
              c2 = t.GetInstanceVariableValue(e);
          }
          return c2 !== a2;
        }
        static Interpolate(e, t, a2, r2) {
          if (!a2) {
            let e2 = r2.GetPropertyTrackDataItem();
            return e2 = r2.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode();
          }
          return t.GetValueWithResultMode();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TimelineDataManager = class {
        constructor() {
          this._timelineDataItems = /* @__PURE__ */ new Map();
        }
        Release() {
          for (const e of this._timelineDataItems.values()) e.Release();
          this._timelineDataItems.clear(), this._timelineDataItems = null;
        }
        Add(e) {
          const a2 = new C33.TimelineDataItem(e), t = a2.GetName();
          this._timelineDataItems.set(t, a2);
        }
        Get(e) {
          return this._timelineDataItems.get(e);
        }
        GetNameId() {
          return 0;
        }
        static _CreateDataItems(e, a2, t, s2) {
          if (a2) for (const i2 of a2) C33.TimelineDataManager._CreateDataItem("create", i2, e, t, s2);
        }
        static _CreateDataItemsIncludingDisabled(e, a2, t, s2) {
          if (a2) for (const i2 of a2) C33.TimelineDataManager._CreateDataItem("create-including-disabled", i2, e, t, s2);
        }
        static _LoadDataItemsFromJson(e, a2, t, s2) {
          e.length ? a2.forEach((a3, t2) => {
            e[t2]._LoadFromJson(a3);
          }) : a2.forEach((a3) => {
            C33.TimelineDataManager._CreateDataItem("load", a3, e, t, s2);
          });
        }
        static _CreateDataItem(e, a2, t, s2, i2) {
          let n;
          if ("function" == typeof s2) switch (e) {
            case "load":
              n = new s2(null, i2);
              break;
            case "create":
            case "create-including-disabled":
              n = new s2(a2, i2);
          }
          else if ("object" == typeof s2) {
            const t2 = a2[s2.prop], c2 = s2.map.get(t2);
            switch (e) {
              case "load":
                n = new c2(null, i2);
                break;
              case "create":
              case "create-including-disabled":
                n = new c2(a2, i2);
            }
          }
          switch (e) {
            case "load":
              n._LoadFromJson(a2), t.push(n);
              break;
            case "create":
              if ("function" == typeof n.GetEnable && !n.GetEnable()) return n.Release();
              t.push(n);
              break;
            case "create-including-disabled":
              t.push(n);
          }
        }
      };
    }
    {
      const C33 = self.C3, NAME = 0, TOTAL_TIME = 1, STEP = 2, INTERPOLATION_MODE = 3, RESULT_MODE = 4, TRACKS = 5, LOOP = 6, PING_PONG = 7, REPEAT_COUNT = 8, START_ON_LAYOUT = 9, TRANSFORM_WITH_SCENE_GRAPH = 10, USE_SYSTEM_TIMESCALE = 11;
      C33.TimelineDataItem = class {
        constructor(t) {
          this._name = "", this._totalTime = NaN, this._step = 0, this._interpolationMode = "default", this._resultMode = "default", this._loop = false, this._pingPong = false, this._repeatCount = 1, this._trackData = null, this._startOnLayout = "", this._transformWithSceneGraph = false, this._useSystemTimescale = true, t && (this._name = t[0], this._totalTime = t[1], this._step = t[2], this._interpolationMode = t[3], this._resultMode = t[4], this._loop = !!t[6], this._pingPong = !!t[7], this._repeatCount = t[8], this._startOnLayout = t[9], this._transformWithSceneGraph = !!t[10], this._useSystemTimescale = !!t[11], this._trackData = new C33.TrackData(t[5], this));
        }
        Release() {
          this._trackData.Release(), this._trackData = null;
        }
        GetTrackData() {
          return this._trackData || (this._trackData = new C33.TrackData(null, this)), this._trackData;
        }
        GetName() {
          return this._name;
        }
        SetName(t) {
          this._name = t;
        }
        GetTotalTime() {
          return this._totalTime;
        }
        SetTotalTime(t) {
          this._totalTime = t;
        }
        GetStep() {
          return this._step;
        }
        SetStep(t) {
          this._step = t;
        }
        GetInterpolationMode() {
          return this._interpolationMode;
        }
        SetInterpolationMode(t) {
          this._interpolationMode = t;
        }
        GetResultMode() {
          return this._resultMode;
        }
        SetResultMode(t) {
          this._resultMode = t;
        }
        GetLoop() {
          return this._loop;
        }
        SetLoop(t) {
          this._loop = t;
        }
        GetPingPong() {
          return this._pingPong;
        }
        SetPingPong(t) {
          this._pingPong = t;
        }
        GetRepeatCount() {
          return this._repeatCount;
        }
        SetRepeatCount(t) {
          this._repeatCount = t;
        }
        GetStartOnLayout() {
          return this._startOnLayout;
        }
        GetTransformWithSceneGraph() {
          return this._transformWithSceneGraph;
        }
        GetUseSystemTimescale() {
          return this._useSystemTimescale;
        }
        _SaveToJson() {
          return { "trackDataJson": this._trackData._SaveToJson(), "name": this._name, "totalTime": this._totalTime, "step": this._step, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "loop": this._loop, "pingPong": this._pingPong, "repeatCount": this._repeatCount, "startOnLayout": this._startOnLayout, "transformWithSceneGraph": !!this._transformWithSceneGraph, "useSystemTimescale": this._useSystemTimescale };
        }
        _LoadFromJson(t) {
          t && (this.GetTrackData()._LoadFromJson(t["trackDataJson"]), this._name = t["name"], this._totalTime = t["totalTime"], this._step = t["step"], this._interpolationMode = t["interpolationMode"], this._resultMode = t["resultMode"], this._loop = t["loop"], this._pingPong = t["pingPong"], this._repeatCount = t["repeatCount"], this._startOnLayout = t["startOnLayout"], this._transformWithSceneGraph = !!t["transformWithSceneGraph"], this._useSystemTimescale = !!t["useSystemTimescale"]);
        }
      };
    }
    {
      const C33 = self.C3, WI_DATA = 0, OC_INDEX = 1, WI_UID = 2, INTERPOLATION_MODE = 1, RESULT_MODE = 2, ENABLED = 3, KEYFRAMES = 4, PROPERTY_TRACKS = 5, ID = 6, NESTED_DATA = 7, START_OFFSET = 0, LOCAL_TOTAL_TIME = 1, WI_ADDITIONAL_DATA = 8, ORIGINAL_WIDTH = 0, ORIGINAL_HEIGHT = 1, TRACK_TYPE = 9, TRACK_NAME = 10;
      class TrackDataItem {
        constructor(t, a2) {
          this._trackData = a2, this._instanceData = null, this._additionalInstanceData = null, this._instanceUid = NaN, this._objectClassIndex = NaN, this._interpolationMode = "default", this._resultMode = "default", this._enabled = false, this._keyframeData = null, this._propertyTrackData = null, this._id = "", this._nestedData = null, this._startOffset = 0, this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), this._type = 0, this._name = "", t && (t[0] && (this._instanceData = t[0], this._instanceUid = t[0][2], this._objectClassIndex = t[0][1]), this._interpolationMode = t[1], this._resultMode = t[2], this._enabled = !!t[3], t[6] && (this._id = t[6]), t[7] && (this._nestedData = t[7], this._startOffset = t[7][0], this._localTotalTime = t[7][1]), t[8] && (this._additionalInstanceData = t[8]), t[8] && (this._additionalInstanceData = t[8]), t[9] && (this._type = t[9]), t[10] && (this._name = t[10]), this._keyframeData = new C33.KeyframeData(t[4], this), this._propertyTrackData = new C33.PropertyTrackData(t[5], this));
        }
        Release() {
          this._instanceData = null, this._trackData = null, this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null), this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData = null), this._nestedData = null;
        }
        GetTrackData() {
          return this._trackData;
        }
        GetKeyframeData() {
          return this._keyframeData || (this._keyframeData = new C33.KeyframeData(null, this)), this._keyframeData;
        }
        GetPropertyTrackData() {
          return this._propertyTrackData || (this._propertyTrackData = new C33.PropertyTrackData(null, this)), this._propertyTrackData;
        }
        GetInstanceData() {
          return this._instanceData;
        }
        GetObjectClassIndex() {
          return this._objectClassIndex;
        }
        SetObjectClassIndex(t) {
          this._objectClassIndex = t;
        }
        GetInstanceUID() {
          return this._instanceUid;
        }
        SetInstanceUID(t) {
          this._instanceUid = t;
        }
        GetInterpolationMode() {
          return this._interpolationMode;
        }
        SetInterpolationMode(t) {
          this._interpolationMode = t;
        }
        GetResultMode() {
          return this._resultMode;
        }
        SetResultMode(t) {
          this._resultMode = t;
        }
        GetEnable() {
          return this._enabled;
        }
        SetEnable(t) {
          this._enabled = !!t;
        }
        GetId() {
          return this._id;
        }
        GetStartOffset() {
          return this._startOffset;
        }
        GetLocalTotalTime() {
          return this._localTotalTime;
        }
        SetLocalTotalTime(t) {
          this._localTotalTime = t;
        }
        GetOriginalWidth() {
          return this._additionalInstanceData[0];
        }
        SetOriginalWidth(t) {
          this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[0] = t;
        }
        GetOriginalHeight() {
          return this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[1];
        }
        SetOriginalHeight(t) {
          this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[1] = t;
        }
        GetType() {
          return this._type;
        }
        GetName() {
          return this._name;
        }
        _SaveToJson() {
          return { "keyframeDataJson": this._keyframeData._SaveToJson(), "propertyTrackDataJson": this._propertyTrackData._SaveToJson(), "instanceData": this._instanceData, "additionalInstanceData": this._additionalInstanceData, "instanceUid": this._instanceUid, "objectClassIndex": this._objectClassIndex, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "enabled": this._enabled, "id": this._id, "nestedData": this._nestedData, "type": this._type, "name": this._name };
        }
        _LoadFromJson(t) {
          t && (this._instanceData = t["instanceData"], this._instanceUid = t["instanceUid"], this._objectClassIndex = t["objectClassIndex"], this._interpolationMode = t["interpolationMode"], this._resultMode = t["resultMode"], this._enabled = t["enabled"], this._id = t["id"], this._type = t["type"] ? t["type"] : 0, this._name = t["name"] ? t["name"] : "", this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), t["nestedData"] && (this._nestedData = t["nestedData"], this._startOffset = this._nestedData[0], this._localTotalTime = this._nestedData[1]), t["additionalInstanceData"] && (this._additionalInstanceData = t["additionalInstanceData"]), this.GetKeyframeData()._LoadFromJson(t["keyframeDataJson"]), this.GetPropertyTrackData()._LoadFromJson(t["propertyTrackDataJson"]));
        }
      }
      C33.TrackData = class {
        constructor(t, a2) {
          this._timelineDataItem = a2, this._trackDataItems = [], C33.TimelineDataManager._CreateDataItems(this._trackDataItems, t, TrackDataItem, this);
        }
        Release() {
          this._timelineDataItem = null;
          for (const t of this._trackDataItems) t.Release();
          C33.clearArray(this._trackDataItems), this._trackDataItems = null;
        }
        GetTimelineDataItem() {
          return this._timelineDataItem;
        }
        AddEmptyTrackDataItem() {
          const t = new TrackDataItem(null, this);
          return this._trackDataItems.push(t), t;
        }
        GetFirstKeyframeDataItem(t) {
          return t.GetKeyframeData().GetKeyframeDataItemArray()[0];
        }
        GetLastKeyframeDataItem(t) {
          return t.GetKeyframeData().GetKeyframeDataItemArray().at(-1);
        }
        GetKeyFrameDataItemAtTime(t, a2) {
          const e = a2.GetKeyframeData().GetKeyframeDataItemArray(), s2 = e.length;
          for (let a3 = 0; a3 < s2; a3++) {
            const s3 = e[a3];
            if (s3.GetTime() === t) return s3;
          }
        }
        GetFirstKeyFrameDataItemHigherThan(t, a2) {
          const e = a2.GetKeyframeData().GetKeyframeDataItemArray(), s2 = e.length;
          for (let a3 = 0; a3 < s2; a3++) {
            const s3 = e[a3];
            if (s3.GetTime() > t) return s3;
          }
        }
        GetFirstKeyFrameDataItemHigherOrEqualThan(t, a2) {
          const e = a2.GetKeyframeData().GetKeyframeDataItemArray(), s2 = e.length;
          for (let a3 = 0; a3 < s2; a3++) {
            const s3 = e[a3];
            if (s3.GetTime() >= t) return s3;
          }
        }
        GetFirstKeyFrameDataItemLowerOrEqualThan(t, a2) {
          const e = a2.GetKeyframeData().GetKeyframeDataItemArray();
          for (let a3 = e.length - 1; a3 >= 0; a3--) {
            const s2 = e[a3];
            if (s2.GetTime() <= t) return s2;
          }
        }
        *trackDataItems() {
          for (const t of this._trackDataItems) yield t;
        }
        _SaveToJson() {
          return { "trackDataItemsJson": this._trackDataItems.map((t) => t._SaveToJson()) };
        }
        _LoadFromJson(t) {
          t && C33.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, t["trackDataItemsJson"], TrackDataItem, this);
        }
      };
    }
    {
      const C33 = self.C3, SOURCE_DATA = 0, SOURCE = 0, PROPERTY = 1, TYPE = 2, MIN = 3, MAX = 4, INTERPOLATION_MODE = 5, RESULT_MODE = 6, ENABLED = 7, PROPERTY_KEYFRAMES = 8, CAN_HAVE_PROPERTY_KEYFRAMES = 9;
      class PropertyTrackDataItem {
        constructor(t, e) {
          this._propertyTrackData = e, this._sourceAdapterId = "", this._sourceAdapterArguments = null, this._property = null, this._type = null, this._min = NaN, this._max = NaN, this._interpolationMode = "default", this._resultMode = "default", this._enabled = false, this._propertyKeyframeData = null, this._canHavePropertyKeyframes = true, t && (this._sourceAdapterId = t[0][0], this._sourceAdapterArguments = t[0].slice(1), this._property = t[1], this._type = t[2], this._min = t[3], this._max = t[4], this._interpolationMode = t[5], this._resultMode = t[6], this._enabled = !!t[7], this._propertyKeyframeData = new C33.PropertyKeyframeData(t[8], this), this._canHavePropertyKeyframes = t[9]);
        }
        Release() {
          this._propertyKeyframeData.Release(), this._propertyKeyframeData = null, this._propertyTrackData = null, this._sourceAdapterArguments = null;
        }
        GetPropertyTrackData() {
          return this._propertyTrackData;
        }
        GetPropertyKeyframeData() {
          return this._propertyKeyframeData || (this._propertyKeyframeData = new C33.PropertyKeyframeData(null, this)), this._propertyKeyframeData;
        }
        GetSourceAdapterId() {
          return this._sourceAdapterId;
        }
        SetSourceAdapterId(t) {
          this._sourceAdapterId = t;
        }
        GetSourceAdapterArguments() {
          return this._sourceAdapterArguments;
        }
        SetSourceAdapterArguments(t) {
          this._sourceAdapterArguments = t;
        }
        GetProperty() {
          return this._property;
        }
        SetProperty(t) {
          this._property = t;
        }
        GetType() {
          return this._type;
        }
        SetType(t) {
          this._type = t;
        }
        GetMin() {
          return this._min;
        }
        SetMin(t) {
          this._min = t;
        }
        GetMax() {
          return this._max;
        }
        SetMax(t) {
          this._max = t;
        }
        GetInterpolationMode() {
          return this._interpolationMode;
        }
        SetInterpolationMode(t) {
          this._interpolationMode = t;
        }
        GetResultMode() {
          return this._resultMode;
        }
        SetResultMode(t) {
          this._resultMode = t;
        }
        GetEnable() {
          return this._enabled;
        }
        SetEnable(t) {
          this._enabled = !!t;
        }
        CanHavePropertyKeyframes() {
          return !!this._canHavePropertyKeyframes;
        }
        _SaveToJson() {
          return { "propertyKeyframeDataJson": this._propertyKeyframeData._SaveToJson(), "sourceAdapterId": this._sourceAdapterId, "sourceAdapterArguments": this._sourceAdapterArguments, "property": this._property, "type": this._type, "min": this._min, "max": this._max, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "enabled": this._enabled, "canHavePropertyKeyframes": this._canHavePropertyKeyframes };
        }
        _LoadFromJson(t) {
          t && (this._sourceAdapterId = t["sourceAdapterId"], this._sourceAdapterArguments = t["sourceAdapterArguments"], this._property = t["property"], this._type = t["type"], this._min = t["min"], this._max = t["max"], this._interpolationMode = t["interpolationMode"], this._resultMode = t["resultMode"], this._enabled = t["enabled"], this._canHavePropertyKeyframes = t["canHavePropertyKeyframes"], this.GetPropertyKeyframeData()._LoadFromJson(t["propertyKeyframeDataJson"]));
        }
      }
      C33.PropertyTrackData = class {
        constructor(t, e) {
          this._trackDataItem = e, this._propertyTrackDataItems = [], C33.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, t, PropertyTrackDataItem, this);
        }
        Release() {
          this._trackDataItem = null;
          for (const t of this._propertyTrackDataItems) t.Release();
          C33.clearArray(this._propertyTrackDataItems), this._propertyTrackDataItems = null;
        }
        GetTrackDataItem() {
          return this._trackDataItem;
        }
        AddEmptyPropertyTrackDataItem() {
          const t = new PropertyTrackDataItem(null, this);
          return this._propertyTrackDataItems.push(t), t;
        }
        GetFirstPropertyKeyframeDataItem(t) {
          return t.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0];
        }
        GetLastPropertyKeyframeDataItem(t) {
          return t.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray().at(-1);
        }
        GetPropertyKeyFrameDataItemAtTime(t, e) {
          const r2 = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a2 = r2.length;
          for (let e2 = 0; e2 < a2; e2++) {
            const a3 = r2[e2];
            if (a3.GetTime() === t) return a3;
          }
        }
        GetFirstPropertyKeyFrameDataItemHigherThan(t, e) {
          const r2 = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a2 = r2.length;
          for (let e2 = 0; e2 < a2; e2++) {
            const a3 = r2[e2];
            if (a3.GetTime() > t) return a3;
          }
        }
        GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t, e) {
          const r2 = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a2 = r2.length;
          for (let e2 = 0; e2 < a2; e2++) {
            const a3 = r2[e2];
            if (a3.GetTime() >= t) return a3;
          }
        }
        GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, e) {
          const r2 = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
          for (let e2 = r2.length - 1; e2 >= 0; e2--) {
            const a2 = r2[e2];
            if (a2.GetTime() <= t) return a2;
          }
        }
        *propertyTrackDataItems() {
          for (const t of this._propertyTrackDataItems) yield t;
        }
        _SaveToJson() {
          return { "propertyTrackDataItemsJson": this._propertyTrackDataItems.map((t) => t._SaveToJson()) };
        }
        _LoadFromJson(t) {
          t && C33.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, t["propertyTrackDataItemsJson"], PropertyTrackDataItem, this);
        }
      };
    }
    {
      const C33 = self.C3, TIME = 0, EASE = 1, ENABLE = 2, TAGS = 3;
      class KeyframeDataItem {
        constructor(e, t) {
          if (this._keyframeData = t, this._time = -1, this._ease = "noease", this._enable = false, this._tags = null, this._lowerTags = null, !e) return;
          this._time = e[0], this._ease = e[1], this._enable = !!e[2];
          const a2 = e[3];
          this._tags = a2 ? a2.split(" ") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())), this._next = null, this._last = null;
        }
        Release() {
          this._keyframeData = null, C33.clearArray(this._tags), this._tags = null, this._lowerTags.clear(), this._lowerTags = null, this._next = null;
        }
        GetKeyframeData() {
          return this._keyframeData;
        }
        GetNext() {
          return this._next;
        }
        SetNext(e) {
          this._next = e;
        }
        GetLast() {
          return this._last;
        }
        SetLast(e) {
          this._last = e;
        }
        GetTime() {
          return this._time;
        }
        SetTime(e) {
          this._time = e, this._keyframeData._LinkKeyframeDataItems();
        }
        GetEase() {
          return this._ease;
        }
        SetEase(e) {
          this._ease = e;
        }
        GetEnable() {
          return this._enable;
        }
        SetEnable(e) {
          this._enable = !!e;
        }
        GetTags() {
          return this._tags;
        }
        SetTags(e) {
          this._tags = e ? e.split(" ") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase()));
        }
        GetLowerTags() {
          return this._lowerTags;
        }
        HasTag(e) {
          return this._lowerTags.has(e.toLowerCase());
        }
        _SaveToJson() {
          return { "time": this._time, "ease": this._ease, "enable": this._enable, "tags": this._tags };
        }
        _LoadFromJson(e) {
          e && (this._time = e["time"], this._ease = e["ease"], this._enable = e["enable"], this._tags = e["tags"], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())));
        }
      }
      C33.KeyframeData = class {
        constructor(e, t) {
          this._trackDataItem = t, this._keyframeDataItems = [], C33.TimelineDataManager._CreateDataItems(this._keyframeDataItems, e, KeyframeDataItem, this), this._LinkKeyframeDataItems();
        }
        Release() {
          this._trackDataItem = null;
          for (const e of this._keyframeDataItems) e.Release();
          C33.clearArray(this._keyframeDataItems), this._keyframeDataItems = null;
        }
        _LinkKeyframeDataItems() {
          this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());
          for (let e = 0; e < this._keyframeDataItems.length; e++) {
            const t = this._keyframeDataItems[e];
            t.SetNext(this._keyframeDataItems[e + 1]), t.SetLast(this._keyframeDataItems[e - 1]);
          }
        }
        GetTrackDataItem() {
          return this._trackDataItem;
        }
        GetKeyframeDataItemCount() {
          return this._keyframeDataItems.length;
        }
        GetKeyframeDataItemArray() {
          return this._keyframeDataItems;
        }
        AddEmptyKeyframeDataItem() {
          const e = new KeyframeDataItem(null, this);
          return this._keyframeDataItems.push(e), this._LinkKeyframeDataItems(), e;
        }
        DeleteKeyframeDataItems(e) {
          for (const t of this._keyframeDataItems) {
            if (!e(t)) continue;
            const a2 = this._keyframeDataItems.indexOf(t);
            -1 !== a2 && (t.Release(), this._keyframeDataItems.splice(a2, 1));
          }
          this.SortKeyframeDataItems(), this._LinkKeyframeDataItems();
        }
        SortKeyframeDataItems() {
          this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());
        }
        GetKeyframeDataItemIndex(e) {
          return this._keyframeDataItems.indexOf(e);
        }
        GetKeyframeDataItemFromIndex(e) {
          return this._keyframeDataItems[e];
        }
        *keyframeDataItems() {
          for (const e of this._keyframeDataItems) yield e;
        }
        *keyframeDataItemsReverse() {
          for (let e = this._keyframeDataItems.length - 1; e >= 0; e--) yield this._keyframeDataItems[e];
        }
        _SaveToJson() {
          return { "keyframeDataItemsJson": this._keyframeDataItems.map((e) => e._SaveToJson()) };
        }
        _LoadFromJson(e) {
          e && (C33.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, e["keyframeDataItemsJson"], KeyframeDataItem, this), this._LinkKeyframeDataItems());
        }
      };
    }
    {
      const C33 = self.C3, VALUE_DATA = 0, VALUE_DATA_VALUE = 0, VALUE_DATA_ABSOLUTE_VALUE = 1, VALUE_DATA_TYPE = 2, TIME = 1, EASE = 2, ENABLE = 3, ADDONS = 4, PATH_MODE = 5;
      class PropertyKeyframeDataItem {
        constructor(e, t) {
          this._propertyKeyframeData = t, this._value = null, this._aValue = null, this._type = "", this._time = NaN, this._ease = "noease", this._enable = false, this._addonData = null, this._addonInstance = void 0, this._pathMode = "line", e && (this._value = e[0][0], this._aValue = e[0][1], this._type = e[0][2], this._time = e[1], this._ease = e[2], this._enable = !!e[3], this._pathMode = e[5], this._addonData = null, e[4] && (this._addonData = new C33.AddonData(e[4], this)), this._next = null, this._prev = null);
        }
        Release() {
          this._propertyKeyframeData = null, this._addonData && (this._addonData.Release(), this._addonData = null), this._next = null, this._prev = null;
        }
        GetAddonData() {
          return this._addonData;
        }
        SetNext(e) {
          this._next = e;
        }
        GetNext() {
          return this._next;
        }
        SetPrevious(e) {
          this._prev = e;
        }
        GetPrevious() {
          return this._prev;
        }
        GetValue() {
          return this._value;
        }
        SetValue(e) {
          "color" === this._type && C33.IsFiniteNumber(e) ? (this._value[0] = C33.GetRValue(e), this._value[1] = C33.GetGValue(e), this._value[2] = C33.GetBValue(e)) : this._value = e;
        }
        GetAbsoluteValue() {
          return this._aValue;
        }
        SetAbsoluteValue(e) {
          "color" === this._type && C33.IsFiniteNumber(e) ? (this._aValue[0] = C33.GetRValue(e), this._aValue[1] = C33.GetGValue(e), this._aValue[2] = C33.GetBValue(e)) : this._aValue = e;
        }
        GetValueWithResultMode() {
          const e = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
          return "relative" === e ? this.GetValue() : "absolute" === e ? this.GetAbsoluteValue() : void 0;
        }
        GetType() {
          return this._type;
        }
        SetType(e) {
          this._type = e;
        }
        GetTime() {
          return this._time;
        }
        SetTime(e) {
          this._time = e, this._propertyKeyframeData._LinkPropertyKeyframeDataItems();
        }
        GetEase() {
          return this._ease;
        }
        SetEase(e) {
          this._ease = e;
        }
        GetEnable() {
          return this._enable;
        }
        SetEnable(e) {
          this._enable = !!e;
        }
        GetPathMode() {
          return this._pathMode;
        }
        GetAddOn(e) {
          if (!this._addonData) return;
          if (this._addonInstance || null === this._addonInstance) return this._addonInstance;
          const t = this._addonData.GetAddDataItemArray();
          if (!t) return this._addonInstance = null, this._addonInstance;
          const a2 = t.length;
          for (let r2 = 0; r2 < a2; r2++) {
            const a3 = t[r2];
            if (a3.GetId() === e) return this._addonInstance = a3, this._addonInstance;
          }
          return this._addonInstance = null, this._addonInstance;
        }
        _SaveToJson() {
          const e = this._addonData;
          return { "addonDataJson": e ? e._SaveToJson() : e, "value": this._value, "aValue": this._aValue, "type": this._type, "time": this._time, "ease": this._ease, "enable": this._enable };
        }
        _LoadFromJson(e) {
          e && (e["addonDataJson"] && this._addonData._SetFromJson(e["addonDataJson"]), this._value = e["value"], this._aValue = e["aValue"], this._type = e["type"], this._time = e["time"], this._ease = e["ease"], this._enable = e["enable"]);
        }
      }
      C33.PropertyKeyframeData = class {
        constructor(e, t) {
          this._propertyTrackDataItem = t, this._propertyKeyframeDataItems = [], this._propertyKeyframeDataItemsIncludingDisabled = [], C33.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, e, PropertyKeyframeDataItem, this), C33.TimelineDataManager._CreateDataItemsIncludingDisabled(this._propertyKeyframeDataItemsIncludingDisabled, e, PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems();
        }
        Release() {
          this._propertyTrackDataItem = null;
          for (const e of this._propertyKeyframeDataItems) e.Release();
          C33.clearArray(this._propertyKeyframeDataItems), this._propertyKeyframeDataItems = null;
          for (const e of this._propertyKeyframeDataItemsIncludingDisabled) e.Release();
          C33.clearArray(this._propertyKeyframeDataItemsIncludingDisabled), this._propertyKeyframeDataItemsIncludingDisabled = null;
        }
        _LinkPropertyKeyframeDataItems() {
          let e = this._propertyKeyframeDataItems;
          e.sort((e2, t) => e2.GetTime() - t.GetTime());
          for (let t = 0; t < e.length; t++) {
            const a2 = e[t];
            t + 1 < e.length && a2.SetNext(e[t + 1]), t - 1 >= 0 && a2.SetPrevious(e[t - 1]);
          }
          e = this._propertyKeyframeDataItemsIncludingDisabled, e.sort((e2, t) => e2.GetTime() - t.GetTime());
          for (let t = 0; t < e.length; t++) {
            const a2 = e[t];
            t + 1 < e.length && a2.SetNext(e[t + 1]), t - 1 >= 0 && a2.SetPrevious(e[t - 1]);
          }
        }
        AddEmptyPropertyKeyframeDataItem() {
          const e = new PropertyKeyframeDataItem(null, this);
          return this._propertyKeyframeDataItems.push(e), this._LinkPropertyKeyframeDataItems(), e;
        }
        DeletePropertyKeyframeDataItems(e) {
          for (const t of this._propertyKeyframeDataItems) {
            if (!e(t)) continue;
            const a2 = this._propertyKeyframeDataItems.indexOf(t);
            -1 !== a2 && (t.Release(), this._propertyKeyframeDataItems.splice(a2, 1));
          }
          this.SortPropertyKeyFrameDataItems(), this._LinkPropertyKeyframeDataItems();
        }
        SortPropertyKeyFrameDataItems() {
          this._propertyKeyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());
        }
        GetPropertyTrackDataItem() {
          return this._propertyTrackDataItem;
        }
        GetPropertyKeyframeDataItemCount() {
          return this._propertyKeyframeDataItems.length;
        }
        GetLastPropertyKeyframeDataItem() {
          return this._propertyKeyframeDataItems[this._propertyKeyframeDataItems.length - 1];
        }
        GetPropertyKeyframeDataItemArray() {
          return this._propertyKeyframeDataItems;
        }
        GetPropertyKeyframeDataItemArrayIncludingDisabled() {
          return this._propertyKeyframeDataItemsIncludingDisabled;
        }
        *propertyKeyframeDataItems() {
          for (const e of this._propertyKeyframeDataItems) yield e;
        }
        *propertyKeyframeDataItemsReverse() {
          for (let e = this._propertyKeyframeDataItems.length - 1; e >= 0; e--) yield this._propertyKeyframeDataItems[e];
        }
        _SaveToJson() {
          const e = this._propertyKeyframeDataItems, t = this._propertyKeyframeDataItemsIncludingDisabled;
          return { "propertyKeyframeDataItemsJson": e.map((e2) => e2._SaveToJson()), "propertyKeyframeDataItemsIncludingDisabledJson": t.map((e2) => e2._SaveToJson()) };
        }
        _LoadFromJson(e) {
          e && (C33.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, e["propertyKeyframeDataItemsJson"], PropertyKeyframeDataItem, this), C33.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItemsIncludingDisabled, e["propertyKeyframeDataItemsIncludingDisabledJson"], PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems());
        }
      };
    }
    {
      const C33 = self.C3, ADDON_ID = 0, ADDON_DATA = 1;
      class AddonDataItem {
        constructor(t, a2) {
          this._addonData = a2, this._id = t[0], this._data = t[1];
        }
        Release() {
          this._addonData = null, this._data = null;
        }
        GetAddonData() {
          return this._addonData;
        }
        GetId() {
          return this._id;
        }
        _SaveToJson() {
          return { "id": this._id, "data": this._data };
        }
        _LoadFromJson(t) {
          t && (this._id = t["id"], this._data = t["data"]);
        }
      }
      const START_ANCHOR = 0, START_ENABLE = 1, END_ANCHOR = 2, END_ENABLE = 3;
      class AddonDataCubicBezierItem extends AddonDataItem {
        constructor(t, a2) {
          super(t, a2), this._startAnchor = this._data[0], this._startEnable = !!this._data[1], this._endAnchor = this._data[2], this._endEnable = !!this._data[3];
        }
        Release() {
          super.Release();
        }
        GetStartAnchor() {
          return this._startAnchor;
        }
        GetStartEnable() {
          return this._startEnable;
        }
        GetEndAnchor() {
          return this._endAnchor;
        }
        GetEndEnable() {
          return this._endEnable;
        }
        _SaveToJson() {
          return Object.assign(super._SaveToJson(), { "startAnchor": this._startAnchor, "startEnable": !!this._startEnable, "endAnchor": this._endAnchor, "endEnable": !!this._endEnable });
        }
        _LoadFromJson(t) {
          t && (super._LoadFromJson(t), this._startAnchor = t["startAnchor"], this._startEnable = !!t["startEnable"], this._endAnchor = t["endAnchor"], this._endEnable = !!t["endEnable"]);
        }
      }
      const DIRECTION = 0, REVOLUTIONS = 1;
      class AddonDataAngleItem extends AddonDataItem {
        constructor(t, a2) {
          super(t, a2), this._direction = this._data[0], this._revolutions = this._data[1];
        }
        Release() {
          super.Release();
        }
        GetDirection() {
          return this._direction;
        }
        GetRevolutions() {
          return this._revolutions;
        }
        _SaveToJson() {
          return Object.assign(super._SaveToJson(), { "direction": this._direction, "revolutions": this._revolutions });
        }
        _LoadFromJson(t) {
          t && (super._LoadFromJson(t), this._direction = t["direction"], this._revolutions = t["revolutions"]);
        }
      }
      C33.AddonData = class {
        constructor(t, a2) {
          this._propertyKeyframeDataItem = a2, this._addonDataItems = [], C33.TimelineDataManager._CreateDataItems(this._addonDataItems, t, { prop: 0, map: /* @__PURE__ */ new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]]) }, this);
        }
        Release() {
          this._propertyKeyframeDataItem = null;
          for (const t of this._addonDataItems) t.Release();
          C33.clearArray(this._addonDataItems), this._addonDataItems = null;
        }
        GetPropertyKeyframeDataItem() {
          return this._propertyKeyframeDataItem;
        }
        GetAddDataItemArray() {
          return this._addonDataItems;
        }
        *addonDataItems() {
          for (const t of this._addonDataItems) yield t;
        }
        _SaveToJson() {
          return { "addonDataItemsJson": this._addonDataItems.map((t) => t._SaveToJson()) };
        }
        _LoadFromJson(t) {
          t && C33.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, t["addonDataItemsJson"], { prop: "id", map: /* @__PURE__ */ new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]]) }, this);
        }
      };
    }
    {
      const C33 = self.C3, INITIAL_VALUE_MODE_START_VALUE = "start-value", INITIAL_VALUE_MODE_CURRENT_STATE = "current-state", PING_PONG_BEGIN = 0, PING_PONG_END = 1;
      let createdTweens = 0;
      C33.TweenState = class extends C33.TimelineState {
        constructor(e, t) {
          super("tween-" + createdTweens++, e, t), this._id = "", this._destroyInstanceOnComplete = false, this._initialValueMode = "start-value", this._instance = null, this._on_completed_callbacks = null, this._on_started_callbacks = null, this._behInst = null, this._track = null, this._iTweenState = null;
        }
        FireReleaseEvent(e) {
          const t = C33.New(C33.Event, "tweenstatereleased");
          t.tweenState = this, e.dispatchEvent(t);
        }
        GetType() {
          return 1;
        }
        CreateTrackStates() {
          for (const e of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(C33.TweenTrackState.Create(this, e));
          this._track = this._tracks[0];
        }
        AddTrack() {
          const e = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), t = C33.TweenTrackState.Create(this, e);
          return this._tracks.push(t), this._CacheTrack(), t;
        }
        _CacheTrack() {
          this._track = this._tracks[0];
        }
        GetPropertyTrack(e) {
          return this._track.GetPropertyTracks()[0];
        }
        SetPropertyType(e) {
          this._propertyType = e;
        }
        GetInstance() {
          const e = this.GetTracks();
          if (!e || !e.length) return;
          const t = e[0];
          if (this._track = t, !t) return;
          const n = t.GetInstance();
          return t.IsInstanceValid() ? n : void 0;
        }
        SetBehaviorInstance(e) {
          this._behInst = e;
        }
        AddStartedCallback(e) {
          this._on_started_callbacks || (this._on_started_callbacks = []), this._on_started_callbacks.push(e);
        }
        AddCompletedCallback(e) {
          this._on_completed_callbacks || (this._on_completed_callbacks = []), this._on_completed_callbacks.push(e);
        }
        RemoveStartedCallback(e) {
          if (!this._on_started_callbacks) return;
          const t = this._on_started_callbacks.indexOf(e);
          -1 !== t && this._on_started_callbacks.splice(t, 1);
        }
        RemoveCompletedCallback(e) {
          if (!this._on_completed_callbacks) return;
          const t = this._on_completed_callbacks.indexOf(e);
          -1 !== t && this._on_completed_callbacks.splice(t, 1);
        }
        SetStartValue(e, t) {
          for (const n of this._tracks) for (const s2 of n._propertyTracks) {
            if (s2.GetPropertyName() !== t) continue;
            const n2 = s2.GetPropertyTrackData(), i2 = s2.GetPropertyTrackDataItem(), a2 = n2.GetFirstPropertyKeyframeDataItem(i2);
            a2.SetValue(e), a2.SetAbsoluteValue(e);
          }
        }
        _GetPropertyTrackState(e) {
          for (const t of this._tracks) for (const n of t._propertyTracks) if (n.GetPropertyName() === e) return n;
        }
        BeforeSetEndValues(e) {
          let t = false;
          for (const n of e) {
            const e2 = this._GetPropertyTrackState(n);
            e2 && (this.SetStartValue(e2.GetCurrentState(), n), t = true);
          }
          if (t) {
            if (this.IsForwardPlayBack()) {
              const e2 = this.GetTotalTime() - this.GetTime();
              this.SetTotalTime(e2);
              for (const t2 of this._tracks) t2.SetLocalTotalTime(e2);
              this._SetTime(0);
            } else {
              const e2 = this.GetTime();
              this.SetTotalTime(e2);
              for (const t2 of this._tracks) t2.SetLocalTotalTime(e2);
              this._SetTime(e2);
            }
            this.SetInitialStateFromSetTime();
          }
        }
        SetEndValue(e, t) {
          const n = this._GetPropertyTrackState(t);
          if (!n) return;
          const s2 = n.GetPropertyTrackData(), i2 = n.GetPropertyTrackDataItem(), a2 = s2.GetLastPropertyKeyframeDataItem(i2);
          a2.SetTime(this.GetTotalTime()), a2.SetValue(e), a2.SetAbsoluteValue(e);
        }
        SetId(e) {
          this._id = e;
        }
        GetId() {
          return this._id;
        }
        SetInitialValueMode(e) {
          this._initialValueMode = e;
        }
        GetInitialValueMode() {
          return this._initialValueMode;
        }
        SetDestroyInstanceOnComplete(e) {
          this._destroyInstanceOnComplete = e;
        }
        GetDestroyInstanceOnComplete() {
          return this._destroyInstanceOnComplete;
        }
        OnStarted() {
          if (this._on_started_callbacks) for (const e of this._on_started_callbacks) e(this);
          if (!this.IsComplete()) for (const e of this._tracks) e.CompareSaveStateWithCurrent();
        }
        OnCompleted() {
          this._completedTick = this._runtime.GetTickCount();
        }
        FinishTriggers() {
          if (!this._finishedTriggers && (this._finishedTriggers = true, this._on_completed_callbacks)) for (const e of this._on_completed_callbacks) e(this);
        }
        SetTime(e) {
          this._DeleteIntermediateKeyframes(), super.SetTime(e);
        }
        _SetTimeAndReset(e) {
          C33.IsFiniteNumber(e) || (e = this.GetTotalTime()), e < 0 ? this._playheadTime = 0 : e >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = e, this._track.SetResetState();
        }
        SetInitialState(e) {
          if (!this.InitialStateSet() && "current-state" === this.GetInitialValueMode()) for (const e2 of this._tracks) e2.CompareInitialStateWithCurrent();
          super.SetInitialState(e);
        }
        Stop(e = false) {
          if (super.Stop(e), !this.IsComplete()) for (const e2 of this._tracks) e2.SaveState();
        }
        Reset(e = true, t = false) {
          this._DeleteIntermediateKeyframes(), super.Reset(e, t);
        }
        _DeleteIntermediateKeyframes() {
          for (const e of this._tracks) {
            const t = (e2) => {
              const t2 = e2.GetTime(), n = this.GetTotalTime();
              return 0 !== t2 && t2 !== n;
            };
            e.DeleteKeyframes(t), e.DeletePropertyKeyframes(t);
          }
        }
        _OnBeforeChangeLayout() {
          if (this.IsReleased()) return true;
          const e = this.GetInstance();
          return (!e || !e.GetObjectClass().IsGlobal()) && (this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.ResetBeforeChangeLayout(), true);
        }
        Tick(e, t, n) {
          if (this._instance || (this._instance = this.GetInstance()), !this._instance || this._instance.IsDestroyed()) return this.Stop(true), void this.OnCompleted();
          const s2 = this._instance.GetTimeScale();
          if (-1 !== s2 && (e = n * s2), 0 === e && 0 === this._lastDelta) return;
          this._lastDelta = e;
          const i2 = this._playheadTime + this._overshoot + e * this._playbackRate, a2 = this._timelineDataItem._totalTime;
          i2 < 0 ? (this._playheadTime = 0, this._overshoot = -i2) : i2 >= a2 ? (this._playheadTime = a2, this._overshoot = this._playheadTime - i2) : (this._playheadTime = i2, this._overshoot = 0);
          let r2 = false, o2 = false;
          const h = this.GetLoop(), T = this.GetPingPong();
          if (h || T ? h && !T ? this._playbackRate > 0 ? this._playheadTime >= a2 && (this._SetTimeAndReset(0), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), o2 = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(a2), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), o2 = true) : !h && T ? this._playbackRate > 0 ? this._playheadTime >= a2 && (this._SetTime(a2), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o2 = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 0 : this._resumePingPongState = 0) : (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), r2 = true) : 0 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 1 : this._resumePingPongState = 1)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o2 = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 0 : this._resumePingPongState = 0) : (r2 = true, this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)) : 0 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 1 : this._resumePingPongState = 1)) : h && T && (this._playbackRate > 0 ? this._playheadTime >= a2 && (this._SetTime(a2), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o2 = true, 0 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), 1 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), this.IsPlaying() ? (this._pingPongState++, this._pingPongState = C33.wrap(this._pingPongState, 0, 2)) : (this._resumePingPongState = this._pingPongState + 1, this._resumePingPongState = C33.wrap(this._resumePingPongState, 0, 2))) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o2 = true, 0 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), 1 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), this.IsPlaying() ? (this._pingPongState++, this._pingPongState = C33.wrap(this._pingPongState, 0, 2)) : (this._resumePingPongState = this._pingPongState + 1, this._resumePingPongState = C33.wrap(this._resumePingPongState, 0, 2)))) : this._playbackRate > 0 ? this._playheadTime >= a2 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), o2 = true) : (this._SetTime(a2), r2 = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(a2), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), o2 = true) : (this._SetTime(0), r2 = true)), !this.IsReleased() && this.IsPlaying()) {
            if (r2) return this._track.SetEndState(), this.Stop(true), void this.OnCompleted();
            this._track.Interpolate(this._playheadTime, true, false, o2, this._firstTick, false), this._firstTick && (this._firstTick = false);
          }
        }
        _TweenTrigger(e) {
          const t = this.GetInstance();
          this._behInst.PushTriggerTween(this), this._runtime.Trigger(e, t, this._behInst.GetBehaviorType()), this._behInst.PopTriggerTween();
        }
        _SaveToJson() {
          const e = super._SaveToJson(), t = this.GetTimelineDataItem();
          return Object.assign(e, { "tweenDataItemJson": t._SaveToJson(), "id": this._id, "destroyInstanceOnComplete": this._destroyInstanceOnComplete, "initialValueMode": this._initialValueMode });
        }
        _LoadFromJson(e) {
          if (!e) return;
          this.GetTimelineDataItem()._LoadFromJson(e["tweenDataItemJson"]), super._LoadFromJson(e), this._id = e["id"], this._destroyInstanceOnComplete = e["destroyInstanceOnComplete"], this._initialValueMode = e["initialValueMode"], this._CacheTrack();
        }
        static IsPlaying(e) {
          return e.IsPlaying();
        }
        static IsPaused(e) {
          return e.IsPaused();
        }
        static IsPing(e) {
          return !!e.GetPingPong() && 0 === e.GetPingPongState();
        }
        static IsPong(e) {
          return !!e.GetPingPong() && 1 === e.GetPingPongState();
        }
        static Build(e) {
          const t = e.runtime.GetTimelineManager(), n = new C33.TimelineDataItem();
          if (e.json) {
            n._LoadFromJson(e.json["tweenDataItemJson"]);
            const s2 = new C33.TweenState(n, t);
            return s2._LoadFromJson(e.json), s2;
          }
          {
            const s2 = new C33.TweenState(n, t);
            C33.IsArray(e.propertyTracksConfig) || (e.propertyTracksConfig = [e.propertyTracksConfig]), s2.SetId(e.id), s2.SetTags(e.tags), s2.SetInitialValueMode(e.initialValueMode), s2.SetDestroyInstanceOnComplete(e.releaseOnComplete), s2.SetLoop(e.loop), s2.SetPingPong(e.pingPong), s2.SetTotalTime(e.time), s2.SetStep(0), s2.SetInterpolationMode("default"), s2.SetResultMode(e.propertyTracksConfig[0].resultMode), s2.SetRepeatCount(e.repeatCount);
            const i2 = s2.AddTrack();
            i2.SetInstanceUID(e.instance.GetUID()), i2.SetInterpolationMode("default"), i2.SetResultMode(e.propertyTracksConfig[0].resultMode), i2.SetEnable(true), i2.SetObjectClassIndex(e.instance.GetObjectClass().GetIndex());
            const a2 = e.instance.GetSdkInstance(), r2 = a2.IsOriginalSizeKnown() ? a2.GetOriginalWidth() : e.instance.GetWorldInfo().GetWidth(), o2 = a2.IsOriginalSizeKnown() ? a2.GetOriginalHeight() : e.instance.GetWorldInfo().GetHeight();
            i2.SetOriginalWidth(r2), i2.SetOriginalHeight(o2);
            const h = i2.AddKeyframe();
            h.SetTime(0), h.SetEase("noease"), h.SetEnable(true), h.SetTags("");
            const T = i2.AddKeyframe();
            T.SetTime(e.time), T.SetEase("noease"), T.SetEnable(true), T.SetTags("");
            for (const t2 of e.propertyTracksConfig) {
              const n2 = i2.AddPropertyTrack();
              n2.SetSourceAdapterId(t2.sourceId), n2.SetSourceAdapterArgs(t2.sourceArgs), n2.SetPropertyName(t2.property), n2.SetPropertyType(t2.type), n2.SetMin(NaN), n2.SetMax(NaN), n2.SetInterpolationMode("default"), n2.SetResultMode(t2.resultMode), n2.SetEnable(true);
              const s3 = n2.AddPropertyKeyframe();
              s3.SetType(t2.valueType), s3.SetTime(0), s3.SetEase(t2.ease), s3.SetEnable(true), s3.SetValue(t2.startValue), s3.SetAbsoluteValue(t2.startValue);
              const a3 = n2.AddPropertyKeyframe();
              a3.SetType(t2.valueType), a3.SetTime(e.time), a3.SetEase(t2.ease), a3.SetEnable(true), a3.SetValue(t2.endValue), a3.SetAbsoluteValue(t2.endValue), n2.GetSourceAdapter();
            }
            return s2;
          }
        }
        static SetInstanceUID(e, t) {
          if (!isNaN(t)) for (const n of e.GetTracks()) n.SetInstanceUID(t);
        }
        static SetBehaviorInstance(e, t) {
          e.SetBehaviorInstance(t);
        }
        GetITweenState(e, t) {
          return this._iTweenState || (this._iTweenState = C33.New(self.ITweenState, this, e, t)), this._iTweenState;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TweenTrackState = class extends C33.TrackState {
        constructor(t, e) {
          super(t, e), this._firstPropertyTrack = null, this._secondPropertyTrack = null;
        }
        static Create(t, e) {
          return C33.New(C33.TweenTrackState, t, e);
        }
        _CachePropertyTracks() {
          1 === this._propertyTracks.length ? this._firstPropertyTrack = this._propertyTracks[0] : (this._firstPropertyTrack = this._propertyTracks[0], this._secondPropertyTrack = this._propertyTracks[1]);
        }
        CreatePropertyTrackStates() {
          for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C33.TweenPropertyTrackState.Create(this, t));
          this._CachePropertyTracks();
        }
        AddPropertyTrack() {
          const t = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem(), e = C33.TweenPropertyTrackState.Create(this, t);
          return this._propertyTracks.push(e), this._CachePropertyTracks(), e;
        }
        SetInitialState() {
          if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
          const t = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
          for (const e of this._propertyTracks) e.SetInitialState(t), 0 === this._worldInfoChange && 1 === e.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === e.GetRenderChange() && (this._renderChange = 1);
          this._needsBeforeAndAfter = 0;
          this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(t), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(t);
        }
        BeforeInterpolate() {
        }
        Interpolate(t, e = false, r2 = false, s2 = false, a2 = false, o2 = false, n = false) {
          if (this._instance || this.GetInstance(), !this._instance) return;
          return !this._instance.IsDestroyed() && ((!o2 || !this.GetObjectClass().IsGlobal()) && (this._secondPropertyTrack ? (this._firstPropertyTrack.Interpolate(t, r2, s2, n), this._secondPropertyTrack.Interpolate(t, r2, s2, n)) : this._firstPropertyTrack.Interpolate(t, r2, s2, n), void (0 !== this._firstPropertyTrack.GetWorldInfoChange() && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged()))));
        }
        AfterInterpolate() {
        }
        _LoadFromJson(t) {
          super._LoadFromJson(t), this._CachePropertyTracks();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TweenPropertyTrackState = class extends C33.PropertyTrackState {
        constructor(t, e) {
          super(t, e), this._basic = false;
        }
        static Create(t, e) {
          return C33.New(C33.TweenPropertyTrackState, t, e);
        }
        Interpolate(t, e = false, r2 = false, a2 = false) {
          let s2, o2;
          if (this._basic) s2 = this._propertyKeyframeDataItems[0], o2 = this._propertyKeyframeDataItems[1];
          else if (e) s2 = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem), o2 = s2.GetNext();
          else {
            if (this._lastPropertyKeyframeDataItem) {
              const e2 = this.GetTimeline(), r3 = this._lastPropertyKeyframeDataItem.GetNext(), a3 = this._lastPropertyKeyframeDataItem.GetTime(), s3 = r3 ? r3.GetTime() : e2.GetTotalTime();
              (t <= a3 || t >= s3) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem));
            } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem);
            s2 = this._lastPropertyKeyframeDataItem, o2 = s2.GetNext();
          }
          this._sourceAdapter.Interpolate(t, s2, o2, e, r2, a2);
        }
        AddPropertyKeyframe() {
          const t = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
          return this._lastPropertyKeyframeDataItem = null, this._basic = this.GetPropertyKeyframeDataItems().length <= 2, t;
        }
        DeletePropertyKeyframes(t) {
          this._lastPropertyKeyframeDataItem = null;
          this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(t), this._basic = this.GetPropertyKeyframeDataItems().length <= 2;
        }
        _SaveToJson() {
          return { "sourceAdapterJson": this.GetSourceAdapter()._SaveToJson(), "basic": this._basic };
        }
        _LoadFromJson(t) {
          t && (this.GetSourceAdapter()._LoadFromJson(t["sourceAdapterJson"]), this._basic = t["basic"]);
        }
      };
    }
    {
      const C33 = self.C3, Ease = self.Ease, NAME = 0, TRANSITION_KEYFRAMES = 1, LINEAR = 2;
      C33.Transition = class extends C33.DefendedBase {
        constructor(e, t = true) {
          super(), this._name = e[0], this._linear = e[2], this._transitionKeyframes = [];
          for (const t2 of e[1]) {
            const e2 = C33.TransitionKeyframe.Create(this, t2);
            this._transitionKeyframes.push(e2);
          }
          for (let e2 = 0; e2 < this._transitionKeyframes.length; e2++) {
            const t2 = this._transitionKeyframes[e2], a2 = this._transitionKeyframes[e2 + 1], s2 = this._transitionKeyframes[e2 - 1];
            t2.SetNext(a2), t2.SetPrevious(s2);
          }
          this._precalculatedSamples = /* @__PURE__ */ new Map(), this._transitionKeyframeCache = /* @__PURE__ */ new Map(), this._PreCalcSamples(), t && Ease.AddCustomEase(this._name, (e2, t2, a2, s2) => this.Interpolate(e2, t2, a2, s2), null, { transition: this });
        }
        static Create(e) {
          return C33.New(C33.Transition, e);
        }
        Release() {
          for (const e of this._transitionKeyframes) e.Release();
          C33.clearArray(this._transitionKeyframes), this._transitionKeyframes = null, this._precalculatedSamples.clear(), this._precalculatedSamples = null, this._transitionKeyframeCache.clear(), this._transitionKeyframeCache = null;
        }
        MakeLinear(e) {
          this._linear = !!e;
        }
        GetTransitionKeyFrameAt(e) {
          const t = this._transitionKeyframeCache.get(e);
          if (t) return t;
          for (const t2 of this._transitionKeyframes) if (t2.GetValueX() === e) return this._transitionKeyframeCache.set(e, t2), t2;
        }
        GetFirstTransitionKeyFrameLowerOrEqualThan(e) {
          for (let t = this._transitionKeyframes.length - 1; t >= 0; t--) {
            const a2 = this._transitionKeyframes[t], s2 = a2.GetValueX();
            if (s2 <= e) {
              let t2 = a2;
              if (s2 < e) return t2;
              if (s2 === e) {
                for (; t2; ) {
                  const e2 = t2.GetPrevious();
                  if (!e2) break;
                  if (e2.GetValueX() !== t2.GetValueX()) break;
                  t2 = e2;
                }
                return t2;
              }
            }
          }
        }
        Interpolate(e, t, a2, s2) {
          let n = e / s2;
          if (this._linear) {
            const n2 = this.GetTransitionKeyFrameAt(0), r3 = this.GetTransitionKeyFrameAt(1), i3 = t + (t + a2) * n2.GetValueY(), l3 = (t + a2) * r3.GetValueY() - i3;
            return 0 === s2 ? i3 + l3 : Ease.NoEase(e, i3, l3, s2);
          }
          0 === s2 && (n = 1);
          let r2 = this.GetFirstTransitionKeyFrameLowerOrEqualThan(n), i2 = r2.GetNext();
          if (!i2) {
            const e2 = r2.GetPrevious(), t2 = r2;
            r2 = e2, i2 = t2;
          }
          const l2 = i2.GetValueX() - r2.GetValueX(), o2 = C33.mapToRange(n, r2.GetValueX(), i2.GetValueX(), 0, l2);
          if (r2.IsSegmentLinear() || 0 === l2) {
            const e2 = t + (t + a2) * r2.GetValueY(), s3 = (t + a2) * i2.GetValueY() - e2;
            return 0 === l2 ? 1 === o2 ? e2 + s3 : e2 : Ease.NoEase(o2, e2, s3, l2);
          }
          const h = r2.GetValueX(), u = r2.GetValueY(), c2 = r2.GetValueX() + r2.GetStartAnchorX(), f2 = r2.GetValueY() + r2.GetStartAnchorY(), G = i2.GetValueX() + i2.GetEndAnchorX(), m = i2.GetValueY() + i2.GetEndAnchorY(), _ = i2.GetValueX(), y = i2.GetValueY();
          let K = Ease.GetRuntimeEase("spline")(o2, h, u, c2, f2, G, m, _, y, this._precalculatedSamples.get(r2));
          return K += r2.GetValueY(), (1 - K) * t + K * (t + a2);
        }
        _PreCalcSamples() {
          this._precalculatedSamples.clear();
          for (let e = 0; e < this._transitionKeyframes.length - 1; e++) {
            const t = this._transitionKeyframes[e];
            if (!t.GetStartEnable()) continue;
            const a2 = t, s2 = this._transitionKeyframes[e + 1];
            if (!s2.GetEndEnable()) continue;
            const n = a2.GetValueX(), r2 = a2.GetValueX() + a2.GetStartAnchorX(), i2 = s2.GetValueX() + s2.GetEndAnchorX(), l2 = s2.GetValueX();
            this._precalculatedSamples.set(a2, Ease.GetBezierSamples(n, r2, i2, l2));
          }
        }
      };
    }
    {
      const C33 = self.C3, VALUE_X = 0, VALUE_Y = 1, START_ANCHOR_X = 2, START_ANCHOR_Y = 3, END_ANCHOR_X = 4, END_ANCHOR_Y = 5, START_ENABLE = 6, END_ENABLE = 7, SEGMENT_MODE = 8;
      C33.TransitionKeyframe = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._transition = t, this._valueX = e[0], this._valueY = e[1], this._startAnchorX = e[2], this._startAnchorY = e[3], this._endAnchorX = e[4], this._endAnchorY = e[5], this._startEnable = e[6], this._endEnable = e[7], this._segmentMode = e[8], this._next = null, this._prev = null;
        }
        Release() {
          this._transition = null;
        }
        static Create(t, e) {
          return C33.New(C33.TransitionKeyframe, t, e);
        }
        SetNext(t) {
          this._next = t;
        }
        GetNext() {
          return this._next;
        }
        SetPrevious(t) {
          this._prev = t;
        }
        GetPrevious() {
          return this._prev;
        }
        GetValueX() {
          return this._valueX;
        }
        GetValueY() {
          return this._valueY;
        }
        GetStartAnchorX() {
          return this._startAnchorX;
        }
        GetStartAnchorY() {
          return this._startAnchorY;
        }
        GetEndAnchorX() {
          return this._endAnchorX;
        }
        GetEndAnchorY() {
          return this._endAnchorY;
        }
        GetStartEnable() {
          return this._startEnable;
        }
        GetEndEnable() {
          return this._endEnable;
        }
        IsSegmentLinear() {
          return "linear" === this._segmentMode;
        }
        IsSegmentCubic() {
          return "cubic" === this._segmentMode;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TransitionManager = class extends C33.DefendedBase {
        constructor(s2) {
          super(), this._runtime = s2, this._transitions = [];
        }
        Release() {
          for (const s2 of this._transitions) s2.Release();
          C33.clearArray(this._transitions), this._transitions = null;
        }
        Create(s2) {
          this._transitions.push(C33.Transition.Create(s2));
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TemplateManager = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e, this._templateDataMap = null, this._instanceToTemplateNameMap = null, this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance);
        }
        Release() {
          if (this.RemoveRuntimeListeners(), this._templateDataMap) {
            for (const e of this._templateDataMap.values()) e.clear();
            this._templateDataMap.clear();
          }
          this._templateDataMap = null, this._runtime = null;
        }
        Create(e) {
          if (this._templateDataMap || (this._templateDataMap = /* @__PURE__ */ new Map()), !e) return;
          const t = e[0][16][0], a2 = e[1];
          this._templateDataMap.has(a2) || this._templateDataMap.set(a2, /* @__PURE__ */ new Map());
          this._templateDataMap.get(a2).set(t, e);
        }
        AddRuntimeListeners() {
          const e = this._runtime.Dispatcher();
          e && e.addEventListener("instancedestroy", this._instanceDestroy);
        }
        RemoveRuntimeListeners() {
          const e = this._runtime.Dispatcher();
          e && e.removeEventListener("instancedestroy", this._instanceDestroy);
        }
        HasTemplates() {
          return !!this._templateDataMap && 0 !== this._templateDataMap.size;
        }
        GetTemplateData(e, t) {
          let a2 = 0;
          if (a2 = e instanceof C33.ObjectClass ? e.GetIndex() : e, !this._templateDataMap.has(a2)) return;
          const s2 = this._templateDataMap.get(a2).get(t);
          return s2 ? JSON.parse(JSON.stringify(s2)) : void 0;
        }
        MapInstanceToTemplateName(e, t) {
          this._instanceToTemplateNameMap || (this._instanceToTemplateNameMap = /* @__PURE__ */ new WeakMap()), this._instanceToTemplateNameMap.has(e) || this._instanceToTemplateNameMap.set(e, t);
        }
        GetInstanceTemplateName(e) {
          if (!this._instanceToTemplateNameMap) return "";
          const t = this._instanceToTemplateNameMap.get(e);
          return t || "";
        }
        _OnInstanceDestroy(e) {
          this._instanceToTemplateNameMap && this._instanceToTemplateNameMap.has(e) && this._instanceToTemplateNameMap.delete(e);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.FlowchartManager = class {
        constructor(a2) {
          this._runtime = a2, this._flowchartDataManager = new C33.FlowchartDataManager();
        }
        Release() {
          this._flowchartDataManager.Release(), this._flowchartDataManager = null, this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        Create(a2) {
          this._flowchartDataManager.Add(a2);
        }
        GetFlowchartDataItemByName(a2) {
          return this._flowchartDataManager.Get(a2);
        }
        HasFlowcharts() {
          return this._flowchartDataManager.HasFlowcharts();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.FlowchartState = class {
        constructor(t, e, r2, a2, o2, h, s2) {
          this._runtime = o2.GetRuntime(), this._flowchartManager = o2, this._flowchartName = t, this._startNodeTag = r2, this._flowchartDataItem = a2, this._tag = e, this._pluginInstance = h, this._pluginUID = s2 ?? h.GetInstance().GetUID(), this._SetStartFlowchartNode(), this._currentFlowchartNodeId = this._startFlowchartNode?.GetFlowchartId() ?? -1, this._previousFlowchartNodeIds = [], this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._triggerCount = 0, this._markForRelease = false, this._released = false;
        }
        Release() {
          this._released || (C33.clearArray(this._previousFlowchartNodeIds), this._previousFlowchartNodeIds = null, this._runtime = null, this._flowchartManager = null, this._flowchartDataItem = null, this._pluginInstance = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._released = true);
        }
        WasReleased() {
          return this._released;
        }
        GetFlowchartManager() {
          return this._flowchartManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetName() {
          return this._flowchartName;
        }
        GetFlowchartDataItem() {
          return this._flowchartDataItem;
        }
        GetTag() {
          return this._tag;
        }
        GetPluginInstance() {
          return this._pluginInstance || (this._pluginInstance = this._runtime.GetInstanceByUID(this._pluginUID).GetSdkInstance()), this._pluginInstance;
        }
        GetCurrentNode() {
          return this.GetFlowchartElementById(this._currentFlowchartNodeId);
        }
        GetCurrentNodeTag() {
          const t = this.GetCurrentNode();
          return t ? t.GetTag() : "";
        }
        GetCurrentNodeTags() {
          const t = this.GetCurrentNode();
          return t ? t.GetTags() : [];
        }
        CurrentNodeHasTags(t) {
          const e = this.GetCurrentNodeTags();
          if (!e) return false;
          if (!e.length) return false;
          const r2 = C33.FlowchartState._GetTagArray(t);
          return !(!r2 || !r2.length) && r2.every(C33.FlowchartState._HasTag, e);
        }
        CurrentNodeCompareTags(t, e) {
          const r2 = this.GetCurrentNodeTags();
          if (!r2) return false;
          if (!r2.length) return false;
          const a2 = C33.FlowchartState._GetTagArray(t);
          return !(!a2 || !a2.length) && a2.every((t2) => C33.FlowchartState._CompareTag.call(r2, t2, e));
        }
        static _HasTag(t) {
          const e = this;
          return "" === t ? 1 === e.length && "" === e[0] : e.map((t2) => t2.trim().toLowerCase()).includes(t.trim().toLowerCase());
        }
        static _GetTagArray(t) {
          return t.trim().split(" ");
        }
        static _CompareTag(t, e) {
          const r2 = this;
          return "" === t ? 1 === r2.length && "" === r2[0] : r2.some((r3) => C33.compare(r3.trim(), e, t.trim()));
        }
        GetCurrentNodeParent(t) {
          const e = this.GetCurrentNode();
          if (e) {
            if (C33.IsFiniteNumber(t)) {
              const r2 = e.GetParentFlowchartIds(), a2 = r2 ? r2[t] : void 0;
              if (C33.IsFiniteNumber(a2)) return this.GetFlowchartElementById(a2);
            }
            if ("string" == typeof t) for (const r2 of e.GetParentFlowchartIds()) {
              const e2 = this.GetFlowchartElementById(r2);
              if (e2.HasTags(t)) return this.GetFlowchartElementById(e2.GetFlowchartId());
            }
          }
        }
        GetCurrentNodeParentTag(t) {
          const e = this.GetCurrentNodeParent(t);
          return e ? e.GetTag() : "";
        }
        GetCurrentNodeParentTags(t) {
          const e = this.GetCurrentNodeParent(t);
          return e ? e.GetTags() : "";
        }
        GetCurrentNodeParentIndex(t) {
          const e = this.GetCurrentNode();
          if (!e) return -1;
          const r2 = e.GetParentFlowchartIds();
          if (!r2) return -1;
          const a2 = this.GetCurrentNodeParent(t);
          return a2 ? r2.indexOf(a2.GetFlowchartId()) : -1;
        }
        GetCurrentNodeParentCount() {
          const t = this.GetCurrentNode();
          if (!t) return 0;
          const e = t.GetParentFlowchartIds();
          return e ? e.length : 0;
        }
        GetFlowchartElementById(t) {
          return this._flowchartDataItem.GetFlowchartElementById(t);
        }
        Reset() {
          this._GetRootFlowchartState()._Reset(true);
        }
        _Reset(t) {
          if (this._GetReferenceFlowchartStates()) {
            for (const [t2, e] of this._GetReferenceFlowchartStates().entries()) e._Reset(false);
            this._GetReferenceFlowchartStates().clear();
          }
          if (this._referenceFlowchartStates = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNode = null, this._currentReferenceFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._previousFlowchartNodeIds = [], t) {
            this._flowchartManager.SetCurrentFlowchartState(this);
            const t2 = this._startFlowchartNode.GetFlowchartId();
            t2 !== this._currentFlowchartNodeId && this._GotoFlowchartNode(t2);
          } else this._currentFlowchartNodeId = this._startFlowchartNode.GetFlowchartId();
        }
        GetCurrentNodeOutputCount() {
          const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
          return t ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemCount() : 0;
        }
        IsIndexOfDefaultOutput(t) {
          return !(t < 0) && t === this.GetDefaultOutputIndex();
        }
        GetDefaultOutputIndex() {
          const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
          if (!t) return -1;
          let e = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();
          return e ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems().indexOf(e) : -1;
        }
        GetCurrentNodeOutputNameAt(t) {
          const e = this._GetFlowchartNodeOutputAt(t);
          return e ? e.GetName() : "";
        }
        GetCurrentNodeOutputValueAt(t) {
          let e;
          return C33.IsFiniteNumber(t) && (e = this._GetFlowchartNodeOutputAt(t)), "string" == typeof t && (e = this._GetFlowchartNodeOutputByName(t)), "number" != typeof t && "string" != typeof t && console.warn("[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression"), e ? e.GetValue() : "";
        }
        _MaybeByPassNodes(t, e) {
          if (t.GetEnable()) return t.GetFlowchartId();
          {
            const r2 = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();
            if (!r2) return e.GetFlowchartId();
            const a2 = r2.GetConnectedFlowchartNodeFlowchartId();
            if (!C33.IsFiniteNumber(a2)) return e.GetFlowchartId();
            const o2 = this.GetFlowchartElementById(a2);
            return o2 ? this._MaybeByPassNodes(o2, e) : e.GetFlowchartId();
          }
        }
        _MaybeByPassNodesInReferenceFlowchart(t, e) {
          if (t.GetEnable()) {
            if ("reference" === t.GetType()) {
              const e2 = t.GetReferenceFlowchartName(), r2 = t.GetReferenceFlowchartStartNodeTag(), a2 = this._flowchartManager.GetFlowchartDataItemByName(e2);
              if (!a2) return [-1, null];
              const o2 = a2.GetFlowchartNodeByTags(r2);
              return o2 ? this._MaybeByPassNodesInReferenceFlowchart(o2, a2) : this._MaybeByPassNodesInReferenceFlowchart(a2.GetFlowchartStartNode(), a2);
            }
            return [t.GetFlowchartId(), e];
          }
          {
            const r2 = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();
            if (!r2) return [-1, null];
            const a2 = r2.GetConnectedFlowchartNodeFlowchartId();
            if (!C33.IsFiniteNumber(a2)) return [-1, null];
            const o2 = e.GetFlowchartElementById(a2);
            return o2 ? this._MaybeByPassNodesInReferenceFlowchart(o2, e) : [-1, null];
          }
        }
        _ProcessAllByPasses(t, e) {
          let r2 = this.GetFlowchartElementById(t);
          if (r2) {
            if (!r2.GetEnable()) {
              const e2 = this.GetFlowchartElementById(this._currentFlowchartNodeId);
              t = this._MaybeByPassNodes(r2, e2);
            }
            if (C33.IsFiniteNumber(t) && t !== this._currentFlowchartNodeId) if (r2 = this.GetFlowchartElementById(t), "reference" === r2.GetType()) {
              const a2 = r2.GetReferenceFlowchartName(), o2 = r2.GetReferenceFlowchartStartNodeTag(), h = this._flowchartManager.GetFlowchartDataItemByName(a2);
              let s2 = h.GetFlowchartNodeByTags(o2);
              if (s2) {
                const r3 = this._MaybeByPassNodesInReferenceFlowchart(s2, h);
                if (-1 === r3[0]) return;
                e(this._currentFlowchartNodeId, t, r3[1], r3[0]);
              } else e(this._currentFlowchartNodeId, t);
            } else e(this._currentFlowchartNodeId, t);
          }
        }
        GotoNextFlowchartNode(t) {
          let e;
          if (C33.IsFiniteNumber(t) && (e = this._GetFlowchartNodeOutputAt(t)), "string" == typeof t && (e = this._GetFlowchartNodeOutputByName(t)), !e) return;
          let r2 = e.GetConnectedFlowchartNodeFlowchartId();
          C33.IsFiniteNumber(r2) && this._ProcessAllByPasses(r2, (t2, e2, r3, a2) => {
            this._previousFlowchartNodeIds.push(t2), this._GotoFlowchartNode(e2, r3, a2);
          });
        }
        GotoNextFlowchartNodeDefault() {
          const t = this._GetFlowchartNodeOutputDefault();
          if (!t) return;
          const e = t.GetConnectedFlowchartNodeFlowchartId();
          C33.IsFiniteNumber(e) && this._ProcessAllByPasses(e, (t2, e2, r2, a2) => {
            this._previousFlowchartNodeIds.push(t2), this._GotoFlowchartNode(e2, r2, a2);
          });
        }
        GotoAnyFlowchartNode(t) {
          const e = this._flowchartDataItem.GetFlowchartNodeByTags(t);
          if (!e) return;
          const r2 = e.GetFlowchartId();
          C33.IsFiniteNumber(r2) && this._ProcessAllByPasses(r2, (t2, e2, r3, a2) => {
            this._previousFlowchartNodeIds.push(t2), this._GotoFlowchartNode(e2, r3, a2);
          });
        }
        GotoPreviousFlowchartNode() {
          const t = this._previousFlowchartNodeIds.pop();
          C33.IsFiniteNumber(t) ? this._GotoFlowchartNode(t) : this._GetPreviousFlowchartState() && (this._flowchartManager.SetCurrentFlowchartState(this._GetPreviousFlowchartState(), true, false, false), this._GetPreviousFlowchartState()._GotoFlowchartNode(this._GetPreviousFlowchartStateStartNodeId()), this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(this._GetPreviousFlowchartState()));
        }
        GotoParentFlowchartNode(t) {
          if (!this.GetCurrentNode()) return;
          const e = this.GetCurrentNodeParent(t);
          if (e) {
            if (!e.GetEnable()) return;
            const t2 = e.GetFlowchartId();
            if (!C33.IsFiniteNumber(t2)) return;
            this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(e.GetFlowchartId());
          }
        }
        HasOutput(t) {
          if (C33.IsFiniteNumber(t)) {
            return !!this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems()[t];
          }
          if ("string" == typeof t) {
            const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
            for (let r2 = 0; r2 < e.length; r2++) if (e[r2].GetName() === t) return true;
            return false;
          }
          return false;
        }
        MarkForRelease() {
          this._markForRelease = true;
        }
        IsInTriggerState() {
          return this._triggerCount > 0;
        }
        PushIsTriggerState() {
          this._triggerCount++;
        }
        PopIsTriggerState() {
          this._triggerCount--, 0 === this._triggerCount && this._markForRelease && this._flowchartManager.RemoveFlowchartState(this);
        }
        _GotoFlowchartNode(t, e, r2) {
          const a2 = this._currentFlowchartNodeId, o2 = this.GetPluginInstance().GetInstance();
          this.PushIsTriggerState(), this._flowchartManager.PushFlowchartState(this), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChange, o2), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChange, o2), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChangeInFlowchart, o2), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChangeInFlowchart, o2), this._currentFlowchartNodeId = t;
          let h = this.GetFlowchartElementById(this._currentFlowchartNodeId);
          if ("dictionary" === h.GetType()) this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChange, o2), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChange, o2), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, o2), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, o2);
          if (this._flowchartManager.PopFlowchartState(), this.PopIsTriggerState(), !this.WasReleased() && (h = this.GetFlowchartElementById(this._currentFlowchartNodeId), "reference" === h.GetType())) {
            const t2 = e ? e.GetName() : h.GetReferenceFlowchartName();
            if (this._HasReferenceFlowchartState(h)) {
              this._previousFlowchartNodeIds.pop();
              const t3 = this._GetReferenceFlowchartState(h);
              this._flowchartManager.SetCurrentFlowchartState(t3, true, true, false), t3._SetPreviousFlowchart(this, a2);
              this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(t3);
            } else {
              const e2 = "number" == typeof r2 ? r2 : h.GetReferenceFlowchartStartNodeTag();
              if (t2) {
                this._previousFlowchartNodeIds.pop();
                let r3 = h.GetReferenceFlowchartTag();
                if (r3) {
                  let t3 = this._flowchartManager.GetFlowchartState(r3);
                  for (; t3; ) r3 = C33.IncrementNumberAtEndOf(r3), t3 = this._flowchartManager.GetFlowchartState(r3);
                } else {
                  r3 = `${t2}-ref`;
                  let e3 = this._flowchartManager.GetFlowchartState(r3);
                  for (; e3; ) r3 = C33.IncrementNumberAtEndOf(r3), e3 = this._flowchartManager.GetFlowchartState(r3);
                }
                const o3 = this._flowchartManager.AddFlowchartState(t2, e2, r3, this._pluginInstance, true);
                o3._SetPreviousFlowchart(this, a2), this._SetReferenceFlowchartState(h, o3);
                const s2 = this._GetRootFlowchartState();
                o3._SetRootFlowchartState(s2), s2._SetCurrentReferenceFlowchart(o3);
              }
            }
          }
        }
        _GetFlowchartNodeOutputDefault() {
          const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
          return t ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault() : null;
        }
        _GetFlowchartNodeOutputAt(t) {
          const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
          if (!e) return null;
          const r2 = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
          if (!r2) return null;
          const a2 = r2[t];
          return a2 || null;
        }
        _GetFlowchartNodeOutputByName(t) {
          const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
          if (!e) return null;
          const r2 = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemByName(t);
          return r2 || null;
        }
        _SetStartFlowchartNode(t) {
          if ("number" == typeof t) {
            let e = this.GetFlowchartElementById(t);
            e || (e = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = e;
          } else if ("number" == typeof this._startNodeTag) {
            let t2 = this.GetFlowchartElementById(this._startNodeTag);
            t2 || (t2 = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = t2;
          } else {
            let t2 = this._flowchartDataItem.GetFlowchartNodeByTags(this._startNodeTag);
            t2 || (t2 = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = t2;
          }
        }
        _SaveToJson() {
          return this._markForRelease ? null : { "flowchartName": this._flowchartName, "flowchartTag": this._tag, "startNodeTag": this._startNodeTag, "currentNodeId": this._currentFlowchartNodeId, "previousNodeIds": this._previousFlowchartNodeIds, "pluginUID": this._pluginInstance.GetInstance().GetUID(), "reference": { "previousFlowchartTag": this._GetPreviousFlowchartState() ? this._GetPreviousFlowchartState().GetTag() : "", "previousStartNodeId": C33.IsFiniteNumber(this._GetPreviousFlowchartStateStartNodeId()) ? this._GetPreviousFlowchartStateStartNodeId() : NaN, "referencesJson": this._GetFlowchartReferencesJson(), "currentReferenceFlowchartTag": this.GetCurrentReferenceFlowchart() ? this.GetCurrentReferenceFlowchart().GetTag() : "", "rootFlowchartTag": this._GetRootFlowchartState() ? this._GetRootFlowchartState().GetTag() : "" } };
        }
        _GetFlowchartReferencesJson() {
          if (!this._HasReferenceFlowchartStates()) return null;
          const t = [];
          for (const [e, r2] of this._GetReferenceFlowchartStates().entries()) t.push({ "flowchartElementId": e.GetFlowchartId(), "flowchartStateTag": r2.GetTag() });
          return t.length ? t : null;
        }
        _LoadFromJson(t) {
          if (t) {
            if (this._flowchartName = t["flowchartName"], this._tag = t["flowchartTag"], this._startNodeTag = t["startNodeTag"], this._currentFlowchartNodeId = t["currentNodeId"], this._previousFlowchartNodeIds = t["previousNodeIds"], this._pluginUID = t["pluginUID"], t.hasOwnProperty("reference")) {
              const e = t["reference"];
              this._previousFlowchartStateTag = e["previousFlowchartTag"], this._previousFlowchartStateStartNodeId = e["previousStartNodeId"], this._referenceFlowchartStatesJson = e["referencesJson"], this._currentReferenceFlowchartStateTag = e["currentReferenceFlowchartTag"], this._rootFlowchartStateTag = e["rootFlowchartTag"];
            }
            this._SetStartFlowchartNode();
          }
        }
        _GetPreviousFlowchartState() {
          return "string" == typeof this._previousFlowchartStateTag && this._previousFlowchartStateTag && (this._previousFlowchartState = this._flowchartManager.GetFlowchartState(this._previousFlowchartStateTag), this._previousFlowchartStateTag = ""), this._previousFlowchartState;
        }
        _GetPreviousFlowchartStateStartNodeId() {
          return this._previousFlowchartStateStartNodeId;
        }
        _SetPreviousFlowchart(t, e) {
          this._previousFlowchartState = t, this._previousFlowchartStateStartNodeId = e;
        }
        GetCurrentReferenceFlowchart() {
          return "string" == typeof this._currentReferenceFlowchartStateTag && this._currentReferenceFlowchartStateTag && (this._currentReferenceFlowchartState = this._flowchartManager.GetFlowchartState(this._currentReferenceFlowchartStateTag), this._currentReferenceFlowchartStateTag = ""), this._currentReferenceFlowchartState;
        }
        _SetCurrentReferenceFlowchart(t) {
          this._currentReferenceFlowchartState = t, this._currentReferenceFlowchartState === this && (this._currentReferenceFlowchartState = null);
        }
        _GetRootFlowchartState() {
          return "string" == typeof this._rootFlowchartStateTag && this._rootFlowchartStateTag && (this._rootFlowchartState = this._flowchartManager.GetFlowchartState(this._rootFlowchartStateTag), this._rootFlowchartStateTag = ""), this._rootFlowchartState ? this._rootFlowchartState : this;
        }
        _SetRootFlowchartState(t) {
          this._rootFlowchartState = t;
        }
        _HasReferenceFlowchartStates() {
          return this._RebuildReferenceFlowchartStates(), !!this._referenceFlowchartStates;
        }
        _HasReferenceFlowchartState(t) {
          return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates && this._referenceFlowchartStates.has(t);
        }
        _RebuildReferenceFlowchartStates() {
          if (this._referenceFlowchartStatesJson) {
            this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map());
            for (const t of this._referenceFlowchartStatesJson) {
              const e = this._flowchartManager.GetFlowchartState(t["flowchartStateTag"]), r2 = e.GetFlowchartElementById(t["flowchartElementId"]);
              this._referenceFlowchartStates.set(r2, e);
            }
            this._referenceFlowchartStatesJson = null;
          }
        }
        _GetReferenceFlowchartStates() {
          return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates;
        }
        _GetReferenceFlowchartState(t) {
          return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates.get(t);
        }
        _SetReferenceFlowchartState(t, e) {
          this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map()), this._referenceFlowchartStates.set(t, e);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.FlowchartStateManager = class {
        constructor(t) {
          this._runtime = t, this._flowchartStates = /* @__PURE__ */ new Map(), this._currentFlowchartState = null, this._flowchartStateStack = [], this._on_after_load = () => this._OnAfterLoad(), this._loadJson = null;
        }
        Release() {
          C33.clearArray(this._flowchartStateStack), this._flowchartStateStack = null, this._flowchartStates.clear(), this._flowchartStates = null, this._currentFlowchartState = null, this._runtime = null, this._loadJson = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetFlowchartDataItemByName(t) {
          return this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(t);
        }
        AddFlowchartState(t, e, a2, r2, h, s2) {
          const o2 = this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(t);
          if (!o2) return void console.warn(`[Flowcharts] no flowchart found with name '${t}'`);
          if (this._flowchartStates.has(a2)) {
            const t2 = this._flowchartStates.get(a2);
            t2 && this.RemoveFlowchartState(t2);
          }
          const n = new C33.FlowchartState(t, a2, e, o2, this, r2, s2);
          return this._flowchartStates.set(a2, n), h && this.SetCurrentFlowchartState(n, true), n;
        }
        RemoveFlowchartState(t) {
          if (t.MarkForRelease(), t.IsInTriggerState()) return;
          const e = t.GetTag();
          this._flowchartStates.delete(e), t.Release(), this._currentFlowchartState === t && (this._currentFlowchartState = null);
        }
        ResetFlowchartState(t) {
          t.Reset();
        }
        GetFlowchartState(t) {
          return this._flowchartStates.get(t);
        }
        PushFlowchartState(t) {
          this._flowchartStateStack.push(t);
        }
        PopFlowchartState() {
          this._flowchartStateStack.pop();
        }
        SetCurrentFlowchartState(t, e = false, a2 = false, r2 = true) {
          if (r2) {
            const e2 = t.GetCurrentReferenceFlowchart();
            t = e2 || t;
          }
          t !== this._currentFlowchartState && (this._TriggerBeforeFlowchartChange(), this._TriggerAfterFlowchartChange(t, e, a2));
        }
        GetCurrentFlowchartState(t) {
          return "string" == typeof t ? this.GetFlowchartState(t) : this._flowchartStateStack.length ? this._flowchartStateStack[this._flowchartStateStack.length - 1] : this._currentFlowchartState;
        }
        _TriggerBeforeFlowchartChange() {
          if (!this._currentFlowchartState) return;
          if (this._currentFlowchartState.WasReleased()) return;
          const t = this._currentFlowchartState.GetPluginInstance().GetInstance();
          this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeFlowchartChange, t), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();
        }
        _TriggerAfterFlowchartChange(t, e = false, a2 = false) {
          if (this._currentFlowchartState = t, !this._currentFlowchartState) return;
          if (this._currentFlowchartState.WasReleased()) return;
          const r2 = this._currentFlowchartState.GetPluginInstance().GetInstance();
          this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnFlowchartChange, r2), true !== a2 && "number" != typeof a2 || this._currentFlowchartState._SetStartFlowchartNode(a2), e && (this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChange, r2), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChange, r2), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, r2), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, r2)), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();
        }
        _SaveToJson() {
          return { "flowchartJsonObjects": [...this._flowchartStates.values()].map((t) => t._SaveToJson()), "currentFlowchartTag": this._currentFlowchartState ? this._currentFlowchartState.GetTag() : null };
        }
        _LoadFromJson(t) {
          if (!t) return;
          this._loadJson = t;
          const e = /* @__PURE__ */ new Map();
          for (const t2 of this._loadJson["flowchartJsonObjects"]) {
            const a2 = t2["flowchartTag"];
            if (this._flowchartStates.has(a2)) {
              const r2 = this._flowchartStates.get(a2);
              r2._LoadFromJson(t2), e.set(a2, r2);
            } else {
              const a3 = this.AddFlowchartState(t2["flowchartName"], t2["startNodeTag"], t2["flowchartTag"], null, false, t2["pluginUID"]);
              a3._LoadFromJson(t2), e.set(t2["flowchartTag"], a3);
            }
          }
          for (const [t2, a2] of this._flowchartStates.entries()) e.has(t2) || a2.Release();
          this._flowchartStates.clear(), this._flowchartStates = e, this._runtime.IsLoadingState() ? this._runtime.Dispatcher().addEventListener("afterload", this._on_after_load) : this._OnAfterLoad();
        }
        _OnAfterLoad() {
          this._runtime.Dispatcher().removeEventListener("afterload", this._on_after_load);
          const t = this._flowchartStates.get(this._loadJson["currentFlowchartTag"]);
          t && this.SetCurrentFlowchartState(t, true), this._loadJson = null;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.FlowchartDataManager = class {
        constructor() {
          this._flowchartDataItems = /* @__PURE__ */ new Map();
        }
        Release() {
          for (const t of this._flowchartDataItems.values()) t.Release();
          this._flowchartDataItems.clear(), this._flowchartDataItems = null;
        }
        Add(t) {
          const a2 = new C33.FlowchartDataItem(t), s2 = a2.GetName();
          this._flowchartDataItems.set(s2, a2);
        }
        Get(t) {
          return this._flowchartDataItems.get(t);
        }
        HasFlowcharts() {
          return !!this._flowchartDataItems.size;
        }
        static CreateDataItems(t, a2, s2, e) {
          if (a2) for (const o2 of a2) {
            const a3 = new s2(o2, e);
            t.push(a3);
          }
        }
      };
    }
    {
      const C33 = self.C3, NAME = 0, NODES = 1;
      C33.FlowchartDataItem = class {
        constructor(t) {
          this._name = t[0], this._flowchartNodeData = new C33.FlowchartNodeData(t[1], this);
        }
        Release() {
          this._flowchartNodeData.Release(), this._flowchartNodeData = null;
        }
        GetFlowchartNodeData() {
          return this._flowchartNodeData;
        }
        GetFlowchartElementById(t) {
          return this._flowchartNodeData.GetFlowchartElementById(t);
        }
        GetFlowchartNodeByTags(t) {
          return this._flowchartNodeData.GetFlowchartNodeByTags(t);
        }
        GetFlowchartStartNode() {
          return this._flowchartNodeData.GetFlowchartStartNode();
        }
        GetName() {
          return this._name;
        }
      };
    }
    {
      const C33 = self.C3, FLOWCHART_ID = 0, TAG = 1, PARENT_FLOWCHART_IDS = 2, PARENT_OUTPUT_FLOWCHART_IDS = 3, CHILDREN_FLOWCHART_IDS = 4, OUTPUTS = 5, IS_START = 6, TYPE = 7, DICTIONARY_ENABLE = 8, REFERENCE_FLOWCHART = 8, REFERENCE_FLOWCHART_START_NODE = 9, REFERENCE_FLOWCHART_TAG = 10, REFERENCE_FLOWCHART_ENABLE = 11;
      class FlowchartNodeDataItem {
        constructor(t, e) {
          this._flowchartNodeData = e, this._type = t[7], this._flowchartId = t[0], this._tag = t[1], this._tag ? this._tags = this._tag.trim().split(" ").map((t2) => t2.trim()) : this._tags = [], this._parentFlowchartIds = t[2], this._parentOutputFlowchartIds = null, this._childrenFlowchartIds = null, this._enable = false, "dictionary" === this._type && (this._parentOutputFlowchartIds = t[3], this._childrenFlowchartIds = t[4], this._enable = t[8]), this._isStart = t[6], this._referenceFlowchartName = null, this._referenceFlowchartStartNodeTag = null, this._referenceFlowchartTag = null, "reference" === this._type && (this._referenceFlowchartName = t[8], this._referenceFlowchartStartNodeTag = t[9], this._referenceFlowchartTag = t[10], this._enable = t[11]), this._flowchartNodeOutputData = new C33.FlowchartNodeOutputData(t[5], this);
        }
        Release() {
          this._flowchartNodeData = null;
        }
        GetFlowchartNodeData() {
          return this._flowchartNodeData;
        }
        GetFlowchartNodeOutputData() {
          return this._flowchartNodeOutputData;
        }
        GetFlowchartId() {
          return this._flowchartId;
        }
        GetTag() {
          return this._tag;
        }
        GetTags() {
          return this._tags;
        }
        HasTags(t) {
          if (!this._tags) return false;
          if (!this._tags.length) return false;
          const e = C33.FlowchartState._GetTagArray(t);
          return !(!e || !e.length) && e.every(C33.FlowchartState._HasTag, this._tags);
        }
        GetIsStart() {
          return this._isStart;
        }
        SetIsStart(t) {
          this._isStart = !!t;
        }
        CanBeStartNode() {
          if ("dictionary" === this._type) return true;
          if ("reference" === this._type) return false;
          throw new Error(`unexpected flowchart node type: ${this._type}`);
        }
        GetParentFlowchartIds() {
          return this._parentFlowchartIds;
        }
        GetParentOutputFlowchartIds() {
          return this._parentOutputFlowchartIds;
        }
        GetChildrenFlowchartIds() {
          return this._childrenFlowchartIds;
        }
        GetType() {
          return this._type;
        }
        GetEnable() {
          return this._enable;
        }
        GetReferenceFlowchartName() {
          return this._referenceFlowchartName;
        }
        GetReferenceFlowchartStartNodeTag() {
          return this._referenceFlowchartStartNodeTag;
        }
        GetReferenceFlowchartTag() {
          return this._referenceFlowchartTag;
        }
      }
      C33.FlowchartNodeData = class {
        constructor(t, e) {
          this._flowchartDataItem = e, this._flowchartNodeItems = [], this._flowchartNodeItemsIdMap = /* @__PURE__ */ new Map(), this._flowchartNodeItemsTagMap = /* @__PURE__ */ new Map(), this._flowchartNodeStartItem = null, C33.FlowchartDataManager.CreateDataItems(this._flowchartNodeItems, t, FlowchartNodeDataItem, this);
          for (const t2 of this._flowchartNodeItems) {
            const e2 = t2.GetFlowchartId(), a2 = t2.GetTag(), r2 = t2.GetTags(), s2 = t2.GetIsStart();
            if (this._flowchartNodeItemsIdMap.set(e2, t2), a2) for (const e3 of r2) this._flowchartNodeItemsTagMap.has(e3) || this._flowchartNodeItemsTagMap.set(e3, /* @__PURE__ */ new Set()), this._flowchartNodeItemsTagMap.get(e3).add(t2);
            s2 && (this._flowchartNodeStartItem = t2);
            const o2 = t2.GetFlowchartNodeOutputData();
            for (const t3 of o2.flowchartNodeOutputDataItems()) {
              const e3 = t3.GetFlowchartId();
              this._flowchartNodeItemsIdMap.set(e3, t3);
            }
          }
          this._flowchartNodeStartItem || this._SetStartNodeIfMissing();
        }
        Release() {
          this._flowchartDataItem = null;
          for (const t of this._flowchartNodeItems) t.Release();
          C33.clearArray(this._flowchartNodeItems), this._flowchartNodeItems = null;
        }
        GetFlowchartDataItem() {
          return this._flowchartDataItem;
        }
        GetFlowchartElementById(t) {
          return this._flowchartNodeItemsIdMap.get(t);
        }
        GetFlowchartNodeByTags(t) {
          if (!t || !t.length) return null;
          const e = [];
          for (const a2 of t.trim().split(" ")) {
            let t2 = this._flowchartNodeItemsTagMap.get(a2.trim()) ?? /* @__PURE__ */ new Set();
            if (0 === t2.size) return null;
            e.push(t2);
          }
          return [...e.reduce((t2, e2) => e2.size < t2.size ? e2 : t2)].filter((t2) => e.every((e2) => e2.has(t2)))[0];
        }
        GetFlowchartStartNode() {
          return this._flowchartNodeStartItem;
        }
        *flowchartNodeDataItems() {
          for (const t of this._flowchartNodeItems) yield t;
        }
        _SetStartNodeIfMissing() {
          let t = 0;
          for (const e of this.flowchartNodeDataItems()) e.GetIsStart() && t++;
          if (0 === t) {
            for (const t2 of this.flowchartNodeDataItems()) if (t2.CanBeStartNode() && !t2.GetIsStart()) return void t2.SetIsStart(true);
          } else {
            if (1 === t) return;
            if (t > 1) {
              let t2 = true;
              for (const e of this.flowchartNodeDataItems()) e.CanBeStartNode() && (e.GetIsStart() && t2 ? t2 = false : e.GetIsStart() && !t2 && e.SetIsStart(false));
            }
          }
          for (const t2 of this.flowchartNodeDataItems()) if (t2.CanBeStartNode() && t2.GetIsStart()) return void (this._flowchartNodeStartItem = t2);
        }
      };
    }
    {
      const C33 = self.C3, FLOWCHART_ID = 0, NAME = 1, VALUE = 2, CONNECTED_FLOWCHART_NODE_FLOWCHART_ID = 3, ENABLE = 4, DEFAULT = 5;
      class FlowchartNodeDataOutputItem {
        constructor(t, e) {
          this._flowchartNodeOutputData = e, this._flowchartId = t[0], this._name = t[1], this._value = t[2], this._connectedFlowchartNodeFlowchartId = t[3], this._enable = t[4], this._default = t[5];
        }
        Release() {
          this._flowchartNodeOutputData = null;
        }
        GetFlowchartNodeOutputData() {
          return this._flowchartNodeOutputData;
        }
        GetFlowchartId() {
          return this._flowchartId;
        }
        GetName() {
          return this._name;
        }
        GetValue() {
          return this._value;
        }
        GetConnectedFlowchartNodeFlowchartId() {
          return this._connectedFlowchartNodeFlowchartId;
        }
        GetEnable() {
          return this._enable;
        }
        GetDefault() {
          return this._default;
        }
      }
      C33.FlowchartNodeOutputData = class {
        constructor(t, e) {
          this._flowchartDataNodeItem = e, this._flowchartNodeOutputItems = [], this._flowchartNodeOutputItemsNameMap = /* @__PURE__ */ new Map(), C33.FlowchartDataManager.CreateDataItems(this._flowchartNodeOutputItems, t, FlowchartNodeDataOutputItem, this), this._enabledFlowchartNodeOutputItems = this._flowchartNodeOutputItems.filter((t2) => t2.GetEnable());
          for (const t2 of this._enabledFlowchartNodeOutputItems) this._flowchartNodeOutputItemsNameMap.set(t2.GetName(), t2);
        }
        Release() {
          this._flowchartDataNodeItem = null;
          for (const t of this._flowchartNodeOutputItems) t.Release();
          C33.clearArray(this._flowchartNodeOutputItems), this._flowchartNodeOutputItems = null, C33.clearArray(this._enabledFlowchartNodeOutputItems), this._enabledFlowchartNodeOutputItems = null;
        }
        GetFlowchartNodeDataItem() {
          return this._flowchartDataNodeItem;
        }
        GetFlowchartNodeOutputDataItemCount() {
          return this._enabledFlowchartNodeOutputItems.length;
        }
        GetFlowchartNodeOutputDataItems() {
          return this._enabledFlowchartNodeOutputItems;
        }
        GetFlowchartNodeOutputDataItemByName(t) {
          return this._flowchartNodeOutputItemsNameMap.get(t);
        }
        GetFlowchartNodeOutputDefault() {
          for (const t of this._enabledFlowchartNodeOutputItems) if (t.GetDefault()) return t;
        }
        *flowchartNodeOutputDataItems() {
          for (const t of this._enabledFlowchartNodeOutputItems) yield t;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SolStack = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._objectClass = t, this._stack = [], this._stack.push(C33.New(C33.Sol, this)), this._index = 0, this._current = this._stack[0];
        }
        Release() {
          for (const t of this._stack) t.Release();
          C33.clearArray(this._stack), this._current = null, this._objectClass = null;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetCurrentSol() {
          return this._current;
        }
        GetOneBelowCurrentSol() {
          return this._stack[this._index - 1];
        }
        Clear() {
          this.GetCurrentSol().Clear();
        }
        PushClean() {
          const t = this._stack, s2 = ++this._index;
          if (s2 === t.length) {
            const s3 = C33.New(C33.Sol, this);
            t.push(s3), this._current = s3;
          } else {
            const e = t[s2];
            e.Reset(), this._current = e;
          }
        }
        PushCopy() {
          const t = this._stack, s2 = ++this._index;
          s2 === t.length && t.push(C33.New(C33.Sol, this));
          const e = t[s2];
          e.Copy(t[s2 - 1]), this._current = e;
        }
        Pop() {
          this._current = this._stack[--this._index];
        }
        RemoveInstances(t) {
          const s2 = this._stack;
          for (let e = 0, n = s2.length; e < n; ++e) s2[e].RemoveInstances(t);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Sol = class extends C33.DefendedBase {
        constructor(s2) {
          super(), this._stack = s2, this._objectClass = this._stack.GetObjectClass(), this._eventStack = this._objectClass.GetRuntime().GetEventStack(), this._selectAll = true, this._instances = [], this._elseInstances = [];
        }
        Release() {
          this.ClearArrays(), this._stack = null, this._objectClass = null, this._eventStack = null;
        }
        ClearArrays() {
          C33.clearArray(this._instances), C33.clearArray(this._elseInstances);
        }
        GetObjectClass() {
          return this._objectClass;
        }
        IsSelectAll() {
          return this._selectAll;
        }
        HasAnyInstances() {
          return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length;
        }
        GetInstances() {
          return this._selectAll ? this._objectClass.GetInstances() : this._instances;
        }
        HasAnyElseInstances() {
          return !!this._elseInstances.length;
        }
        GetElseInstances() {
          return this._elseInstances;
        }
        GetExpressionInstances() {
          const s2 = this.GetInstances();
          return s2.length ? s2 : this._elseInstances;
        }
        Reset() {
          this._selectAll = true, C33.clearArray(this._elseInstances);
        }
        Clear() {
          this._selectAll = true;
        }
        Copy(s2) {
          s2.IsSelectAll() ? this.Reset() : (this._selectAll = false, C33.shallowAssignArray(this._instances, s2._instances), C33.clearArray(this._elseInstances));
        }
        _PushInstance(s2) {
          this._instances.push(s2);
        }
        _PushElseInstance(s2) {
          this._elseInstances.push(s2);
        }
        _SetSelectAll(s2) {
          this._selectAll = !!s2;
        }
        _GetOwnInstances() {
          return this._instances;
        }
        _GetOwnElseInstances() {
          return this._elseInstances;
        }
        SetSinglePicked(s2) {
          this._selectAll = false, C33.clearArray(this._instances), this._instances.push(s2);
        }
        SetArrayPicked(s2) {
          this._selectAll = false, C33.shallowAssignArray(this._instances, s2);
        }
        SetSetPicked(s2) {
          this._selectAll = false, C33.clearArray(this._instances);
          for (const e of s2) this._instances.push(e);
        }
        AddElseInstances(s2, e) {
          for (const t of e) s2.has(t) || this._elseInstances.push(t);
        }
        TransferElseInstancesToOwn(s2) {
          for (const e of s2) this._instances.push(e);
          C33.arrayRemoveAllInSet(this._elseInstances, s2);
        }
        ClearElseInstances() {
          C33.clearArray(this._elseInstances);
        }
        PickOne(s2) {
          if (s2) if (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()) {
            this.IsSelectAll() && (C33.clearArray(this._instances), C33.shallowAssignArray(this._elseInstances, s2.GetObjectClass().GetInstances()), this._selectAll = false);
            const e = this._elseInstances.indexOf(s2);
            -1 !== e && (this._instances.push(this._elseInstances[e]), this._elseInstances.splice(e, 1));
          } else this.SetSinglePicked(s2);
        }
        RemoveInstances(s2) {
          C33.arrayRemoveAllInSet(this._instances, s2), C33.arrayRemoveAllInSet(this._elseInstances, s2);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.EventStack = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._stack.push(C33.New(C33.EventStackFrame, this, null)), this._index = 0, this._expFuncStack = [];
        }
        Release() {
          for (const t of this._stack) t.Release();
          C33.clearArray(this._stack), C33.clearArray(this._expFuncStack), this._eventSheetManager = null, this._runtime = null;
        }
        GetEventSheetManager() {
          return this._eventSheetManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetCurrentStackFrame() {
          return this._stack[this._index];
        }
        GetAllStackFrames() {
          return this._stack;
        }
        GetCurrentStackFrameIndex() {
          return this._index;
        }
        Push(t) {
          const e = this._stack, n = ++this._index;
          if (n === e.length) {
            const n2 = C33.New(C33.EventStackFrame, this, t);
            return e.push(n2), n2;
          }
          {
            const s2 = e[n];
            return s2.Reset(t), s2;
          }
        }
        Pop() {
          --this._index;
        }
        PushExpFunc(t) {
          this._expFuncStack.push(t);
        }
        PopExpFunc() {
          this._expFuncStack.pop();
        }
        GetCurrentExpFuncStackFrame() {
          const t = this._expFuncStack;
          return 0 === t.length ? null : t.at(-1);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.EventStackFrame = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._stack = t, this._runtime = this._stack.GetRuntime(), this._currentEvent = e, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._expressionObjectClass = null, this._functionReturnType = 0, this._functionReturnValue = 0, this._dynamicSolModifiers = null;
        }
        Release() {
          this.Reset(null), this._stack = null, this._runtime = null;
        }
        Reset(t) {
          this._currentEvent = t, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._dynamicSolModifiers = null;
        }
        _Restore(t, e) {
          this._currentEvent = t, this._cndIndex = 0, this._actIndex = e;
        }
        ResetQuick() {
          this._cndIndex = 0, this._actIndex = 0;
        }
        GetCurrentEvent() {
          return this._currentEvent;
        }
        SetCurrentEvent(t) {
          this._currentEvent = t;
        }
        GetConditionIndex() {
          return this._cndIndex;
        }
        SetConditionIndex(t) {
          this._cndIndex = t;
        }
        GetActionIndex() {
          return this._actIndex;
        }
        SetActionIndex(t) {
          this._actIndex = t;
        }
        SetLastEventTrue(t) {
          this._lastEventTrue = !!t;
        }
        GetLastEventTrue() {
          return this._lastEventTrue;
        }
        SetElseBranchRan(t) {
          this._elseBranchRan = !!t;
        }
        GetElseBranchRan() {
          return this._elseBranchRan;
        }
        SetExpressionObjectClass(t) {
          this._expressionObjectClass = t;
        }
        GetExpressionObjectClass() {
          return this._expressionObjectClass;
        }
        InitCallFunctionExpression(t, e) {
          this._functionReturnType = t, this._functionReturnValue = e;
        }
        GetFunctionReturnType() {
          return this._functionReturnType;
        }
        SetFunctionReturnValue(t) {
          this._functionReturnValue = t;
        }
        GetFunctionReturnValue() {
          return this._functionReturnValue;
        }
        IsSolModifierAfterCnds() {
          const t = this._currentEvent;
          return !!t.IsSolWriterAfterCnds() || this._cndIndex < t.GetConditionCount() - 1 && !!t.GetSolModifiers().length;
        }
        SetDynamicSolModifiers(t) {
          this._dynamicSolModifiers = t;
        }
        GetDynamicSolModifiers() {
          return this._dynamicSolModifiers;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.LocalVarStack = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1, this._current = null, this._initialValues = [];
        }
        Release() {
          C33.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;
        }
        _SetInitialValues(t) {
          this._initialValues = t;
          const e = this._initialValues.slice(0);
          this._stack.push(e), this._index = 0, this._current = e;
        }
        GetEventSheetManager() {
          return this._eventSheetManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetCurrent() {
          return this._current;
        }
        Push() {
          const t = ++this._index, e = this._stack;
          t === e.length ? e.push(this._initialValues.slice(0)) : C33.shallowAssignArray(e[t], this._initialValues), this._current = e[t];
        }
        Pop() {
          this._current = this._stack[--this._index];
        }
      };
    }
    {
      const C33 = self.C3;
      C33.LoopStack = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1;
        }
        Release() {
          C33.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;
        }
        GetEventSheetManager() {
          return this._eventSheetManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        IsInLoop() {
          return this._index >= 0;
        }
        GetCurrent() {
          return this._stack[this._index];
        }
        Push() {
          if (++this._index, this._index === this._stack.length) {
            const t = C33.New(C33.Loop, this);
            return this._stack.push(t), t;
          }
          {
            const t = this._stack[this._index];
            return t.Reset(), t;
          }
        }
        Pop() {
          --this._index;
        }
        FindByName(t) {
          const e = this._stack;
          for (let s2 = this._index; s2 >= 0; --s2) {
            const n = e[s2];
            if (n.GetName() === t) return n;
          }
          return null;
        }
        _GetStack() {
          return this._stack.slice(0, this._index + 1);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Loop = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._loopStack = e, this._name = "", this._index = 0, this._isStopped = false, this._end = NaN;
        }
        Reset() {
          this._name = "", this._index = 0, this._isStopped = false, this._end = NaN;
        }
        SetName(e) {
          this._name = e;
        }
        GetName() {
          return this._name;
        }
        SetIndex(e) {
          this._index = e;
        }
        GetIndex() {
          return this._index;
        }
        Stop() {
          this._isStopped = true;
        }
        IsStopped() {
          return this._isStopped;
        }
        SetEnd(e) {
          this._end = e;
        }
        GetEnd() {
          return this._end;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.ArrayStack = class extends C33.DefendedBase {
        constructor() {
          super(), this._stack = [], this._index = -1;
        }
        Release() {
          C33.clearArray(this._stack);
        }
        GetCurrent() {
          return this._stack[this._index];
        }
        Push() {
          if (++this._index, this._index === this._stack.length) {
            const s2 = [];
            return this._stack.push(s2), s2;
          }
          return this._stack[this._index];
        }
        Pop() {
          --this._index;
        }
      };
    }
    {
      let SortSolArray2 = function(t, e) {
        return t.GetIndex() - e.GetIndex();
      }, IsSolArrayIdentical2 = function(t, e) {
        for (let s2 = 0, n = t.length; s2 < n; ++s2) if (t[s2] !== e[s2]) return false;
        return true;
      };
      SortSolArray = SortSolArray2, IsSolArrayIdentical = IsSolArrayIdentical2;
      const C33 = self.C3, assert = self.assert;
      C33.EventSheetManager = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._runtime = t, this._allSheets = [], this._sheetsByName = /* @__PURE__ */ new Map(), this._allGroups = [], this._groupsByName = /* @__PURE__ */ new Map(), this._blocksBySid = /* @__PURE__ */ new Map(), this._cndsBySid = /* @__PURE__ */ new Map(), this._actsBySid = /* @__PURE__ */ new Map(), this._allUniqueSolModifiers = /* @__PURE__ */ new Map(), this._eventVarsBySid = /* @__PURE__ */ new Map(), this._nextLocalVarIndex = 0, this._allGlobalVars = [], this._allLocalVars = [], this._localVarInitialValues = [], this._functionBlocksByName = /* @__PURE__ */ new Map(), this._customActionBlocksMap = /* @__PURE__ */ new Map(), this._eventStack = C33.New(C33.EventStack, this), this._localVarStack = C33.New(C33.LocalVarStack, this), this._loopStack = C33.New(C33.LoopStack, this), this._triggersToPostInit = [], this._queuedTriggers = [], this._queuedDebugTriggers = [], this._runningEventsDepth = 0, this._executingTriggerDepth = 0, this._blockFlushingDepth = 0, this._scheduledWaits = [], this._asyncActionPromises = [], this._signalTags = [], this._signalPromises = /* @__PURE__ */ new Map(), this._instSignals = /* @__PURE__ */ new Map(), self["c3_callFunction"] = (t2, e) => this._InvokeFunctionFromJS(t2, e);
        }
        Release() {
          this.ClearAllScheduledWaits(), this._eventStack.Release(), this._eventStack = null, this._localVarStack.Release(), this._localVarStack = null, C33.clearArray(this._queuedTriggers), C33.clearArray(this._queuedDebugTriggers), this._runtime = null, C33.clearArray(this._allSheets), this._sheetsByName.clear();
        }
        Create(t) {
          const e = C33.New(C33.EventSheet, this, t);
          this._allSheets.push(e), this._sheetsByName.set(e.GetName().toLowerCase(), e);
        }
        _AddTriggerToPostInit(t) {
          this._triggersToPostInit.push(t);
        }
        _PostInit() {
          for (const t of this._customActionBlocksMap.values()) t._CheckOverrideState();
          for (const t of this._functionBlocksByName.values()) t._PostInit();
          for (const t of this._customActionBlocksMap.values()) t._PostInit();
          for (const t of this._allSheets) t._PostInit();
          for (const t of this._allSheets) t._UpdateDeepIncludes();
          for (const t of this._triggersToPostInit) t._PostInit(false);
          C33.clearArray(this._triggersToPostInit), this._localVarStack._SetInitialValues(this._localVarInitialValues);
        }
        GetRuntime() {
          return this._runtime;
        }
        GetEventSheetByName(t) {
          return this._sheetsByName.get(t.toLowerCase()) || null;
        }
        _RegisterGroup(t) {
          this._allGroups.push(t), this._groupsByName.set(t.GetGroupName(), t);
        }
        _RegisterEventBlock(t) {
          this._blocksBySid.set(t.GetSID(), t);
        }
        _RegisterCondition(t) {
          this._cndsBySid.set(t.GetSID(), t);
        }
        _RegisterAction(t) {
          this._actsBySid.set(t.GetSID(), t);
        }
        _RegisterFunctionBlock(t) {
          switch (t.GetFunctionType()) {
            case 0:
              this._functionBlocksByName.set(t.GetFunctionName().toLowerCase(), t);
              break;
            case 1:
              this._customActionBlocksMap.set(t.GetFunctionName().toLowerCase(), t);
          }
        }
        _RegisterEventVariable(t) {
          this._eventVarsBySid.set(t.GetSID(), t), t.IsGlobal() ? this._allGlobalVars.push(t) : this._allLocalVars.push(t);
        }
        _DeduplicateSolModifierList(t) {
          t.length >= 2 && t.sort(SortSolArray2);
          let e = this._allUniqueSolModifiers.get(t.length);
          e || (e = [], this._allUniqueSolModifiers.set(t.length, e));
          for (let s2 = 0, n = e.length; s2 < n; ++s2) {
            const n2 = e[s2];
            if (IsSolArrayIdentical2(t, n2)) return n2;
          }
          return e.push(t), t;
        }
        _GetNextLocalVarIndex(t) {
          return this._localVarInitialValues.push(t.GetInitialValue()), this._nextLocalVarIndex++;
        }
        GetEventStack() {
          return this._eventStack;
        }
        GetCurrentEventStackFrame() {
          return this.GetEventStack().GetCurrentStackFrame();
        }
        GetCurrentEvent() {
          return this.GetCurrentEventStackFrame().GetCurrentEvent();
        }
        GetCurrentCondition() {
          const t = this.GetCurrentEventStackFrame();
          return t.GetCurrentEvent().GetConditionAt(t.GetConditionIndex());
        }
        GetCurrentAction() {
          const t = this.GetCurrentEventStackFrame();
          return t.GetCurrentEvent().GetActionAt(t.GetActionIndex());
        }
        GetLocalVarStack() {
          return this._localVarStack;
        }
        GetLoopStack() {
          return this._loopStack;
        }
        GetAllLocalVariablesInScope(t) {
          const e = [];
          for (t = t.GetScopeParent(); t; ) C33.appendArray(e, t._GetAllLocalVariablesInScope()), t = t.GetScopeParent();
          return e;
        }
        _GetLocalVariablesScriptInterface(t) {
          const e = {};
          for (const s2 of this.GetAllLocalVariablesInScope(t)) e[s2.GetJsPropName()] = s2._GetScriptInterfaceDescriptor();
          return Object.create(Object.prototype, e);
        }
        GetEventVariableBySID(t) {
          return this._eventVarsBySid.get(t) || null;
        }
        GetEventBlockBySID(t) {
          return this._blocksBySid.get(t) || null;
        }
        GetConditionBySID(t) {
          return this._cndsBySid.get(t) || null;
        }
        GetActionBySID(t) {
          return this._actsBySid.get(t) || null;
        }
        GetFunctionBlockByName(t) {
          return this._functionBlocksByName.get(t.toLowerCase()) || null;
        }
        GetCustomActionBlockByName(t, e) {
          let s2 = this._customActionBlocksMap.get((t.GetName() + "." + e).toLowerCase());
          if (s2) return s2;
          if (!t.IsFamily()) {
            for (const n of t.GetFamilies()) if (s2 = this._customActionBlocksMap.get((n.GetName() + "." + e).toLowerCase()), s2) return s2;
          }
          return null;
        }
        GetAllGlobalVariables() {
          return this._allGlobalVars;
        }
        GetAllLocalVariables() {
          return this._allLocalVars;
        }
        ResetAllGlobalsToInitialValue(t) {
          for (const t2 of this._allGlobalVars) t2.ResetToInitialValue();
          if (t) for (const t2 of this._allLocalVars) t2.IsStatic() && t2.ResetToInitialValue();
        }
        GetEventGroupByName(t) {
          return this._groupsByName.get(t.toLowerCase()) || null;
        }
        GetEventGroupBySID(t) {
          const e = this._blocksBySid.get(t);
          return e && e.IsGroup() ? e : null;
        }
        GetAllGroups() {
          return this._allGroups;
        }
        ResetAllGroupsInitialActivation() {
          for (const t of this._allGroups) t.ResetInitialActivation();
        }
        _ResetAllHasRunFlags() {
          for (const t of this._allSheets) t._ResetHasRunFlag();
        }
        RunEvents(t) {
          this._ResetAllHasRunFlags(), this._runningEventsDepth++;
          for (const e of t.runningLayouts()) {
            const t2 = e.GetEventSheet();
            t2 && (this._runtime.PushCurrentLayout(e), t2.Run(), this._runtime.PopCurrentLayout());
          }
          this._runningEventsDepth--;
        }
        async DebugRunEvents(t) {
          this._ResetAllHasRunFlags(), this._runningEventsDepth++;
          for (const e of this._DebugRunEventsGen(t)) await this._runtime.DebugBreak(e);
          this._runningEventsDepth--;
        }
        *_DebugRunEventsGen(t) {
          for (const e of t.runningLayouts()) {
            const t2 = e.GetEventSheet();
            t2 && (this._runtime.PushCurrentLayout(e), yield* t2.DebugRun(), this._runtime.PopCurrentLayout());
          }
        }
        _Trigger(t, e, s2, n) {
          let i2 = false;
          if (!t.GetMainRunningLayout()) return this.QueueTrigger(e, s2, n);
          this._executingTriggerDepth++;
          for (const r2 of t.runningLayouts()) {
            const t2 = r2.GetEventSheet();
            if (!t2) continue;
            this._runtime.PushCurrentLayout(r2);
            for (const r3 of t2.deepIncludes()) {
              const t3 = r3._Trigger(e, s2, n);
              i2 = i2 || t3;
            }
            const o2 = t2._Trigger(e, s2, n);
            i2 = i2 || o2, this._runtime.PopCurrentLayout();
          }
          return this._executingTriggerDepth--, i2;
        }
        *_DebugTrigger(t, e, s2, n) {
          let i2 = false;
          if (!t.GetMainRunningLayout()) return this.QueueTrigger(e, s2, n);
          this._executingTriggerDepth++;
          for (const r2 of t.runningLayouts()) {
            const t2 = r2.GetEventSheet();
            if (!t2) continue;
            this._runtime.PushCurrentLayout(r2);
            for (const r3 of t2.deepIncludes()) {
              const t3 = yield* r3._DebugTrigger(e, s2, n);
              i2 = i2 || t3;
            }
            const o2 = yield* t2._DebugTrigger(e, s2, n);
            i2 = i2 || o2, this._runtime.PopCurrentLayout();
          }
          return this._executingTriggerDepth--, i2;
        }
        QueueTrigger(t, e, s2) {
          return this._queuedTriggers.push([t, e, s2]), false;
        }
        QueueDebugTrigger(t, e, s2) {
          let n = null;
          const i2 = new Promise((t2) => n = t2);
          return this._queuedDebugTriggers.push([t, e, s2, n]), i2;
        }
        *_RunQueuedDebugTriggersGen() {
          if (this._runtime.HitBreakpoint()) throw new Error("should not be in breakpoint");
          const t = this._runtime.GetLayoutManager();
          for (; this._queuedDebugTriggers.length; ) {
            const [e, s2, n, i2] = this._queuedDebugTriggers.shift();
            i2(yield* this._DebugTrigger(t, e, s2, n));
          }
        }
        async RunQueuedDebugTriggersAsync() {
          for (const t of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(t);
        }
        _FastTrigger(t, e, s2, n) {
          let i2 = false;
          const r2 = t.GetMainRunningLayout(), o2 = r2.GetEventSheet();
          if (!o2) return;
          this._executingTriggerDepth++, this._runtime.PushCurrentLayout(r2);
          const a2 = o2.deepIncludes();
          for (let t2 = 0, r3 = a2.length; t2 < r3; ++t2) {
            const r4 = a2[t2]._FastTrigger(e, s2, n);
            i2 = i2 || r4;
          }
          const l2 = o2._FastTrigger(e, s2, n);
          return i2 = i2 || l2, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, i2;
        }
        *_DebugFastTrigger(t, e, s2, n) {
          let i2 = false;
          const r2 = t.GetMainRunningLayout(), o2 = r2.GetEventSheet();
          if (!o2) return;
          this._executingTriggerDepth++, this._runtime.PushCurrentLayout(r2);
          const a2 = o2.deepIncludes();
          for (let t2 = 0, r3 = a2.length; t2 < r3; ++t2) {
            const r4 = yield* a2[t2]._DebugFastTrigger(e, s2, n);
            i2 = i2 || r4;
          }
          const l2 = yield* o2._DebugFastTrigger(e, s2, n);
          return i2 = i2 || l2, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, i2;
        }
        GetTriggerDepth() {
          return this._executingTriggerDepth;
        }
        IsInTrigger() {
          return this.GetTriggerDepth() > 0;
        }
        _IncTriggerDepth() {
          return ++this._executingTriggerDepth;
        }
        _DecTriggerDepth() {
          --this._executingTriggerDepth;
        }
        IsRunningEvents() {
          return this._runningEventsDepth > 0;
        }
        IsInEventEngine() {
          return this.IsRunningEvents() || this.IsInTrigger();
        }
        _RunQueuedTriggers(t) {
          for (const [e, s2, n] of this._queuedTriggers) this._Trigger(t, e, s2, n);
          C33.clearArray(this._queuedTriggers);
        }
        BlockFlushingInstances(t) {
          t ? this._blockFlushingDepth++ : this._blockFlushingDepth--;
        }
        IsFlushingBlocked() {
          return this._blockFlushingDepth > 0;
        }
        ClearSol(t) {
          for (let e = 0, s2 = t.length; e < s2; ++e) t[e].GetSolStack().Clear();
        }
        PushCleanSol(t) {
          for (let e = 0, s2 = t.length; e < s2; ++e) t[e].GetSolStack().PushClean();
        }
        PushCopySol(t) {
          for (let e = 0, s2 = t.length; e < s2; ++e) t[e].GetSolStack().PushCopy();
        }
        PopSol(t) {
          for (let e = 0, s2 = t.length; e < s2; ++e) t[e].GetSolStack().Pop();
        }
        GetDynamicSolModifiersSet(t) {
          const e = /* @__PURE__ */ new Set(), s2 = this._eventStack.GetAllStackFrames(), n = this._eventStack.GetCurrentStackFrameIndex();
          for (let i2 = 0; i2 <= n; ++i2) {
            const n2 = s2[i2].GetDynamicSolModifiers();
            if (n2) for (const s3 of n2) t && t.has(s3) || e.add(s3);
          }
          return e;
        }
        PushCleanSolDynamic(t) {
          const e = /* @__PURE__ */ new Set([...t]), s2 = this.GetDynamicSolModifiersSet(e);
          if (s2.size > 0) {
            for (const t2 of s2) t2.GetSolStack().PushClean();
            return [...s2];
          }
          return null;
        }
        AddScheduledWait() {
          const t = C33.New(C33.ScheduledWait, this);
          return this._scheduledWaits.push(t), t;
        }
        scheduledWaits() {
          return this._scheduledWaits;
        }
        RunScheduledWaits() {
          if (!this._scheduledWaits.length) return;
          const t = this.GetCurrentEventStackFrame();
          let e = false;
          this._runningEventsDepth++;
          for (let s2 = 0, n = this._scheduledWaits.length; s2 < n; ++s2) {
            const n2 = this._scheduledWaits[s2];
            n2._ShouldRun() && n2._Run(t), n2.ShouldRelease() && (e = true);
          }
          e && (this._FilterScheduledWaitsToRelease(), t.Reset(null)), this._runningEventsDepth--;
        }
        async DebugRunScheduledWaits() {
          if (!this._scheduledWaits.length) return;
          const t = this.GetCurrentEventStackFrame();
          let e = false;
          this._runningEventsDepth++;
          for (let s2 = 0, n = this._scheduledWaits.length; s2 < n; ++s2) {
            const n2 = this._scheduledWaits[s2];
            n2._ShouldRun() && await n2._DebugRun(t), n2.ShouldRelease() && (e = true);
          }
          e && (this._FilterScheduledWaitsToRelease(), t.Reset(null)), this._runningEventsDepth--;
        }
        _FilterScheduledWaitsToRelease() {
          const t = C33.arrayFilterOut(this._scheduledWaits, (t2) => t2.ShouldRelease());
          for (const e of t) e.Release();
        }
        ClearAllScheduledWaits() {
          for (const t of this._scheduledWaits) t.Release();
          C33.clearArray(this._scheduledWaits);
        }
        _OnInstancesReleased(t) {
          for (const e of this._scheduledWaits) e.RemoveInstances(t);
          for (const e of t) {
            const t2 = this._instSignals.get(e);
            if (this._instSignals.delete(e), t2) for (const { resolve: e2 } of t2.signalPromises.values()) e2(true);
          }
        }
        AddAsyncActionPromise(t) {
          this._asyncActionPromises.push({ promise: t, triggerDepth: this.GetTriggerDepth() });
        }
        ClearAsyncActionPromises() {
          C33.clearArray(this._asyncActionPromises);
        }
        GetPromiseForAllAsyncActions() {
          const t = this.GetTriggerDepth(), e = Promise.all(this._asyncActionPromises.filter((e2) => e2.triggerDepth === t).map((t2) => t2.promise));
          return this._asyncActionPromises = this._asyncActionPromises.filter((e2) => e2.triggerDepth < t), e;
        }
        Signal(t) {
          const e = t.toLowerCase();
          this._signalTags.push(e), this._runtime.Trigger(C33.Plugins.System.Cnds.OnSignal, null), this._signalTags.pop();
          for (const t2 of this._runtime.GetEventSheetManager().scheduledWaits()) t2.IsSignal() && t2.GetSignalTag() === e && t2.SetSignalled();
          const s2 = this._signalPromises.get(e);
          s2 && (s2.resolve(), this._signalPromises.delete(e));
        }
        WaitForSignal(t) {
          const e = t.toLowerCase(), s2 = this._signalPromises.get(e);
          if (s2) return s2.promise;
          {
            let t2 = null;
            const s3 = new Promise((e2) => t2 = e2);
            return this._signalPromises.set(e, { promise: s3, resolve: t2 }), s3;
          }
        }
        GetCurrentSignalTag() {
          if (0 === this._signalTags.length) throw new Error("not in a signal");
          return this._signalTags.at(-1);
        }
        _GetInstanceSignalState(t) {
          let e = this._instSignals.get(t);
          return e || (e = { signalTags: [], signalPromises: /* @__PURE__ */ new Map() }, this._instSignals.set(t, e)), e;
        }
        InstanceSignal(t, e) {
          const s2 = this._GetInstanceSignalState(t), n = e.toLowerCase();
          s2.signalTags.push(n), this._runtime.Trigger(t.GetPlugin().GetConstructor().Cnds.OnInstanceSignal, t), s2.signalTags.pop();
          for (const e2 of this._runtime.GetEventSheetManager().scheduledWaits()) e2.IsInstanceSignals() && e2.GetSignalTag() === n && e2.SetInstanceSignalled(t);
          const i2 = s2.signalPromises.get(n);
          i2 && (i2.resolve(false), s2.signalPromises.delete(n)), 0 === s2.signalTags.length && 0 === s2.signalPromises.size && this._instSignals.delete(t);
        }
        WaitForInstanceSignal(t, e) {
          const s2 = this._GetInstanceSignalState(t), n = e.toLowerCase(), i2 = s2.signalPromises.get(n);
          if (i2) return i2.promise;
          {
            let t2 = null;
            const e2 = new Promise((e3) => t2 = e3);
            return s2.signalPromises.set(n, { promise: e2, resolve: t2 }), e2;
          }
        }
        GetCurrentInstanceSignalTag(t) {
          const e = this._GetInstanceSignalState(t);
          if (!e || 0 === e.signalTags.length) throw new Error("not in a signal");
          return e.signalTags.at(-1);
        }
        _SaveToJson() {
          return { "groups": this._SaveGroupsToJson(), "cnds": this._SaveCndsToJson(), "acts": this._SaveActsToJson(), "vars": this._SaveVarsToJson(), "waits": this._SaveScheduledWaitsToJson() };
        }
        _LoadFromJson(t) {
          this._LoadGroupsFromJson(t["groups"]), this._LoadCndsFromJson(t["cnds"]), this._LoadActsFromJson(t["acts"]), this._LoadVarsFromJson(t["vars"]), this._LoadScheduledWaitsFromJson(t["waits"]);
        }
        _SaveGroupsToJson() {
          const t = {};
          for (const e of this.GetAllGroups()) t[e.GetSID().toString()] = e.IsGroupActive();
          return t;
        }
        _LoadGroupsFromJson(t) {
          for (const [e, s2] of Object.entries(t)) {
            const t2 = parseInt(e, 10), n = this.GetEventGroupBySID(t2);
            n && n.SetGroupActive(s2);
          }
        }
        _SaveCndsToJson() {
          const t = {};
          for (const [e, s2] of this._cndsBySid) {
            const n = s2._SaveToJson();
            n && (t[e.toString()] = n);
          }
          return t;
        }
        _LoadCndsFromJson(t) {
          const e = /* @__PURE__ */ new Map();
          for (const [s2, n] of Object.entries(t)) e.set(parseInt(s2, 10), n);
          for (const [t2, s2] of this._cndsBySid) s2._LoadFromJson(e.get(t2) || null);
        }
        _SaveActsToJson() {
          const t = {};
          for (const [e, s2] of this._actsBySid) {
            const n = s2._SaveToJson();
            n && (t[e.toString()] = n);
          }
          return t;
        }
        _LoadActsFromJson(t) {
          const e = /* @__PURE__ */ new Map();
          for (const [s2, n] of Object.entries(t)) e.set(parseInt(s2, 10), n);
          for (const [t2, s2] of this._actsBySid) s2._LoadFromJson(e.get(t2) || null);
        }
        _SaveVarsToJson() {
          const t = {};
          for (const [e, s2] of this._eventVarsBySid) s2.IsConstant() || !s2.IsGlobal() && !s2.IsStatic() || (t[e.toString()] = s2.GetValue());
          return t;
        }
        _LoadVarsFromJson(t) {
          for (const [e, s2] of Object.entries(t)) {
            const t2 = parseInt(e, 10), n = this.GetEventVariableBySID(t2);
            n && n.SetValue(s2);
          }
        }
        _SaveScheduledWaitsToJson() {
          return this._scheduledWaits.filter((t) => !t.IsPromise()).map((t) => t._SaveToJson());
        }
        _LoadScheduledWaitsFromJson(t) {
          this.ClearAllScheduledWaits();
          for (const e of t) {
            const t2 = C33.ScheduledWait._CreateFromJson(this, e);
            t2 && this._scheduledWaits.push(t2);
          }
        }
        _GetPerfRecords() {
          return [...this._runtime.GetLayoutManager().runningLayouts()].map((t) => t.GetEventSheet()).filter((t) => t).map((t) => t._GetPerfRecord());
        }
        FindFirstFunctionBlockParent(t) {
          for (; t; ) {
            const e = t.GetScopeParent();
            if (e instanceof C33.FunctionBlock) return e;
            t = e;
          }
          return null;
        }
        _InvokeFunctionFromJS(t, e) {
          Array.isArray(e) || (e = []);
          const s2 = this.GetFunctionBlockByName(t.toLowerCase());
          if (!s2) return null;
          if (!s2.IsEnabled()) return s2.GetDefaultReturnValue();
          const n = s2.GetFunctionParameters();
          if (e.length < n.length) {
            e = e.slice(0);
            do {
              e.push(n[e.length].GetInitialValue());
            } while (e.length < n.length);
          }
          const i2 = s2.GetEventBlock();
          return i2.RunAsExpressionFunctionCall(i2.GetSolModifiersIncludingParents(), false, s2.GetReturnType(), s2.GetDefaultReturnValue(), ...e);
        }
      };
    }
    var SortSolArray;
    var IsSolArrayIdentical;
    {
      const C33 = self.C3;
      C33.EventSheet = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._eventSheetManager = e, this._runtime = e.GetRuntime(), this._name = t[0], this._events = [], this._triggers = /* @__PURE__ */ new Map(), this._fastTriggers = /* @__PURE__ */ new Map(), this._eventsByDisplayNumber = /* @__PURE__ */ new Map(), this._hasRun = false, this._shallowIncludes = [], this._deepIncludes = [], this._alreadyIncludedSheets = /* @__PURE__ */ new Set();
          for (const e2 of t[1]) this._CreateEvent(e2, null, this._events);
          this._perfRecord = this._runtime.IsDebug() ? { type: "sheet", name: this._name, totalTimeCounter: 0, children: [] } : null;
        }
        Release() {
          this._eventSheetManager = null, this._runtime = null;
        }
        _CreateEvent(e, t, s2) {
          switch (e[0]) {
            case 0:
            case 3:
              this._CreateEventBlock(e, t, s2);
              break;
            case 1:
              this._CreateEventVariable(e, t, s2);
              break;
            case 2:
              this._CreateInclude(e, t, s2);
              break;
            case 4:
              this._CreateFunctionBlock(e, t);
              break;
            case 5:
              this._CreateScriptBlock(e, t, s2);
              break;
            case 6:
              this._CreateCustomACEBlock(e, t);
              break;
            default:
              throw new Error("invalid event type");
          }
        }
        _CreateEventBlock(e, t, s2) {
          const n = C33.EventBlock.Create(this, t, e);
          if (n.IsOrBlock()) {
            s2.push(n);
            const e2 = n.GetConditions();
            for (let t2 = 0, s3 = e2.length; t2 < s3; ++t2) e2[t2].IsTrigger() && this._InitTrigger(n, t2);
          } else n.IsTrigger() ? this._InitTrigger(n, 0) : s2.push(n);
        }
        _CreateFunctionBlock(e, t) {
          const s2 = C33.FunctionBlock.CreateFunctionBlock(this, t, e);
          this._eventSheetManager._RegisterFunctionBlock(s2);
        }
        _CreateCustomACEBlock(e, t) {
          const s2 = C33.FunctionBlock.CreateCustomACEBlock(this, t, e);
          this._eventSheetManager._RegisterFunctionBlock(s2);
        }
        _CreateEventVariable(e, t, s2) {
          const n = C33.EventVariable.Create(this, t, e);
          s2.push(n);
        }
        _CreateInclude(e, t, s2) {
          const n = C33.EventInclude.Create(this, t, e);
          s2.push(n);
        }
        _CreateScriptBlock(e, t, s2) {
          const n = C33.EventScript.Create(this, t, e);
          s2.push(n);
        }
        _InitTrigger(e, t) {
          e.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(e);
          const s2 = e.GetConditionAt(t), n = s2._GetFunc(), r2 = s2.GetObjectClass();
          if (s2.IsFastTrigger()) {
            let i2 = this._fastTriggers.get(r2);
            i2 || (i2 = /* @__PURE__ */ new Map(), this._fastTriggers.set(r2, i2));
            const l2 = s2.GetFastTriggerValue().toLowerCase();
            let o2 = i2.get(n);
            o2 || (o2 = /* @__PURE__ */ new Map(), i2.set(n, o2));
            let a2 = o2.get(l2);
            a2 || (a2 = [], o2.set(l2, a2)), a2.push([e, t]);
          } else {
            let i2 = this._triggers.get(r2);
            i2 || (i2 = { methodMap: /* @__PURE__ */ new Map(), behaviors: /* @__PURE__ */ new Map() }, this._triggers.set(r2, i2));
            const l2 = s2.GetBehaviorType();
            let o2;
            l2 ? (o2 = i2.behaviors.get(l2), o2 || (o2 = /* @__PURE__ */ new Map(), i2.behaviors.set(l2, o2))) : o2 = i2.methodMap;
            let a2 = o2.get(n);
            a2 || (a2 = [], o2.set(n, a2)), a2.push([e, t]);
          }
        }
        _PostInit() {
          const e = this._events;
          for (let t = 0, s2 = e.length; t < s2; ++t) {
            const n = t < s2 - 1 && e[t + 1] instanceof C33.EventBlock && e[t + 1].IsElseBlock();
            e[t]._PostInit(n);
          }
        }
        _AddShallowInclude(e) {
          this._shallowIncludes.push(e);
        }
        _UpdateDeepIncludes() {
          C33.clearArray(this._deepIncludes), this._AddDeepIncludes(this), this._alreadyIncludedSheets.clear();
        }
        _AddDeepIncludes(e) {
          const t = e._deepIncludes, s2 = e._alreadyIncludedSheets;
          for (const n of this._shallowIncludes) {
            const r2 = n.GetIncludeSheet();
            n.IsActive() && e !== r2 && !s2.has(r2) && (s2.add(r2), r2._AddDeepIncludes(e), t.push(r2));
          }
        }
        deepIncludes() {
          return this._deepIncludes;
        }
        GetEventSheetManager() {
          return this._eventSheetManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetName() {
          return this._name;
        }
        _RegisterEventByDisplayNumber(e, t) {
          this._eventsByDisplayNumber.set(t, e);
        }
        _GetEventByDisplayNumber(e) {
          return this._eventsByDisplayNumber.get(e) || null;
        }
        _ResetHasRunFlag() {
          this._hasRun = false;
        }
        Run() {
          if (this._hasRun) return;
          const e = this._runtime, t = e.IsCPUProfiling(), s2 = t ? performance.now() : 0;
          this._hasRun = true;
          const n = this.GetEventSheetManager(), r2 = n.GetCurrentEventStackFrame();
          for (const t2 of this._events) t2.Run(r2), n.ClearSol(t2.GetSolModifiers()), n.ClearAsyncActionPromises(), e.FlushPendingInstances();
          r2.Reset(null), t && (this._perfRecord.totalTimeCounter += performance.now() - s2);
        }
        *DebugRun() {
          if (this._hasRun) return;
          this._hasRun = true;
          const e = this._runtime, t = this.GetEventSheetManager(), s2 = t.GetCurrentEventStackFrame();
          for (const n of this._events) yield* n.DebugRun(s2), t.ClearSol(n.GetSolModifiers()), t.ClearAsyncActionPromises(), e.FlushPendingInstances();
          s2.Reset(null);
        }
        _Trigger(e, t, s2) {
          if (!t) return this._TriggerForClass(e, t, null, null);
          {
            const n = t.GetObjectClass();
            let r2 = false, i2 = this._TriggerForClass(e, t, n, s2);
            r2 = r2 || i2;
            for (const l2 of n.GetFamilies()) i2 = this._TriggerForClass(e, t, l2, s2), r2 = r2 || i2;
          }
        }
        _TriggerForClass(e, t, s2, n) {
          const r2 = this._triggers.get(s2);
          if (!r2) return false;
          const i2 = n ? r2.behaviors.get(n) : r2.methodMap;
          if (!i2) return false;
          const l2 = i2.get(e);
          if (!l2) return false;
          let o2 = false;
          for (const [e2, s3] of l2) {
            const n2 = this._ExecuteTrigger(t, e2, s3);
            o2 = o2 || n2;
          }
          return o2;
        }
        *_DebugTrigger(e, t, s2) {
          if (!t) return yield* this._DebugTriggerForClass(e, t, null, null);
          {
            const n = t.GetObjectClass();
            let r2 = false, i2 = yield* this._DebugTriggerForClass(e, t, n, s2);
            r2 = r2 || i2;
            for (const l2 of n.GetFamilies()) i2 = yield* this._DebugTriggerForClass(e, t, l2, s2), r2 = r2 || i2;
          }
        }
        *_DebugTriggerForClass(e, t, s2, n) {
          const r2 = this._triggers.get(s2);
          if (!r2) return false;
          const i2 = n ? r2.behaviors.get(n) : r2.methodMap;
          if (!i2) return false;
          const l2 = i2.get(e);
          if (!l2) return false;
          let o2 = false;
          for (const [e2, s3] of l2) {
            let n2;
            n2 = e2.DebugCanRunFast() ? this._ExecuteTrigger(t, e2, s3) : yield* this._DebugExecuteTrigger(t, e2, s3), o2 = o2 || n2;
          }
          return o2;
        }
        _FastTrigger(e, t, s2) {
          const n = t.GetObjectClass(), r2 = this._fastTriggers.get(n);
          if (!r2) return false;
          const i2 = r2.get(e);
          if (!i2) return false;
          const l2 = i2.get(s2);
          if (!l2) return false;
          let o2 = false;
          for (let e2 = 0, t2 = l2.length; e2 < t2; ++e2) {
            const t3 = l2[e2], s3 = this._ExecuteTrigger(null, t3[0], t3[1]);
            o2 = o2 || s3;
          }
          return o2;
        }
        *_DebugFastTrigger(e, t, s2) {
          const n = t.GetObjectClass(), r2 = this._fastTriggers.get(n);
          if (!r2) return false;
          const i2 = r2.get(e);
          if (!i2) return false;
          const l2 = i2.get(s2);
          if (!l2) return false;
          let o2 = false;
          for (let e2 = 0, t2 = l2.length; e2 < t2; ++e2) {
            const t3 = l2[e2], s3 = t3[0], n2 = t3[1];
            let r3;
            r3 = s3.DebugCanRunFast() ? this._ExecuteTrigger(null, s3, n2) : yield* this._DebugExecuteTrigger(null, s3, n2), o2 = o2 || r3;
          }
          return o2;
        }
        _ExecuteTrigger(e, t, s2) {
          const n = this._runtime, r2 = this._eventSheetManager, i2 = r2.GetCurrentEvent(), l2 = r2.GetEventStack(), o2 = r2.GetTriggerDepth();
          let a2 = false;
          i2 && r2.PushCleanSol(i2.GetSolModifiersIncludingParents()), r2.PushCleanSol(t.GetSolModifiersIncludingParents());
          const c2 = o2 > 1;
          c2 && r2.GetLocalVarStack().Push();
          const u = l2.Push(t);
          if (e) {
            t.GetConditions()[s2].GetObjectClass().GetCurrentSol().SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();
          }
          let g = true;
          if (t.GetParent()) {
            const e2 = t.GetTriggerParents();
            for (let t2 = 0, s3 = e2.length; t2 < s3; ++t2) if (!e2[t2].RunPreTrigger(u)) {
              g = false;
              break;
            }
          }
          return g && (t.IsOrBlock() ? t.RunOrBlockTrigger(u, s2) : t.Run(u), a2 = u.GetLastEventTrue()), l2.Pop(), c2 && r2.GetLocalVarStack().Pop(), r2.PopSol(t.GetSolModifiersIncludingParents()), i2 && r2.PopSol(i2.GetSolModifiersIncludingParents()), i2 || 1 !== o2 || (r2.ClearAsyncActionPromises(), r2.IsFlushingBlocked() || n.FlushPendingInstances()), a2;
        }
        *_DebugExecuteTrigger(e, t, s2) {
          const n = this._runtime, r2 = this._eventSheetManager, i2 = r2.GetCurrentEvent(), l2 = r2.GetEventStack(), o2 = r2.GetTriggerDepth();
          let a2 = false;
          i2 && r2.PushCleanSol(i2.GetSolModifiersIncludingParents()), r2.PushCleanSol(t.GetSolModifiersIncludingParents());
          const c2 = o2 > 1;
          c2 && r2.GetLocalVarStack().Push();
          const u = l2.Push(t);
          if (e) {
            t.GetConditions()[s2].GetObjectClass().GetCurrentSol().SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();
          }
          let g = true;
          if (t.GetParent()) {
            const e2 = t.GetTriggerParents();
            for (let t2 = 0, s3 = e2.length; t2 < s3; ++t2) if (!(yield* e2[t2].DebugRunPreTrigger(u))) {
              g = false;
              break;
            }
          }
          return g && (t.IsOrBlock() ? yield* t.DebugRunOrBlockTrigger(u, s2) : yield* t.DebugRun(u), a2 = u.GetLastEventTrue()), l2.Pop(), c2 && r2.GetLocalVarStack().Pop(), r2.PopSol(t.GetSolModifiersIncludingParents()), i2 && r2.PopSol(i2.GetSolModifiersIncludingParents()), i2 || 1 !== o2 || (r2.ClearAsyncActionPromises(), r2.IsFlushingBlocked() || n.FlushPendingInstances()), a2;
        }
        _GetPerfRecord() {
          return this._perfRecord;
        }
      };
    }
    {
      let NoActions2 = function(t, e) {
        return true;
      };
      NoActions = NoActions2;
      const C33 = self.C3, EMPTY_ARRAY = [];
      function* DebugNoActions(t, e) {
        return true;
      }
      C33.EventBlock = class extends C33.DefendedBase {
        constructor(t, e, n) {
          super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = e, this._scopeParent = null, this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._solModifiers = [], this._solModifiersIncludingParents = [], this._hasGotSolModifiersIncludingParents = false, this._isSolWriterAfterCnds = false, this._isTopLevelGroup = false, this._hasElseBlock = false, this._isOrBlock = !!n[2], this._isElseBlock = false, this._triggerParents = null, this._conditions = [], this._actions = [], this._subEvents = [], this._RunActions = NoActions2, this._DebugRunActions = DebugNoActions, this._isGroup = false, this._isInitiallyActive = false, this._groupName = "", this._isGroupActive = false, this._containedIncludes = null, this._perfRecord = null, this._sid = n[4], this._displayNumber = n[5], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = this._runtime.IsDebug() ? { isBreakpoint: n[3][0], isBreakable: n[3][1], canRunAllConditionsFast: false, canRunAllActionsFast: false, canRunAllSubEventsFast: false, canRunSelfFast: false } : null, this.GetEventSheetManager()._RegisterEventBlock(this), 3 === n[0] && this._InitGroup(n[1]);
          let s2 = 0;
          for (const t2 of n[6]) {
            const e2 = C33.Condition.Create(this, t2, s2++);
            this._conditions.push(e2), this._AddSolModifier(e2.GetObjectClass());
          }
          s2 = 0;
          for (const t2 of n[7]) {
            const e2 = C33.Action.Create(this, t2, s2++);
            this._actions.push(e2);
          }
          if (9 === n.length) {
            const t2 = n[8];
            for (const e2 of t2) this._eventSheet._CreateEvent(e2, this, this._subEvents);
          }
          this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() && this._conditions[0]._GetFunc() === C33.Plugins.System.Cnds.Else), 0 === this._conditions.length && (this._conditions = EMPTY_ARRAY), 0 === this._actions.length && (this._actions = EMPTY_ARRAY), 0 === this._subEvents.length && (this._subEvents = EMPTY_ARRAY);
        }
        static Create(t, e, n) {
          return C33.New(C33.EventBlock, t, e, n);
        }
        _InitGroup(t) {
          this._isGroup = true, this._isInitiallyActive = !!t[0], this._isGroupActive = this._isInitiallyActive, this._groupName = t[1].toLowerCase(), this._containedIncludes = [], this.GetEventSheetManager()._RegisterGroup(this), this._runtime.IsDebug() && (this._perfRecord = { type: "group", name: t[1], totalTimeCounter: 0, children: [] });
        }
        _AddContainedInclude(t) {
          this._containedIncludes.push(t);
        }
        _AddContainerSolModifierToList(t, e) {
          for (const n of t.GetContainer().objectTypes()) e.includes(n) || e.push(n);
        }
        _AddSolModifierToList(t, e) {
          if (t) if (e.includes(t) || e.push(t), t.IsFamily()) for (const n of t.GetFamilyMembers()) n.IsInContainer() && this._AddContainerSolModifierToList(n, e);
          else t.IsInContainer() && this._AddContainerSolModifierToList(t, e);
        }
        _AddSolModifier(t) {
          this._AddSolModifierToList(t, this._solModifiers);
        }
        _AddParentSolModifier(t) {
          this._AddSolModifierToList(t, this._solModifiersIncludingParents);
        }
        SetAllSolModifiers() {
          this._solModifiers = this._runtime.GetAllObjectClasses();
        }
        _PostInit(t) {
          this._hasElseBlock = !!t, this._IdentifyTopLevelGroup(), this._IdentifyTriggerParents();
          for (const t2 of this._conditions) t2._PostInit();
          if (this._actions.length > 0) {
            let t2 = false;
            for (const e2 of this._actions) e2._PostInit(), e2.HasReturnType() && (t2 = true);
            t2 ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast, this._DebugRunActions = this._DebugRunActions_Fast);
          }
          const e = this._subEvents;
          for (let t2 = 0, n = e.length; t2 < n; ++t2) {
            const s2 = t2 < n - 1 && e[t2 + 1] instanceof C33.EventBlock && e[t2 + 1].IsElseBlock();
            e[t2]._PostInit(s2);
          }
          this._debugData && this._UpdateCanRunFast(), this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord);
        }
        _GetPerfRecord() {
          return this._perfRecord;
        }
        _GetPerfRecordParent() {
          let t = this.GetParent();
          for (; t; ) {
            if (t.IsGroup()) return t;
            t = t.GetParent();
          }
          return this._eventSheet;
        }
        _UpdateCanRunFast() {
          const t = this._debugData;
          t.canRunAllConditionsFast = this._conditions.every((t2) => t2.DebugCanRunFast()), t.canRunAllActionsFast = this._actions.every((t2) => t2.DebugCanRunFast()), t.canRunAllSubEventsFast = this._subEvents.every((t2) => t2.DebugCanRunFast()), t.canRunSelfFast = t.canRunAllConditionsFast && t.canRunAllActionsFast && t.canRunAllSubEventsFast;
        }
        _UpdateCanRunFastRecursive() {
          let t = this;
          do {
            t._UpdateCanRunFast(), t = t.GetParent();
          } while (t);
        }
        _IdentifyTopLevelGroup() {
          if (!this.IsGroup()) return;
          let t = this.GetParent();
          for (this._isTopLevelGroup = true; t; ) {
            if (!t.IsGroup()) {
              this._isTopLevelGroup = false;
              break;
            }
            t = t.GetParent();
          }
        }
        _IdentifySolModifiersIncludingParents() {
          const t = this._runtime.GetAllObjectClasses();
          if (this._solModifiers === t) this._solModifiersIncludingParents = t;
          else {
            this._solModifiersIncludingParents = C33.cloneArray(this._solModifiers);
            let t2 = this.GetParent();
            for (; t2; ) {
              for (const e2 of t2._solModifiers) this._AddParentSolModifier(e2);
              t2 = t2.GetParent();
            }
            const e = this.GetEventSheetManager();
            this._solModifiers = e._DeduplicateSolModifierList(this._solModifiers), this._solModifiersIncludingParents = e._DeduplicateSolModifierList(this._solModifiersIncludingParents);
          }
        }
        _IdentifyTriggerParents() {
          if (!this.HasAnyTriggeredCondition()) return;
          this._triggerParents = [];
          let t = this.GetParent();
          for (; t; ) this._triggerParents.push(t), t = t.GetParent();
          this._triggerParents.reverse();
        }
        SetSolWriterAfterCnds() {
          this._isSolWriterAfterCnds = true, this._parent && this._parent.SetSolWriterAfterCnds();
        }
        IsSolWriterAfterCnds() {
          return this._isSolWriterAfterCnds;
        }
        GetSolModifiers() {
          return this._solModifiers;
        }
        GetSolModifiersIncludingParents() {
          return this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = true, this._IdentifySolModifiersIncludingParents()), this._solModifiersIncludingParents;
        }
        HasSolModifier(t) {
          return this._solModifiers.includes(t);
        }
        GetTriggerParents() {
          return this._triggerParents;
        }
        GetEventSheet() {
          return this._eventSheet;
        }
        GetEventSheetManager() {
          return this._eventSheet.GetEventSheetManager();
        }
        GetRuntime() {
          return this._runtime;
        }
        GetParent() {
          return this._parent;
        }
        _SetScopeParent(t) {
          this._scopeParent = t;
        }
        GetScopeParent() {
          return this._scopeParent || this._parent;
        }
        GetDisplayNumber() {
          return this._displayNumber;
        }
        IsDebugBreakable() {
          return this._debugData && this._debugData.isBreakable;
        }
        IsDebugBreakpoint() {
          return this.IsDebugBreakable() && this._debugData.isBreakpoint;
        }
        _SetDebugBreakpoint(t) {
          this._debugData.isBreakpoint = !!t, this._UpdateCanRunFastRecursive();
        }
        IsGroup() {
          return this._isGroup;
        }
        IsTopLevelGroup() {
          return this._isTopLevelGroup;
        }
        IsElseBlock() {
          return this._isElseBlock;
        }
        HasElseBlock() {
          return this._hasElseBlock;
        }
        GetGroupName() {
          return this._groupName;
        }
        IsGroupActive() {
          return this._isGroupActive;
        }
        ResetInitialActivation() {
          this.SetGroupActive(this._isInitiallyActive);
        }
        SetGroupActive(t) {
          if (t = !!t, !this._isGroup) throw new Error("not a group");
          if (this._isGroupActive !== t) {
            this._isGroupActive = t;
            for (const t2 of this._containedIncludes) t2.UpdateActive();
            if (this._containedIncludes.length) {
              const t2 = this._runtime.GetCurrentLayout().GetEventSheet();
              t2 && t2._UpdateDeepIncludes();
            }
          }
        }
        GetSID() {
          return this._sid;
        }
        IsOrBlock() {
          return this._isOrBlock;
        }
        IsTrigger() {
          return this._conditions.length && this._conditions[0].IsTrigger();
        }
        IsForFunctionBlock() {
          return this._scopeParent && this._scopeParent instanceof C33.FunctionBlock;
        }
        HasAnyTriggeredCondition() {
          return this.IsForFunctionBlock() || this._conditions.some((t) => t.IsTrigger());
        }
        GetConditions() {
          return this._conditions;
        }
        GetConditionCount() {
          return this._conditions.length;
        }
        GetConditionAt(t) {
          if ((t = Math.floor(t)) < 0 || t >= this._conditions.length) throw new RangeError("invalid condition index");
          return this._conditions[t];
        }
        GetConditionByDebugIndex(t) {
          return this.GetConditionAt(t);
        }
        IsFirstConditionOfType(t) {
          let e = t.GetIndex();
          if (0 === e) return true;
          --e;
          const n = t.IsSystemOrSingleGlobalCondition() ? t.GetFirstObjectParameterObjectClass() : t.GetObjectClass();
          for (; e >= 0; --e) {
            const t2 = this._conditions[e];
            if (n === t2.GetObjectClass() || t2.IsSystemOrSingleGlobalCondition() && t2.GetFirstObjectParameterObjectClass() === n) return false;
          }
          return true;
        }
        GetActions() {
          return this._actions;
        }
        GetActionCount() {
          return this._actions.length;
        }
        GetActionAt(t) {
          if ((t = Math.floor(t)) < 0 || t >= this._actions.length) throw new RangeError("invalid action index");
          return this._actions[t];
        }
        GetActionByDebugIndex(t) {
          t = Math.floor(t);
          const e = this._actions.find((e2) => e2.GetDebugIndex() === t);
          if (!e) throw new RangeError("invalid action debug index");
          return e;
        }
        _HasActionIndex(t) {
          return (t = Math.floor(t)) >= 0 && t < this._actions.length;
        }
        GetSubEvents() {
          return this._subEvents;
        }
        _GetAllLocalVariablesInScope() {
          return this._subEvents.filter((t) => t instanceof C33.EventVariable);
        }
        RunPreTrigger(t) {
          t.SetCurrentEvent(this);
          const e = this._conditions;
          let n = 0 === e.length;
          for (let s2 = 0, i2 = e.length; s2 < i2; ++s2) {
            const i3 = e[s2];
            if (t.SetConditionIndex(s2), i3.IsLooping()) throw new Error("trigger cannot be used as sub-event to a loop");
            if (i3.Run()) n = true;
            else if (!this._isOrBlock) return false;
          }
          return !this._isOrBlock || n;
        }
        RunOrBlockTrigger(t, e) {
          t.SetCurrentEvent(this), t.SetConditionIndex(e), this._conditions[e].Run() && (this._RunActions(t, 0) && this._RunSubEvents(t), t.SetLastEventTrue(true));
        }
        *DebugRunPreTrigger(t) {
          t.SetCurrentEvent(this);
          const e = this._conditions;
          let n = 0 === e.length;
          for (let s2 = 0, i2 = e.length; s2 < i2; ++s2) {
            const i3 = e[s2];
            if (t.SetConditionIndex(s2), i3.IsLooping()) throw new Error("trigger cannot be used as sub-event to a loop");
            let o2;
            if (o2 = i3.DebugCanRunFast() ? i3.Run() : yield* i3.DebugRun(), o2) n = true;
            else if (!this._isOrBlock) return false;
          }
          return !this._isOrBlock || n;
        }
        *DebugRunOrBlockTrigger(t, e) {
          t.SetCurrentEvent(this), t.SetConditionIndex(e);
          const n = this._conditions[e];
          let s2;
          if (s2 = n.DebugCanRunFast() ? n.Run() : yield* n.DebugRun(), s2) {
            let e2;
            e2 = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield* this._DebugRunActions(t, 0), e2 && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), t.SetLastEventTrue(true);
          }
        }
        Run(t) {
          t.SetCurrentEvent(this), this._isElseBlock || t.SetElseBranchRan(false), this._isOrBlock ? this._RunOrBlock(t) : this._RunAndBlock(t);
        }
        *DebugRun(t) {
          (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), t.SetCurrentEvent(this), this._isElseBlock || t.SetElseBranchRan(false), this._isOrBlock ? yield* this._DebugRunOrBlock(t) : yield* this._DebugRunAndBlock(t);
        }
        _RunOrBlock(t) {
          const e = this._conditions;
          let n = 0 === e.length;
          for (let s2 = 0, i2 = e.length; s2 < i2; ++s2) {
            const i3 = e[s2];
            if (i3.IsTrigger()) continue;
            t.SetConditionIndex(s2);
            const o2 = i3.Run();
            n = n || o2;
          }
          t.SetLastEventTrue(n), n && (this._RunActions(t, 0) && this._RunSubEvents(t), this._hasElseBlock && t.SetElseBranchRan(true));
        }
        *_DebugRunOrBlock(t) {
          const e = this._conditions;
          let n = 0 === e.length;
          for (let s2 = 0, i2 = e.length; s2 < i2; ++s2) {
            const i3 = e[s2];
            if (i3.IsTrigger()) continue;
            let o2;
            t.SetConditionIndex(s2), o2 = i3.DebugCanRunFast() ? i3.Run() : yield* i3.DebugRun(), n = n || o2;
          }
          if (t.SetLastEventTrue(n), n) {
            let e2;
            e2 = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield* this._DebugRunActions(t, 0), e2 && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && t.SetElseBranchRan(true);
          }
        }
        _RunAndBlock(t) {
          const e = this._conditions;
          for (let n = 0, s2 = e.length; n < s2; ++n) {
            const s3 = e[n];
            t.SetConditionIndex(n);
            if (!s3.Run()) return void t.SetLastEventTrue(false);
          }
          t.SetLastEventTrue(true), this._RunActions(t, 0) && this._RunSubEvents(t), t.GetLastEventTrue() && this._hasElseBlock && t.SetElseBranchRan(true);
        }
        *_DebugRunAndBlock(t) {
          const e = this._conditions;
          for (let n2 = 0, s2 = e.length; n2 < s2; ++n2) {
            const s3 = e[n2];
            let i2;
            if (t.SetConditionIndex(n2), i2 = s3.DebugCanRunFast() ? s3.Run() : yield* s3.DebugRun(), !i2) return void t.SetLastEventTrue(false);
          }
          let n;
          t.SetLastEventTrue(true), n = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield* this._DebugRunActions(t, 0), n && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), t.GetLastEventTrue() && this._hasElseBlock && t.SetElseBranchRan(true);
        }
        _RunActions_Fast(t, e) {
          const n = this._actions;
          for (let s2 = e, i2 = n.length; s2 < i2; ++s2) {
            const e2 = n[s2];
            t.SetActionIndex(s2), e2.Run();
          }
          return true;
        }
        *_DebugRunActions_Fast(t, e) {
          const n = this._actions;
          for (let s2 = e, i2 = n.length; s2 < i2; ++s2) {
            const e2 = n[s2];
            t.SetActionIndex(s2), e2.DebugCanRunFast() ? e2.Run() : yield* e2.DebugRun();
          }
          return true;
        }
        _RunActions_ReturnValue(t, e) {
          const n = this.GetEventSheetManager(), s2 = this._actions;
          for (let i2 = e, o2 = s2.length; i2 < o2; ++i2) {
            const e2 = s2[i2];
            t.SetActionIndex(i2);
            const o3 = e2.Run();
            if (e2.CanBailOut() && true === o3) return false;
            e2.IsAsync() && o3 instanceof Promise && n.AddAsyncActionPromise(o3);
          }
          return true;
        }
        *_DebugRunActions_ReturnValue(t, e) {
          const n = this.GetEventSheetManager(), s2 = this._actions;
          for (let i2 = e, o2 = s2.length; i2 < o2; ++i2) {
            const e2 = s2[i2];
            let o3;
            if (t.SetActionIndex(i2), o3 = e2.DebugCanRunFast() ? e2.Run() : yield* e2.DebugRun(), e2.CanBailOut() && true === o3) return false;
            e2.IsAsync() && o3 instanceof Promise && n.AddAsyncActionPromise(o3);
          }
          return true;
        }
        _ResumeActionsAndSubEvents(t) {
          this._RunActions(t, t.GetActionIndex()) && this._RunSubEvents();
        }
        *_DebugResumeActionsAndSubEvents(t) {
          (yield* this._DebugRunActions(t, t.GetActionIndex())) && (yield* this._DebugRunSubEvents());
        }
        _RunSubEvents() {
          if (!this._subEvents.length) return;
          const t = this.IsGroup() && this._runtime.IsCPUProfiling(), e = t ? performance.now() : 0, n = this._eventStack, s2 = n.Push(this);
          this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(s2) : this._RunSubEvents_Fast(s2), n.Pop(), t && (this._perfRecord.totalTimeCounter += performance.now() - e);
        }
        _RunSubEvents_SolWriterAfterCnds(t) {
          const e = this._isGroup, n = this._isTopLevelGroup, s2 = this.GetEventSheetManager(), i2 = this._subEvents;
          for (let o2 = 0, r2 = i2.length, u = r2 - 1; o2 < r2; ++o2) {
            const r3 = i2[o2], l2 = r3.GetSolModifiers(), a2 = !n || !e && o2 < u;
            a2 && s2.PushCopySol(l2), r3.Run(t), a2 ? s2.PopSol(l2) : s2.ClearSol(l2);
          }
        }
        _RunSubEvents_Fast(t) {
          const e = this._subEvents;
          for (let n = 0, s2 = e.length; n < s2; ++n) e[n].Run(t);
        }
        *_DebugRunSubEvents() {
          if (!this._subEvents.length) return;
          const t = this._eventStack, e = t.Push(this);
          this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(e) : yield* this._DebugRunSubEvents_Fast(e), t.Pop();
        }
        *_DebugRunSubEvents_SolWriterAfterCnds(t) {
          const e = this._isGroup, n = this._isTopLevelGroup, s2 = this.GetEventSheetManager(), i2 = this._subEvents;
          for (let o2 = 0, r2 = i2.length, u = r2 - 1; o2 < r2; ++o2) {
            const r3 = i2[o2], l2 = r3.GetSolModifiers(), a2 = !n || !e && o2 < u;
            a2 && s2.PushCopySol(l2), yield* r3.DebugRun(t), a2 ? s2.PopSol(l2) : s2.ClearSol(l2);
          }
        }
        *_DebugRunSubEvents_Fast(t) {
          const e = this._subEvents;
          for (let n = 0, s2 = e.length; n < s2; ++n) yield* e[n].DebugRun(t);
        }
        Retrigger(t, e) {
          e.ResetQuick();
          const n = this._conditions;
          if (!this.IsOrBlock()) for (let s2 = t.GetConditionIndex() + 1, i2 = n.length; s2 < i2; ++s2) {
            const t2 = n[s2];
            e.SetConditionIndex(s2);
            if (!t2.Run()) return false;
          }
          return this._RunActions(e, 0) && this._RunSubEvents(e), true;
        }
        *DebugRetrigger(t, e) {
          e.ResetQuick();
          const n = this._conditions;
          if (!this.IsOrBlock()) for (let s3 = t.GetConditionIndex() + 1, i2 = n.length; s3 < i2; ++s3) {
            const t2 = n[s3];
            let i3;
            if (e.SetConditionIndex(s3), i3 = t2.DebugCanRunFast() ? t2.Run() : yield* t2.DebugRun(), !i3) return false;
          }
          let s2;
          return s2 = this.DebugCanRunActionsFast() ? this._RunActions(e, 0) : yield* this._DebugRunActions(e, 0), s2 && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), true;
        }
        DebugCanRunFast() {
          return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast;
        }
        DebugCanRunActionsFast() {
          return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast;
        }
        DebugCanRunSubEventsFast() {
          return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast;
        }
        _CheckParentsOKToRun(t) {
          if (this.GetParent()) {
            const e = this.GetTriggerParents();
            for (let n = 0, s2 = e.length; n < s2; ++n) if (!e[n].RunPreTrigger(t)) return false;
          }
          return true;
        }
        *_DebugCheckParentsOKToRun(t) {
          if (this.GetParent()) {
            const e = this.GetTriggerParents();
            for (let n = 0, s2 = e.length; n < s2; ++n) if (!(yield* e[n].DebugRunPreTrigger(t))) return false;
          }
          return true;
        }
        _EvaluateFunctionCallParameters(t, e, n) {
          if (e.length > 0) if (n) {
            const n2 = e.map((t2) => t2.Get(0));
            t.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(n2);
          } else this._scopeParent.EvaluateFunctionParameters(e);
          else n && t.GetLocalVarStack().Push();
        }
        RunAsFunctionCall(t, e, n, s2) {
          let i2, o2;
          const r2 = t.length > 0;
          let u = null;
          const l2 = this._runtime, a2 = this._eventStack, h = l2.GetEventSheetManager(), c2 = this._scopeParent, _ = c2.IsAsync(), d2 = h._IncTriggerDepth() > 1;
          if (this._EvaluateFunctionCallParameters(h, e, d2), r2 && (n ? h.PushCopySol(t) : h.PushCleanSol(t)), null !== s2) {
            if (s2.copyFromObjectClass) {
              const t2 = n ? s2.copyFromObjectClass.GetCurrentSol() : s2.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), e2 = s2.copyToObjectClass.GetCurrentSol();
              e2.SetArrayPicked(t2.GetInstances()), e2.ClearElseInstances(), n || s2.copyToObjectClass.ApplySolToContainer();
            } else if (s2.pickObjectClass) {
              const t2 = s2.pickObjectClass.GetCurrentSol();
              t2.SetArrayPicked(s2.pickInstances), t2.ClearElseInstances();
            }
            s2.pushCleanSolDynamic && (u = h.PushCleanSolDynamic(t));
          }
          const g = a2.Push(this);
          return n && g.SetDynamicSolModifiers(t), this._CheckParentsOKToRun(g) && (g.SetCurrentEvent(this), _ && ([o2, i2] = c2.StartAsyncFunctionCall()), this._RunAndBlock(g), _ && c2.MaybeFinishAsyncFunctionCall(o2)), a2.Pop(), d2 && h.GetLocalVarStack().Pop(), null !== u && h.PopSol(u), r2 && h.PopSol(t), h._DecTriggerDepth(), i2;
        }
        *DebugRunAsFunctionCall(t, e, n, s2) {
          let i2, o2;
          (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
          const r2 = t.length > 0;
          let u = null;
          const l2 = this._runtime, a2 = this._eventStack, h = l2.GetEventSheetManager(), c2 = this._scopeParent, _ = c2.IsAsync(), d2 = h._IncTriggerDepth() > 1;
          if (this._EvaluateFunctionCallParameters(h, e, d2), r2 && (n ? h.PushCopySol(t) : h.PushCleanSol(t)), null !== s2) {
            if (s2.copyFromObjectClass) {
              const t2 = n ? s2.copyFromObjectClass.GetCurrentSol() : s2.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), e2 = s2.copyToObjectClass.GetCurrentSol();
              e2.SetArrayPicked(t2.GetInstances()), e2.ClearElseInstances(), n || s2.copyToObjectClass.ApplySolToContainer();
            } else if (s2.pickObjectClass) {
              const t2 = s2.pickObjectClass.GetCurrentSol();
              t2.SetArrayPicked(s2.pickInstances), t2.ClearElseInstances();
            }
            s2.pushCleanSolDynamic && (u = h.PushCleanSolDynamic(t));
          }
          const g = a2.Push(this);
          return n && g.SetDynamicSolModifiers(t), (yield* this._DebugCheckParentsOKToRun(g)) && (g.SetCurrentEvent(this), _ && ([o2, i2] = c2.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(g), _ && c2.MaybeFinishAsyncFunctionCall(o2)), a2.Pop(), d2 && h.GetLocalVarStack().Pop(), null !== u && h.PopSol(u), r2 && h.PopSol(t), h._DecTriggerDepth(), i2;
        }
        RunAsMappedFunctionCall(t, e) {
          const n = this.GetSolModifiersIncludingParents(), s2 = n.length > 0, i2 = this._runtime, o2 = this._eventStack, r2 = i2.GetEventSheetManager(), u = r2._IncTriggerDepth() > 1;
          u && r2.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t), s2 && (e ? r2.PushCopySol(n) : r2.PushCleanSol(n));
          const l2 = o2.Push(this);
          this._CheckParentsOKToRun(l2) && (l2.SetCurrentEvent(this), this._RunAndBlock(l2)), o2.Pop(), u && r2.GetLocalVarStack().Pop(), s2 && r2.PopSol(n), r2._DecTriggerDepth();
        }
        *DebugRunAsMappedFunctionCall(t, e) {
          (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
          const n = this.GetSolModifiersIncludingParents(), s2 = n.length > 0, i2 = this._runtime, o2 = this._eventStack, r2 = i2.GetEventSheetManager(), u = r2._IncTriggerDepth() > 1;
          u && r2.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t), s2 && (e ? r2.PushCopySol(n) : r2.PushCleanSol(n));
          const l2 = o2.Push(this);
          (yield* this._DebugCheckParentsOKToRun(l2)) && (l2.SetCurrentEvent(this), yield* this._DebugRunAndBlock(l2)), o2.Pop(), u && r2.GetLocalVarStack().Pop(), s2 && r2.PopSol(n), r2._DecTriggerDepth();
        }
        RunAsExpressionFunctionCall(t, e, n, s2, ...i2) {
          let o2, r2;
          const u = t.length > 0, l2 = this._runtime, a2 = this._eventStack, h = l2.GetEventSheetManager(), c2 = this._scopeParent, _ = c2.IsAsync(), d2 = h._IncTriggerDepth() > 1;
          d2 && h.GetLocalVarStack().Push(), i2.length > 0 && this._scopeParent.SetFunctionParameters(i2), u && (e ? h.PushCopySol(t) : h.PushCleanSol(t));
          const g = a2.Push(this);
          return g.InitCallFunctionExpression(n, s2), a2.PushExpFunc(g), l2.SetDebuggingEnabled(false), this._CheckParentsOKToRun(g) && (g.SetCurrentEvent(this), _ && ([r2, o2] = c2.StartAsyncFunctionCall()), this._RunAndBlock(g), _ && c2.MaybeFinishAsyncFunctionCall(r2)), l2.SetDebuggingEnabled(true), a2.Pop(), a2.PopExpFunc(), d2 && h.GetLocalVarStack().Pop(), u && h.PopSol(t), h._DecTriggerDepth(), o2 || g.GetFunctionReturnValue();
        }
      };
    }
    var NoActions;
    {
      const C33 = self.C3, EMPTY_SOL_MODIFIERS = [];
      let hadUserScriptException = false;
      C33.EventScript = class extends C33.DefendedBase {
        constructor(e, t, i2) {
          super();
          const r2 = e.GetRuntime(), n = e.GetEventSheetManager();
          this._eventSheet = e, this._eventSheetManager = n, this._runtime = e.GetRuntime(), this._parent = t;
          const s2 = r2.GetObjectReference(i2[1]);
          this._func = s2, this._displayNumber = i2[2], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = r2.IsDebug() ? { isBreakpoint: i2[3][0], isBreakable: i2[3][1] } : null;
        }
        static Create(e, t, i2) {
          return C33.New(C33.EventScript, e, t, i2);
        }
        _PostInit() {
          const e = this._func, t = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
          this._func = e.bind(null, this._runtime.GetIRuntime(), t);
        }
        GetParent() {
          return this._parent;
        }
        GetScopeParent() {
          return this._parent;
        }
        GetEventSheet() {
          return this._eventSheet;
        }
        GetDisplayNumber() {
          return this._displayNumber;
        }
        IsDebugBreakable() {
          return this._debugData && this._debugData.isBreakable;
        }
        IsDebugBreakpoint() {
          return this.IsDebugBreakable() && this._debugData.isBreakpoint;
        }
        _SetDebugBreakpoint(e) {
          this._debugData.isBreakpoint = !!e;
        }
        IsElseBlock() {
          return false;
        }
        GetSolModifiers() {
          return EMPTY_SOL_MODIFIERS;
        }
        GetSolModifiersIncludingParents() {
          return this._parent ? this._parent.GetSolModifiersIncludingParents() : EMPTY_SOL_MODIFIERS;
        }
        Run(e) {
          e.SetCurrentEvent(this), this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript());
        }
        async _RunUserScript() {
          try {
            await this._func();
          } catch (e) {
            console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", e), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), hadUserScriptException || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), hadUserScriptException = true);
          }
        }
        *DebugRun(e) {
          e.SetCurrentEvent(this), (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.Run(e);
        }
        DebugCanRunFast() {
          return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext();
        }
        static HadUserScriptException() {
          return hadUserScriptException;
        }
        static SetHadUserScriptException() {
          hadUserScriptException = true;
        }
      };
    }
    {
      const C33 = self.C3, assert = self.assert;
      C33.FunctionBlock = class extends C33.DefendedBase {
        constructor(t, e, s2) {
          super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = e, this._functionType = 0, this._functionName = "", this._returnType = 0, this._functionParameters = [], this._isEnabled = true, this._aceName = "", this._objectClass = null, this._hasOverrides = false, this._innerLocalVariables = [], this._isCopyPicked = false, this._isAsync = false, this._nextAsyncId = 0, this._currentAsyncId = -1, this._asyncMap = /* @__PURE__ */ new Map(), this._eventBlock = C33.EventBlock.Create(t, e, s2), this._eventBlock._SetScopeParent(this);
        }
        InitFunctionBlock(t) {
          this._functionType = 0, this._functionName = t[0], this._returnType = t[1], this._functionParameters = t[2].map((t2) => C33.EventVariable.Create(this._eventSheet, this, t2)), this._isEnabled = t[3], this._isAsync = t[4], this._isCopyPicked = t[5];
        }
        InitCustomACEBlock(t) {
          this._functionType = 1, this._aceName = t[1], this._objectClass = this._runtime.GetObjectClassByIndex(t[2]), this._eventBlock._AddSolModifier(this._objectClass), this._functionName = this._objectClass.GetName() + "." + this._aceName, this._returnType = t[3], this._functionParameters = t[4].map((t2) => C33.EventVariable.Create(this._eventSheet, this, t2)), this._isEnabled = t[5], this._isAsync = t[6], this._isCopyPicked = t[7], this._objectClass.AddCustomAction(this);
        }
        static CreateFunctionBlock(t, e, s2) {
          const n = C33.New(C33.FunctionBlock, t, e, s2), i2 = s2[1];
          return n.InitFunctionBlock(i2), n;
        }
        static CreateCustomACEBlock(t, e, s2) {
          const n = C33.New(C33.FunctionBlock, t, e, s2), i2 = s2[1];
          return n.InitCustomACEBlock(i2), n;
        }
        _CheckOverrideState() {
          if (this._objectClass && this._objectClass.IsFamily()) {
            for (const t of this._objectClass.GetFamilyMembers()) if (t.HasOwnCustomActionByName(this._aceName)) {
              this._hasOverrides = true;
              break;
            }
          }
        }
        _PostInit() {
          for (const t of this._functionParameters) t._PostInit();
          this._eventBlock._PostInit(false);
        }
        GetFunctionType() {
          return this._functionType;
        }
        _GetAllLocalVariablesInScope() {
          return this._functionParameters;
        }
        GetFunctionParameters() {
          return this._functionParameters;
        }
        GetFunctionParameterCount() {
          return this._functionParameters.length;
        }
        _RegisterLocalVariable(t) {
          this._innerLocalVariables.push(t);
        }
        _GetAllInnerLocalVariables() {
          return this._innerLocalVariables;
        }
        EvaluateFunctionParameters(t) {
          const e = this._functionParameters;
          for (let s2 = 0, n = e.length; s2 < n; ++s2) e[s2].SetValue(t[s2].Get(0));
        }
        SetFunctionParameters(t) {
          const e = this._functionParameters;
          for (let s2 = 0, n = e.length; s2 < n; ++s2) e[s2].SetValue(t[s2]);
        }
        CaptureFunctionParameters() {
          return this._functionParameters.map((t) => t.GetValue());
        }
        GetParent() {
          return this._parent;
        }
        GetScopeParent() {
          return this._parent;
        }
        GetFunctionName() {
          return this._functionName;
        }
        GetACEName() {
          return this._aceName;
        }
        HasCustomACEOverrides() {
          return this._hasOverrides;
        }
        GetReturnType() {
          return this._returnType;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        IsEnabled() {
          return this._isEnabled;
        }
        GetDefaultReturnValue() {
          switch (this._returnType) {
            case 0:
              return null;
            case 2:
              return "";
            default:
              return 0;
          }
        }
        GetEventBlock() {
          return this._eventBlock;
        }
        IsCopyPicked() {
          return this._isCopyPicked;
        }
        IsAsync() {
          return this._isAsync;
        }
        StartAsyncFunctionCall() {
          const t = this._nextAsyncId++;
          let e;
          this._currentAsyncId = t;
          const s2 = new Promise((t2) => e = t2);
          return this._asyncMap.set(t, { resolve: e, pauseCount: 0 }), [t, s2];
        }
        MaybeFinishAsyncFunctionCall(t) {
          const e = this._asyncMap.get(t);
          0 === e.pauseCount && (e.resolve(), this._asyncMap.delete(t)), this._currentAsyncId = -1;
        }
        PauseCurrentAsyncFunction() {
          return this._asyncMap.get(this._currentAsyncId).pauseCount++, this._currentAsyncId;
        }
        ResumeAsyncFunction(t) {
          this._currentAsyncId = t;
          this._asyncMap.get(t).pauseCount--;
        }
        RunAsFamilyCustomActionWithOverrides(t, e) {
          const s2 = /* @__PURE__ */ new Map(), n = [];
          for (const t2 of this._objectClass.GetCurrentSol().GetInstances()) {
            const e2 = t2.GetObjectClass();
            if (e2.HasOwnCustomActionByName(this._aceName)) {
              const n2 = s2.get(e2);
              Array.isArray(n2) ? n2.push(t2) : s2.set(e2, [t2]);
            } else n.push(t2);
          }
          if (n.length > 0 && this._eventBlock.RunAsFunctionCall(t, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n }), s2.size > 0) for (const [n2, i2] of s2) {
            const s3 = n2.GetOwnCustomActionByName(this._aceName).GetEventBlock(), a2 = [.../* @__PURE__ */ new Set([...t, ...s3.GetSolModifiers()])];
            s3.RunAsFunctionCall(a2, e, this._isCopyPicked, { pickObjectClass: n2, pickInstances: i2 });
          }
        }
        *DebugRunAsFamilyCustomActionWithOverrides(t, e) {
          const s2 = /* @__PURE__ */ new Map(), n = [];
          for (const t2 of this._objectClass.GetCurrentSol().GetInstances()) {
            const e2 = t2.GetObjectClass();
            if (e2.HasOwnCustomActionByName(this._aceName)) {
              const n2 = s2.get(e2);
              Array.isArray(n2) ? n2.push(t2) : s2.set(e2, [t2]);
            } else n.push(t2);
          }
          if (n.length > 0 && (yield* this._eventBlock.DebugRunAsFunctionCall(t, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n })), s2.size > 0) for (const [n2, i2] of s2) {
            const s3 = n2.GetOwnCustomActionByName(this._aceName).GetEventBlock(), a2 = [.../* @__PURE__ */ new Set([...t, ...s3.GetSolModifiers()])];
            yield* s3.DebugRunAsFunctionCall(a2, e, this._isCopyPicked, { pickObjectClass: n2, pickInstances: i2 });
          }
        }
      };
    }
    {
      const C33 = self.C3, EMPTY_SOL_MODIFIERS = [];
      C33.EventVariable = class extends C33.DefendedBase {
        constructor(t, e, s2) {
          super();
          const i2 = t.GetEventSheetManager();
          this._eventSheet = t, this._eventSheetManager = i2, this._runtime = t.GetRuntime(), this._parent = e, this._localVarStack = i2.GetLocalVarStack(), this._name = s2[1], this._type = s2[2], this._initialValue = s2[3], this._isStatic = !!s2[4], this._isConstant = !!s2[5], this._isFunctionParameter = e instanceof C33.FunctionBlock, this._sid = s2[6], this._jsPropName = this._runtime.GetJsPropName(s2[8]), this._scriptSetter = (t2) => this.SetValue(t2), this._scriptGetter = () => this.GetValue(), this._hasSingleValue = !this._parent || this._isStatic || this._isConstant, this._value = this._initialValue, this._localIndex = -1, this.IsBoolean() && (this._value = this._value ? 1 : 0), !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = i2._GetNextLocalVarIndex(this)), i2._RegisterEventVariable(this);
        }
        static Create(t, e, s2) {
          return C33.New(C33.EventVariable, t, e, s2);
        }
        _PostInit() {
          if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {
            const t = this._eventSheetManager.FindFirstFunctionBlockParent(this);
            t && t._RegisterLocalVariable(this);
          }
        }
        GetName() {
          return this._name;
        }
        GetJsPropName() {
          return this._jsPropName;
        }
        GetParent() {
          return this._parent;
        }
        GetScopeParent() {
          return this.GetParent();
        }
        IsGlobal() {
          return !this.GetParent();
        }
        IsLocal() {
          return !this.IsGlobal();
        }
        IsFunctionParameter() {
          return this._isFunctionParameter;
        }
        IsStatic() {
          return this._isStatic;
        }
        IsConstant() {
          return this._isConstant;
        }
        IsNumber() {
          return 0 === this._type;
        }
        IsString() {
          return 1 === this._type;
        }
        IsBoolean() {
          return 2 === this._type;
        }
        IsElseBlock() {
          return false;
        }
        GetSID() {
          return this._sid;
        }
        GetInitialValue() {
          return this._initialValue;
        }
        GetSolModifiers() {
          return EMPTY_SOL_MODIFIERS;
        }
        Run(t) {
          !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue());
        }
        DebugCanRunFast() {
          return true;
        }
        *DebugRun(t) {
          this.Run(t);
        }
        SetValue(t) {
          this.IsNumber() ? "number" != typeof t && (t = parseFloat(t)) : this.IsString() ? "string" != typeof t && (t = t.toString()) : this.IsBoolean() && (t = t ? 1 : 0), this._hasSingleValue ? this._value = t : this._localVarStack.GetCurrent()[this._localIndex] = t;
        }
        GetValue() {
          return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex];
        }
        GetTypedValue() {
          let t = this.GetValue();
          return this.IsBoolean() && (t = !!t), t;
        }
        ResetToInitialValue() {
          this._value = this._initialValue;
        }
        _GetScriptInterfaceDescriptor() {
          return { configurable: false, enumerable: true, get: this._scriptGetter, set: this._scriptSetter };
        }
      };
    }
    {
      const C33 = self.C3, assert = self.assert, EMPTY_SOL_MODIFIERS = [];
      C33.EventInclude = class extends C33.DefendedBase {
        constructor(e, t, n) {
          super();
          const s2 = e.GetEventSheetManager();
          this._eventSheet = e, this._eventSheetManager = s2, this._runtime = e.GetRuntime(), this._parent = t, this._includeSheet = null, this._includeSheetName = n[1], this._isActive = true;
        }
        static Create(e, t, n) {
          return C33.New(C33.EventInclude, e, t, n);
        }
        _PostInit() {
          this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName), this._eventSheet._AddShallowInclude(this);
          let e = this.GetParent();
          for (; e; ) e instanceof C33.EventBlock && e.IsGroup() && e._AddContainedInclude(this), e = e.GetParent();
          this.UpdateActive(), this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord());
        }
        GetParent() {
          return this._parent;
        }
        GetSolModifiers() {
          return EMPTY_SOL_MODIFIERS;
        }
        GetIncludeSheet() {
          return this._includeSheet;
        }
        Run(e) {
          const t = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();
          t && this._eventSheetManager.PushCleanSol(n), this._includeSheet.Run(), t && this._eventSheetManager.PopSol(n);
        }
        *DebugRun(e) {
          const t = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();
          t && this._eventSheetManager.PushCleanSol(n), yield* this._includeSheet.DebugRun(), t && this._eventSheetManager.PopSol(n);
        }
        DebugCanRunFast() {
          return false;
        }
        IsActive() {
          return this._isActive;
        }
        UpdateActive() {
          let e = this.GetParent();
          for (; e; ) {
            if (e instanceof C33.EventBlock && e.IsGroup() && !e.IsGroupActive()) return void (this._isActive = false);
            e = e.GetParent();
          }
          this._isActive = true;
        }
      };
    }
    {
      let WrapIndex2 = function(e, t) {
        return e >= t ? e % t : e < 0 ? (e <= -t && (e %= t), e < 0 && (e += t), e) : e;
      };
      WrapIndex = WrapIndex2;
      const C33 = self.C3, assert = self.assert;
      C33.ExpNode = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._owner = e, this._runtime = e.GetRuntime();
        }
        _PostInit() {
        }
        static CreateNode(e, t) {
          const s2 = t[0], n = [BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode];
          return C33.New(n[s2], e, t);
        }
      };
      class SystemExpressionExpNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._systemPlugin = this._runtime.GetSystemPlugin(), this._func = this._runtime.GetObjectReference(t[1]), this._func !== C33.Plugins.System.Exps.random && this._func !== C33.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance();
        }
        GetBoundMethod() {
          return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin);
        }
      }
      class CallFunctionExpressionExpNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._functionBlock = null, this._functionName = t[1], this._owner.SetVariesPerInstance();
        }
        _PostInit() {
          const e = this._runtime.GetEventSheetManager();
          this._functionBlock = e.GetFunctionBlockByName(this._functionName), this._functionName = null;
          const t = this._owner.GetEventBlock(), s2 = this._functionBlock.GetEventBlock();
          this._combinedSolModifiers = [.../* @__PURE__ */ new Set([...t.GetSolModifiersIncludingParents(), ...s2.GetSolModifiersIncludingParents()])], this._combinedSolModifiers = e._DeduplicateSolModifierList(this._combinedSolModifiers);
        }
        GetBoundMethod() {
          const e = this._functionBlock;
          if (e.IsEnabled()) {
            const t = e.GetEventBlock();
            return C33.EventBlock.prototype.RunAsExpressionFunctionCall.bind(t, this._combinedSolModifiers, e.IsCopyPicked(), e.GetReturnType(), e.GetDefaultReturnValue());
          }
          {
            const t = e.GetDefaultReturnValue();
            return () => t;
          }
        }
      }
      class ObjectExpressionNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._func = this._runtime.GetObjectReference(t[2]), this._returnsString = !!t[3], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);
        }
        GetBoundMethod() {
          return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance());
        }
        ExpObject(...e) {
          const t = this._objectClass, s2 = t.GetCurrentSol().GetExpressionInstances(), n = s2.length;
          if (0 === n) return this._returnsString ? "" : 0;
          const r2 = WrapIndex2(this._owner.GetSolIndex(), n);
          return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t), this._func.apply(s2[r2].GetSdkInstance(), e);
        }
        ExpObject_InstExpr(e, ...t) {
          const s2 = this._objectClass, n = s2.GetInstances(), r2 = n.length;
          if (0 === r2 || "number" != typeof e) return this._returnsString ? "" : 0;
          const i2 = WrapIndex2(e, r2);
          return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s2), this._func.apply(n[i2].GetSdkInstance(), t);
        }
      }
      class InstVarExpressionNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._varIndex = t[3], this._returnsString = !!t[2], this._owner._MaybeVaryFor(this._objectClass);
        }
        ExpInstVar() {
          const e = this._objectClass.GetCurrentSol().GetExpressionInstances(), t = e.length;
          if (0 === t) return this._returnsString ? "" : 0;
          return e[WrapIndex2(this._owner.GetSolIndex(), t)]._GetInstanceVariableValueUnchecked(this._varIndex);
        }
        ExpInstVar_Family() {
          const e = this._objectClass, t = e.GetCurrentSol().GetExpressionInstances(), s2 = t.length;
          if (0 === s2) return this._returnsString ? "" : 0;
          const n = t[WrapIndex2(this._owner.GetSolIndex(), s2)], r2 = n.GetObjectClass().GetFamilyInstanceVariableOffset(e.GetFamilyIndex());
          return n._GetInstanceVariableValueUnchecked(this._varIndex + r2);
        }
        ExpInstVar_InstExpr(e) {
          const t = this._objectClass, s2 = t.GetInstances(), n = s2.length;
          if (0 === n || "number" != typeof e) return this._returnsString ? "" : 0;
          const r2 = s2[WrapIndex2(e, n)];
          let i2 = 0;
          return t.IsFamily() && (i2 = r2.GetObjectClass().GetFamilyInstanceVariableOffset(t.GetFamilyIndex())), r2._GetInstanceVariableValueUnchecked(this._varIndex + i2);
        }
      }
      class BehaviorExpressionNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._behaviorType = this._objectClass.GetBehaviorTypeByName(t[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(t[2]), this._func = this._runtime.GetObjectReference(t[3]), this._returnsString = !!t[4], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);
        }
        ExpBehavior(...e) {
          const t = this._objectClass, s2 = t.GetCurrentSol().GetExpressionInstances(), n = s2.length;
          if (0 === n) return this._returnsString ? "" : 0;
          const r2 = WrapIndex2(this._owner.GetSolIndex(), n);
          this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t);
          const i2 = s2[r2];
          let o2 = 0;
          return t.IsFamily() && (o2 = i2.GetObjectClass().GetFamilyBehaviorOffset(t.GetFamilyIndex())), this._func.apply(i2.GetBehaviorInstances()[this._behaviorIndex + o2].GetSdkInstance(), e);
        }
        ExpBehavior_InstExpr(e, ...t) {
          const s2 = this._objectClass, n = s2.GetInstances(), r2 = n.length;
          if (0 === r2 || "number" != typeof e) return this._returnsString ? "" : 0;
          const i2 = WrapIndex2(e, r2);
          this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s2);
          const o2 = n[i2];
          let a2 = 0;
          return s2.IsFamily() && (a2 = o2.GetObjectClass().GetFamilyBehaviorOffset(s2.GetFamilyIndex())), this._func.apply(o2.GetBehaviorInstances()[this._behaviorIndex + a2].GetSdkInstance(), t);
        }
      }
      class EventVarExpNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._eventVar = null, this._eventVarSid = t[1];
        }
        _PostInit() {
          this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);
        }
        GetVar() {
          return this._eventVar;
        }
      }
    }
    var WrapIndex;
    {
      let GetExpressionFunc2 = function(t) {
        const e = self.C3_ExpressionFuncs[t];
        if (!e) throw new Error("invalid expression number");
        return e;
      };
      GetExpressionFunc = GetExpressionFunc2;
      const C33 = self.C3, assert = self.assert;
      C33.Parameter = class extends C33.DefendedBase {
        constructor(t, e, s2) {
          super(), this._owner = t, this._index = s2, this._type = e, this.Get = null, this._variesPerInstance = false, this._isConstant = false;
        }
        static Create(t, e, s2) {
          const r2 = e[0], n = [ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter, TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter, FlowchartParameter];
          return C33.New(n[r2], t, r2, s2, e);
        }
        _PostInit() {
        }
        SetVariesPerInstance() {
          this._variesPerInstance = true;
        }
        _MaybeVaryFor(t) {
          this._variesPerInstance || t && (t.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = true));
        }
        VariesPerInstance() {
          return this._variesPerInstance;
        }
        GetIndex() {
          return this._index;
        }
        GetRuntime() {
          return this._owner.GetRuntime();
        }
        GetEventBlock() {
          return this._owner.GetEventBlock();
        }
        IsConstant() {
          return this._isConstant;
        }
        IsObjectParameter() {
          return 4 === this._type;
        }
      };
      class ExpressionParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._solIndex = 0;
          const n = r2[1];
          this._expressionNumber = n[0], this._numberedNodes = [], this._expressionFunc = null;
          for (let t2 = 1, e2 = n.length; t2 < e2; ++t2) this._numberedNodes.push(C33.ExpNode.CreateNode(this, n[t2]));
          this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = GetExpressionFunc2(this._expressionNumber), this._isConstant = true);
        }
        _GetNode(t) {
          if (t < 0 || t >= this._numberedNodes.length) throw new RangeError("invalid numbered node");
          return this._numberedNodes[t];
        }
        _PostInit() {
          for (const t2 of this._numberedNodes) t2._PostInit();
          const t = GetExpressionFunc2(this._expressionNumber);
          this._numberedNodes.length ? this._expressionFunc = t(this) : this._expressionFunc = t;
        }
        GetSolIndex() {
          return this._solIndex;
        }
        GetExpression(t) {
          return this._solIndex = t, this._expressionFunc();
        }
      }
      class StringExpressionParameter extends ExpressionParameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2, r2), this.Get = this.GetStringExpression, 14 === e && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof C33.Action && this.GetEventBlock().SetSolWriterAfterCnds());
        }
        GetStringExpression(t) {
          this._solIndex = t;
          const e = this._expressionFunc();
          return "string" == typeof e ? e : "";
        }
        _GetFastTriggerValue() {
          return GetExpressionFunc2(this._expressionNumber)();
        }
      }
      class LayerExpressionParameter extends ExpressionParameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2, r2), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetILayer : this.Get = this.GetLayer, this._isConstant = false;
        }
        GetLayer(t) {
          this._solIndex = t;
          const e = this._expressionFunc();
          return this.GetRuntime().GetCurrentLayout().GetLayer(e);
        }
        GetILayer(t) {
          const e = this.GetLayer(t);
          return e ? e.GetILayer() : null;
        }
      }
      class ComboParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._combo = r2[1], this.Get = this.GetCombo, this._isConstant = true;
        }
        GetCombo() {
          return this._combo;
        }
      }
      class BooleanParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._bool = r2[1], this.Get = this.GetBoolean, this._isConstant = true;
        }
        GetBoolean() {
          return this._bool;
        }
      }
      class ObjectParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._objectClass = this.GetRuntime().GetObjectClassByIndex(r2[1]), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIObjectClass : this.Get = this.GetObjectClass;
          const n = this.GetEventBlock();
          n._AddSolModifier(this._objectClass), this._owner instanceof C33.Action ? n.SetSolWriterAfterCnds() : n.GetParent() && n.GetParent().SetSolWriterAfterCnds(), this._isConstant = true;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetIObjectClass() {
          return this._objectClass ? this._objectClass.GetIObjectClass() : null;
        }
      }
      class LayoutParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(r2[1]), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetILayout : this.Get = this.GetLayout, this._isConstant = true;
        }
        GetLayout() {
          return this._layout;
        }
        GetILayout() {
          return this._layout ? this._layout.GetILayout() : null;
        }
      }
      class TimelineParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(r2[1]), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetITimelineState : this.Get = this.GetTimeline, this._isConstant = true;
        }
        GetTimeline() {
          return this._timeline;
        }
        GetITimelineState() {
          return this._timeline ? this._timeline.GetITimelineState() : null;
        }
      }
      class FileParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._fileInfo = r2[1], this.Get = this.GetFile, this._isConstant = true;
        }
        GetFile() {
          return this._fileInfo;
        }
      }
      class InstVarParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._instVarIndex = r2[1];
          const n = this._owner.GetObjectClass();
          this._owner instanceof C33.Condition && this._owner.IsStatic() ? (this.Get = this.GetInstanceVariable, this._isConstant = true) : n && n.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = true);
        }
        GetInstanceVariable() {
          return this._instVarIndex;
        }
        GetFamilyInstanceVariable(t) {
          t = t || 0;
          const e = this._owner.GetObjectClass(), s2 = e.GetCurrentSol(), r2 = s2.GetInstances();
          let n = null;
          if (r2.length) n = r2[t % r2.length].GetObjectClass();
          else if (s2.HasAnyElseInstances()) {
            const e2 = s2.GetElseInstances();
            n = e2[t % e2.length].GetObjectClass();
          } else {
            if (!(e.GetInstanceCount() > 0)) return 0;
            {
              const s3 = e.GetInstances();
              n = s3[t % s3.length].GetObjectClass();
            }
          }
          return this._instVarIndex + n.GetFamilyInstanceVariableOffset(e.GetFamilyIndex());
        }
      }
      class EventVarParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._eventVarSid = r2[1], this._eventVar = null, t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIEventVariable : this.Get = this.GetEventVariable, this._isConstant = true;
        }
        _PostInit() {
          this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);
        }
        GetEventVariable() {
          return this._eventVar;
        }
        GetIEventVariable() {
          return null;
        }
      }
      class FunctionParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._functionBlockName = r2[1], this._functionBlock = null, t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIFunction : this.Get = this.GetFunction, this._isConstant = true;
        }
        _PostInit() {
          this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName), this._functionBlockName = null;
        }
        GetFunction() {
          return this._functionBlock;
        }
        GetIFunction() {
          return null;
        }
      }
      class VariadicParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._subParams = [], this._variadicRet = [], this._isConstant = true;
          for (let t2 = 1, e2 = r2.length; t2 < e2; ++t2) {
            const e3 = C33.Parameter.Create(this._owner, r2[t2], 0);
            this._subParams.push(e3), this._variadicRet.push(0), e3.IsConstant() || (this._isConstant = false);
          }
          this.Get = this.GetVariadic;
        }
        _PostInit() {
          for (const t of this._subParams) t._PostInit();
        }
        GetVariadic() {
          const t = this._subParams, e = this._variadicRet;
          for (let s2 = 0, r2 = t.length; s2 < r2; ++s2) e[s2] = t[s2].Get(0);
          return e;
        }
      }
      class EaseParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._easeIndex = r2[1], this.Get = this.GetEase, this._isConstant = true;
        }
        GetEase() {
          return this._easeIndex;
        }
      }
      class TilemapBrushParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._brushIndex = r2[1], this.Get = this.GetTilemapBrush, this._isConstant = true;
        }
        GetTilemapBrush() {
          return this._brushIndex;
        }
      }
      class TemplateExpressionParameter extends ExpressionParameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2, r2), this.Get = this.GetTemplateName, this._isConstant = false;
        }
        GetTemplateName() {
          return this._expressionFunc();
        }
      }
      class FlowchartParameter extends C33.Parameter {
        constructor(t, e, s2, r2) {
          super(t, e, s2), this._flowchartDataItem = this.GetRuntime().GetFlowchartManager().GetFlowchartDataItemByName(r2[1]), this.Get = this.GetFlowchartName, this._isConstant = true;
        }
        GetFlowchartName() {
          return this._flowchartDataItem.GetName();
        }
      }
    }
    var GetExpressionFunc;
    {
      let EvalParams2 = function(t, e) {
        for (let s2 = 0, n = t.length; s2 < n; ++s2) e[s2] = t[s2].Get(0);
      };
      EvalParams = EvalParams2;
      const C33 = self.C3, assert = self.assert;
      const EMPTY_PARAMS_ARRAY = [], noop = function() {
      };
      C33.Condition = class extends C33.DefendedBase {
        constructor(t, e, s2) {
          if (super(), this._eventBlock = t, this._runtime = t.GetRuntime(), this._index = s2, this._func = this._runtime.GetObjectReference(e[1]), this._isTrigger = e[3] > 0, this._isFastTrigger = 2 === e[3], this._isLooping = !!e[4], this._isInverted = !!e[5], this._isStatic = !!e[6], this._sid = e[7], this._isInOrBlock = this._eventBlock.IsOrBlock(), this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null, this._debugData = this._runtime.IsDebug() ? { isBreakpoint: e[8][0], canDebug: e[8][1] } : null, -1 === e[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(e[0]), e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])), this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds()), 10 === e.length) {
            let t2 = e[9];
            for (let e2 of t2) this._parameters.push(C33.Parameter.Create(this, e2, this._parameters.length)), this._results.push(0);
          }
          0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this._eventBlock.GetEventSheetManager()._RegisterCondition(this);
        }
        static Create(t, e, s2) {
          return C33.New(C33.Condition, t, e, s2);
        }
        _PostInit() {
          for (const t of this._parameters) t._PostInit(), t.VariesPerInstance() && (this._anyParamVariesPerInstance = true);
          this._isFastTrigger ? (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject);
        }
        _SetSystemRunMethod() {
          const t = this._systemPlugin, e = this._systemPlugin;
          this._SetRunMethodForBoundFunc(t, e, this._RunSystem);
        }
        _SetSingleGlobalRunMethod() {
          const t = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
          this._SetRunMethodForBoundFunc(t, e, this._RunSingleGlobal);
        }
        _SetRunMethodForBoundFunc(t, e, s2) {
          const n = this._func, i2 = this._isInverted, r2 = this._parameters;
          if (0 === r2.length) {
            const s3 = t._GetBoundACEMethod(n, e);
            this.Run = i2 ? function() {
              return C33.xor(s3(), i2);
            } : s3;
          } else if (1 === r2.length) {
            const s3 = r2[0];
            if (!i2 && s3.IsConstant()) this.Run = t._GetBoundACEMethod_1param(n, e, s3.Get(0));
            else {
              const r3 = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return C33.xor(r3(s3.Get(0)), i2);
              };
            }
          } else if (2 === r2.length) {
            const s3 = r2[0], a2 = r2[1];
            if (!i2 && s3.IsConstant() && a2.IsConstant()) this.Run = t._GetBoundACEMethod_2params(n, e, s3.Get(0), a2.Get(0));
            else {
              const r3 = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return C33.xor(r3(s3.Get(0), a2.Get(0)), i2);
              };
            }
          } else if (3 === r2.length) {
            const s3 = r2[0], a2 = r2[1], h = r2[2];
            if (!i2 && s3.IsConstant() && a2.IsConstant() && h.IsConstant()) this.Run = t._GetBoundACEMethod_3params(n, e, s3.Get(0), a2.Get(0), h.Get(0));
            else {
              const r3 = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return C33.xor(r3(s3.Get(0), a2.Get(0), h.Get(0)), i2);
              };
            }
          } else this.Run = s2;
        }
        GetSID() {
          return this._sid;
        }
        _GetFunc() {
          return this._func;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetBehaviorType() {
          return this._behaviorType;
        }
        GetImplementationAddon() {
          return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;
        }
        GetImplementationSdkVersion() {
          const t = this.GetImplementationAddon();
          return t ? t.GetSdkVersion() : 1;
        }
        GetEventBlock() {
          return this._eventBlock;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetIndex() {
          return this._index;
        }
        GetDebugIndex() {
          return this.GetIndex();
        }
        IsTrigger() {
          return this._isTrigger;
        }
        IsFastTrigger() {
          return this._isFastTrigger;
        }
        IsInverted() {
          return this._isInverted;
        }
        IsLooping() {
          return this._isLooping;
        }
        IsStatic() {
          return this._isStatic;
        }
        IsBreakpoint() {
          return this._debugData.isBreakpoint;
        }
        IsSystemCondition() {
          return !!this._systemPlugin;
        }
        IsSystemOrSingleGlobalCondition() {
          return this.IsSystemCondition() || this._objectClass.GetPlugin().IsSingleGlobal();
        }
        GetFirstObjectParameterObjectClass() {
          for (const t of this._parameters) if (t.IsObjectParameter()) return t.GetObjectClass();
          return null;
        }
        _SetBreakpoint(t) {
          this._debugData.isBreakpoint = !!t, this._eventBlock._UpdateCanRunFastRecursive();
        }
        _DebugReturnsGenerator() {
          return this._debugData.canDebug;
        }
        DebugCanRunFast() {
          return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();
        }
        GetSavedDataMap() {
          return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
        }
        GetUnsavedDataMap() {
          return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;
        }
        _RunSystem() {
          const t = this._results;
          return EvalParams2(this._parameters, t), C33.xor(this._func.apply(this._systemPlugin, t), this._isInverted);
        }
        *_DebugRunSystem() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._results;
            EvalParams2(this._parameters, t);
            let e = this._func.apply(this._systemPlugin, t);
            return C33.IsIterator(e) && (e = yield* e), C33.xor(e, this._isInverted);
          }
          return this.Run();
        }
        _RunSingleGlobal() {
          const t = this._results;
          EvalParams2(this._parameters, t);
          const e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
          return C33.xor(this._func.apply(e, t), this._isInverted);
        }
        *_DebugRunSingleGlobal() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._results;
            EvalParams2(this._parameters, t);
            const e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            let s2 = this._func.apply(e, t);
            return C33.IsIterator(s2) && (s2 = yield* s2), C33.xor(s2, this._isInverted);
          }
          return this.Run();
        }
        _RunFastTrigger() {
          return true;
        }
        *_DebugRunFastTrigger() {
          return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), true;
        }
        _GetStaticConditionThis() {
          return this._behaviorType ? this._behaviorType.GetBehavior().GetSdkVersion() >= 2 ? this._behaviorType.GetIBehaviorType() : this._behaviorType : this._objectClass.GetPlugin().GetSdkVersion() >= 2 ? this._objectClass.GetIObjectClass() : this._objectClass;
        }
        _RunStatic() {
          const t = this._results;
          EvalParams2(this._parameters, t);
          const e = this._func.apply(this._GetStaticConditionThis(), t);
          return this._objectClass.ApplySolToContainer(), e;
        }
        *_DebugRunStatic() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._results;
            EvalParams2(this._parameters, t);
            let e = this._func.apply(this._GetStaticConditionThis(), t);
            return C33.IsIterator(e) && (e = yield* e), this._objectClass.ApplySolToContainer(), e;
          }
          return this.Run();
        }
        _RunObject() {
          const t = this._parameters, e = this._results, s2 = this._objectClass.GetCurrentSol();
          for (let s3 = 0, n = t.length; s3 < n; ++s3) {
            const n2 = t[s3];
            n2.VariesPerInstance() || (e[s3] = n2.Get(0));
          }
          return s2.IsSelectAll() ? this._RunObject_FirstFilter(s2) : this._RunObject_NextFilter(s2);
        }
        *_DebugRunObject() {
          return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._RunObject();
        }
        _EvaluateVaryingParameters(t) {
          const e = this._parameters, s2 = this._results;
          for (let n = 0, i2 = e.length; n < i2; ++n) {
            const i3 = e[n];
            i3.VariesPerInstance() && (s2[n] = i3.Get(t));
          }
        }
        _RunObject_FirstFilter(t) {
          const e = this._objectClass, s2 = e.IsFamily(), n = e.GetFamilyIndex(), i2 = this._behaviorIndex, r2 = i2 >= 0, a2 = e.GetInstances(), h = this._anyParamVariesPerInstance, o2 = this._results, l2 = this._func, u = this._isInverted, _ = this._isInOrBlock && !this._isTrigger;
          t.ClearArrays();
          for (let e2 = 0, c2 = a2.length; e2 < c2; ++e2) {
            const c3 = a2[e2];
            let g;
            if (h && this._EvaluateVaryingParameters(e2), r2) {
              const t2 = s2 ? c3.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
              g = l2.apply(c3.GetBehaviorInstances()[i2 + t2].GetSdkInstance(), o2);
            } else g = l2.apply(c3.GetSdkInstance(), o2);
            C33.xor(g, u) ? t._PushInstance(c3) : _ && t._PushElseInstance(c3);
          }
          return e.FinishCondition(true), t._SetSelectAll(false), e.ApplySolToContainer(), t.HasAnyInstances();
        }
        _RunObject_NextFilter(t) {
          const e = this._objectClass, s2 = e.IsFamily(), n = e.GetFamilyIndex(), i2 = e.IsInContainer(), r2 = this._behaviorIndex, a2 = r2 >= 0, h = this._anyParamVariesPerInstance, o2 = this._results, l2 = this._func, u = this._isInverted, _ = this._isInOrBlock && !this._isTrigger, c2 = t._GetOwnInstances(), g = t._GetOwnElseInstances(), d2 = _ && !this._eventBlock.IsFirstConditionOfType(this), I = d2 ? g : c2;
          let G = 0, b = false;
          for (let t2 = 0, e2 = I.length; t2 < e2; ++t2) {
            const e3 = I[t2];
            let m2;
            if (h && this._EvaluateVaryingParameters(t2), a2) {
              const t3 = s2 ? e3.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
              m2 = l2.apply(e3.GetBehaviorInstances()[r2 + t3].GetSdkInstance(), o2);
            } else m2 = l2.apply(e3.GetSdkInstance(), o2);
            C33.xor(m2, u) ? (b = true, d2 ? (c2.push(e3), i2 && e3._PushSiblingsToSolInstances()) : (I[G] = e3, i2 && e3._SetSiblingsToSolInstancesIndex(G), ++G)) : d2 ? (I[G] = e3, i2 && e3._SetSiblingsToSolElseInstancesIndex(G), ++G) : _ && (g.push(e3), i2 && e3._PushSiblingsToSolElseInstances());
          }
          C33.truncateArray(I, G), i2 && e._TruncateContainerSols(d2, G);
          const m = b;
          return d2 && !b && (b = this._OrBlockCheckInstances(c2)), e.FinishCondition(m || _), _ ? b : t.HasAnyInstances();
        }
        _OrBlockCheckInstances(t) {
          const e = this._objectClass, s2 = e.IsFamily(), n = e.GetFamilyIndex(), i2 = this._anyParamVariesPerInstance, r2 = this._behaviorIndex, a2 = r2 >= 0, h = this._results, o2 = this._func, l2 = this._isInverted;
          for (let e2 = 0, u = t.length; e2 < u; ++e2) {
            const u2 = t[e2];
            let _;
            if (i2 && this._EvaluateVaryingParameters(e2), a2) {
              const t2 = s2 ? u2.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
              _ = o2.apply(u2.GetBehaviorInstances()[r2 + t2].GetSdkInstance(), h);
            } else _ = o2.apply(u2.GetSdkInstance(), h);
            if (C33.xor(_, l2)) return true;
          }
          return false;
        }
        ReevaluateParameter(t, e) {
          return this._parameters[t].Get(e);
        }
        GetFastTriggerValue() {
          const t = this._parameters;
          if (!t.length) throw new Error("no parameters");
          return t[0]._GetFastTriggerValue();
        }
        _SaveToJson() {
          if (!this._savedData || !this._savedData.size) return null;
          const t = {};
          for (const [e, s2] of this._savedData.entries()) {
            let n = s2;
            "collmemory" === e && (n = [...s2.entries()].map((t2) => [t2[0].GetUID(), t2[1].GetUID(), t2[2]])), t[e] = n;
          }
          return { "ex": t };
        }
        _LoadFromJson(t) {
          if (this._savedData && (this._savedData.clear(), this._savedData = null), !t) return;
          const e = this._runtime, s2 = t["ex"];
          if (s2) {
            const t2 = this.GetSavedDataMap();
            t2.clear();
            for (const [n, i2] of Object.entries(s2)) {
              let s3 = i2;
              "collmemory" === n && (s3 = C33.New(C33.PairMap, i2.map((t3) => [e.GetInstanceByUID(t3[0]), e.GetInstanceByUID(t3[1]), t3[2]]).filter((t3) => t3[0] && t3[1]))), t2.set(n, s3);
            }
          }
        }
      };
    }
    var EvalParams;
    {
      let EvalParams2 = function(t, e) {
        for (let s2 = 0, n = t.length; s2 < n; ++s2) e[s2] = t[s2].Get(0);
      };
      EvalParams = EvalParams2;
      const C33 = self.C3, assert = self.assert;
      const EMPTY_PARAMS_ARRAY = [], noop = function() {
      }, noopGenerator = function* () {
      }, FLAG_CANPICKANYOBJECTCLASS = 1, FLAG_COPYPICKED = 2, FLAG_CUSTOM_ACE = 4, FLAG_IS_ASYNC = 8, FLAG_CAN_BAIL_OUT = 16;
      C33.Action = class extends C33.DefendedBase {
        constructor(t, e, s2) {
          super(), this._eventBlock = t;
          const n = t.GetRuntime();
          this._runtime = n, this._index = s2, this._sid = e.length >= 4 ? e[3] : -1, this._actionType = e.length >= 5 ? 255 & e[4] : 0, this._flags = e.length >= 5 ? e[4] >> 8 : 0, this._func = null, this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this._callFunctionName = "", this._callCustomAceObjectClass = null, this._callEventBlock = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null;
          const i2 = -3 === e[0], a2 = i2 ? e[2] : e[5];
          if (this._debugData = n.IsDebug() || i2 ? { isBreakpoint: a2[0], canDebug: a2[1], index: a2[2] } : null, -1 === e[0]) this._systemPlugin = n.GetSystemPlugin(), this._func = n.GetObjectReference(e[1]);
          else if (-2 === e[0]) this._callFunctionName = e[1];
          else if (i2) {
            const t2 = n.GetObjectReference(e[1]);
            this._func = t2, this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._flags |= 8;
          } else this._objectClass = n.GetObjectClassByIndex(e[0]), 4 & this._flags ? (this._callFunctionName = e[1], this._callCustomAceObjectClass = n.GetObjectClassByIndex(e[2])) : (e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])), this._func = n.GetObjectReference(e[1]));
          if (7 === e.length) {
            const t2 = e[6];
            for (const e2 of t2) this._parameters.push(C33.Parameter.Create(this, e2, this._parameters.length)), this._results.push(0);
          }
          0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this.CanPickAnyObjectClass() && (this._eventBlock.SetAllSolModifiers(), this._eventBlock.SetSolWriterAfterCnds()), this._eventBlock.GetEventSheetManager()._RegisterAction(this);
        }
        static Create(t, e, s2) {
          return C33.New(C33.Action, t, e, s2);
        }
        _PostInit() {
          for (const t of this._parameters) t._PostInit(), t.VariesPerInstance() && (this._anyParamVariesPerInstance = true);
          if (this._systemPlugin) this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem;
          else if (this._callFunctionName) 4 & this._flags ? this._SetCallCustomActionRunMethod() : this._SetCallFunctionRunMethod(), this._callFunctionName = "", this._callCustomAceObjectClass = null;
          else if (this.Run === this.RunUserScript) {
            const t = this._func, e = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
            this._func = t.bind(null, this._runtime.GetIRuntime(), e);
          } else this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsStatic() ? (this.Run = this._RunObject_Static, this.DebugRun = this._DebugRunObject_Static) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this.CallBeforeAfterHooks() ? (this.Run = this._RunObject_BeforeAfterHooks, this.DebugRun = this._DebugRunObject_BeforeAfterHooks) : this._parameters.length ? this._parameters.every((t) => t.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary, this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every((t) => t.IsConstant()) ? (EvalParams2(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst);
        }
        _SetSystemRunMethod() {
          const t = this._systemPlugin, e = this._systemPlugin;
          this._SetRunMethodForBoundFunc(t, e, this._RunSystem);
        }
        _SetSingleGlobalRunMethod() {
          const t = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
          this._SetRunMethodForBoundFunc(t, e, this._RunSingleGlobal);
        }
        _SetCallFunctionRunMethod() {
          const t = this._eventBlock.GetEventSheetManager(), e = t.GetFunctionBlockByName(this._callFunctionName);
          if (e.IsEnabled()) {
            const s2 = !!(2 & this._flags);
            this._callEventBlock = e.GetEventBlock();
            let n = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])];
            n = t._DeduplicateSolModifierList(n);
            const i2 = !e.IsCopyPicked() && this._HasCopyPickedParent() ? { pushCleanSolDynamic: true } : null;
            if (this.Run = C33.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, n, this._parameters, s2, i2), this._runtime.IsDebug()) {
              const t2 = this;
              this.DebugRun = function* () {
                (t2.IsBreakpoint() || t2._runtime.DebugBreakNext()) && (yield t2);
                return yield* t2._callEventBlock.DebugRunAsFunctionCall(n, t2._parameters, s2, i2);
              };
            } else this.DebugRun = noopGenerator;
          } else this.Run = noop, this.DebugRun = noopGenerator;
        }
        _SetCallCustomActionRunMethod() {
          const t = this._eventBlock.GetEventSheetManager(), e = t.GetCustomActionBlockByName(this._callCustomAceObjectClass, this._callFunctionName);
          if (e.IsEnabled()) {
            const s2 = !!(2 & this._flags);
            this._callEventBlock = e.GetEventBlock();
            let n = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents(), this._objectClass, e.GetObjectClass()])];
            n = t._DeduplicateSolModifierList(n);
            const i2 = !this._objectClass.IsFamily() && !e.GetObjectClass().IsFamily(), a2 = !this._objectClass.IsFamily() && e.GetObjectClass().IsFamily(), r2 = this._objectClass.IsFamily();
            let o2 = null;
            if (!e.IsCopyPicked() && this._HasCopyPickedParent() && (o2 = o2 || {}, o2.pushCleanSolDynamic = true), !a2 && s2 || (o2 = o2 || {}, o2.copyFromObjectClass = this._objectClass, o2.copyToObjectClass = e.GetObjectClass()), i2 || a2 || r2 && !e.HasCustomACEOverrides() ? this.Run = C33.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, n, this._parameters, s2, o2) : r2 && (this.Run = C33.FunctionBlock.prototype.RunAsFamilyCustomActionWithOverrides.bind(e, n, this._parameters)), this._runtime.IsDebug()) {
              const t2 = this;
              i2 || a2 || r2 && !e.HasCustomACEOverrides() ? this.DebugRun = function* () {
                (t2.IsBreakpoint() || t2._runtime.DebugBreakNext()) && (yield t2);
                return yield* t2._callEventBlock.DebugRunAsFunctionCall(n, t2._parameters, s2, o2);
              } : r2 && (this.DebugRun = function* () {
                (t2.IsBreakpoint() || t2._runtime.DebugBreakNext()) && (yield t2);
                return yield* e.DebugRunAsFamilyCustomActionWithOverrides(n, t2._parameters);
              });
            } else this.DebugRun = noopGenerator;
          } else this.Run = noop, this.DebugRun = noopGenerator;
        }
        _SetRunMethodForBoundFunc(t, e, s2) {
          const n = this._func, i2 = this._parameters;
          if (0 === i2.length) this.Run = t._GetBoundACEMethod(n, e);
          else if (1 === i2.length) {
            const s3 = i2[0];
            if (s3.IsConstant()) this.Run = t._GetBoundACEMethod_1param(n, e, s3.Get(0));
            else {
              const i3 = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return i3(s3.Get(0));
              };
            }
          } else if (2 === i2.length) {
            const s3 = i2[0], a2 = i2[1];
            if (s3.IsConstant() && a2.IsConstant()) this.Run = t._GetBoundACEMethod_2params(n, e, s3.Get(0), a2.Get(0));
            else {
              const i3 = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return i3(s3.Get(0), a2.Get(0));
              };
            }
          } else if (3 === i2.length) {
            const s3 = i2[0], a2 = i2[1], r2 = i2[2];
            if (s3.IsConstant() && a2.IsConstant() && r2.IsConstant()) this.Run = t._GetBoundACEMethod_3params(n, e, s3.Get(0), a2.Get(0), r2.Get(0));
            else {
              const i3 = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return i3(s3.Get(0), a2.Get(0), r2.Get(0));
              };
            }
          } else this.Run = s2;
        }
        GetSID() {
          return this._sid;
        }
        IsAsync() {
          return !!(8 & this._flags);
        }
        CanBailOut() {
          return !!(16 & this._flags);
        }
        CallBeforeAfterHooks() {
          return 1 === this._actionType;
        }
        IsStatic() {
          return 2 === this._actionType;
        }
        CanPickAnyObjectClass() {
          return !!(1 & this._flags);
        }
        HasReturnType() {
          return this.IsAsync() || this.CanBailOut();
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetImplementationAddon() {
          return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;
        }
        GetImplementationSdkVersion() {
          const t = this.GetImplementationAddon();
          return t ? t.GetSdkVersion() : 1;
        }
        GetEventBlock() {
          return this._eventBlock;
        }
        _HasCopyPickedParent() {
          let t = this._eventBlock;
          do {
            if (t instanceof C33.FunctionBlock && t.IsCopyPicked()) return true;
            t = t.GetScopeParent();
          } while (t);
          return false;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetIndex() {
          return this._index;
        }
        GetDebugIndex() {
          return this._debugData.index;
        }
        IsBreakpoint() {
          return this._debugData.isBreakpoint;
        }
        _SetBreakpoint(t) {
          this._debugData.isBreakpoint = !!t, this._eventBlock._UpdateCanRunFastRecursive();
        }
        _DebugReturnsGenerator() {
          return this._debugData.canDebug;
        }
        DebugCanRunFast() {
          return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();
        }
        GetSavedDataMap() {
          return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
        }
        GetUnsavedDataMap() {
          return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;
        }
        _RunSystem() {
          const t = this._results;
          return EvalParams2(this._parameters, t), this._func.apply(this._systemPlugin, t);
        }
        *_DebugRunSystem() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._results;
            EvalParams2(this._parameters, t);
            return yield* this._func.apply(this._systemPlugin, t);
          }
          return this.Run();
        }
        _RunSingleGlobal() {
          const t = this._results;
          return EvalParams2(this._parameters, t), this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t);
        }
        *_DebugRunSingleGlobal() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._results;
            EvalParams2(this._parameters, t);
            return yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t);
          }
          return this.Run();
        }
        _RunObject_ParamsConst() {
          const t = this._results, e = this._objectClass.GetCurrentSol().GetInstances();
          for (let s2 = 0, n = e.length; s2 < n; ++s2) this._func.apply(e[s2].GetSdkInstance(), t);
        }
        *_DebugRunObject_ParamsConst() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._results, e = this._objectClass.GetCurrentSol().GetInstances();
            for (let s2 = 0, n = e.length; s2 < n; ++s2) yield* this._func.apply(e[s2].GetSdkInstance(), t);
          } else this._RunObject_ParamsConst();
        }
        _RunObject_ParamsDontVary() {
          const t = this._results;
          EvalParams2(this._parameters, t);
          const e = this._objectClass.GetCurrentSol().GetInstances();
          for (let s2 = 0, n = e.length; s2 < n; ++s2) this._func.apply(e[s2].GetSdkInstance(), t);
        }
        *_DebugRunObject_ParamsDontVary() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._results;
            EvalParams2(this._parameters, t);
            const e = this._objectClass.GetCurrentSol().GetInstances();
            for (let s2 = 0, n = e.length; s2 < n; ++s2) yield* this._func.apply(e[s2].GetSdkInstance(), t);
          } else this._RunObject_ParamsDontVary();
        }
        _RunObject_AllParamsVary() {
          const t = this._parameters, e = this._results, s2 = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
          for (let i2 = 0, a2 = n.length; i2 < a2; ++i2) {
            const a3 = n[i2];
            for (let s3 = 0, n2 = t.length; s3 < n2; ++s3) e[s3] = t[s3].Get(i2);
            s2.apply(a3.GetSdkInstance(), e);
          }
        }
        *_DebugRunObject_AllParamsVary() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._parameters, e = this._results, s2 = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
            for (let i2 = 0, a2 = n.length; i2 < a2; ++i2) {
              const a3 = n[i2];
              for (let s3 = 0, n2 = t.length; s3 < n2; ++s3) e[s3] = t[s3].Get(i2);
              yield* s2.apply(a3.GetSdkInstance(), e);
            }
          } else this._RunObject_AllParamsVary();
        }
        _RunObject_SomeParamsVary() {
          const t = this._parameters, e = this._results, s2 = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
          for (let s3 = 0, n2 = t.length; s3 < n2; ++s3) {
            const n3 = t[s3];
            n3.VariesPerInstance() || (e[s3] = n3.Get(0));
          }
          for (let i2 = 0, a2 = n.length; i2 < a2; ++i2) {
            const a3 = n[i2];
            for (let s3 = 0, n2 = t.length; s3 < n2; ++s3) {
              const n3 = t[s3];
              n3.VariesPerInstance() && (e[s3] = n3.Get(i2));
            }
            s2.apply(a3.GetSdkInstance(), e);
          }
        }
        *_DebugRunObject_SomeParamsVary() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._parameters, e = this._results, s2 = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
            for (let s3 = 0, n2 = t.length; s3 < n2; ++s3) {
              const n3 = t[s3];
              n3.VariesPerInstance() || (e[s3] = n3.Get(0));
            }
            for (let i2 = 0, a2 = n.length; i2 < a2; ++i2) {
              const a3 = n[i2];
              for (let s3 = 0, n2 = t.length; s3 < n2; ++s3) {
                const n3 = t[s3];
                n3.VariesPerInstance() && (e[s3] = n3.Get(i2));
              }
              yield* s2.apply(a3.GetSdkInstance(), e);
            }
          } else this._RunObject_SomeParamsVary();
        }
        _RunObject_BeforeAfterHooks() {
          const t = this._parameters, e = this._results, s2 = this._func, n = this._objectClass, i2 = n.GetSdkType(), a2 = n.GetCurrentSol().GetInstances();
          i2.BeforeRunAction(s2);
          for (let n2 = 0, i3 = a2.length; n2 < i3; ++n2) {
            const i4 = a2[n2];
            for (let s3 = 0, i5 = t.length; s3 < i5; ++s3) e[s3] = t[s3].Get(n2);
            s2.apply(i4.GetSdkInstance(), e);
          }
          i2.AfterRunAction(s2);
        }
        *_DebugRunObject_BeforeAfterHooks() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._parameters, e = this._results, s2 = this._func, n = this._objectClass, i2 = n.GetSdkType(), a2 = n.GetCurrentSol().GetInstances();
            i2.BeforeRunAction(s2);
            for (let n2 = 0, i3 = a2.length; n2 < i3; ++n2) {
              const i4 = a2[n2];
              for (let s3 = 0, i5 = t.length; s3 < i5; ++s3) e[s3] = t[s3].Get(n2);
              yield* s2.apply(i4.GetSdkInstance(), e);
            }
            i2.AfterRunAction(s2);
          } else this._RunObject_BeforeAfterHooks();
        }
        _GetStaticActionThis() {
          return this._behaviorType ? this._behaviorType.GetBehavior().GetSdkVersion() >= 2 ? this._behaviorType.GetIBehaviorType() : this._behaviorType : this._objectClass.GetPlugin().GetSdkVersion() >= 2 ? this._objectClass.GetIObjectClass() : this._objectClass;
        }
        _RunObject_Static() {
          const t = this._results;
          return EvalParams2(this._parameters, t), this._func.apply(this._GetStaticActionThis(), t);
        }
        *_DebugRunObject_Static() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._results;
            EvalParams2(this._parameters, t);
            let e = this._func.apply(this._GetStaticActionThis(), t);
            return C33.IsIterator(e) && (e = yield* e), e;
          }
          return this._RunObject_Static();
        }
        _RunBehavior() {
          const t = this._objectClass, e = t.IsFamily(), s2 = t.GetFamilyIndex(), n = this._parameters, i2 = this._anyParamVariesPerInstance, a2 = this._results, r2 = this._func, o2 = this._behaviorIndex, l2 = t.GetCurrentSol().GetInstances();
          for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) {
            const e3 = n[t2];
            e3.VariesPerInstance() || (a2[t2] = e3.Get(0));
          }
          for (let t2 = 0, h = l2.length; t2 < h; ++t2) {
            const h2 = l2[t2];
            if (i2) for (let e2 = 0, s3 = n.length; e2 < s3; ++e2) {
              const s4 = n[e2];
              s4.VariesPerInstance() && (a2[e2] = s4.Get(t2));
            }
            const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s2) : 0;
            r2.apply(h2.GetBehaviorInstances()[o2 + u].GetSdkInstance(), a2);
          }
        }
        *_DebugRunBehavior() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._objectClass, e = t.IsFamily(), s2 = t.GetFamilyIndex(), n = this._parameters, i2 = this._anyParamVariesPerInstance, a2 = this._results, r2 = this._func, o2 = this._behaviorIndex, l2 = t.GetCurrentSol().GetInstances();
            for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) {
              const e3 = n[t2];
              e3.VariesPerInstance() || (a2[t2] = e3.Get(0));
            }
            for (let t2 = 0, h = l2.length; t2 < h; ++t2) {
              const h2 = l2[t2];
              if (i2) for (let e2 = 0, s3 = n.length; e2 < s3; ++e2) {
                const s4 = n[e2];
                s4.VariesPerInstance() && (a2[e2] = s4.Get(t2));
              }
              const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s2) : 0;
              yield* r2.apply(h2.GetBehaviorInstances()[o2 + u].GetSdkInstance(), a2);
            }
          } else this._RunBehavior();
        }
        _RunObject_Async() {
          const t = this._parameters, e = this._results, s2 = this._func, n = this._objectClass.GetCurrentSol().GetInstances(), i2 = [];
          for (let a2 = 0, r2 = n.length; a2 < r2; ++a2) {
            const r3 = n[a2];
            for (let s3 = 0, n2 = t.length; s3 < n2; ++s3) e[s3] = t[s3].Get(a2);
            i2.push(s2.apply(r3.GetSdkInstance(), e));
          }
          return Promise.all(i2);
        }
        *_DebugRunObject_Async() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._parameters, e = this._results, s2 = this._func, n = this._objectClass.GetCurrentSol().GetInstances(), i2 = [];
            for (let a2 = 0, r2 = n.length; a2 < r2; ++a2) {
              const r3 = n[a2];
              for (let s3 = 0, n2 = t.length; s3 < n2; ++s3) e[s3] = t[s3].Get(a2);
              i2.push(yield* s2.apply(r3.GetSdkInstance(), e));
            }
            return Promise.all(i2);
          }
          return this._RunObject_Async();
        }
        _RunBehavior_Async() {
          const t = this._objectClass, e = t.IsFamily(), s2 = t.GetFamilyIndex(), n = this._parameters, i2 = this._results, a2 = this._func, r2 = this._behaviorIndex, o2 = t.GetCurrentSol().GetInstances(), l2 = [];
          for (let t2 = 0, h = o2.length; t2 < h; ++t2) {
            const h2 = o2[t2];
            for (let e2 = 0, s3 = n.length; e2 < s3; ++e2) i2[e2] = n[e2].Get(t2);
            const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s2) : 0;
            l2.push(a2.apply(h2.GetBehaviorInstances()[r2 + u].GetSdkInstance(), i2));
          }
          return Promise.all(l2);
        }
        *_DebugRunBehavior_Async() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._objectClass, e = t.IsFamily(), s2 = t.GetFamilyIndex(), n = this._parameters, i2 = this._results, a2 = this._func, r2 = this._behaviorIndex, o2 = t.GetCurrentSol().GetInstances(), l2 = [];
            for (let t2 = 0, h = o2.length; t2 < h; ++t2) {
              const h2 = o2[t2];
              for (let e2 = 0, s3 = n.length; e2 < s3; ++e2) i2[e2] = n[e2].Get(t2);
              const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s2) : 0;
              l2.push(yield* a2.apply(h2.GetBehaviorInstances()[r2 + u].GetSdkInstance(), i2));
            }
            return Promise.all(l2);
          }
          return this._RunBehavior_Async();
        }
        async RunUserScript() {
          try {
            await this._func();
          } catch (t) {
            console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, "font-size: 1.2em; font-weight: bold;", t), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), C33.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), C33.EventScript.SetHadUserScriptException());
          }
        }
        *DebugRunUserScript() {
          return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.RunUserScript();
        }
        _SaveToJson() {
          return this._savedData && this._savedData.size ? { "ex": C33.ToSuperJSON(this._savedData) } : null;
        }
        _LoadFromJson(t) {
          if (this._savedData && (this._savedData.clear(), this._savedData = null), !t) return;
          const e = t["ex"];
          e && (this._savedData = C33.FromSuperJSON(e));
        }
      };
    }
    var EvalParams;
    {
      let GetInst2 = function(t) {
        return t instanceof IInstance ? runtime._UnwrapScriptInterface(t) : t.GetInstance();
      }, GetWorldInfo2 = function(t) {
        return GetInst2(t).GetWorldInfo();
      }, GetInst_SDKv22 = function(t) {
        return runtime._UnwrapScriptInterface(t);
      }, GetWorldInfo_SDKv22 = function(t) {
        return GetInst_SDKv22(t).GetWorldInfo();
      }, GetObjectClass2 = function(t) {
        return t instanceof IObjectClass ? runtime._UnwrapScriptInterface(t) : t;
      }, GetLayer2 = function(t) {
        return t instanceof ILayer ? runtime._UnwrapScriptInterface(t) : t;
      }, CollMemory_Add2 = function(t, e, n, o2) {
        e.GetUID() < n.GetUID() ? t.Set(e, n, o2) : t.Set(n, e, o2);
      }, CollMemory_Remove2 = function(t, e, n) {
        e.GetUID() < n.GetUID() ? t.Delete(e, n) : t.Delete(n, e);
      }, CollMemory_RemoveInstance2 = function(t, e) {
        t.DeleteEither(e);
      }, CollMemory_Get2 = function(t, e, n) {
        return e.GetUID() < n.GetUID() ? t.Get(e, n) : t.Get(n, e);
      }, DoOverlapCondition2 = function(t, e, n, o2) {
        if (!e) return false;
        const s2 = 0 !== n || 0 !== o2, i2 = t.GetWorldInfo(), r2 = runtime.GetCollisionEngine(), a2 = runtime.GetCurrentCondition(), l2 = a2.GetEventBlock().IsOrBlock(), c2 = a2.GetObjectClass(), u = a2.IsInverted(), S = e.GetCurrentSol(), f2 = c2 !== e;
        let G;
        rPickType = e, needsCollisionFinish = f2 && !u, rPickFromElseInstances = false;
        let d2 = 0, I = 0, C = false;
        S.IsSelectAll() ? (tempRect.copy(i2.GetBoundingBox()), tempRect.offset(n, o2), r2.GetCollisionCandidates(i2.GetLayer(), e, tempRect, tempCandidates2), G = tempCandidates2) : l2 ? runtime.IsCurrentConditionFirst() && !S._GetOwnElseInstances().length && S._GetOwnInstances().length ? G = S._GetOwnInstances() : (G = S._GetOwnElseInstances(), rPickFromElseInstances = true) : G = S._GetOwnInstances(), s2 && (d2 = i2.GetX(), I = i2.GetY(), i2.OffsetXY(n, o2), i2.SetBboxChanged());
        for (const e2 of G) if (r2.TestOverlap(t, e2)) {
          if (C = true, u) break;
          f2 && rToPick.add(e2);
        }
        return s2 && (i2.SetXY(d2, I), i2.SetBboxChanged()), C33.clearArray(tempCandidates2), C;
      }, FinishCollisionConditionPicking2 = function(t) {
        const e = runtime.GetCurrentEvent().IsOrBlock(), n = rPickType.GetCurrentSol(), o2 = n._GetOwnInstances(), s2 = n._GetOwnElseInstances();
        n.IsSelectAll() ? (n.SetSetPicked(rToPick), e && (C33.clearArray(s2), n.AddElseInstances(rToPick, rPickType.GetInstances()))) : e ? rPickFromElseInstances ? n.TransferElseInstancesToOwn(rToPick) : (n.AddElseInstances(rToPick, o2), n.SetSetPicked(rToPick)) : n.SetSetPicked(rToPick), rPickType.ApplySolToContainer();
      }, FinishCollisionCondition2 = function(t, e) {
        needsCollisionFinish && (e && FinishCollisionConditionPicking2(t), rToPick.clear(), rPickType = null, needsCollisionFinish = false);
      }, PickByUID_Normal2 = function(t, e) {
        const n = runtime.GetInstanceByUID(e);
        if (!n) return false;
        const o2 = t.GetCurrentSol();
        if (!o2.IsSelectAll() && !o2._GetOwnInstances().includes(n)) return false;
        if (t.IsFamily()) {
          if (n.GetObjectClass().BelongsToFamily(t)) return o2.PickOne(n), t.ApplySolToContainer(), true;
        } else if (n.GetObjectClass() === t) return o2.PickOne(n), t.ApplySolToContainer(), true;
        return false;
      }, PickByUID_Inverted2 = function(t, e) {
        const n = t.GetCurrentSol();
        if (n.IsSelectAll()) {
          n._SetSelectAll(false), n.ClearArrays();
          const o2 = t.GetInstances();
          for (let t2 = 0, s2 = o2.length; t2 < s2; ++t2) {
            const s3 = o2[t2];
            s3.GetUID() === e ? n._PushElseInstance(s3) : n._PushInstance(s3);
          }
          return t.ApplySolToContainer(), !!n._GetOwnInstances().length;
        }
        {
          const o2 = n._GetOwnInstances();
          let s2 = 0;
          for (let t2 = 0, i2 = o2.length; t2 < i2; ++t2) {
            const i3 = o2[t2];
            o2[s2] = i3, i3.GetUID() === e ? n._PushElseInstance(i3) : ++s2;
          }
          return C33.truncateArray(o2, s2), t.ApplySolToContainer(), !!o2.length;
        }
      };
      GetInst = GetInst2, GetWorldInfo = GetWorldInfo2, GetInst_SDKv2 = GetInst_SDKv22, GetWorldInfo_SDKv2 = GetWorldInfo_SDKv22, GetObjectClass = GetObjectClass2, GetLayer = GetLayer2, CollMemory_Add = CollMemory_Add2, CollMemory_Remove = CollMemory_Remove2, CollMemory_RemoveInstance = CollMemory_RemoveInstance2, CollMemory_Get = CollMemory_Get2, DoOverlapCondition = DoOverlapCondition2, FinishCollisionConditionPicking = FinishCollisionConditionPicking2, FinishCollisionCondition = FinishCollisionCondition2, PickByUID_Normal = PickByUID_Normal2, PickByUID_Inverted = PickByUID_Inverted2;
      const C33 = self.C3, tempColor = new C33.Color(), AnySDK = {}, SDKv1 = {}, SDKv2 = {};
      let runtime = null;
      C33.CommonACES_SetRuntime = function(t) {
        runtime = t;
      };
      const IInstance = self.IInstance, IObjectClass = self.IObjectClass, ILayer = self.ILayer;
      SDKv1.CompareX = function(t, e) {
        return C33.compare(this.GetWorldInfo().GetX(), t, e);
      }, SDKv2.CompareX = function(t, e) {
        return C33.compare(this.x, t, e);
      }, SDKv1.CompareY = function(t, e) {
        return C33.compare(this.GetWorldInfo().GetY(), t, e);
      }, SDKv2.CompareY = function(t, e) {
        return C33.compare(this.y, t, e);
      }, SDKv1.IsOnScreen = function() {
        return this.GetWorldInfo().IsInViewport2();
      }, SDKv2.IsOnScreen = function() {
        return this.isOnScreen();
      }, AnySDK.IsOutsideLayout = function() {
        const t = GetWorldInfo2(this), e = t.GetLayout(), n = t.GetBoundingBox();
        return n.getRight() < 0 || n.getBottom() < 0 || n.getLeft() > e.GetWidth() || n.getTop() > e.GetHeight();
      }, AnySDK.PickDistance = function(t, e, n) {
        const o2 = GetObjectClass2(this).GetCurrentSol(), s2 = o2.GetInstances();
        if (!s2.length) return false;
        let i2 = s2[0], r2 = i2.GetWorldInfo(), a2 = i2, l2 = C33.distanceSquared(r2.GetX(), r2.GetY(), e, n);
        for (let o3 = 1, c2 = s2.length; o3 < c2; ++o3) {
          i2 = s2[o3], r2 = i2.GetWorldInfo();
          const c3 = C33.distanceSquared(r2.GetX(), r2.GetY(), e, n);
          (0 === t && c3 < l2 || 1 === t && c3 > l2) && (l2 = c3, a2 = i2);
        }
        return o2.PickOne(a2), true;
      }, SDKv1.SetX = function(t) {
        const e = this.GetWorldInfo();
        e.GetX() !== t && (e.SetX(t), e.SetBboxChanged());
      }, SDKv2.SetX = function(t) {
        this.x = +t;
      }, SDKv1.SetY = function(t) {
        const e = this.GetWorldInfo();
        e.GetY() !== t && (e.SetY(t), e.SetBboxChanged());
      }, SDKv2.SetY = function(t) {
        this.y = +t;
      }, SDKv1.SetPos = function(t, e) {
        const n = this.GetWorldInfo();
        n.EqualsXY(t, e) || (n.SetXY(t, e), n.SetBboxChanged());
      }, SDKv2.SetPos = function(t, e) {
        this.setPosition(t, e);
      }, AnySDK.SetPosToObject = function(t, e) {
        if (!(t = GetObjectClass2(t))) return;
        const n = GetInst2(this), o2 = t.GetPairedInstance(n);
        if (!o2) return;
        const [s2, i2] = o2.GetImagePoint(e), r2 = n.GetWorldInfo();
        r2.GetX() === s2 && r2.GetY() === i2 || (r2.SetXY(s2, i2), r2.SetBboxChanged());
      }, AnySDK.MoveForward = function(t) {
        if (0 === t) return;
        const e = GetWorldInfo2(this);
        e.OffsetXY(e.GetCosAngle() * t, e.GetSinAngle() * t), e.SetBboxChanged();
      }, SDKv1.MoveAtAngle = function(t, e) {
        if (0 === e) return;
        const n = this.GetWorldInfo();
        t = C33.toRadians(t), n.OffsetXY(Math.cos(t) * e, Math.sin(t) * e), n.SetBboxChanged();
      }, SDKv2.MoveAtAngle = function(t, e) {
        0 !== e && (t = C33.toRadians(t), this.offsetPosition(Math.cos(t) * e, Math.sin(t) * e));
      }, SDKv1.GetX = function() {
        return this.GetWorldInfo().GetX();
      }, SDKv2.GetX = function() {
        return this.x;
      }, SDKv1.GetY = function() {
        return this.GetWorldInfo().GetY();
      }, SDKv2.GetY = function() {
        return this.y;
      }, AnySDK.GetDt = function() {
        return runtime.GetDt(GetInst2(this));
      }, SDKv1.CompareWidth = function(t, e) {
        return C33.compare(this.GetWorldInfo().GetWidth(), t, e);
      }, SDKv2.CompareWidth = function(t, e) {
        return C33.compare(this.width, t, e);
      }, SDKv1.CompareHeight = function(t, e) {
        return C33.compare(this.GetWorldInfo().GetHeight(), t, e);
      }, SDKv2.CompareHeight = function(t, e) {
        return C33.compare(this.height, t, e);
      }, SDKv1.SetWidth = function(t) {
        const e = this.GetWorldInfo();
        e.GetWidth() !== t && (e.SetWidth(t), e.SetBboxChanged());
      }, SDKv2.SetWidth = function(t) {
        this.width = t;
      }, SDKv1.SetHeight = function(t) {
        const e = this.GetWorldInfo();
        e.GetHeight() !== t && (e.SetHeight(t), e.SetBboxChanged());
      }, SDKv2.SetHeight = function(t) {
        this.height = t;
      }, SDKv1.SetSize = function(t, e) {
        const n = GetWorldInfo2(this);
        n.GetWidth() === t && n.GetHeight() === e || (n.SetSize(t, e), n.SetBboxChanged());
      }, SDKv2.SetSize = function(t, e) {
        this.setSize(t, e);
      }, SDKv1.GetWidth = function() {
        return this.GetWorldInfo().GetWidth();
      }, SDKv2.GetWidth = function() {
        return this.width;
      }, SDKv1.GetHeight = function() {
        return this.GetWorldInfo().GetHeight();
      }, SDKv2.GetHeight = function() {
        return this.height;
      }, AnySDK.GetBboxLeft = function() {
        return GetWorldInfo2(this).GetBoundingBox().getLeft();
      }, AnySDK.GetBboxTop = function() {
        return GetWorldInfo2(this).GetBoundingBox().getTop();
      }, AnySDK.GetBboxRight = function() {
        return GetWorldInfo2(this).GetBoundingBox().getRight();
      }, AnySDK.GetBboxBottom = function() {
        return GetWorldInfo2(this).GetBoundingBox().getBottom();
      }, AnySDK.GetBboxMidX = function() {
        const t = GetWorldInfo2(this).GetBoundingBox();
        return (t.getLeft() + t.getRight()) / 2;
      }, AnySDK.GetBboxMidY = function() {
        const t = GetWorldInfo2(this).GetBoundingBox();
        return (t.getTop() + t.getBottom()) / 2;
      }, AnySDK.IsAngleWithin = function(t, e) {
        return C33.angleDiff(GetWorldInfo2(this).GetAngle(), C33.toRadians(e)) <= C33.toRadians(t);
      }, AnySDK.IsAngleClockwiseFrom = function(t) {
        return C33.angleClockwise(GetWorldInfo2(this).GetAngle(), C33.toRadians(t));
      }, AnySDK.IsBetweenAngles = function(t, e) {
        const n = C33.toRadians(t), o2 = C33.toRadians(e), s2 = GetWorldInfo2(this).GetAngle();
        return !C33.angleClockwise(o2, n) ? !(!C33.angleClockwise(s2, n) && C33.angleClockwise(s2, o2)) : C33.angleClockwise(s2, n) && !C33.angleClockwise(s2, o2);
      }, SDKv1.SetAngle = function(t) {
        const e = this.GetWorldInfo(), n = C33.clampAngle(C33.toRadians(t));
        isNaN(n) || e.GetAngle() === n || (e.SetAngle(n), e.SetBboxChanged());
      }, SDKv2.SetAngle = function(t) {
        this.angleDegrees = t;
      }, AnySDK.RotateClockwise = function(t) {
        if (isNaN(t) || 0 === t) return;
        const e = GetWorldInfo2(this);
        e.SetAngle(e.GetAngle() + C33.toRadians(t)), e.SetBboxChanged();
      }, AnySDK.RotateCounterclockwise = function(t) {
        if (isNaN(t) || 0 === t) return;
        const e = GetWorldInfo2(this);
        e.SetAngle(e.GetAngle() - C33.toRadians(t)), e.SetBboxChanged();
      }, AnySDK.RotateTowardAngle = function(t, e) {
        const n = GetWorldInfo2(this), o2 = n.GetAngle(), s2 = C33.angleRotate(o2, C33.toRadians(e), C33.toRadians(t));
        isNaN(s2) || o2 === s2 || (n.SetAngle(s2), n.SetBboxChanged());
      }, AnySDK.RotateTowardPosition = function(t, e, n) {
        const o2 = GetWorldInfo2(this), s2 = o2.GetAngle(), i2 = e - o2.GetX(), r2 = n - o2.GetY(), a2 = Math.atan2(r2, i2), l2 = C33.angleRotate(s2, a2, C33.toRadians(t));
        isNaN(l2) || s2 === l2 || (o2.SetAngle(l2), o2.SetBboxChanged());
      }, AnySDK.SetTowardPosition = function(t, e) {
        const n = GetWorldInfo2(this), o2 = n.GetAngle(), s2 = t - n.GetX(), i2 = e - n.GetY(), r2 = Math.atan2(i2, s2);
        isNaN(r2) || o2 === r2 || (n.SetAngle(r2), n.SetBboxChanged());
      }, SDKv1.GetAngle = function() {
        return C33.toDegrees(this.GetWorldInfo().GetAngle());
      }, SDKv2.GetAngle = function() {
        return this.angleDegrees;
      }, AnySDK.CompareOpacity = function(t, e) {
        return C33.compare(C33.roundToDp(100 * GetWorldInfo2(this).GetOpacity(), 6), t, e);
      }, SDKv1.IsVisible = function() {
        return this.GetWorldInfo().IsVisible();
      }, SDKv2.IsVisible = function() {
        return this.isVisible;
      }, AnySDK.SetVisible = function(t) {
        const e = GetWorldInfo2(this);
        t = 2 === t ? !e.IsVisible() : 0 !== t, e.IsVisible() !== t && (e.SetVisible(t), runtime.UpdateRender());
      }, AnySDK.SetOpacity = function(t) {
        const e = C33.clamp(t / 100, 0, 1), n = GetWorldInfo2(this);
        if (n.GetTransformWithParentOpacity()) {
          if (n._GetSceneGraphInfo().GetOwnOpacity() === e) return;
        } else if (n.GetOpacity() === e) return;
        n.SetOpacity(e), runtime.UpdateRender();
      }, AnySDK.SetDefaultColor = function(t) {
        tempColor.setFromRgbValue(t);
        const e = GetWorldInfo2(this);
        e.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (e.SetUnpremultipliedColor(tempColor), runtime.UpdateRender());
      }, AnySDK.GetColor = function() {
        const t = GetWorldInfo2(this).GetUnpremultipliedColor();
        return C33.PackRGBAEx(t.getR(), t.getG(), t.getB(), t.getA());
      }, AnySDK.GetOpacity = function() {
        return C33.roundToDp(100 * GetWorldInfo2(this).GetOpacity(), 6);
      }, AnySDK.IsOnLayer = function(t) {
        return !!(t = GetLayer2(t)) && GetWorldInfo2(this).GetLayer() === t;
      }, AnySDK.PickTopBottom = function(t) {
        const e = GetObjectClass2(this).GetCurrentSol(), n = e.GetInstances();
        if (!n.length) return false;
        let o2 = n[0];
        for (let e2 = 1, s2 = n.length; e2 < s2; ++e2) {
          const s3 = n[e2], i2 = s3.GetWorldInfo(), r2 = o2.GetWorldInfo(), a2 = i2.GetLayer().GetIndex(), l2 = r2.GetLayer().GetIndex();
          0 === t ? (a2 > l2 || a2 === l2 && i2.GetZIndex() > r2.GetZIndex()) && (o2 = s3) : (a2 < l2 || a2 === l2 && i2.GetZIndex() < r2.GetZIndex()) && (o2 = s3);
        }
        return e.PickOne(o2), true;
      }, SDKv1.CompareZElevation = function(t, e, n) {
        const o2 = this.GetWorldInfo(), s2 = 0 === t ? o2.GetZElevation() : o2.GetTotalZElevation();
        return C33.compare(s2, e, n);
      }, SDKv2.CompareZElevation = function(t, e, n) {
        const o2 = 0 === t ? this.zElevation : this.totalZElevation;
        return C33.compare(o2, e, n);
      }, SDKv1.MoveToTop = function() {
        this.GetWorldInfo().ZOrderMoveToTop();
      }, SDKv2.MoveToTop = function() {
        this.moveToTop();
      }, SDKv1.MoveToBottom = function() {
        this.GetWorldInfo().ZOrderMoveToBottom();
      }, SDKv2.MoveToBottom = function() {
        this.moveToBottom();
      }, AnySDK.MoveToLayer = function(t) {
        (t = GetLayer2(t)) && GetWorldInfo2(this).ZOrderMoveToLayer(t);
      }, AnySDK.ZMoveToObject = function(t, e) {
        const n = 0 === t;
        if (!(e = GetObjectClass2(e))) return;
        const o2 = GetInst2(this), s2 = e.GetFirstPicked(o2);
        s2 && o2.GetWorldInfo().ZOrderMoveAdjacentToInstance(s2, n);
      }, SDKv1.SetZElevation = function(t) {
        const e = this.GetWorldInfo();
        e.GetZElevation() !== t && (e.SetZElevation(t), runtime.UpdateRender());
      }, SDKv2.SetZElevation = function(t) {
        this.zElevation = t;
      }, AnySDK.LayerNumber = function() {
        return GetWorldInfo2(this).GetLayer().GetIndex();
      }, AnySDK.LayerName = function() {
        return GetWorldInfo2(this).GetLayer().GetName();
      }, SDKv1.ZIndex = function() {
        return this.GetWorldInfo().GetZIndex();
      }, SDKv2.ZIndex = function() {
        return this.zIndex;
      }, SDKv1.ZElevation = function() {
        return this.GetWorldInfo().GetZElevation();
      }, SDKv2.ZElevation = function() {
        return this.zElevation;
      }, SDKv1.TotalZElevation = function() {
        return this.GetWorldInfo().GetTotalZElevation();
      }, SDKv2.TotalZElevation = function() {
        return this.totalZElevation;
      }, AnySDK.IsEffectEnabled = function(t) {
        const e = GetInst2(this), n = e.GetObjectClass().GetEffectList().GetEffectTypeByName(t);
        if (!n) return;
        const o2 = n.GetIndex();
        return e.GetWorldInfo().GetInstanceEffectList().IsEffectIndexActive(o2);
      }, AnySDK.SetEffectEnabled = function(t, e) {
        const n = GetInst2(this), o2 = n.GetObjectClass().GetEffectList().GetEffectTypeByName(e);
        if (!o2) return;
        const s2 = o2.GetIndex(), i2 = 1 === t, r2 = n.GetWorldInfo().GetInstanceEffectList();
        r2.IsEffectIndexActive(s2) !== i2 && (r2.SetEffectIndexActive(s2, i2), r2.UpdateActiveEffects(), runtime.UpdateRender());
      }, AnySDK.SetEffectParam = function(t, e, n) {
        const o2 = GetInst2(this), s2 = o2.GetObjectClass().GetEffectList().GetEffectTypeByName(t);
        if (!s2) return;
        e = Math.floor(e);
        const i2 = s2.GetShaderProgram().GetParameterType(e);
        if (!i2) return;
        "color" === i2 ? (tempColor.setFromRgbValue(n), n = tempColor) : "percent" === i2 && (n /= 100);
        const r2 = s2.GetIndex(), a2 = o2.GetWorldInfo().GetInstanceEffectList();
        a2.SetEffectParameter(r2, e, n) && a2.IsEffectIndexActive(r2) && runtime.UpdateRender();
      };
      const tempRect = C33.New(C33.Rect), tempCandidates1 = [], tempCandidates2 = [];
      let needsCollisionFinish = false, rPickType = null, rPickFromElseInstances = false;
      const rToPick = /* @__PURE__ */ new Set();
      function* DebugOnCollision(t) {
        if (!t) return false;
        const e = this.GetRuntime(), n = e.GetCollisionEngine(), o2 = e.GetEventSheetManager(), s2 = o2.GetEventStack(), i2 = o2.GetCurrentCondition(), r2 = i2.GetObjectClass(), a2 = i2.GetSavedDataMap(), l2 = i2.GetUnsavedDataMap(), c2 = s2.GetCurrentStackFrame(), u = e.GetTickCount(), S = u - 1, f2 = c2.GetCurrentEvent(), G = s2.Push(f2);
        let d2 = a2.get("collmemory");
        d2 || (d2 = C33.New(C33.PairMap), a2.set("collmemory", d2)), l2.get("collisionCreatedDestroyCallback") || (l2.set("collisionCreatedDestroyCallback", true), e.Dispatcher().addEventListener("instancedestroy", (t2) => CollMemory_RemoveInstance2(d2, t2.instance)));
        const I = r2.GetCurrentSol(), C = t.GetCurrentSol(), h = I.GetInstances();
        let m = null;
        for (let e2 = 0; e2 < h.length; ++e2) {
          const s3 = h[e2];
          C.IsSelectAll() ? (n.GetCollisionCandidates(s3.GetWorldInfo().GetLayer(), t, s3.GetWorldInfo().GetBoundingBox(), tempCandidates1), m = tempCandidates1, n.AddRegisteredCollisionCandidates(s3, t, m)) : m = C.GetInstances();
          for (let e3 = 0; e3 < m.length; ++e3) {
            const i3 = m[e3];
            if (n.TestOverlap(s3, i3) || n.CheckRegisteredCollision(s3, i3)) {
              const e4 = CollMemory_Get2(d2, s3, i3);
              let n2 = false, a3 = -2;
              "number" == typeof e4 && (n2 = true, a3 = e4);
              const l3 = !n2 || a3 < S;
              if (CollMemory_Add2(d2, s3, i3, u), l3) {
                const e5 = f2.GetSolModifiers();
                o2.PushCopySol(e5);
                const n3 = r2.GetCurrentSol(), a4 = t.GetCurrentSol();
                if (n3._SetSelectAll(false), a4._SetSelectAll(false), r2 === t) {
                  const t2 = n3._GetOwnInstances();
                  C33.clearArray(t2), t2.push(s3), t2.push(i3), r2.ApplySolToContainer();
                } else {
                  const e6 = n3._GetOwnInstances(), o3 = a4._GetOwnInstances();
                  C33.clearArray(e6), C33.clearArray(o3), e6.push(s3), o3.push(i3), r2.ApplySolToContainer(), t.ApplySolToContainer();
                }
                yield* f2.DebugRetrigger(c2, G), o2.PopSol(e5);
              }
            } else CollMemory_Remove2(d2, s3, i3);
          }
          C33.clearArray(tempCandidates1);
        }
        return s2.Pop(), false;
      }
      AnySDK.OnCollision = function(t) {
        const e = GetObjectClass2(this);
        t = GetObjectClass2(t);
        const n = e.GetRuntime();
        if (n.IsDebugging()) return DebugOnCollision.call(e, t);
        if (!t) return false;
        const o2 = n.GetCollisionEngine(), s2 = n.GetEventSheetManager(), i2 = s2.GetEventStack(), r2 = s2.GetCurrentCondition(), a2 = r2.GetObjectClass(), l2 = r2.GetSavedDataMap(), c2 = r2.GetUnsavedDataMap(), u = i2.GetCurrentStackFrame(), S = n.GetTickCount(), f2 = S - 1, G = u.GetCurrentEvent(), d2 = i2.Push(G);
        let I = l2.get("collmemory");
        I || (I = C33.New(C33.PairMap), l2.set("collmemory", I)), c2.get("collisionCreatedDestroyCallback") || (c2.set("collisionCreatedDestroyCallback", true), n.Dispatcher().addEventListener("instancedestroy", (t2) => CollMemory_RemoveInstance2(I, t2.instance)));
        const C = a2.GetCurrentSol(), h = t.GetCurrentSol(), m = C.GetInstances();
        let g = null;
        for (let e2 = 0; e2 < m.length; ++e2) {
          const n2 = m[e2];
          h.IsSelectAll() ? (o2.GetCollisionCandidates(n2.GetWorldInfo().GetLayer(), t, n2.GetWorldInfo().GetBoundingBox(), tempCandidates1), g = tempCandidates1, o2.AddRegisteredCollisionCandidates(n2, t, g)) : g = h.GetInstances();
          for (let e3 = 0; e3 < g.length; ++e3) {
            const i3 = g[e3];
            if (o2.TestOverlap(n2, i3) || o2.CheckRegisteredCollision(n2, i3)) {
              const e4 = CollMemory_Get2(I, n2, i3);
              let o3 = false, r3 = -2;
              "number" == typeof e4 && (o3 = true, r3 = e4);
              const l3 = !o3 || r3 < f2;
              if (CollMemory_Add2(I, n2, i3, S), l3) {
                const e5 = G.GetSolModifiers();
                s2.PushCopySol(e5);
                const o4 = a2.GetCurrentSol(), r4 = t.GetCurrentSol();
                if (o4._SetSelectAll(false), r4._SetSelectAll(false), a2 === t) {
                  const t2 = o4._GetOwnInstances();
                  C33.clearArray(t2), t2.push(n2), t2.push(i3), a2.ApplySolToContainer();
                } else {
                  const e6 = o4._GetOwnInstances(), s3 = r4._GetOwnInstances();
                  C33.clearArray(e6), C33.clearArray(s3), e6.push(n2), s3.push(i3), a2.ApplySolToContainer(), t.ApplySolToContainer();
                }
                G.Retrigger(u, d2), s2.PopSol(e5);
              }
            } else CollMemory_Remove2(I, n2, i3);
          }
          C33.clearArray(tempCandidates1);
        }
        return i2.Pop(), false;
      }, AnySDK.IsOverlapping = function(t) {
        return t = GetObjectClass2(t), DoOverlapCondition2(GetInst2(this), t, 0, 0);
      }, AnySDK.IsOverlappingOffset = function(t, e, n) {
        return t = GetObjectClass2(t), DoOverlapCondition2(GetInst2(this), t, e, n);
      }, AnySDK.OnHierarchyReady = function() {
        return true;
      }, AnySDK.HasParent = function() {
        return GetWorldInfo2(this).HasParent();
      }, AnySDK.HasChildren = function() {
        return GetWorldInfo2(this).HasChildren();
      }, AnySDK.PickParent = function(t, e) {
        const n = GetObjectClass2(this);
        t = GetObjectClass2(t);
        const o2 = n.GetRuntime(), s2 = this.GetCurrentSol().GetInstances();
        if (0 === s2.length) return false;
        const i2 = t.GetCurrentSol();
        let r2 = i2.GetInstances();
        if (i2.IsSelectAll()) {
          const e2 = [...o2.instancesPendingCreateForObjectClass(t)];
          e2.length > 0 && (r2 = r2.concat(e2));
        }
        if (0 === r2.length) return false;
        const a2 = i2.IsSelectAll() ? null : new Set(r2), l2 = /* @__PURE__ */ new Set();
        for (let n2 = 0, o3 = s2.length; n2 < o3; ++n2) {
          const o4 = s2[n2];
          if (1 === e) for (const e2 of o4.parents()) e2.BelongsToObjectClass(t) && (null === a2 || a2.has(e2)) && l2.add(e2);
          else {
            let n3;
            if (0 === e) {
              if (n3 = o4.GetParent(), null === n3) continue;
            } else n3 = o4.GetTopParent();
            n3.BelongsToObjectClass(t) && (null === a2 || a2.has(n3)) && l2.add(n3);
          }
        }
        return 0 !== l2.size && (i2.SetSetPicked(l2), t.ApplySolToContainer(), true);
      }, AnySDK.PickChildren = function(t, e) {
        const n = GetObjectClass2(this);
        t = GetObjectClass2(t);
        const o2 = n.GetRuntime(), s2 = n.GetCurrentSol().GetInstances();
        if (0 === s2.length) return false;
        const i2 = t.GetCurrentSol();
        let r2 = i2.GetInstances();
        if (i2.IsSelectAll()) {
          const e2 = [...o2.instancesPendingCreateForObjectClass(t)];
          e2.length > 0 && (r2 = r2.concat(e2));
        }
        if (0 === r2.length) return false;
        const a2 = i2.IsSelectAll() ? null : new Set(r2), l2 = /* @__PURE__ */ new Set();
        for (let n2 = 0, o3 = s2.length; n2 < o3; ++n2) {
          const o4 = s2[n2];
          2 !== e || o4.HasChildren() || !o4.BelongsToObjectClass(t) || null !== a2 && !a2.has(o4) || l2.add(o4);
          for (const n3 of 0 === e ? o4.children() : o4.allChildren()) 2 === e && n3.HasChildren() || n3.BelongsToObjectClass(t) && (null === a2 || a2.has(n3)) && l2.add(n3);
        }
        return 0 !== l2.size && (i2.SetSetPicked(l2), t.ApplySolToContainer(), true);
      }, AnySDK.PickNthChild = function(t, e, n) {
        const o2 = GetObjectClass2(this);
        t = GetObjectClass2(t);
        const s2 = o2.GetRuntime(), i2 = o2.GetCurrentSol().GetInstances();
        if (0 === i2.length) return false;
        const r2 = t.GetCurrentSol();
        let a2 = r2.GetInstances();
        if (r2.IsSelectAll()) {
          const e2 = [...s2.instancesPendingCreateForObjectClass(t)];
          e2.length > 0 && (a2 = a2.concat(e2));
        }
        if (0 === a2.length) return false;
        const l2 = r2.IsSelectAll() ? null : new Set(a2), c2 = [];
        for (let o3 = 0, s3 = i2.length; o3 < s3; ++o3) {
          const s4 = i2[o3];
          if (0 === e) {
            const e2 = s4.GetChildAt(n);
            null !== e2 && e2.BelongsToObjectClass(t) && (null === l2 || l2.has(e2)) && c2.push(e2);
          } else if (1 === e) {
            for (const e2 of s4.children()) if (e2.BelongsToObjectClass(t)) {
              if (0 === n) {
                (null === l2 || l2.has(e2)) && c2.push(e2);
                break;
              }
              --n;
            }
          }
        }
        return 0 !== c2.length && (r2.SetArrayPicked(c2), t.ApplySolToContainer(), true);
      }, AnySDK.CompareChildCount = function(t, e, n) {
        const o2 = GetInst2(this);
        switch (t) {
          case 0:
          default:
            return C33.compare(o2.GetChildCount(), e, n);
          case 1:
            return C33.compare(o2.GetAllChildCount(), e, n);
        }
      }, AnySDK.AddChild = function(t, e, n, o2, s2, i2, r2, a2, l2, c2) {
        t = GetObjectClass2(t);
        const u = GetInst2(this), S = runtime.GetCurrentAction().GetObjectClass();
        for (const f2 of t.allCorrespondingInstances(u, S)) {
          if (!f2.GetPlugin().SupportsSceneGraph()) return;
          u.AddChild(f2, { transformX: e, transformY: n, transformWidth: o2, transformHeight: s2, transformAngle: i2, transformOpacity: r2, transformZElevation: a2, transformVisibility: l2, destroyWithParent: c2 });
        }
      }, AnySDK.RemoveChild = function(t) {
        t = GetObjectClass2(t);
        const e = GetInst2(this), n = runtime.GetCurrentAction().GetObjectClass();
        for (const o2 of t.allCorrespondingInstances(e, n)) e.RemoveChild(o2);
      }, AnySDK.RemoveFromParent = function() {
        const t = GetInst2(this);
        if (!t.HasParent()) return;
        t.GetParent().RemoveChild(t);
      }, AnySDK.ParentUID = function() {
        const t = GetInst2(this).GetParent();
        return t ? t.GetUID() : -1;
      }, AnySDK.ChildCount = function() {
        return GetInst2(this).GetChildCount();
      }, AnySDK.AllChildCount = function() {
        return GetInst2(this).GetAllChildCount();
      }, AnySDK.SetMeshSize = function(t, e) {
        t = Math.floor(t), e = Math.floor(e);
        const n = GetWorldInfo2(this);
        t < 2 || e < 2 || !isFinite(t) || !isFinite(e) ? (n.ReleaseMesh(), n.SetBboxChanged()) : n.CreateMesh(t, e);
      }, AnySDK.SetMeshPoint = function(t, e, n, o2, s2, i2, r2, a2) {
        const l2 = GetWorldInfo2(this);
        l2.SetMeshPoint(t, e, { mode: 0 === n ? "absolute" : "relative", x: o2, y: s2, zElevation: i2, u: r2, v: a2 }) && l2.SetBboxChanged();
      }, AnySDK.MeshColumns = function() {
        const t = GetWorldInfo2(this);
        return t.HasMesh() ? t.GetSourceMesh().GetHSize() : 0;
      }, AnySDK.MeshRows = function() {
        const t = GetWorldInfo2(this);
        return t.HasMesh() ? t.GetSourceMesh().GetVSize() : 0;
      }, AnySDK.SetElementVisible = function(t) {
        const e = GetWorldInfo2(this);
        t = 2 === t ? !e.IsVisible() : 0 !== t, e.IsVisible() !== t && e.SetVisible(t);
      }, AnySDK.SetElementCSSStyle = function(t, e) {
        this instanceof self.IInstance ? this.setElementCSSStyle(t, e) : this.SetElementCSSStyle(t, e);
      }, AnySDK.SetElementAttribute = function(t, e) {
        this instanceof self.IInstance ? this.setElementAttribute(t, "" + e) : this.SetElementAttribute(t, "" + e);
      }, AnySDK.RemoveElementAttribute = function(t) {
        this instanceof self.IInstance ? this.removeElementAttribute(t) : this.RemoveElementAttribute(t);
      }, AnySDK.SetElementFocus = function() {
        this instanceof self.IInstance ? this.focusElement() : this.FocusElement();
      }, AnySDK.SetElementBlur = function() {
        this instanceof self.IInstance ? this.blurElement() : this.BlurElement();
      }, AnySDK.IsElementFocused = function() {
        return this instanceof self.IInstance ? this.isElementFocused() : this.IsElementFocused();
      }, AnySDK.SetElementEnabled = function(t) {
        this instanceof self.IInstance ? this._setEnabled(0 !== t) : this._SetEnabled(0 !== t);
      }, AnySDK.IsElementEnabled = function() {
        return this instanceof self.IInstance ? this._isEnabled() : this._IsEnabled();
      }, SDKv1.CompareInstanceVar = function(t, e, n) {
        return C33.compare(this.GetInstance().GetInstanceVariableValue(t), e, n);
      }, SDKv2.CompareInstanceVar = function(t, e, n) {
        return C33.compare(GetInst_SDKv22(this).GetInstanceVariableValue(t), e, n);
      }, SDKv1.IsBoolInstanceVarSet = function(t) {
        return !!this.GetInstance().GetInstanceVariableValue(t);
      }, SDKv2.IsBoolInstanceVarSet = function(t) {
        return !!GetInst_SDKv22(this).GetInstanceVariableValue(t);
      }, AnySDK.PickInstVarHiLow = function(t, e) {
        const n = GetObjectClass2(this), o2 = n.GetCurrentSol(), s2 = o2.GetInstances();
        if (!s2.length) return false;
        const i2 = n.IsFamily();
        let r2 = null, a2 = 0;
        for (let o3 = 0, l2 = s2.length; o3 < l2; ++o3) {
          const l3 = s2[o3], c2 = i2 ? l3.GetObjectClass().GetFamilyInstanceVariableOffset(n.GetFamilyIndex()) : 0, u = l3.GetInstanceVariableValue(c2 + e);
          (null === r2 || 0 === t && u < a2 || 1 === t && u > a2) && (a2 = u, r2 = l3);
        }
        return o2.PickOne(r2), true;
      }, AnySDK.PickByUID = function(t) {
        const e = GetObjectClass2(this);
        return e.GetRuntime().GetCurrentCondition().IsInverted() ? PickByUID_Inverted2(e, t) : PickByUID_Normal2(e, t);
      }, AnySDK.HasTags = function(t) {
        const e = new Set(C33.splitStringAndNormalize(t)), n = GetInst2(this).GetTagsSet();
        return e.isSubsetOf(n);
      }, AnySDK.Tags = function() {
        return GetInst2(this).GetTagsString();
      }, AnySDK.TagsCount = function() {
        return GetInst2(this).GetTagsSet().size;
      }, AnySDK.TagAt = function(t) {
        return GetInst2(this).GetTagAt(t);
      }, AnySDK.ChangeTags = function(t, e) {
        const n = C33.splitStringAndNormalize(e);
        if (0 === n.length) return;
        const o2 = GetInst2(this), s2 = new Set(o2.GetTagsSet());
        if (0 === t) for (const t2 of n) s2.add(t2);
        else if (1 === t) for (const t2 of n) s2.delete(t2);
        o2.SetTagsSet(s2);
      }, AnySDK.Destroy = function() {
        runtime.DestroyInstance(GetInst2(this));
      }, AnySDK.OnCreated = function() {
        return true;
      }, AnySDK.OnDestroyed = function() {
        return true;
      }, SDKv1.SetInstanceVar = function(t, e) {
        this.GetInstance().SetInstanceVariableValue(t, e);
      }, SDKv2.SetInstanceVar = function(t, e) {
        GetInst_SDKv22(this).SetInstanceVariableValue(t, e);
      }, SDKv1.AddInstanceVar = function(t, e) {
        const n = this.GetInstance(), o2 = n.GetInstanceVariableValue(t);
        "number" == typeof o2 && "number" != typeof e ? e = parseFloat(e) : "string" == typeof o2 && "string" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t, o2 + e);
      }, SDKv2.AddInstanceVar = function(t, e) {
        const n = GetInst_SDKv22(this), o2 = n.GetInstanceVariableValue(t);
        "number" == typeof o2 && "number" != typeof e ? e = parseFloat(e) : "string" == typeof o2 && "string" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t, o2 + e);
      }, SDKv1.SubInstanceVar = function(t, e) {
        const n = this.GetInstance(), o2 = n.GetInstanceVariableValue(t);
        "number" == typeof o2 && ("number" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t, o2 - e));
      }, SDKv2.SubInstanceVar = function(t, e) {
        const n = GetInst_SDKv22(this), o2 = n.GetInstanceVariableValue(t);
        "number" == typeof o2 && ("number" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t, o2 - e));
      }, SDKv1.SetBoolInstanceVar = function(t, e) {
        this.GetInstance().SetInstanceVariableValue(t, e ? 1 : 0);
      }, SDKv2.SetBoolInstanceVar = function(t, e) {
        GetInst_SDKv22(this).SetInstanceVariableValue(t, e ? 1 : 0);
      }, SDKv1.ToggleBoolInstanceVar = function(t) {
        const e = this.GetInstance();
        e.SetInstanceVariableValue(t, 0 === e.GetInstanceVariableValue(t) ? 1 : 0);
      }, SDKv2.ToggleBoolInstanceVar = function(t) {
        const e = GetInst_SDKv22(this);
        e.SetInstanceVariableValue(t, 0 === e.GetInstanceVariableValue(t) ? 1 : 0);
      }, AnySDK.LoadFromJsonString = function(t) {
        let e;
        try {
          e = JSON.parse(t);
        } catch (t2) {
          return void console.error("Failed to load from JSON string: ", t2);
        }
        const n = GetInst2(this), o2 = "state";
        runtime.ClearIntancesNeedingAfterLoad(), n._OnBeforeLoad(o2), n.LoadFromJson(e, o2), runtime.DoAfterLoad(o2, { setFromJson: true });
      }, AnySDK.AsJSON = function() {
        return JSON.stringify(GetInst2(this).SaveToJson("state"));
      }, AnySDK.ObjectTypeName = function() {
        return GetInst2(this).GetObjectClass().GetName();
      }, AnySDK.Count = function() {
        const t = runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();
        let e = t.GetInstanceCount();
        for (const n of runtime.instancesPendingCreateForObjectClass(t)) ++e;
        return e;
      }, AnySDK.PickedCount = function() {
        return runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length;
      }, SDKv1.GetIID = function() {
        return this.GetInstance().GetIID();
      }, SDKv2.GetIID = function() {
        return GetInst_SDKv22(this).GetIID();
      }, SDKv1.GetUID = function() {
        return this.GetInstance().GetUID();
      }, SDKv2.GetUID = function() {
        return GetInst_SDKv22(this).GetUID();
      }, AnySDK.OnInstanceSignal = function(t) {
        const e = GetInst2(this);
        return t.toLowerCase() === runtime.GetEventSheetManager().GetCurrentInstanceSignalTag(e);
      }, AnySDK.InstanceSignal = function(t) {
        const e = GetInst2(this);
        runtime.GetEventSheetManager().InstanceSignal(e, t);
      }, AnySDK.InstanceWaitForSignal = function(t) {
        const e = GetObjectClass2(this);
        return runtime.GetEventSheetManager().AddScheduledWait().InitInstanceSignals(e.GetCurrentSol().GetInstances(), t), true;
      }, AnySDK.TemplateName = function() {
        return GetInst2(this).GetTemplateName();
      }, C33.AddCommonACEs = function(t, e, n) {
        const o2 = t[1], s2 = t[3], i2 = t[4], r2 = t[5], a2 = t[6], l2 = t[7], c2 = t[8], u = t[10], S = t[11], f2 = t[12], G = t[13], d2 = t[14], I = t[15], C = t[16], h = e.Cnds, m = e.Acts, g = e.Exps, y = Object.assign({}, AnySDK, n >= 2 ? SDKv2 : SDKv1);
        s2 && (h.CompareX = y.CompareX, h.CompareY = y.CompareY, h.IsOnScreen = y.IsOnScreen, h.IsOutsideLayout = y.IsOutsideLayout, h.PickDistance = y.PickDistance, m.SetX = y.SetX, m.SetY = y.SetY, m.SetPos = y.SetPos, m.SetPosToObject = y.SetPosToObject, m.MoveForward = y.MoveForward, m.MoveAtAngle = y.MoveAtAngle, g.X = y.GetX, g.Y = y.GetY, g.dt = y.GetDt), i2 && (h.CompareWidth = y.CompareWidth, h.CompareHeight = y.CompareHeight, m.SetWidth = y.SetWidth, m.SetHeight = y.SetHeight, m.SetSize = y.SetSize, g.Width = y.GetWidth, g.Height = y.GetHeight, g.BBoxLeft = y.GetBboxLeft, g.BBoxTop = y.GetBboxTop, g.BBoxRight = y.GetBboxRight, g.BBoxBottom = y.GetBboxBottom, g.BBoxMidX = y.GetBboxMidX, g.BBoxMidY = y.GetBboxMidY), r2 && (h.AngleWithin = y.IsAngleWithin, h.IsClockwiseFrom = y.IsAngleClockwiseFrom, h.IsBetweenAngles = y.IsBetweenAngles, m.SetAngle = y.SetAngle, m.RotateClockwise = y.RotateClockwise, m.RotateCounterclockwise = y.RotateCounterclockwise, m.RotateTowardAngle = y.RotateTowardAngle, m.RotateTowardPosition = y.RotateTowardPosition, m.SetTowardPosition = y.SetTowardPosition, g.Angle = y.GetAngle), a2 && (h.IsVisible = y.IsVisible, h.CompareOpacity = y.CompareOpacity, m.SetVisible = y.SetVisible, m.SetOpacity = y.SetOpacity, m.SetDefaultColor = y.SetDefaultColor, g.Opacity = y.GetOpacity, g.ColorValue = y.GetColor), l2 && (h.IsOnLayer = y.IsOnLayer, h.PickTopBottom = y.PickTopBottom, h.CompareZElevation = y.CompareZElevation, m.MoveToTop = y.MoveToTop, m.MoveToBottom = y.MoveToBottom, m.MoveToLayer = y.MoveToLayer, m.ZMoveToObject = y.ZMoveToObject, m.SetZElevation = y.SetZElevation, g.LayerNumber = y.LayerNumber, g.LayerName = y.LayerName, g.ZIndex = y.ZIndex, g.ZElevation = y.ZElevation, g.TotalZElevation = y.TotalZElevation), c2 && (h.IsEffectEnabled = y.IsEffectEnabled, m.SetEffectEnabled = y.SetEffectEnabled, m.SetEffectParam = y.SetEffectParam), G && (h.OnHierarchyReady = y.OnHierarchyReady, h.HasParent = y.HasParent, h.HasChildren = y.HasChildren, h.PickParent = y.PickParent, h.PickChildren = y.PickChildren, h.PickNthChild = y.PickNthChild, h.CompareChildCount = y.CompareChildCount, m.AddChild = y.AddChild, m.RemoveChild = y.RemoveChild, m.RemoveFromParent = y.RemoveFromParent, g.ParentUID = y.ParentUID, g.ChildCount = y.ChildCount, g.AllChildCount = y.AllChildCount), d2 && (m.SetMeshSize = y.SetMeshSize, m.SetMeshPoint = y.SetMeshPoint, g.MeshColumns = y.MeshColumns, g.MeshRows = y.MeshRows), u && (h.IsVisible = y.IsVisible, m.SetVisible = y.SetElementVisible, m.SetCSSStyle = y.SetElementCSSStyle, m.SetElemAttribute = y.SetElementAttribute, m.RemoveElemAttribute = y.RemoveElementAttribute), S && (h.IsFocused = y.IsElementFocused, m.SetFocus = y.SetElementFocus, m.SetBlur = y.SetElementBlur), f2 && (h.IsEnabled = y.IsElementEnabled, m.SetEnabled = y.SetElementEnabled), I && (h.OnCollision = y.OnCollision, h.IsOverlapping = y.IsOverlapping, h.IsOverlappingOffset = y.IsOverlappingOffset, e.FinishCollisionCondition = FinishCollisionCondition2), o2 || (h.CompareInstanceVar = y.CompareInstanceVar, h.IsBoolInstanceVarSet = y.IsBoolInstanceVarSet, h.PickInstVarHiLow = y.PickInstVarHiLow, h.PickByUID = y.PickByUID, h.HasTags = y.HasTags, m.SetInstanceVar = y.SetInstanceVar, m.AddInstanceVar = y.AddInstanceVar, m.SubInstanceVar = y.SubInstanceVar, m.SetBoolInstanceVar = y.SetBoolInstanceVar, m.ToggleBoolInstanceVar = y.ToggleBoolInstanceVar, m.ChangeTags = y.ChangeTags, h.OnCreated = y.OnCreated, h.OnDestroyed = y.OnDestroyed, m.Destroy = y.Destroy, m.LoadFromJsonString || (m.LoadFromJsonString = y.LoadFromJsonString), g.AsJSON || (g.AsJSON = y.AsJSON), g.Count = y.Count, g.PickedCount = y.PickedCount, g.IID = y.GetIID, g.UID = y.GetUID, g.ObjectTypeName = y.ObjectTypeName, g.Tags = y.Tags, g.TagsCount = y.TagsCount, g.TagAt = y.TagAt, h.OnInstanceSignal = y.OnInstanceSignal, m.InstanceSignal = y.InstanceSignal, m.InstanceWaitForSignal = y.InstanceWaitForSignal), C && (g.TemplateName = y.TemplateName);
      };
    }
    var GetInst;
    var GetWorldInfo;
    var GetInst_SDKv2;
    var GetWorldInfo_SDKv2;
    var GetObjectClass;
    var GetLayer;
    var CollMemory_Add;
    var CollMemory_Remove;
    var CollMemory_RemoveInstance;
    var CollMemory_Get;
    var DoOverlapCondition;
    var FinishCollisionConditionPicking;
    var FinishCollisionCondition;
    var PickByUID_Normal;
    var PickByUID_Inverted;
    {
      const C33 = self.C3;
      C33.ScheduledWait = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._eventSheetManager = t, this._type = "", this._time = -1, this._signalTag = "", this._isSignalled = false, this._event = null, this._actIndex = 0, this._solModifiers = [], this._dynamicSolModifiers = null, this._sols = /* @__PURE__ */ new Map(), this._pendingInstances = null, this._callingFunctionBlock = null, this._asyncId = -1, this._functionParameters = null, this._functionInnerLocalVars = null, this._shouldRelease = false;
        }
        Release() {
          this._type = "", this._time = -1, this._signalTag = "", this._event = null, this._callingFunctionBlock = null, this._functionParameters = null, this._functionInnerLocalVars = null, this._asyncId = -1, C33.clearArray(this._solModifiers), this._dynamicSolModifiers && (this._dynamicSolModifiers.clear(), this._dynamicSolModifiers = null);
          for (const t of this._sols.values()) t.Release();
          this._sols.clear(), this._pendingInstances = null;
        }
        _Init() {
          const t = this._eventSheetManager, e = t.GetRuntime().GetAllObjectClasses(), s2 = t.GetCurrentEventStackFrame();
          this._event = s2.GetCurrentEvent(), this._actIndex = s2.GetActionIndex() + 1;
          const i2 = t.FindFirstFunctionBlockParent(this._event);
          i2 && (this._callingFunctionBlock = i2, this._functionParameters = i2.CaptureFunctionParameters(), this._functionInnerLocalVars = i2._GetAllInnerLocalVariables().map((t2) => t2.GetValue()), i2.IsAsync() && (this._asyncId = i2.PauseCurrentAsyncFunction()));
          for (const t2 of e) {
            const e2 = t2.GetCurrentSol();
            e2.IsSelectAll() && !this._event.HasSolModifier(t2) || (this._solModifiers.push(t2), this._sols.set(t2, C33.New(C33.SolState, e2)));
          }
          const n = t.GetDynamicSolModifiersSet();
          this._dynamicSolModifiers = n.size > 0 ? n : null;
        }
        InitTimer(t) {
          this._type = "timer", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetGameTime() + t;
        }
        InitWallTimer(t) {
          this._type = "walltimer", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetWallTime() + t;
        }
        InitSignal(t) {
          this._type = "signal", this._Init(), this._signalTag = t.toLowerCase();
        }
        InitInstanceSignals(t, e) {
          this._type = "instance-signals", this._Init(), this._signalTag = e.toLowerCase(), this._pendingInstances = new Set(t);
        }
        InitPromise(t) {
          this._type = "promise", this._Init(), t.then(() => this.SetSignalled()).catch((t2) => {
            console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", t2), this.SetSignalled();
          });
        }
        IsTimer() {
          return "timer" === this._type;
        }
        IsWallTimer() {
          return "walltimer" === this._type;
        }
        IsSignal() {
          return "signal" === this._type;
        }
        IsInstanceSignals() {
          return "instance-signals" === this._type;
        }
        IsPromise() {
          return "promise" === this._type;
        }
        GetSignalTag() {
          return this._signalTag;
        }
        IsSignalled() {
          return this._isSignalled;
        }
        SetSignalled() {
          this._isSignalled = true;
        }
        SetInstanceSignalled(t) {
          this._pendingInstances.delete(t), 0 === this._pendingInstances.size && this.SetSignalled();
        }
        _ShouldRun() {
          return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsWallTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetWallTime() : this.IsSignalled();
        }
        _RestoreState(t) {
          t._Restore(this._event, this._actIndex);
          for (const [t2, e2] of this._sols.entries()) {
            const s2 = t2.GetCurrentSol();
            e2._Restore(s2);
          }
          this._dynamicSolModifiers && t.SetDynamicSolModifiers([...this._dynamicSolModifiers]);
          const e = this._callingFunctionBlock;
          e && (e.SetFunctionParameters(this._functionParameters), e._GetAllInnerLocalVariables().map((t2, e2) => t2.SetValue(this._functionInnerLocalVars[e2])), e.IsAsync() && e.ResumeAsyncFunction(this._asyncId));
        }
        _Run(t) {
          this._RestoreState(t), this._event._ResumeActionsAndSubEvents(t), this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;
        }
        async _DebugRun(t) {
          this._RestoreState(t);
          for (const e of this._event._DebugResumeActionsAndSubEvents(t)) await this._eventSheetManager.GetRuntime().DebugBreak(e);
          this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;
        }
        ShouldRelease() {
          return this._shouldRelease;
        }
        RemoveInstances(t) {
          for (const e of this._sols.values()) e.RemoveInstances(t);
          if ("instance-signals" === this._type) {
            for (const e of t) this._pendingInstances.delete(e);
            0 === this._pendingInstances.size && this.SetSignalled();
          }
        }
        _SaveToJson() {
          const t = {}, e = { "wt": this._type, "t": this._time, "st": this._signalTag, "s": this._isSignalled, "ev": this._event.GetSID(), "sm": this._solModifiers.map((t2) => t2.GetSID()), "dsm": this._dynamicSolModifiers ? [...this._dynamicSolModifiers].map((t2) => t2.GetSID()) : null, "sols": t };
          this._event._HasActionIndex(this._actIndex) && (e["act"] = this._event.GetActionAt(this._actIndex).GetSID());
          for (const [e2, s2] of this._sols) t[e2.GetSID().toString()] = s2._SaveToJson();
          return "instance-signals" === this._type && (e["pi"] = [...this._pendingInstances].map((t2) => t2.GetUID())), e;
        }
        static _CreateFromJson(t, e) {
          const s2 = t.GetRuntime(), i2 = t.GetEventBlockBySID(e["ev"]);
          if (!i2) return null;
          let n = 0;
          if (e.hasOwnProperty("act")) {
            const s3 = t.GetActionBySID(e["act"]);
            if (!s3) return null;
            n = s3.GetIndex();
          }
          const a2 = C33.New(C33.ScheduledWait, t);
          a2._time = e["t"], e.hasOwnProperty("wt") ? a2._type = e["wt"] : a2._type = -1 === a2._time ? "signal" : "timer", a2._signalTag = e["st"], a2._isSignalled = e["s"], a2._event = i2, a2._actIndex = n;
          for (const t2 of e["sm"]) {
            const e2 = s2.GetObjectClassBySID(t2);
            e2 && a2._solModifiers.push(e2);
          }
          if (Array.isArray(e["dsm"])) for (const t2 of e["dsm"]) {
            const e2 = s2.GetObjectClassBySID(t2);
            e2 && (a2._dynamicSolModifiers || (a2._dynamicSolModifiers = /* @__PURE__ */ new Set()), a2._dynamicSolModifiers.add(e2));
          }
          for (const [i3, n2] of Object.entries(e["sols"])) {
            const e2 = parseInt(i3, 10), l2 = s2.GetObjectClassBySID(e2);
            if (!l2) continue;
            const o2 = C33.New(C33.SolState, null);
            o2._LoadFromJson(t, n2), a2._sols.set(l2, o2);
          }
          if ("instance-signals" === a2._type) {
            a2._pendingInstances = /* @__PURE__ */ new Set();
            for (const t2 of e["pi"]) {
              const e2 = s2.GetInstanceByUID(t2);
              e2 && a2._pendingInstances.add(e2);
            }
          }
          return a2;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SolState = class extends C33.DefendedBase {
        constructor(s2) {
          super(), this._objectClass = null, this._isSelectAll = true, this._instances = [], s2 && (this._objectClass = s2.GetObjectClass(), this._isSelectAll = s2.IsSelectAll(), C33.shallowAssignArray(this._instances, s2._GetOwnInstances()));
        }
        Release() {
          this._objectClass = null, C33.clearArray(this._instances);
        }
        _Restore(s2) {
          s2._SetSelectAll(this._isSelectAll), C33.shallowAssignArray(s2._GetOwnInstances(), this._instances);
        }
        RemoveInstances(s2) {
          C33.arrayRemoveAllInSet(this._instances, s2);
        }
        _SaveToJson() {
          return { "sa": this._isSelectAll, "insts": this._instances.map((s2) => s2.GetUID()) };
        }
        _LoadFromJson(s2, e) {
          const t = s2.GetRuntime();
          this._isSelectAll = !!e["sa"], C33.clearArray(this._instances);
          for (const s3 of e["insts"]) {
            const e2 = t.GetInstanceByUID(s3);
            e2 && this._instances.push(e2);
          }
        }
      };
    }
    {
      let GetNextParamMap2 = function(t, e) {
        let s2 = t.get(e);
        return s2 || (s2 = /* @__PURE__ */ new Map(), t.set(e, s2)), s2;
      };
      GetNextParamMap = GetNextParamMap2;
      const C33 = self.C3;
      C33.SDKPluginBase = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._runtime = t.runtime, this._id = t.id, this._name = t.name ?? "", this._isSingleGlobal = !!t.isSingleGlobal, this._isWorldType = !!t.isWorld, this._isRotatable = !!t.isRotatable, this._mustPredraw = !!t.mustPredraw, this._hasEffects = !!t.hasEffects, this._supportsSceneGraph = !!t.supportsSceneGraph, this._supportsMesh = !!t.supportsMesh, this._isHTMLElementType = !!t.isHTMLElementType, this._is3d = !!t.is3d, this._sdkVersion = t.sdkVersion, this._singleGlobalObjectClass = null, this._boundACEMethodCache = /* @__PURE__ */ new Map(), this._boundACEMethodCache_1param = /* @__PURE__ */ new Map(), this._boundACEMethodCache_2params = /* @__PURE__ */ new Map(), this._boundACEMethodCache_3params = /* @__PURE__ */ new Map(), this._scriptInterfaceClass = t.scriptInterfaceClass, this._iPlugin = null;
        }
        Release() {
          this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetID() {
          return this._id;
        }
        GetName() {
          return this._name;
        }
        OnCreate() {
        }
        GetConstructor() {
          return this.GetSdkVersion() >= 2 ? this._iPlugin.constructor : this.constructor;
        }
        GetSdkVersion() {
          return this._sdkVersion;
        }
        GetScriptInterfaceClass(t = false) {
          let e = this._scriptInterfaceClass;
          return t && "function" != typeof e && this.GetSdkVersion() >= 2 && (e = globalThis.ISDKPluginBase), e;
        }
        IsSingleGlobal() {
          return this._isSingleGlobal;
        }
        IsWorldType() {
          return this._isWorldType;
        }
        IsHTMLElementType() {
          return this._isHTMLElementType;
        }
        Is3D() {
          return this._is3d;
        }
        IsRotatable() {
          return this._isRotatable;
        }
        MustPreDraw() {
          return this._mustPredraw;
        }
        HasEffects() {
          return this._hasEffects;
        }
        SupportsSceneGraph() {
          return this._supportsSceneGraph;
        }
        SupportsMesh() {
          return this._supportsMesh;
        }
        _GetBoundACEMethod(t, e) {
          if (!e) throw new Error("missing 'this' binding");
          let s2 = this._boundACEMethodCache.get(t);
          return s2 || (s2 = t.bind(e), this._boundACEMethodCache.set(t, s2), s2);
        }
        _GetBoundACEMethod_1param(t, e, s2) {
          if (!e) throw new Error("missing 'this' binding");
          const i2 = GetNextParamMap2(this._boundACEMethodCache_1param, t);
          let n = i2.get(s2);
          return n || (n = t.bind(e, s2), i2.set(s2, n), n);
        }
        _GetBoundACEMethod_2params(t, e, s2, i2) {
          if (!e) throw new Error("missing 'this' binding");
          const n = GetNextParamMap2(this._boundACEMethodCache_2params, t), r2 = GetNextParamMap2(n, s2);
          let a2 = r2.get(i2);
          return a2 || (a2 = t.bind(e, s2, i2), r2.set(i2, a2), a2);
        }
        _GetBoundACEMethod_3params(t, e, s2, i2, n) {
          if (!e) throw new Error("missing 'this' binding");
          const r2 = GetNextParamMap2(this._boundACEMethodCache_3params, t), a2 = GetNextParamMap2(r2, s2), l2 = GetNextParamMap2(a2, i2);
          let o2 = l2.get(n);
          return o2 || (o2 = t.bind(e, s2, i2, n), l2.set(n, o2), o2);
        }
        _SetSingleGlobalObjectClass(t) {
          if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
          this._singleGlobalObjectClass = t;
        }
        GetSingleGlobalObjectClass() {
          if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
          return this._singleGlobalObjectClass;
        }
        GetSingleGlobalInstance() {
          if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
          return this._singleGlobalObjectClass.GetSingleGlobalInstance();
        }
        _InitScriptInterface() {
          const t = this.GetSdkVersion();
          C33.AddonManager._PushInitObject(this, t);
          const e = this.GetScriptInterfaceClass(true);
          if (e) {
            if (this._iPlugin = new e(), !(this._iPlugin instanceof self.IPlugin)) throw new TypeError("plugin class must derive from IPlugin");
          } else this._iPlugin = new self.IPlugin();
          C33.AddonManager._PopInitObject(t);
        }
        GetIPlugin() {
          return this._iPlugin;
        }
      };
    }
    var GetNextParamMap;
    {
      const C33 = self.C3;
      C33.SDKDOMPluginBase = class extends C33.SDKPluginBase {
        constructor(e, s2) {
          super(e), this._domComponentId = s2, this._nextElementId = 0, this._instMap = /* @__PURE__ */ new Map(), this.AddElementMessageHandler("elem-focused", (e2) => e2._OnElemFocused()), this.AddElementMessageHandler("elem-blurred", (e2) => {
            e2 && e2._OnElemBlurred();
          });
        }
        Release() {
          super.Release();
        }
        _AddElement(e) {
          const s2 = this._nextElementId++;
          return this._instMap.set(s2, e), s2;
        }
        _RemoveElement(e) {
          this._instMap.delete(e);
        }
        AddElementMessageHandler(e, s2) {
          this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, (e2) => {
            const t = this._instMap.get(e2["elementId"]);
            s2(t, e2);
          });
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SDKTypeBase = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();
        }
        Release() {
          this._objectClass = null, this._runtime = null, this._plugin = null;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetPlugin() {
          return this._plugin;
        }
        GetImageInfo() {
          return this._objectClass.GetImageInfo();
        }
        OnCreate() {
        }
        FinishCondition(e) {
        }
        BeforeRunAction(e) {
        }
        AfterRunAction(e) {
        }
        LoadTextures(e) {
        }
        ReleaseTextures() {
        }
        OnDynamicTextureLoadComplete() {
        }
        PreloadTexturesWithInstances(e) {
        }
        LoadTilemapData() {
        }
        GetScriptInterfaceClass() {
          return null;
        }
        DispatchScriptEvent(e, t, s2) {
          const n = C33.New(C33.Event, e, t);
          n.objectClass = this, s2 && Object.assign(n, s2), this.GetObjectClass().DispatchUserScriptEvent(n);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SDKInstanceBase = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._inst = e, this._domComponentId = t, this._wrapperComponentId = null, this._runtime = e.GetRuntime(), this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._tickFunc = null, this._tick2Func = null, this._isTicking = false, this._isTicking2 = false, this._disposables = null, this._wasReleased = false;
        }
        Release() {
          this._wasReleased = true, this._StopTicking(), this._StopTicking2(), this._tickFunc = null, this._tick2Func = null, this._disposables && (this._disposables.Release(), this._disposables = null), this._inst = null, this._runtime = null, this._objectClass = null, this._sdkType = null;
        }
        WasReleased() {
          return this._wasReleased;
        }
        GetInstance() {
          return this._inst;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetPlugin() {
          return this._sdkType.GetPlugin();
        }
        GetSdkType() {
          return this._sdkType;
        }
        GetScriptInterface() {
          return this._inst.GetInterfaceClass();
        }
        Trigger(e) {
          return this._runtime.Trigger(e, this._inst, null);
        }
        DebugTrigger(e) {
          return this._runtime.DebugTrigger(e, this._inst, null);
        }
        TriggerAsync(e) {
          return this._runtime.TriggerAsync(e, this._inst, null);
        }
        FastTrigger(e, t) {
          return this._runtime.FastTrigger(e, this._inst, t);
        }
        DebugFastTrigger(e, t) {
          return this._runtime.DebugFastTrigger(e, this._inst, t);
        }
        ScheduleTriggers(e) {
          return this._runtime.ScheduleTriggers(e);
        }
        AddDOMMessageHandler(e, t) {
          this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, t);
        }
        AddDOMMessageHandlers(e) {
          for (const [t, i2] of e) this.AddDOMMessageHandler(t, i2);
        }
        PostToDOM(e, t) {
          this._runtime.PostComponentMessageToDOM(this._domComponentId, e, t);
        }
        PostToDOMAsync(e, t) {
          return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, e, t);
        }
        _PostToDOMMaybeSync(e, t) {
          if (!this._runtime.IsInWorker()) return window["c3_runtimeInterface"]["_OnMessageFromRuntime"]({ "type": "event", "component": this._domComponentId, "handler": e, "data": t, "responseId": null });
          this.PostToDOM(e, t);
        }
        SetWrapperExtensionComponentId(e) {
          if (!e) throw new Error("cannot set empty component id");
          this._wrapperComponentId = e;
        }
        IsWrapperExtensionAvailable() {
          if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
          return this._runtime.HasWrapperComponentId(this._wrapperComponentId);
        }
        AddWrapperExtensionMessageHandler(e, t) {
          if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
          this._runtime.AddWrapperExtensionMessageHandler(this._wrapperComponentId, e, t);
        }
        AddWrapperExtensionMessageHandlers(e) {
          for (const [t, i2] of e) this.AddWrapperExtensionMessageHandler(t, i2);
        }
        SendWrapperExtensionMessage(e, t) {
          if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
          this._runtime.SendWrapperExtensionMessage(this._wrapperComponentId, e, t);
        }
        SendWrapperExtensionMessageAsync(e, t) {
          if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
          return this._runtime.SendWrapperExtensionMessageAsync(this._wrapperComponentId, e, t);
        }
        Tick() {
        }
        Tick2() {
        }
        _StartTicking() {
          if (!this._isTicking) {
            if (!this._tickFunc) if (this._runtime.IsDebug()) {
              const e = globalThis.C3Debugger, t = this.GetPlugin();
              this._tickFunc = () => {
                const i2 = performance.now();
                this.Tick(), e.AddIndividualPluginTickTime(t, performance.now() - i2);
              };
            } else this._tickFunc = () => this.Tick();
            this._runtime.Dispatcher().addEventListener("tick", this._tickFunc), this._isTicking = true;
          }
        }
        _StopTicking() {
          this._isTicking && (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc), this._isTicking = false);
        }
        IsTicking() {
          return this._isTicking;
        }
        _StartTicking2() {
          if (!this._isTicking2) {
            if (!this._tick2Func) if (this._runtime.IsDebug()) {
              const e = globalThis.C3Debugger, t = this.GetPlugin();
              this._tick2Func = () => {
                const i2 = performance.now();
                this.Tick2(), e.AddIndividualPluginTickTime(t, performance.now() - i2);
              };
            } else this._tick2Func = () => this.Tick2();
            this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func), this._isTicking2 = true;
          }
        }
        _StopTicking2() {
          this._isTicking2 && (this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func), this._isTicking2 = false);
        }
        IsTicking2() {
          return this._isTicking2;
        }
        GetDebuggerProperties() {
          return [];
        }
        SaveToJson() {
          return null;
        }
        LoadFromJson(e) {
        }
        GetPropertyValueByIndex(e) {
        }
        SetPropertyValueByIndex(e, t) {
        }
        OffsetPropertyValueByIndex(e, t, i2) {
          if (0 === t) return;
          const n = this.GetPropertyValueByIndex(e);
          if ("number" != typeof n) throw new Error("expected number");
          this.SetPropertyValueByIndex(e, n + t, i2);
        }
        SetPropertyColorOffsetValueByIndex(e, t, i2, n) {
        }
        CallAction(e, ...t) {
          e.call(this, ...t);
        }
        CallExpression(e, ...t) {
          return e.call(this, ...t);
        }
        GetScriptInterfaceClass() {
          return null;
        }
        DispatchScriptEvent(e, t, i2) {
          if (!this._inst.HasScriptInterface()) return;
          const n = this.GetScriptInterface(), s2 = C33.New(C33.Event, e, t);
          s2.instance = n, i2 && Object.assign(s2, i2), n.dispatchEvent(s2);
        }
        MustPreDraw() {
          return false;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SDKWorldInstanceBase = class extends C33.SDKInstanceBase {
        constructor(e, t) {
          super(e, t), this._worldInfo = e.GetWorldInfo(), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;
        }
        Release() {
          if (this._renderercontextlost_handler) {
            const e = this._runtime.Dispatcher();
            e.removeEventListener("renderercontextlost", this._renderercontextlost_handler), e.removeEventListener("renderercontextrestored", this._renderercontextrestored_handler), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;
          }
          this._worldInfo = null, super.Release();
        }
        HandleWebGLContextLoss() {
          this.HandleRendererContextLoss();
        }
        OnWebGLContextLost() {
        }
        OnWebGLContextRestored() {
        }
        HandleRendererContextLoss() {
          if (this._renderercontextlost_handler) return;
          this._renderercontextlost_handler = () => this.OnRendererContextLost(), this._renderercontextrestored_handler = () => this.OnRendererContextRestored();
          const e = this._runtime.Dispatcher();
          e.addEventListener("renderercontextlost", this._renderercontextlost_handler), e.addEventListener("renderercontextrestored", this._renderercontextrestored_handler);
        }
        OnRendererContextLost() {
          this.OnWebGLContextLost();
        }
        OnRendererContextRestored() {
          this.OnWebGLContextRestored();
        }
        GetWorldInfo() {
          return this._worldInfo;
        }
        IsOriginalSizeKnown() {
          return false;
        }
        GetOriginalWidth() {
          if (!this.IsOriginalSizeKnown()) throw new Error("original size not known");
          const e = this.GetCurrentImageInfo();
          if (e) return e.GetWidth();
        }
        GetOriginalHeight() {
          if (!this.IsOriginalSizeKnown()) throw new Error("original size not known");
          const e = this.GetCurrentImageInfo();
          if (e) return e.GetHeight();
        }
        GetCurrentImageInfo() {
          return null;
        }
        GetCurrentSurfaceSize() {
          const e = this.GetCurrentImageInfo();
          if (e) {
            const t = e.GetTexture();
            if (t) return [t.GetWidth(), t.GetHeight()];
          }
          return [100, 100];
        }
        GetCurrentTexRect() {
          const e = this.GetCurrentImageInfo();
          return e ? e.GetTexRect() : null;
        }
        GetCurrentTexQuad() {
          const e = this.GetCurrentImageInfo();
          return e ? e.GetTexQuad() : null;
        }
        IsCurrentTexRotated() {
          const e = this.GetCurrentImageInfo();
          return !!e && e.IsRotated();
        }
        GetImagePoint(e) {
          const t = this._inst.GetWorldInfo();
          return [t.GetX(), t.GetY(), t.GetTotalZElevation()];
        }
        LoadTilemapData(e, t, r2) {
        }
        TestPointOverlapTile(e, t) {
        }
        RendersToOwnZPlane() {
          return true;
        }
      };
    }
    {
      const C33 = self.C3, tempRect = C33.New(C33.Rect);
      C33.SDKDOMInstanceBase = class extends C33.SDKWorldInstanceBase {
        constructor(t, e) {
          super(t, e), this._elementId = this.GetPlugin()._AddElement(this), this._isElementShowing = true, this._elemHasFocus = false, this._autoFontSize = false, this._autoFontSizeOffset = -0.2, this._lastRect = C33.New(C33.Rect, 0, 0, -1, -1);
          const s2 = this._runtime.GetCanvasManager();
          this._lastWindowWidth = s2.GetLastWidth(), this._lastWindowHeight = s2.GetLastHeight(), this._lastHTMLIndex = -1, this._lastHTMLZIndex = -1, this._isPendingUpdateState = false, this._StartTicking();
        }
        Release() {
          this.GetPlugin()._RemoveElement(this._elementId), this.PostToDOMElement("destroy"), this._elementId = -1, super.Release();
        }
        _GetElementInDOMMode() {
          if (this._runtime.IsInWorker()) throw new Error("not valid in worker mode");
          return this._PostToDOMElementMaybeSync("get-element");
        }
        PostToDOMElement(t, e) {
          e || (e = {}), e["elementId"] = this._elementId, this.PostToDOM(t, e);
        }
        _PostToDOMElementMaybeSync(t, e) {
          return e || (e = {}), e["elementId"] = this._elementId, this._PostToDOMMaybeSync(t, e);
        }
        PostToDOMElementAsync(t, e) {
          return e || (e = {}), e["elementId"] = this._elementId, this.PostToDOMAsync(t, e);
        }
        CreateElement(t) {
          t || (t = {});
          const e = this.GetWorldInfo();
          t["elementId"] = this._elementId, t["isVisible"] = e.IsVisible(), t["htmlIndex"] = e.GetLayer().GetHTMLIndex(), t["htmlZIndex"] = e.GetHTMLZIndex(), Object.assign(t, this.GetElementState()), this._isElementShowing = !!t["isVisible"], this._PostToDOMMaybeSync("create", t), this._UpdatePosition(true);
        }
        SetElementVisible(t) {
          t = !!t, this._isElementShowing !== t && (this._isElementShowing = t, this.PostToDOMElement("set-visible", { "isVisible": t }));
        }
        Tick() {
          this._UpdatePosition(false);
        }
        _ShouldPreserveElement() {
          const t = this._runtime.GetCanvasManager().GetFullscreenMode();
          return "Android" === C33.Platform.OS && ("scale-inner" === t || "scale-outer" === t || "crop" === t);
        }
        _UpdatePosition(t) {
          if (this.GetInstance().IsDestroyed()) return;
          const e = this.GetWorldInfo(), s2 = e.GetLayer(), i2 = e.GetBoundingBox();
          let [n, l2] = s2.LayerToCanvasCss(i2.getLeft(), i2.getTop()), [o2, h] = s2.LayerToCanvasCss(i2.getRight(), i2.getBottom());
          const a2 = this._runtime.GetCanvasManager(), d2 = a2.GetCssWidth(), m = a2.GetCssHeight();
          if (!e.IsVisible() || !s2.IsVisible()) return void this.SetElementVisible(false);
          if (!this._ShouldPreserveElement() && (o2 <= 0 || h <= 0 || n >= d2 || l2 >= m)) return void this.SetElementVisible(false);
          tempRect.set(n, l2, o2, h);
          const r2 = a2.GetLastWidth(), _ = a2.GetLastHeight(), c2 = s2.GetHTMLIndex(), u = e.GetHTMLZIndex();
          if (!t && tempRect.equals(this._lastRect) && this._lastWindowWidth === r2 && this._lastWindowHeight === _ && this._lastHTMLIndex === c2 && this._lastHTMLZIndex === u) return void this.SetElementVisible(true);
          this._lastRect.copy(tempRect), this._lastWindowWidth = r2, this._lastWindowHeight = _, this._lastHTMLIndex = c2, this._lastHTMLZIndex = u, this.SetElementVisible(true);
          let M = null;
          this._autoFontSize && (M = s2.GetDisplayScale() + this._autoFontSizeOffset), this._PostToDOMElementMaybeSync("update-position", { "left": Math.round(this._lastRect.getLeft()), "top": Math.round(this._lastRect.getTop()), "width": Math.round(this._lastRect.width()), "height": Math.round(this._lastRect.height()), "htmlIndex": c2, "htmlZIndex": u, "fontSize": M });
        }
        FocusElement() {
          this._PostToDOMElementMaybeSync("focus", { "focus": true });
        }
        BlurElement() {
          this._PostToDOMElementMaybeSync("focus", { "focus": false });
        }
        _OnElemFocused() {
          this._elemHasFocus = true;
        }
        _OnElemBlurred() {
          this._elemHasFocus = false;
        }
        IsElementFocused() {
          return this._elemHasFocus;
        }
        SetElementCSSStyle(t, e) {
          this.PostToDOMElement("set-css-style", { "prop": C33.CSSToCamelCase(t), "val": e });
        }
        SetElementAttribute(t, e) {
          this.PostToDOMElement("set-attribute", { "name": t, "val": e });
        }
        RemoveElementAttribute(t) {
          this.PostToDOMElement("remove-attribute", { "name": t });
        }
        UpdateElementState() {
          this._isPendingUpdateState || (this._isPendingUpdateState = true, Promise.resolve().then(() => {
            this._isPendingUpdateState = false, this.PostToDOMElement("update-state", this.GetElementState());
          }));
        }
        GetElementState() {
        }
        GetElementId() {
          return this._elementId;
        }
      };
    }
    {
      const C33 = self.C3, IBehavior = self.IBehavior;
      C33.SDKBehaviorBase = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e.runtime, this._id = e.id, this._name = e.name ?? "", this._myObjectClasses = C33.New(C33.ArraySet), this._myInstances = C33.New(C33.ArraySet), this._sdkVersion = e.sdkVersion, this._scriptInterfaceClass = e.scriptInterfaceClass, this._iBehavior = null;
        }
        Release() {
          this._myInstances.Release(), this._myObjectClasses.Release(), this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetID() {
          return this._id;
        }
        GetName() {
          return this._name;
        }
        OnCreate() {
        }
        GetSdkVersion() {
          return this._sdkVersion;
        }
        GetScriptInterfaceClass(e = false) {
          let s2 = this._scriptInterfaceClass;
          return e && "function" != typeof s2 && this.GetSdkVersion() >= 2 && (s2 = globalThis.ISDKBehaviorBase), s2;
        }
        _AddObjectClass(e) {
          this._myObjectClasses.Add(e);
        }
        GetObjectClasses() {
          return this._myObjectClasses.GetArray();
        }
        _AddInstance(e) {
          this._myInstances.Add(e);
        }
        _RemoveInstance(e) {
          this._myInstances.Delete(e);
        }
        GetInstances() {
          return this._myInstances.GetArray();
        }
        _InitScriptInterface() {
          const e = this.GetSdkVersion();
          C33.AddonManager._PushInitObject(this, e);
          const s2 = this.GetScriptInterfaceClass(true);
          if (s2) {
            if (this._iBehavior = new s2(), !(this._iBehavior instanceof IBehavior)) throw new TypeError("behavior class must derive from IBehavior");
          } else this._iBehavior = new IBehavior();
          C33.AddonManager._PopInitObject(e);
        }
        GetIBehavior() {
          return this._iBehavior;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SDKBehaviorTypeBase = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e.GetRuntime(), this._behaviorType = e, this._objectClass = e.GetObjectClass(), this._behavior = e.GetBehavior(), this._behavior._AddObjectClass(this._objectClass);
        }
        Release() {
          this._runtime = null, this._behaviorType = null, this._objectClass = null, this._behavior = null;
        }
        OnCreate() {
        }
        GetBehaviorType() {
          return this._behaviorType;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetBehavior() {
          return this._behavior;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SDKBehaviorInstanceBase = class extends C33.DefendedBase {
        constructor(t, i2) {
          super(), this._behInst = t, this._domComponentId = i2, this._inst = t.GetObjectInstance(), this._runtime = t.GetRuntime(), this._behaviorType = t.GetBehaviorType(), this._sdkType = this._behaviorType.GetSdkType(), this._isTicking = false, this._isTicking2 = false, this._isPostTicking = false, this._disposables = null;
        }
        Release() {
          this._StopTicking(), this._StopTicking2(), this._StopPostTicking(), this._disposables && (this._disposables.Release(), this._disposables = null), this._behInst = null, this._inst = null, this._runtime = null, this._behaviorType = null, this._sdkType = null;
        }
        GetBehavior() {
          return this._behaviorType.GetBehavior();
        }
        GetBehaviorInstance() {
          return this._behInst;
        }
        GetObjectInstance() {
          return this._inst;
        }
        GetObjectClass() {
          return this._inst.GetObjectClass();
        }
        GetWorldInfo() {
          return this._inst.GetWorldInfo();
        }
        GetRuntime() {
          return this._runtime;
        }
        GetBehaviorType() {
          return this._behaviorType;
        }
        GetSdkType() {
          return this._sdkType;
        }
        GetScriptInterface() {
          return this._behInst.GetScriptInterface();
        }
        Trigger(t) {
          return this._runtime.Trigger(t, this._inst, this._behaviorType);
        }
        DebugTrigger(t) {
          return this._runtime.DebugTrigger(t, this._inst, this._behaviorType);
        }
        TriggerAsync(t) {
          return this._runtime.TriggerAsync(t, this._inst, this._behaviorType);
        }
        PostCreate() {
        }
        Tick() {
        }
        Tick2() {
        }
        PostTick() {
        }
        _StartTicking() {
          this._isTicking || (this._runtime._AddBehInstToTick(this), this._isTicking = true);
        }
        _StopTicking() {
          this._isTicking && (this._runtime._RemoveBehInstToTick(this), this._isTicking = false);
        }
        IsTicking() {
          return this._isTicking;
        }
        _StartTicking2() {
          this._isTicking2 || (this._runtime._AddBehInstToTick2(this), this._isTicking2 = true);
        }
        _StopTicking2() {
          this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = false);
        }
        IsTicking2() {
          return this._isTicking2;
        }
        _StartPostTicking() {
          this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), this._isPostTicking = true);
        }
        _StopPostTicking() {
          this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = false);
        }
        IsPostTicking() {
          return this._isPostTicking;
        }
        GetDebuggerProperties() {
          return [];
        }
        AddDOMMessageHandler(t, i2) {
          this._runtime.AddDOMComponentMessageHandler(this._domComponentId, t, i2);
        }
        OnSpriteFrameChanged(t, i2) {
        }
        SaveToJson() {
          return null;
        }
        LoadFromJson(t) {
        }
        GetPropertyValueByIndex(t) {
        }
        SetPropertyValueByIndex(t, i2) {
        }
        OffsetPropertyValueByIndex(t, i2) {
          if (0 === i2) return;
          const e = this.GetPropertyValueByIndex(t);
          if ("number" != typeof e) throw new Error("expected number");
          this.SetPropertyValueByIndex(t, e + i2);
        }
        SetPropertyColorOffsetValueByIndex(t, i2, e, s2) {
        }
        CallAction(t, ...i2) {
          t.call(this, ...i2);
        }
        CallExpression(t, ...i2) {
          return t.call(this, ...i2);
        }
        GetScriptInterfaceClass() {
          return null;
        }
        DispatchScriptEvent(t, i2, e) {
          if (!this._behInst.HasScriptInterface()) return;
          const s2 = this.GetScriptInterface(), n = C33.New(C33.Event, t, i2);
          n.behaviorInstance = s2, n.instance = s2.instance, e && Object.assign(n, e), s2.dispatchEvent(n);
        }
      };
    }
    {
      let ValidateInternalAPIToken2 = function(t) {
        if (t !== internalApiToken) throw new Error("invalid internal API token");
      };
      ValidateInternalAPIToken = ValidateInternalAPIToken2;
      const C33 = self.C3;
      C33.Plugins = {}, C33.Behaviors = {};
      const internalApiToken = C33._GetInternalAPIToken();
      let initObjectStack = [], initObjectStack2 = [], initPropertiesStack = [], originalPushInitObject = null, originalPopInitObject = null, originalGetInitObject = null, originalGetInitObject2 = null;
      const pluginsByCtor = /* @__PURE__ */ new Map(), behaviorsByCtor = /* @__PURE__ */ new Map();
      C33.AddonManager = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._runtime = t, this._allPlugins = [], this._systemPlugin = null, this._allBehaviors = [], this._delayCreateBehaviors = /* @__PURE__ */ new Map(), this._solidBehavior = null, this._jumpthruBehavior = null, this._wrapperComponentIds = new Set(e);
        }
        CreatePlugin(t) {
          const e = t[19], i2 = this._runtime.GetObjectReference(t[0]);
          if (!i2) throw new Error("missing plugin");
          C33.AddCommonACEs(t, i2, e);
          const n = e >= 2 ? C33.SDKPluginBase : i2, r2 = C33.New(n, { runtime: this._runtime, isSingleGlobal: t[1], isWorld: t[2], isRotatable: t[5], hasEffects: t[8], mustPredraw: t[9], supportsSceneGraph: t[13], supportsMesh: t[14], isHTMLElementType: t[17], is3d: t[18], sdkVersion: e, id: t[20], name: t[21], scriptInterfaceClass: e >= 2 ? i2 : null });
          r2.OnCreate(), this._allPlugins.push(r2), pluginsByCtor.set(i2, r2);
        }
        CreateSystemPlugin() {
          this._systemPlugin = C33.New(C33.Plugins.System, { runtime: this._runtime, isSingleGlobal: true }), this._systemPlugin.OnCreate();
        }
        CreateBehavior(t) {
          const e = t[1], i2 = t[2], n = t[3], r2 = this._runtime.GetObjectReference(t[0]);
          if (!r2) throw new Error("missing behavior");
          this._delayCreateBehaviors.set(r2, () => {
            const t2 = e >= 2 ? C33.SDKBehaviorBase : r2, s2 = C33.New(t2, { runtime: this._runtime, id: i2, name: n, sdkVersion: e, scriptInterfaceClass: e >= 2 ? r2 : null });
            s2.OnCreate(), this._allBehaviors.push(s2), behaviorsByCtor.set(r2, s2), !this._solidBehavior && C33.Behaviors.solid && s2 instanceof C33.Behaviors.solid ? this._solidBehavior = s2 : !this._jumpthruBehavior && C33.Behaviors.jumpthru && s2 instanceof C33.Behaviors.jumpthru && (this._jumpthruBehavior = s2), s2._InitScriptInterface();
          });
        }
        _DelayCreateBehavior(t) {
          const e = this._delayCreateBehaviors.get(t);
          e && (e(), this._delayCreateBehaviors.delete(t));
        }
        static _PushInitObject(t, e = 1) {
          if (C33.AddonManager._PushInitObject !== originalPushInitObject) throw new Error("invalid method");
          1 === e && initObjectStack.push(t), initObjectStack2.push(t);
        }
        static _PopInitObject(t = 1) {
          if (C33.AddonManager._PopInitObject !== originalPopInitObject) throw new Error("invalid method");
          1 === t && initObjectStack.pop(), initObjectStack2.pop();
        }
        static _GetInitObject() {
          if (C33.AddonManager._GetInitObject !== originalGetInitObject) throw new Error("invalid method");
          if (0 === initObjectStack.length) throw new Error("no init object set");
          return initObjectStack.at(-1);
        }
        static _GetInitObject2(t) {
          if (C33.AddonManager._GetInitObject2 !== originalGetInitObject2) throw new Error("invalid method");
          if (ValidateInternalAPIToken2(t), 0 === initObjectStack2.length) throw new Error("no init object set");
          return initObjectStack2.at(-1);
        }
        static _PushInitProperties(t) {
          initPropertiesStack.push(t);
        }
        static _PopInitProperties() {
          initPropertiesStack.pop();
        }
        static _GetInitProperties() {
          if (0 === initPropertiesStack.length) throw new Error("no init properties set");
          return initPropertiesStack.at(-1);
        }
        _InitAddonScriptInterfaces() {
          for (const t of this._allPlugins) t._InitScriptInterface();
        }
        static GetPluginByConstructorFunction(t) {
          return pluginsByCtor.get(t) || null;
        }
        static GetBehaviorByConstructorFunction(t) {
          return behaviorsByCtor.get(t) || null;
        }
        GetSystemPlugin() {
          return this._systemPlugin;
        }
        GetSolidBehavior() {
          return this._solidBehavior;
        }
        GetJumpthruBehavior() {
          return this._jumpthruBehavior;
        }
        HasWrapperComponentId(t) {
          return this._wrapperComponentIds.has(t);
        }
      }, originalPushInitObject = C33.AddonManager._PushInitObject, originalPopInitObject = C33.AddonManager._PopInitObject, originalGetInitObject = C33.AddonManager._GetInitObject, originalGetInitObject2 = C33.AddonManager._GetInitObject2;
    }
    var ValidateInternalAPIToken;
    {
      const C33 = self.C3, allImageInfos = /* @__PURE__ */ new Set();
      C33.ImageInfo = class extends C33.DefendedBase {
        constructor() {
          super(), this._generation = 0, this._url = "", this._size = 0, this._offsetX = 0, this._offsetY = 0, this._width = 0, this._height = 0, this._isRotated = false, this._hasMetaData = false, this._imageAsset = null, this._textureState = "", this._rcTex = C33.New(C33.Rect), this._quadTex = C33.New(C33.Quad), this._blobUrl = "", this._iImageInfo = new self.IImageInfo(this), allImageInfos.add(this);
        }
        Release() {
          this.ReleaseTexture(), this._imageAsset && 0 === this._imageAsset.GetRefCount() && this._imageAsset.Release(), this._imageAsset = null, allImageInfos.delete(this), this.ReleaseBlobURL();
        }
        static OnRendererContextLost() {
          for (const t of allImageInfos) t._textureState = "", t._rcTex.set(0, 0, 0, 0), t._quadTex.setFromRect(t._rcTex);
        }
        LoadData(t) {
          this._url = t[0], this._size = t[1], this._offsetX = t[2], this._offsetY = t[3], this._width = t[4], this._height = t[5], this._isRotated = t[6], this._hasMetaData = true;
        }
        LoadDynamicAsset(t, e, s2) {
          if (s2 = !!s2, this._imageAsset) throw new Error("already loaded asset");
          this._url = e;
          const i2 = { isTiled: s2 };
          return C33.IsAbsoluteURL(e) && (i2.loadPolicy = "remote"), this.LoadAsset(t, i2), this._imageAsset.Load();
        }
        LoadDynamicBlobAsset(t, e) {
          if (this._imageAsset) throw new Error("already loaded asset");
          this._url = "", this._size = e.size, this._imageAsset = C33.New(C33.ImageAsset, t.GetAssetManager(), { blob: e, size: this._size, loadPolicy: "local" });
        }
        ReplaceWith(t) {
          if (t === this) throw new Error("cannot replace with self");
          this._generation++, this.ReleaseTexture(), this._url = t._url, this._size = t._size, this._offsetX = t._offsetX, this._offsetY = t._offsetY, this._width = t._width, this._height = t._height, this._isRotated = t._isRotated, this._hasMetaData = t._hasMetaData, this._imageAsset = t._imageAsset, this._textureState = t._textureState, this._rcTex = t._rcTex, this._quadTex = t._quadTex, this.ReleaseBlobURL();
        }
        GetURL() {
          return this._url;
        }
        GetSize() {
          return this._size;
        }
        GetOffsetX() {
          return this._offsetX;
        }
        GetOffsetY() {
          return this._offsetY;
        }
        IsRotated() {
          return this._isRotated;
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        GetSheetWidth() {
          return this._imageAsset.GetWidth();
        }
        GetSheetHeight() {
          return this._imageAsset.GetHeight();
        }
        LoadAsset(t, e) {
          if (this._imageAsset) throw new Error("already got asset");
          e = Object.assign({}, e, { url: this.GetURL(), size: this.GetSize() }), this._imageAsset = t.LoadImage(e);
        }
        IsLoaded() {
          return this._imageAsset && this._imageAsset.IsLoaded();
        }
        async LoadStaticTexture(t, e) {
          if (!this._imageAsset) throw new Error("no asset");
          if (this._textureState) throw new Error("already loaded texture");
          const s2 = this._generation;
          this._textureState = "loading";
          const i2 = await this._imageAsset.LoadStaticTexture(t, e);
          if (this._generation !== s2) return null;
          if (!i2) return this._textureState = "", null;
          this._textureState = "loaded", this._hasMetaData || (this._width = i2.GetWidth(), this._height = i2.GetHeight(), this._hasMetaData = true);
          const h = this._isRotated ? this._height : this._width, a2 = this._isRotated ? this._width : this._height;
          return this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + h, this._offsetY + a2), this._rcTex.divide(i2.GetWidth(), i2.GetHeight()), this._quadTex.setFromRect(this._rcTex), this._isRotated && this._quadTex.rotatePointsAnticlockwise(), i2;
        }
        ReleaseTexture() {
          this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(), this._textureState = "", this._rcTex.set(0, 0, 0, 0), this._quadTex.setFromRect(this._rcTex));
        }
        GetTexture() {
          return this._imageAsset && "loaded" === this._textureState ? this._imageAsset.GetTexture() : null;
        }
        GetTexRect() {
          return this._rcTex;
        }
        GetTexQuad() {
          return this._quadTex;
        }
        GetIImageInfo() {
          return this._iImageInfo;
        }
        GetImageAsset() {
          return this._imageAsset;
        }
        async ExtractImageToCanvas(t) {
          t || (t = await this._imageAsset.LoadToDrawable());
          const e = C33.CreateCanvas(this._width, this._height), s2 = e.getContext("2d");
          return this._isRotated ? (s2.rotate(Math.PI / -2), s2.translate(-this._height, 0), s2.drawImage(t, this._offsetX, this._offsetY, this._height, this._width, 0, 0, this._height, this._width)) : s2.drawImage(t, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height), e;
        }
        async ExtractImageToBlobURL(t) {
          if (this._blobUrl) return this._blobUrl;
          const e = await this.ExtractImageToCanvas(t), s2 = await C33.CanvasToBlob(e);
          return this._blobUrl = URL.createObjectURL(s2), this._blobUrl;
        }
        ReleaseBlobURL() {
          this._blobUrl && (URL.revokeObjectURL(this._blobUrl), this._blobUrl = "");
        }
      };
    }
    {
      const C33 = self.C3;
      C33.AnimationInfo = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._name = e[0], this._speed = e[1], this._isLooping = !!e[2], this._repeatCount = e[3], this._repeatTo = e[4], this._isPingPong = !!e[5], this._sid = e[6], this._frames = e[7].map((e2) => C33.New(C33.AnimationFrameInfo, e2)), this._iAnimation = new self.IAnimation(this);
        }
        static CreateDynamic(e, t) {
          const r2 = C33.New(C33.AnimationInfo, [t, 0, false, 0, 0, false, Math.floor(1e15 * Math.random()), []]);
          return r2._frames.push(C33.AnimationFrameInfo.CreateDynamic(e)), r2;
        }
        Release() {
          for (const e of this._frames) e.Release();
          C33.clearArray(this._frames);
        }
        LoadAllAssets(e) {
          for (const t of this._frames) t.GetImageInfo().LoadAsset(e);
        }
        LoadAllTextures(e, t) {
          return Promise.all(this._frames.map((r2) => r2.GetImageInfo().LoadStaticTexture(e, t)));
        }
        ReleaseAllTextures() {
          for (const e of this._frames) e.GetImageInfo().ReleaseTexture();
        }
        GetName() {
          return this._name;
        }
        GetSID() {
          return this._sid;
        }
        GetFrameCount() {
          return this._frames.length;
        }
        GetFrames() {
          return this._frames;
        }
        GetFrameAt(e) {
          if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError("invalid frame");
          return this._frames[e];
        }
        InsertFrameAt(e, t) {
          (t = Math.floor(t)) < 0 ? this._frames.unshift(e) : t >= this._frames.length ? this._frames.push(e) : this._frames.splice(t, 0, e);
        }
        RemoveFrameAt(e) {
          if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError("invalid frame");
          this._frames[e].Release(), this._frames.splice(e, 1);
        }
        GetFrameIndexByTag(e) {
          for (let t = 0, r2 = this._frames.length; t < r2; ++t) if (C33.equalsNoCase(this._frames[t].GetTag(), e)) return t;
          return -1;
        }
        FrameTagOrIndexToIndex(e) {
          if ("string" == typeof e) {
            const t = this.GetFrameIndexByTag(e);
            if (-1 === t) throw new Error(`cannot find animation frame with tag ${e}`);
            return t;
          }
          return e;
        }
        GetSpeed() {
          return this._speed;
        }
        IsLooping() {
          return this._isLooping;
        }
        GetRepeatCount() {
          return this._repeatCount;
        }
        GetRepeatTo() {
          return this._repeatTo;
        }
        IsPingPong() {
          return this._isPingPong;
        }
        GetIAnimation() {
          return this._iAnimation;
        }
      };
    }
    {
      const C33 = self.C3, EMPTY_IMAGE_BLOB = (() => {
        const t = atob("iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC"), i2 = new Uint8Array(t.length);
        for (let e = 0, n = t.length; e < n; ++e) i2[e] = t.charCodeAt(e);
        return new Blob([i2], { type: "image/png" });
      })();
      C33.AnimationFrameInfo = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._imageInfo = C33.New(C33.ImageInfo), this._imageInfo.LoadData(t), this._duration = t[7], this._origin = C33.New(C33.Vector2, t[8], t[9]), this._imagePoints = t[10].map((t2) => C33.New(C33.ImagePoint, this, t2)), this._imagePointsByName = /* @__PURE__ */ new Map();
          for (const t2 of this._imagePoints) this._imagePointsByName.set(t2.GetName().toLowerCase(), t2);
          this._collisionPoly = null;
          const i2 = t[11];
          i2.length >= 6 && (this._collisionPoly = C33.New(C33.CollisionPoly, i2)), this._tag = t[12] ? t[12] : "", this._iAnimationFrame = new self.IAnimationFrame(this);
        }
        static CreateDynamic(t) {
          const i2 = C33.New(C33.AnimationFrameInfo, ["", 0, 0, 0, 100, 100, false, 1, 0, 0, [], [], ""]);
          return i2._imageInfo.LoadDynamicBlobAsset(t, EMPTY_IMAGE_BLOB), i2;
        }
        Release() {
          this._collisionPoly && (this._collisionPoly.Release(), this._collisionPoly = null), this._imageInfo.Release(), this._imageInfo = null;
        }
        GetImageInfo() {
          return this._imageInfo;
        }
        GetDuration() {
          return this._duration;
        }
        GetOriginX() {
          return this._origin.getX();
        }
        GetOriginY() {
          return this._origin.getY();
        }
        GetCollisionPoly() {
          return this._collisionPoly;
        }
        GetImagePointByName(t) {
          return this._imagePointsByName.get(t.toLowerCase()) || null;
        }
        GetImagePointByIndex(t) {
          return (t = Math.floor(t)) < 0 || t >= this._imagePoints.length ? null : this._imagePoints[t];
        }
        GetImagePointCount() {
          return this._imagePoints.length;
        }
        GetTag() {
          return this._tag;
        }
        GetIAnimationFrame() {
          return this._iAnimationFrame;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.ImagePoint = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._afi = e, this._name = t[0], this._pos = C33.New(C33.Vector2, t[1], t[2]);
        }
        Release() {
        }
        GetName() {
          return this._name;
        }
        GetX() {
          return this._pos.getX();
        }
        GetY() {
          return this._pos.getY();
        }
        GetVec2() {
          return this._pos;
        }
      };
    }
    {
      const C33 = globalThis.C3, C3Debugger = globalThis.C3Debugger, IObjectClass = globalThis.IObjectClass, IObjectType = globalThis.IObjectType, IFamily = globalThis.IFamily, assert = globalThis.assert;
      C33.ObjectClass = class extends C33.DefendedBase {
        constructor(t, e, s2) {
          super();
          const i2 = t.GetObjectReference(s2[1]);
          this._runtime = t, this._plugin = C33.AddonManager.GetPluginByConstructorFunction(i2), this._sdkType = null, this._instSdkCtor = i2.Instance, this._index = e, this._sid = s2[11], this._name = s2[0], this._jsPropName = this._runtime.GetJsPropName(s2[14]), this._isGlobal = !!s2[9], this._isFamily = !!s2[2], this._isOnLoaderLayout = !!s2[10], this._instVars = s2[3].map((e2) => ({ sid: e2[0], type: e2[1], name: e2[2], jsPropName: t.GetJsPropName(e2[3]) })), this._behaviorsCount = s2[4], this._effectsCount = s2[5], this._isWorldType = this._plugin.IsWorldType(), this._dispatcher = C33.New(C33.Event.Dispatcher), this._effectList = null;
          const [n, a2] = t.GetCollisionEngine().GetCollisionCellSize();
          if (this._collisionGrid = C33.New(C33.SparseGrid, n, a2), this._anyCollisionCellChanged = true, this._familyMembers = null, this._familyMembersSet = null, this._familyIndex = -1, this._families = null, this._familiesSet = null, this._familyInstVarMap = null, this._familyBehaviorMap = null, this._familyEffectMap = null, this._isInContainer = false, this._container = null, this._behaviorTypes = s2[8].map((t2) => C33.BehaviorType.Create(this, t2)), this._behaviorTypesIncludingInherited = [], this._behaviorsByName = /* @__PURE__ */ new Map(), this._behaviorNameToIndex = /* @__PURE__ */ new Map(), this._usedBehaviorCtors = /* @__PURE__ */ new Set(), this._customActionMap = /* @__PURE__ */ new Map(), this._solStack = C33.New(C33.SolStack, this), this._defaultInstanceData = null, this._defaultLayerIndex = 0, this._isContained = false, this._container = null, this._imageInfo = null, this._animations = null, this._animationsByName = null, this._animationsBySid = null, this._textureRefCount = 0, this._savedData = /* @__PURE__ */ new Map(), this._unsavedData = /* @__PURE__ */ new Map(), this._instances = [], this._worldInfosByLayer = /* @__PURE__ */ new Map(), this._iidsStale = true, this._plugin.HasEffects() && (this._effectList = C33.New(C33.EffectList, this, s2[12])), s2[6] && (this._imageInfo = C33.New(C33.ImageInfo), this._imageInfo.LoadData(s2[6])), s2[7]) {
            this._animations = s2[7].map((t2) => C33.New(C33.AnimationInfo, t2)), this._animationsByName = /* @__PURE__ */ new Map(), this._animationsBySid = /* @__PURE__ */ new Map();
            for (const t2 of this._animations) this._animationsByName.set(t2.GetName().toLowerCase(), t2), this._animationsBySid.set(t2.GetSID(), t2);
          }
          this._isFamily ? (this._familyMembers = [], this._familyMembersSet = /* @__PURE__ */ new Set(), this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = /* @__PURE__ */ new Set(), this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []);
          const r2 = this._plugin.GetSdkVersion();
          if (r2 < 2 && (this._sdkType = C33.New(i2.Type, this, s2[15]), !(this._sdkType instanceof C33.SDKTypeBase))) throw new Error("v1 sdk type must derive from SDKTypeBase");
          let o2;
          if (this._iObjectClass = null, this._instanceUserScriptClass = null, this._userScriptDispatcher = C33.New(C33.Event.Dispatcher), C33.AddonManager._PushInitObject(this, r2), r2 >= 2 ? (o2 = i2.Type, o2 || (o2 = globalThis.ISDKObjectTypeBase)) : o2 = this._sdkType.GetScriptInterfaceClass(), o2 && !this._isFamily) {
            if (this._iObjectClass = new o2(r2 < 2 ? this : null), r2 < 2 && !(this._iObjectClass instanceof IObjectType)) throw new TypeError("script interface class must derive from IObjectType");
            if (r2 >= 2 && !(this._iObjectClass instanceof globalThis.ISDKObjectTypeBase)) throw new TypeError("script interface class must derive from ISDKObjectTypeBase");
          } else {
            const t2 = this._isFamily ? IFamily : IObjectType;
            this._iObjectClass = new t2();
          }
          if (C33.AddonManager._PopInitObject(r2), s2[13]) {
            const t2 = s2[13];
            if (t2) {
              const e2 = t2[0], s3 = t2[1], i3 = t2[2];
              this._sdkType.LoadTilemapData(e2, s3, i3);
            }
          }
          this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate(), this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(s2)), this._loadInstancesJson = null;
        }
        static Create(t, e, s2) {
          return C33.New(C33.ObjectClass, t, e, s2);
        }
        Release() {
          if (this._dispatcher.Release(), this._dispatcher = null, this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null), this._animations) {
            for (const t of this._animations) t.Release();
            C33.clearArray(this._animations), this._animationsByName.clear(), this._animationsBySid.clear();
          }
          this._loadInstancesJson = null, this._solStack.Release(), this._solStack = null, this._savedData.clear(), this._unsavedData.clear(), this._container = null, this._runtime = null;
        }
        _LoadFamily(t) {
          for (let e = 1, s2 = t.length; e < s2; ++e) {
            const s3 = this._runtime.GetObjectClassByIndex(t[e]);
            this._familyMembers.push(s3), this._familyMembersSet.add(s3), s3._families.push(this), s3._familiesSet.add(this);
          }
        }
        _SetContainer(t) {
          this._isInContainer = true, this._container = t;
        }
        IsInContainer() {
          return this._isInContainer;
        }
        GetContainer() {
          return this._container;
        }
        _OnAfterCreate() {
          let t = 0;
          if (!this._isFamily) for (const e of this._families) for (const s2 of e.GetBehaviorTypes()) {
            const e2 = s2.GetName().toLowerCase();
            this._behaviorsByName.set(e2, s2), this._behaviorNameToIndex.set(e2, t), this._behaviorTypesIncludingInherited.push(s2), ++t;
          }
          for (const e of this.GetBehaviorTypes()) {
            const s2 = e.GetName().toLowerCase();
            this._behaviorsByName.set(s2, e), this._behaviorNameToIndex.set(s2, t), this._behaviorTypesIncludingInherited.push(e), ++t;
          }
          for (const t2 of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(t2.GetBehavior().constructor);
          if (!this._isFamily && this._families.length) {
            const t2 = this._runtime.GetFamilyCount();
            C33.extendArray(this._familyInstVarMap, t2, 0), C33.extendArray(this._familyBehaviorMap, t2, 0), C33.extendArray(this._familyEffectMap, t2, 0);
            const e = [];
            let s2 = 0, i2 = 0, n = 0;
            for (const t3 of this._families) {
              const a2 = t3.GetFamilyIndex();
              this._familyInstVarMap[a2] = s2, s2 += t3.GetInstanceVariablesCount(), this._familyBehaviorMap[a2] = i2, i2 += t3.GetBehaviorTypesCount(), this._familyEffectMap[a2] = n, n += t3.GetEffectTypesCount();
              const r2 = t3.GetEffectList();
              if (r2 && this._effectList) for (const t4 of r2.GetAllEffectTypes()) e.push(t4.Clone(this._effectList));
            }
            this._effectList && this._effectList.PrependEffectTypes(e);
          }
        }
        _CreateSingleGlobalInstance(t) {
          const e = C33.IsFiniteNumber(t[17]) ? t[17] : this._runtime._GetNewUID(), s2 = C33.New(C33.Instance, { runtime: this._runtime, objectType: this, uid: e });
          s2._CreateSdkInstance(t[16], []), this._runtime._MapInstanceByUID(e, s2), this._instances.push(s2);
        }
        GetSdkType() {
          return this._sdkType;
        }
        IsOnLoaderLayout() {
          return this._isOnLoaderLayout;
        }
        Dispatcher() {
          return this._dispatcher;
        }
        OnCreate() {
          this._isFamily || (this._sdkType ? this._sdkType.OnCreate() : this._iObjectClass._onCreate());
        }
        HasLoadedTextures() {
          return this._textureRefCount > 0;
        }
        async LoadTextures(t) {
          this._isFamily || (this._textureRefCount++, 1 === this._textureRefCount && (this._sdkType ? await this._sdkType.LoadTextures(t) : await this._iObjectClass._loadTextures(this._runtime.GetCanvasManager().GetIRenderer())));
        }
        ReleaseTextures() {
          if (!this._isFamily) {
            if (this._textureRefCount--, this._textureRefCount < 0) throw new Error("released textures too many times");
            0 === this._textureRefCount && (this._sdkType ? this._sdkType.ReleaseTextures() : this._iObjectClass._releaseTextures(this._runtime.GetCanvasManager().GetIRenderer()));
          }
        }
        OnDynamicTextureLoadComplete() {
          if (this._isFamily) throw new Error("not applicable to family");
          this._sdkType ? this._sdkType.OnDynamicTextureLoadComplete() : this._iObjectClass._onDynamicTextureLoadComplete();
        }
        async PreloadTexturesWithInstances(t) {
          this._isFamily || (this._sdkType ? await this._sdkType.PreloadTexturesWithInstances(t) : await this._iObjectClass._preloadTexturesWithInstances(this._runtime.GetCanvasManager().GetIRenderer()));
        }
        GetRuntime() {
          return this._runtime;
        }
        GetPlugin() {
          return this._plugin;
        }
        GetInstanceSdkCtor() {
          return this._instSdkCtor;
        }
        GetName() {
          return this._name;
        }
        GetJsPropName() {
          return this._jsPropName;
        }
        GetIndex() {
          return this._index;
        }
        GetSID() {
          return this._sid;
        }
        IsFamily() {
          return this._isFamily;
        }
        IsGlobal() {
          return this._isGlobal;
        }
        IsWorldType() {
          return this._isWorldType;
        }
        GetFamilyIndex() {
          return this._familyIndex;
        }
        GetBehaviorTypes() {
          return this._behaviorTypes;
        }
        GetBehaviorTypesCount() {
          return this._behaviorsCount;
        }
        UsesBehaviorByCtor(t) {
          return t && this._usedBehaviorCtors.has(t);
        }
        GetInstanceVariablesCount() {
          return this._instVars.length;
        }
        GetInstanceVariableSIDs() {
          return this._instVars.map((t) => t.sid);
        }
        GetInstanceVariableIndexBySID(t) {
          return this._instVars.findIndex((e) => e.sid === t);
        }
        GetInstanceVariableIndexByName(t) {
          return this._instVars.findIndex((e) => e.name === t);
        }
        _GetAllInstanceVariableNames() {
          return this._instVars.map((t) => t.name);
        }
        _GetAllInstanceVariableJsPropNames() {
          return this._instVars.map((t) => t.jsPropName);
        }
        GetInstanceVariableType(t) {
          if ((t = Math.floor(t)) < 0 || t >= this._instVars.length) throw new RangeError("invalid instance variable index");
          return this._instVars[t].type;
        }
        GetInstanceVariableName(t) {
          if ((t = Math.floor(t)) < 0 || t >= this._instVars.length) throw new RangeError("invalid instance variable index");
          return this._instVars[t].name;
        }
        GetEffectTypesCount() {
          return this._effectsCount;
        }
        GetBehaviorTypesIncludingInherited() {
          return this._behaviorTypesIncludingInherited;
        }
        GetBehaviorTypeByName(t) {
          return this._behaviorsByName.get(t.toLowerCase()) || null;
        }
        GetBehaviorIndexByName(t) {
          const e = this._behaviorNameToIndex.get(t.toLowerCase());
          return void 0 === e ? -1 : e;
        }
        GetEffectList() {
          return this._effectList;
        }
        HasEffects() {
          return this._plugin.HasEffects();
        }
        UsesEffects() {
          return this._effectList && this._effectList.HasAnyEffectType();
        }
        GetSolStack() {
          return this._solStack;
        }
        GetCurrentSol() {
          return this._solStack.GetCurrentSol();
        }
        GetImageInfo() {
          return this._imageInfo;
        }
        SetDefaultInstanceData(t) {
          this._defaultInstanceData = t;
        }
        GetDefaultInstanceData() {
          return this._defaultInstanceData;
        }
        _SetDefaultLayerIndex(t) {
          this._defaultLayerIndex = t;
        }
        GetDefaultLayerIndex() {
          return this._defaultLayerIndex;
        }
        GetAnimations() {
          return this._animations;
        }
        GetAnimationCount() {
          return this._animations.length;
        }
        GetFamilies() {
          return this._families;
        }
        BelongsToFamily(t) {
          return this._familiesSet.has(t);
        }
        GetFamilyMembers() {
          return this._familyMembers;
        }
        FamilyHasMember(t) {
          return this._familyMembersSet.has(t);
        }
        GetFamilyBehaviorOffset(t) {
          return this._familyBehaviorMap[t];
        }
        GetFamilyInstanceVariableOffset(t) {
          return this._familyInstVarMap[t];
        }
        AddCustomAction(t) {
          this._customActionMap.set(t.GetACEName().toLowerCase(), t);
        }
        HasOwnCustomActionByName(t) {
          return !!this.GetOwnCustomActionByName(t);
        }
        GetOwnCustomActionByName(t) {
          const e = this._customActionMap.get(t.toLowerCase());
          return e && e.IsEnabled() ? e : null;
        }
        GetAllAnimations() {
          return this._animations;
        }
        GetAnimationByName(t) {
          if (!this._animations) throw new Error("no animations");
          return this._animationsByName.get(t.toLowerCase()) || null;
        }
        GetAnimationBySID(t) {
          if (!this._animations) throw new Error("no animations");
          return this._animationsBySid.get(t) || null;
        }
        AddAnimation(t) {
          if (this.GetAnimationByName(t)) throw new Error(`animation name '${t}' already exists`);
          const e = C33.AnimationInfo.CreateDynamic(this.GetRuntime(), t);
          return this._animations.push(e), this._animationsByName.set(e.GetName().toLowerCase(), e), this._animationsBySid.set(e.GetSID(), e), e;
        }
        RemoveAnimation(t) {
          const e = this.GetAnimationByName(t);
          if (!e) throw new Error(`animation name '${t}' does not exist`);
          if (1 === this._animations.length) throw new Error("cannot remove last animation");
          const s2 = this._animations.indexOf(e);
          this._animations.splice(s2, 1), this._animationsByName.delete(e.GetName().toLowerCase()), this._animationsBySid.delete(e.GetSID()), e.Release();
        }
        GetFirstAnimation() {
          if (!this._animations) throw new Error("no animations");
          return this._animations[0];
        }
        GetFirstAnimationFrame() {
          return this.GetFirstAnimation().GetFrameAt(0);
        }
        GetDefaultInstanceSize() {
          if (this._animations) {
            const t = this.GetFirstAnimationFrame().GetImageInfo();
            return [t.GetWidth(), t.GetHeight()];
          }
          return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100];
        }
        GetSingleGlobalInstance() {
          if (!this._plugin.IsSingleGlobal()) throw new Error("not a single-global plugin");
          return this._instances[0];
        }
        GetInstances() {
          return this._instances;
        }
        *instances() {
          yield* this._instances;
        }
        *instancesIncludingPendingCreate() {
          yield* this._instances, yield* this._runtime.instancesPendingCreateForObjectClass(this);
        }
        GetInstanceCount() {
          return this._instances.length;
        }
        _AddInstance(t) {
          this._instances.push(t);
        }
        _SetIIDsStale() {
          this._iidsStale = true;
        }
        _UpdateIIDs() {
          if (!this._iidsStale || this._isFamily) return;
          const t = this._instances;
          let e = 0;
          for (let s3 = t.length; e < s3; ++e) t[e]._SetIID(e);
          const s2 = this._runtime._GetInstancesPendingCreate();
          for (const t2 of s2) t2.GetObjectClass() === this && t2._SetIID(e++);
          this._iidsStale = false;
        }
        GetInstanceByIID(t) {
          const e = this._instances;
          if (t < e.length) return e[t];
          t -= e.length;
          const s2 = this._runtime._GetInstancesPendingCreate();
          for (const e2 of s2) if (e2.GetObjectClass() === this) {
            if (0 === t) return e2;
            --t;
          }
          return null;
        }
        GetFirstPicked(t) {
          if (t && t.IsInContainer() && t.GetObjectClass() !== this) {
            for (const e2 of t.siblings()) if (e2.GetObjectClass() === this) return e2;
          }
          const e = this.GetCurrentSol().GetInstances();
          return e.length ? e[0] : null;
        }
        GetPairedInstance(t) {
          const e = this.GetCurrentSol().GetInstances();
          return e.length > 0 ? e[t.GetIID() % e.length] : null;
        }
        *allCorrespondingInstances(t, e) {
          const s2 = this.GetCurrentSol().GetInstances(), i2 = s2.length, n = e.GetCurrentSol(), a2 = e.GetCurrentSol().GetInstances(), r2 = a2.length;
          let o2 = t.GetIID();
          !e.IsFamily() && n.IsSelectAll() || (o2 = a2.indexOf(t));
          const h = Math.ceil(i2 / r2), l2 = i2 % r2;
          let _ = 0, c2 = 0;
          0 === l2 || o2 < l2 ? (_ = o2 * h, c2 = h) : (_ = l2 * h + (o2 - l2) * (h - 1), c2 = h - 1);
          for (let t2 = _, e2 = _ + c2; t2 < e2; ++t2) yield s2[t2];
        }
        FinishCondition(t) {
          this._sdkType?.FinishCondition(t);
        }
        ApplySolToContainer() {
          if (!this._isInContainer || this._isFamily) return;
          this._UpdateIIDs();
          const t = this.GetCurrentSol(), e = t._GetOwnInstances(), s2 = t.IsSelectAll(), i2 = this._runtime.GetCurrentEventStackFrame(), n = i2 && i2.GetCurrentEvent() && i2.GetCurrentEvent().IsOrBlock();
          for (const i3 of this._container.objectTypes()) {
            if (i3 === this) continue;
            i3._UpdateIIDs();
            const a2 = i3.GetCurrentSol();
            if (a2._SetSelectAll(s2), !s2) {
              const s3 = a2._GetOwnInstances();
              C33.clearArray(s3);
              for (const t2 of e) s3.push(i3.GetInstanceByIID(t2.GetIID()));
              if (n) {
                const e2 = t._GetOwnElseInstances(), s4 = a2._GetOwnElseInstances();
                C33.clearArray(s4);
                for (const t2 of e2) s4.push(i3.GetInstanceByIID(t2.GetIID()));
              }
            }
          }
        }
        _TruncateContainerSols(t, e) {
          for (const s2 of this.GetContainer().objectTypes()) {
            const i2 = s2.GetCurrentSol();
            t ? C33.truncateArray(i2._GetOwnElseInstances(), e) : C33.truncateArray(i2._GetOwnInstances(), e);
          }
        }
        _GetCollisionCellGrid() {
          return this._collisionGrid;
        }
        _SetAnyCollisionCellChanged(t) {
          this._anyCollisionCellChanged = !!t;
        }
        _UpdateAllCollisionCells() {
          if (this._anyCollisionCellChanged && this._isWorldType) {
            for (const t of this._instances) t.GetWorldInfo()._UpdateCollisionCell();
            for (const t of this._runtime._GetInstancesPendingCreate()) t.GetObjectClass() === this && t.GetWorldInfo()._UpdateCollisionCell();
            this._anyCollisionCellChanged = false;
          }
        }
        _OnWorldInstanceLayerChanged(t, e, s2) {
          if (e) {
            const s3 = this._worldInfosByLayer.get(e);
            s3 && (s3.delete(t), 0 === s3.size && this._worldInfosByLayer.delete(e));
          }
          if (s2) {
            let e2 = this._worldInfosByLayer.get(s2);
            e2 || (e2 = /* @__PURE__ */ new Set(), this._worldInfosByLayer.set(s2, e2)), e2.add(t);
          }
        }
        *layersHasInstancesOn() {
          if (this.IsFamily()) {
            const t = /* @__PURE__ */ new Set();
            for (const e of this._familyMembers) for (const s2 of e.layersHasInstancesOn()) t.add(s2);
            yield* t.values();
          } else for (const t of this._worldInfosByLayer.keys()) t.WasReleased() || (yield t);
        }
        GetSavedDataMap() {
          return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
        }
        GetUnsavedDataMap() {
          return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;
        }
        HasSolidBehavior() {
          return this.UsesBehaviorByCtor(C33.Behaviors.solid);
        }
        HasJumpthruBehavior() {
          return this.UsesBehaviorByCtor(C33.Behaviors.jumpthru);
        }
        HasNoSaveBehavior() {
          return this.UsesBehaviorByCtor(C33.Behaviors.NoSave);
        }
        HasPersistBehavior() {
          return this.UsesBehaviorByCtor(C33.Behaviors.Persist);
        }
        _SaveToJson() {
          const t = { "instances": this._instances.map((t2) => t2.SaveToJson()) };
          return this._savedData && this._savedData.size && (t["ex"] = C33.ToSuperJSON(this._savedData)), t;
        }
        _LoadFromJson(t, e) {
          this._savedData && (this._savedData.clear(), this._savedData = null);
          const s2 = t["ex"];
          s2 && (this._savedData = C33.FromSuperJSON(s2));
          const i2 = this._instances, n = t["instances"];
          for (let t2 = 0, e2 = Math.min(i2.length, n.length); t2 < e2; ++t2) i2[t2].LoadFromJson(n[t2]);
          for (let t2 = n.length, e2 = i2.length; t2 < e2; ++t2) this._runtime.DestroyInstance(i2[t2]);
          for (let t2 = i2.length, s3 = n.length; t2 < s3; ++t2) {
            const s4 = n[t2];
            let i3 = null;
            if (this.IsWorldType() && (i3 = this._runtime.GetMainRunningLayout().GetLayerBySID(s4["w"]["l"]), !i3)) continue;
            const a2 = this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, i3, false, 0, 0, true);
            a2.LoadFromJson(s4), e && e.add(a2);
          }
          this._loadInstancesJson = n, this._SetIIDsStale();
        }
        _GetLoadInstancesJson() {
          return this._loadInstancesJson;
        }
        _ClearLoadInstancesJson() {
          this._loadInstancesJson = null;
        }
        _SetupSceneGraphConnectionsOnChangeOfLayout() {
          for (let t = 0, e = this._instances; t < e; ++t) this._instances[t]._SetupSceneGraphConnectionsOnChangeOfLayout();
        }
        GetIObjectClass() {
          return this._iObjectClass;
        }
        UserScriptDispatcher() {
          return this._userScriptDispatcher;
        }
        _GetUserScriptInstanceClass() {
          return this._instanceUserScriptClass;
        }
        _SetUserScriptInstanceClass(t) {
          this._instanceUserScriptClass = t;
        }
        DispatchUserScriptEvent(t) {
          const e = this._runtime, s2 = e.IsDebug() && !e.GetEventSheetManager().IsInEventEngine();
          s2 && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(t), s2 && C3Debugger.AddScriptTime();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Container = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._runtime = e, this._objectTypes = t;
          for (const e2 of this._objectTypes) e2._SetContainer(this);
        }
        Release() {
          this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetObjectTypes() {
          return this._objectTypes;
        }
        objectTypes() {
          return this._objectTypes;
        }
        HasAnyWorldType() {
          return this._objectTypes.some((e) => e.IsWorldType());
        }
      };
    }
    {
      const C33 = self.C3, C3Debugger = self.C3Debugger, IInstance = self.IInstance, originalAddonManager = C33.AddonManager, EMPTY_ARRAY = [];
      let nextPuid = 0;
      const savedDataMaps = /* @__PURE__ */ new WeakMap(), unsavedDataMaps = /* @__PURE__ */ new WeakMap(), FLAG_DESTROYED = 1, FLAG_TILEMAP = 2, FLAG_MUST_PREDRAW = 4, FLAG_SOLID_ENABLED = 8, FLAG_JUMPTHRU_ENABLED = 16, FLAG_MUST_MITIGATE_Z_FIGHTING = 32, FLAG_IS_DRAWING_WITH_EFFECTS = 64;
      C33.Instance = class extends C33.DefendedBase {
        constructor(t) {
          if (C33.AddonManager !== originalAddonManager) throw new Error("invalid addon manager");
          super(), this._runtime = t.runtime, this._objectType = t.objectType, this._worldInfo = null, this._sdkInst = null, this._iScriptInterface = null, this._iid = 0, this._uid = t.uid, this._puid = nextPuid++, this._flags = 0, this._tagsSet = null;
          const e = C33.splitStringAndNormalize(t.tags);
          e.length > 0 && (this._tagsSet = new Set(e)), this._instVarValues = EMPTY_ARRAY, this._behaviorInstances = EMPTY_ARRAY;
          const s2 = this._objectType.GetBehaviorTypesIncludingInherited();
          s2.length > 0 && (this._behaviorInstances = s2.map((t2, e2) => C33.New(C33.BehaviorInstance, { runtime: this._runtime, behaviorType: t2, instance: this, index: e2 }))), this._siblings = this._objectType.IsInContainer() ? [] : null, this._timeScale = -1, this._dispatcher = null;
          const n = this.GetPlugin();
          if (n.MustPreDraw() && (this._flags |= 4), n.IsWorldType()) if (this._worldInfo = C33.New(C33.WorldInfo, this, t.layer), t.worldData) this._worldInfo.Init(t.worldData);
          else {
            this._worldInfo.InitNoData();
            const [t2, e2] = this._objectType.GetDefaultInstanceSize();
            this._worldInfo.SetSize(t2, e2), this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters();
          }
          t.instVarData ? this._LoadInstanceVariableData(t.instVarData) : this._LoadDefaultInstanceVariables();
        }
        Release() {
          if (this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), this._behaviorInstances.length > 0) {
            for (const t2 of this._behaviorInstances) t2.Release();
            C33.clearArray(this._behaviorInstances);
          }
          this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null);
          const t = savedDataMaps.get(this);
          t && (t.clear(), savedDataMaps.delete(this));
          const e = unsavedDataMaps.get(this);
          e && (e.clear(), unsavedDataMaps.delete(this)), this._siblings && C33.clearArray(this._siblings), this._dispatcher && (this._dispatcher.Release(), this._dispatcher = null), this._tagsSet && this._tagsSet.clear(), this._tagsSet = null, this._runtime = null, this._objectType = null, this._instVarValues.length > 0 && C33.clearArray(this._instVarValues), this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null);
        }
        _LoadInstanceVariableData(t) {
          t.length > 0 && (this._instVarValues = [], C33.shallowAssignArray(this._instVarValues, t));
        }
        _LoadDefaultInstanceVariables() {
          const t = this._objectType.GetInstanceVariablesCount();
          if (0 === t) return;
          this._instVarValues = [];
          const e = [0, 0, ""];
          for (let s2 = 0; s2 < t; ++s2) this._instVarValues.push(e[this._objectType.GetInstanceVariableType(s2)]);
        }
        _CreateSdkInstance(t, e) {
          if (this._sdkInst) throw new Error("already got sdk instance");
          for (let t2 = 0, s2 = this._behaviorInstances.length; t2 < s2; ++t2) {
            this._behaviorInstances[t2]._CreateSdkInstance(e ? e[t2] : null);
          }
          if (this.GetPlugin().GetSdkVersion() < 2) {
            if (this._sdkInst = C33.New(this._objectType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof C33.SDKInstanceBase)) throw new Error("sdk type must derive from SDKInstanceBase");
            !this.GetPlugin().IsWorldType() && this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();
          } else {
            const e2 = this.GetPlugin().GetScriptInterfaceClass();
            this._InitUserScriptInterface(e2.Instance, t);
          }
        }
        GetSdkInstance() {
          return this._sdkInst ?? this._iScriptInterface;
        }
        GetWorldInfo() {
          return this._worldInfo;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetTimeScale() {
          return this._timeScale;
        }
        GetActiveTimeScale() {
          const t = this._timeScale;
          return -1 === t ? this.GetRuntime().GetTimeScale() : t;
        }
        SetTimeScale(t) {
          ((t = +t) < 0 || !isFinite(t)) && (t = 0), this._timeScale = t, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, true);
        }
        RestoreTimeScale() {
          this._timeScale = -1, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, false);
        }
        GetInstanceGameTime() {
          return this._runtime._GetInstanceGameTime(this);
        }
        Dispatcher() {
          return this._dispatcher || (this._dispatcher = C33.New(C33.Event.Dispatcher)), this._dispatcher;
        }
        Draw(t) {
          this._sdkInst ? this._sdkInst.Draw(t) : this._iScriptInterface._draw(this._runtime.GetCanvasManager().GetIRenderer());
        }
        OnCreate(t) {
          this._sdkInst.OnCreate(t);
        }
        _SetHasTilemap() {
          this._flags |= 2;
        }
        HasTilemap() {
          return !!(2 & this._flags);
        }
        _MarkDestroyed() {
          this._flags |= 1;
        }
        IsDestroyed() {
          return !!(1 & this._flags);
        }
        MustPreDraw() {
          return !!(4 & this._flags) || (this._sdkInst ? this._sdkInst.MustPreDraw() : this._iScriptInterface._mustPreDraw());
        }
        SetMustMitigateZFighting() {
          this._flags |= 32;
        }
        MustMitigateZFighting() {
          return !!(32 & this._flags);
        }
        _IsSolidEnabled() {
          return !!(8 & this._flags);
        }
        _SetSolidEnabled(t) {
          t ? this._flags |= 8 : this._flags &= -9;
        }
        _IsJumpthruEnabled() {
          return !!(16 & this._flags);
        }
        _SetJumpthruEnabled(t) {
          t ? this._flags |= 16 : this._flags &= -17;
        }
        _IsDrawingWithEffects() {
          return !!(64 & this._flags);
        }
        _SetIsDrawingWithEffects(t) {
          t ? this._flags |= 64 : this._flags &= -65;
        }
        SetFlag(t, e) {
          t <<= 16, e ? this._flags |= t : this._flags &= ~t;
        }
        GetFlag(t) {
          return !!(this._flags & t << 16);
        }
        GetCurrentImageInfo() {
          return this._sdkInst ? this._sdkInst.GetCurrentImageInfo() : null;
        }
        GetCurrentSurfaceSize() {
          return this._sdkInst ? this._sdkInst.GetCurrentSurfaceSize() : null;
        }
        GetCurrentTexRect() {
          return this._sdkInst ? this._sdkInst.GetCurrentTexRect() : null;
        }
        GetCurrentTexQuad() {
          return this._sdkInst ? this._sdkInst.GetCurrentTexQuad() : null;
        }
        IsCurrentTexRotated() {
          return !!this._sdkInst && this._sdkInst.IsCurrentTexRotated();
        }
        GetImagePoint(t) {
          return this._sdkInst ? this._sdkInst.GetImagePoint(t) : [this._iScriptInterface.x, this._iScriptInterface.y, this._iScriptInterface.totalZElevation];
        }
        GetObjectClass() {
          return this._objectType;
        }
        RendersToOwnZPlane() {
          return this._sdkInst ? this._sdkInst.RendersToOwnZPlane() : this._iScriptInterface._rendersToOwnZPlane();
        }
        BelongsToObjectClass(t) {
          return t.IsFamily() ? t.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === t;
        }
        CollectInstancesToPick(t, e, s2) {
          const n = (e2, s3) => {
            const n2 = s3 || e2.GetObjectClass(), i2 = t.get(n2);
            i2 ? i2.add(e2) : t.set(n2, /* @__PURE__ */ new Set([e2]));
          };
          if (n(this, e), this.IsInContainer()) for (const t2 of this.siblings()) n(t2);
          if (s2) for (const t2 of this.allChildren()) n(t2);
        }
        VerifySupportsSceneGraph() {
          if (!this.GetPlugin().SupportsSceneGraph()) throw new Error("object does not support scene graph");
        }
        HasParent() {
          return null !== this.GetParent();
        }
        GetParent() {
          const t = this.GetWorldInfo();
          if (!t) return null;
          const e = t.GetParent();
          return e ? e.GetInstance() : null;
        }
        GetTopParent() {
          const t = this.GetWorldInfo();
          if (!t) return null;
          const e = t.GetTopParent();
          return e ? e.GetInstance() : null;
        }
        *parents() {
          const t = this.GetWorldInfo();
          if (t) for (const e of t.parents()) yield e.GetInstance();
        }
        HasChild(t) {
          if (!t) return false;
          for (const e of this.children()) if (e === t) return true;
          return false;
        }
        HasChildren() {
          const t = this.GetWorldInfo();
          return !!t && t.HasChildren();
        }
        GetChildrenOfObjectClass(t) {
          const e = this.GetWorldInfo();
          if (!e) return [];
          const s2 = t.GetName();
          return e.GetChildren().map((t2) => t2.GetInstance()).filter((t2) => t2.GetObjectClass().GetName() === s2);
        }
        GetChildren() {
          const t = this.GetWorldInfo();
          return t ? t.GetChildren().map((t2) => t2.GetInstance()) : [];
        }
        *children() {
          const t = this.GetWorldInfo();
          if (t) for (const e of t.children()) yield e.GetInstance();
        }
        *allChildren() {
          const t = this.GetWorldInfo();
          if (t) for (const e of t.allChildren()) yield e.GetInstance();
        }
        GetChildCount() {
          const t = this.GetWorldInfo();
          return t ? t.GetChildCount() : 0;
        }
        GetParentCount() {
          return [...this.parents()].length;
        }
        GetAllChildCount() {
          const t = this.GetWorldInfo();
          return t ? t.GetAllChildCount() : 0;
        }
        GetChildAt(t) {
          const e = this.GetWorldInfo();
          if (!e) return null;
          const s2 = e.GetChildAt(t);
          return s2 ? s2.GetInstance() : null;
        }
        GetIndexInParent() {
          const t = this.GetWorldInfo();
          if (!t) return NaN;
          const e = t.GetParent();
          return e ? e.GetChildIndex(t) : NaN;
        }
        HasChildWithUID(t) {
          for (const e of this.GetWorldInfo().GetChildren()) if (e.GetInstance().GetUID() === t) return true;
          return false;
        }
        AddChild(t, e) {
          this.VerifySupportsSceneGraph(), t.VerifySupportsSceneGraph(), this.GetWorldInfo().AddChild(t.GetWorldInfo(), e || {});
        }
        RemoveChild(t) {
          const e = this.GetWorldInfo();
          e && e.RemoveChild(t.GetWorldInfo());
        }
        GetDestroyWithParent() {
          const t = this.GetWorldInfo();
          return !!t && t.GetDestroyWithParent();
        }
        SetupInitialSceneGraphConnections() {
          const t = this.GetWorldInfo();
          if (!t) return;
          const e = t.GetSceneGraphChildrenExportData();
          if (e) for (const t2 of e) {
            const e2 = this._runtime.GetInstanceByUID(t2[2]);
            if (e2) {
              const s2 = t2[3];
              this.AddChild(e2, { transformX: !!(1 & s2), transformY: !!(s2 >> 1 & 1), transformWidth: !!(s2 >> 2 & 1), transformHeight: !!(s2 >> 3 & 1), transformAngle: !!(s2 >> 4 & 1), destroyWithParent: !!(s2 >> 5 & 1), transformZElevation: !!(s2 >> 6 & 1), transformOpacity: !!(s2 >> 7 & 1), transformVisibility: !!(s2 >> 8 & 1) });
            }
          }
        }
        SetupPersistedSceneGraphConnections(t, e) {
          const s2 = t.get(this);
          if (s2) for (const t2 of s2["sceneGraphJson"]["children"]) {
            const s3 = e.get(t2["index"]);
            if (!s3) continue;
            const n = t2["flags"];
            this.AddChild(s3, { transformX: !!(1 & n), transformY: !!(n >> 1 & 1), transformWidth: !!(n >> 2 & 1), transformHeight: !!(n >> 3 & 1), transformAngle: !!(n >> 4 & 1), destroyWithParent: !!(n >> 5 & 1), transformZElevation: !!(n >> 6 & 1), transformOpacity: !!(n >> 7 & 1), transformVisibility: !!(n >> 8 & 1) });
          }
        }
        GetTemplateName() {
          const t = this._runtime.GetTemplateManager();
          return t ? t.GetInstanceTemplateName(this) : "";
        }
        IsInContainer() {
          return null !== this._siblings;
        }
        _ClearSiblings() {
          C33.clearArray(this._siblings);
        }
        _AddSibling(t) {
          this._siblings.push(t);
        }
        GetSiblings() {
          return this._siblings;
        }
        HasSibling(t) {
          return !!this.GetSibling(t);
        }
        GetSibling(t) {
          const e = this.siblings();
          if (null === e || 0 === e.length) return false;
          for (const s2 of e) if (s2.GetObjectClass() === t) return s2;
          return null;
        }
        siblings() {
          return this._siblings;
        }
        SetSiblingsSinglePicked() {
          for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol().SetSinglePicked(t);
        }
        _PushSiblingsToSolInstances() {
          for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._PushInstance(t);
        }
        _SetSiblingsToSolInstancesIndex(t) {
          for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnInstances()[t] = e;
        }
        _PushSiblingsToSolElseInstances() {
          for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._PushElseInstance(t);
        }
        _SetSiblingsToSolElseInstancesIndex(t) {
          for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[t] = e;
        }
        GetPlugin() {
          return this._objectType.GetPlugin();
        }
        _SetIID(t) {
          this._iid = t;
        }
        GetIID() {
          return this._objectType._UpdateIIDs(), this._iid;
        }
        GetUID() {
          return this._uid;
        }
        SetUID(t) {
          this._uid = t;
        }
        GetPUID() {
          return this._puid;
        }
        _SetTagsSetFromJson(t) {
          t ? this.SetTagsSet(new Set(t)) : this._tagsSet = null;
        }
        SetTagsSet(t) {
          if (0 === t.size) this._tagsSet = null;
          else {
            this._tagsSet ? this._tagsSet.clear() : this._tagsSet = /* @__PURE__ */ new Set();
            for (const e of t) this._tagsSet.add(e);
          }
        }
        GetTagsSet() {
          return this._tagsSet ?? /* @__PURE__ */ new Set();
        }
        GetTagsString() {
          return Array.from(this.GetTagsSet()).join(" ");
        }
        GetTagAt(t) {
          t = Math.floor(t);
          for (const e of this.GetTagsSet()) {
            if (0 === t) return e;
            --t;
          }
          return "";
        }
        GetBehaviorInstances() {
          return this._behaviorInstances;
        }
        GetBehaviorInstanceFromCtor(t) {
          if (!t) return null;
          for (const e of this._behaviorInstances) if (e.GetBehavior() instanceof t) return e;
          return null;
        }
        GetBehaviorSdkInstanceFromCtor(t) {
          if (!t) return null;
          const e = this.GetBehaviorInstanceFromCtor(t);
          return e ? e.GetSdkInstance() : null;
        }
        GetBehaviorIndexBySID(t) {
          const e = this._behaviorInstances;
          for (let s2 = 0, n = e.length; s2 < n; ++s2) if (e[s2].GetBehaviorType().GetSID() === t) return s2;
          return -1;
        }
        GetAllInstanceVariableValues() {
          return this._instVarValues;
        }
        _GetAllInstanceVariableNames() {
          return this._objectType._GetAllInstanceVariableNames();
        }
        GetInstanceVariableCount() {
          return this._instVarValues.length;
        }
        GetInstanceVariableValue(t) {
          t |= 0;
          const e = this._instVarValues;
          if (t < 0 || t >= e.length) throw new RangeError("invalid instance variable");
          return e[t];
        }
        _GetInstanceVariableValueUnchecked(t) {
          return this._instVarValues[t];
        }
        _GetInstanceVariableTypedValue(t) {
          const e = this._instVarValues[t];
          return 0 === this._objectType.GetInstanceVariableType(t) ? !!e : e;
        }
        SetInstanceVariableValue(t, e) {
          t |= 0;
          const s2 = this._instVarValues;
          if (t < 0 || t >= s2.length) throw new RangeError("invalid instance variable");
          switch (this._objectType.GetInstanceVariableType(t)) {
            case 0:
              s2[t] = e ? 1 : 0;
              break;
            case 1:
              s2[t] = "number" == typeof e ? e : parseFloat(e);
              break;
            case 2:
              s2[t] = "string" == typeof e ? e : e.toString();
              break;
            default:
              throw new Error("unknown instance variable type");
          }
        }
        SetInstanceVariableOffset(t, e) {
          if (0 === e) return;
          t |= 0;
          const s2 = this._instVarValues;
          if (t < 0 || t >= s2.length) throw new RangeError("invalid instance variable");
          const n = s2[t];
          if ("number" != typeof n) throw "boolean" == typeof n ? new Error("can not set offset of boolean variable") : "string" == typeof n ? new Error("can not set offset of string variable") : new Error("unknown instance variable type");
          s2[t] += "number" == typeof e ? e : parseFloat(e);
        }
        GetSavedDataMap() {
          let t = savedDataMaps.get(this);
          return t || (t = /* @__PURE__ */ new Map(), savedDataMaps.set(this, t), t);
        }
        GetUnsavedDataMap() {
          let t = unsavedDataMaps.get(this);
          return t || (t = /* @__PURE__ */ new Map(), unsavedDataMaps.set(this, t), t);
        }
        _HasAnyCreateDestroyHandler(t) {
          const e = this.GetObjectClass();
          if (e.UserScriptDispatcher().HasAnyHandlerFor(t)) return true;
          for (const s2 of e.GetFamilies()) if (s2.UserScriptDispatcher().HasAnyHandlerFor(t)) return true;
          return !!this._runtime.UserScriptDispatcher().HasAnyHandlerFor(t);
        }
        _TriggerOnCreatedOnSelfAndRelated(t = void 0) {
          const e = t ?? /* @__PURE__ */ new Set();
          if (e.has(this)) return;
          e.add(this);
          const s2 = this.GetWorldInfo();
          if (s2 && s2.HasChildren()) {
            for (const t2 of this.allChildren()) if (e.add(t2), t2.IsInContainer()) for (const s3 of t2.siblings()) e.add(s3);
          }
          if (this.IsInContainer()) for (const t2 of this.siblings()) t2._TriggerOnCreatedOnSelfAndRelated(e);
          if (!t) {
            for (const t2 of e.values()) t2._TriggerOnCreated();
            this._OnHierarchyReady();
          }
        }
        _OnCreatedCommon() {
          this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();
          for (const t of this._behaviorInstances) t.PostCreate();
        }
        _OnCreatedForLoadingSavegame() {
          this._OnCreatedCommon();
        }
        _TriggerOnCreated() {
          if (this._OnCreatedCommon(), this._HasAnyCreateDestroyHandler("instancecreate")) {
            const t = this.GetObjectClass(), e = new C33.Event("instancecreate");
            e.instance = this.GetInterfaceClass(), t.DispatchUserScriptEvent(e);
            for (const s2 of t.GetFamilies()) s2.DispatchUserScriptEvent(e);
            this._runtime.DispatchUserScriptEvent(e);
          }
          this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnCreated, this, null);
        }
        _OnHierarchyReady() {
          if (this.GetPlugin().SupportsSceneGraph()) {
            if (this.DispatchUserScriptEvent(new C33.Event("hierarchyready")), this._HasAnyCreateDestroyHandler("hierarchyready")) {
              const t = this.GetObjectClass(), e = new C33.Event("hierarchyready");
              e.instance = this.GetInterfaceClass(), t.DispatchUserScriptEvent(e);
              for (const s2 of t.GetFamilies()) s2.DispatchUserScriptEvent(e);
              this._runtime.DispatchUserScriptEvent(e);
            }
            this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnHierarchyReady, this, null);
          }
        }
        _TriggerOnDestroyed() {
          this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnDestroyed, this, null);
        }
        _FireDestroyedScriptEvents(t) {
          if (this._iScriptInterface) {
            const e2 = new C33.Event("destroy");
            e2.isEndingLayout = t, this.DispatchUserScriptEvent(e2);
          }
          if (!this._HasAnyCreateDestroyHandler("instancedestroy")) return;
          const e = this.GetObjectClass(), s2 = new C33.Event("instancedestroy");
          s2.instance = this.GetInterfaceClass(), s2.isEndingLayout = t, e.DispatchUserScriptEvent(s2);
          for (const t2 of e.GetFamilies()) t2.DispatchUserScriptEvent(s2);
          this._runtime.DispatchUserScriptEvent(s2);
        }
        _GetDebuggerProperties() {
          return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();
        }
        SaveToJson(t = "full", e = null) {
          const s2 = {};
          "full" === t ? s2["uid"] = this.GetUID() : s2["c3"] = true;
          const n = this.GetTagsSet();
          if (n.size > 0 && (s2["tags"] = Array.from(n)), "visual-state" !== t) {
            const e2 = savedDataMaps.get(this);
            if (e2 && e2.size && (s2["ex"] = C33.ToSuperJSON(e2)), -1 !== this.GetTimeScale() && (s2["mts"] = this.GetTimeScale()), this._objectType.GetInstanceVariablesCount() > 0) {
              const t2 = {}, e3 = this._objectType.GetInstanceVariableSIDs();
              for (let s3 = 0, n2 = this._instVarValues.length; s3 < n2; ++s3) t2[e3[s3].toString()] = this._instVarValues[s3];
              s2["ivs"] = t2;
            }
            if (this._behaviorInstances.length) {
              const e3 = {};
              for (const s3 of this._behaviorInstances) {
                const n2 = s3.SaveToJson(t);
                n2 && (e3[s3.GetBehaviorType().GetSID().toString()] = n2);
              }
              s2["behs"] = e3;
            }
          }
          this._worldInfo && (s2["w"] = this._worldInfo._SaveToJson(t, e));
          const i2 = this._sdkInst ? this._sdkInst.SaveToJson() : this._iScriptInterface._saveToJson();
          return i2 && (s2["data"] = i2), s2;
        }
        _OnBeforeLoad(t = "full", e = null) {
          this._worldInfo && this._worldInfo._OnBeforeLoad(t);
        }
        _OnAfterLoad(t, e = "full", s2 = null) {
          this._worldInfo && this._worldInfo._OnAfterLoad(t, e, s2);
        }
        _OnAfterLoad2(t, e = "full", s2 = null) {
          this._worldInfo && this._worldInfo._OnAfterLoad2(t, e, s2);
        }
        _SetupSceneGraphConnectionsOnChangeOfLayout() {
          this.GetPlugin().IsWorldType() && this._worldInfo._SetupSceneGraphConnectionsOnChangeOfLayout();
        }
        LoadFromJson(t, e = "full", s2 = null) {
          if ("full" === e) this._uid = t["uid"];
          else if (!t["c3"]) return;
          if (this._SetTagsSetFromJson(t["tags"]), "visual-state" !== e) {
            let e2 = savedDataMaps.get(this);
            e2 && (e2.clear(), savedDataMaps.delete(this));
            const s3 = t["ex"];
            s3 && (e2 = C33.FromSuperJSON(s3), savedDataMaps.set(this, e2)), this._timeScale = t.hasOwnProperty("mts") ? t["mts"] : -1;
            const n2 = t["ivs"];
            if (n2) for (const [t2, e3] of Object.entries(n2)) {
              const s4 = parseInt(t2, 10), n3 = this._objectType.GetInstanceVariableIndexBySID(s4);
              if (n3 < 0 || n3 >= this._instVarValues.length) continue;
              let i2 = e3;
              null === i2 && (i2 = NaN), this._instVarValues[n3] = i2;
            }
          }
          if (this.GetPlugin().IsWorldType()) {
            const n2 = t["w"];
            if (n2) {
              const t2 = n2["l"];
              if (this._worldInfo.GetLayer().GetSID() !== t2) {
                const s3 = this._worldInfo.GetLayer(), n3 = s3.GetLayout().GetLayerBySID(t2);
                n3 ? (this._worldInfo._SetLayer(n3), s3._RemoveInstance(this, true), n3._AddInstance(this, true), n3.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged()) : "full" === e && this._runtime.DestroyInstance(this);
              }
              this._worldInfo._LoadFromJson(n2, e, s2);
            }
          }
          if ("visual-state" !== e) {
            const s3 = t["behs"];
            if (s3) for (const [t2, n2] of Object.entries(s3)) {
              const s4 = parseInt(t2, 10), i2 = this.GetBehaviorIndexBySID(s4);
              i2 < 0 || i2 >= this._behaviorInstances.length || this._behaviorInstances[i2].LoadFromJson(n2, e);
            }
          }
          const n = t["data"];
          n && (this._sdkInst ? this._sdkInst.LoadFromJson(n, e) : this._iScriptInterface._loadFromJson(n));
        }
        MoveToLayerWithSID(t) {
          if (this._worldInfo.GetLayer().GetSID() === t) return;
          const e = this._worldInfo.GetLayer(), s2 = e.GetLayout().GetLayerBySID(t);
          s2 && (this._worldInfo._SetLayer(s2), e._RemoveInstance(this, true), s2._AddInstance(this, true), s2.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged());
        }
        GetInterfaceClass() {
          return this._iScriptInterface || this._InitUserScriptInterface();
        }
        HasScriptInterface() {
          return !!this._iScriptInterface;
        }
        _InitUserScriptInterface(t, e) {
          const s2 = this._worldInfo ? t ? self.ISDKWorldInstanceBase : self.IWorldInstance : t ? self.ISDKInstanceBase : self.IInstance, n = t || this._sdkInst.GetScriptInterfaceClass(), i2 = this._objectType._GetUserScriptInstanceClass(), r2 = i2 || n || s2, a2 = this.GetPlugin().GetSdkVersion();
          if (C33.AddonManager._PushInitObject(this, a2), C33.AddonManager._PushInitProperties(e), this._iScriptInterface = new r2(), C33.AddonManager._PopInitProperties(), C33.AddonManager._PopInitObject(a2), n && !(this._iScriptInterface instanceof s2)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s2.name}'`);
          if (i2) {
            const t2 = n || s2;
            if (!(this._iScriptInterface instanceof t2)) throw new TypeError(`setInstanceClass(): class '${i2.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);
          }
          return this._iScriptInterface;
        }
        _GetInstVarsScriptDescriptor(t) {
          if (0 === this._instVarValues.length) return;
          const e = {}, s2 = this._objectType._GetAllInstanceVariableJsPropNames();
          for (let t2 = 0, n2 = s2.length; t2 < n2; ++t2) e[s2[t2]] = { configurable: false, enumerable: true, get: C33.Instance.prototype._GetInstanceVariableTypedValue.bind(this, t2), set: C33.Instance.prototype.SetInstanceVariableValue.bind(this, t2) };
          const n = Object.create(Object.prototype, e);
          t.instVars = { value: n, writable: false };
        }
        _GetBehaviorsScriptDescriptor(t) {
          const e = this._behaviorInstances;
          if (0 === e.length) return;
          const s2 = {};
          for (const t2 of e) s2[t2.GetBehaviorType().GetJsPropName()] = { value: t2.GetScriptInterface(), writable: false };
          const n = Object.create(Object.prototype, s2);
          t.behaviors = { value: n, writable: false };
        }
        DispatchUserScriptEvent(t) {
          if (!this.HasScriptInterface()) return;
          const e = this.GetInterfaceClass();
          t.instance = e;
          const s2 = this._runtime, n = s2.IsDebug() && !s2.GetEventSheetManager().IsInEventEngine();
          n && C3Debugger.StartMeasuringScriptTime(), e.dispatchEvent(t), n && C3Debugger.AddScriptTime();
        }
      };
    }
    {
      const C33 = self.C3, updatedInstances = /* @__PURE__ */ new Map();
      C33.SceneGraphInfo = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._owner = t, this._parent = null, this._children = [], this._startWidth = t.GetWidth(), this._startHeight = t.GetHeight(), this._startScaleX = 1, this._startScaleY = 1, this._parentStartAngle = 0, this._ownOpacity = 1, this._startOpacity = t.GetOpacity(), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, this._on_instance_create = (e) => {
            if (e.instance !== this._parent.GetInstance()) return;
            t.GetRuntime().Dispatcher().removeEventListener("instancecreate", this._on_instance_create);
            const n = this._parent.GetInstance().GetSdkInstance();
            this._originalSizeKnown = !!n.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? n.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? n.GetOriginalHeight() : NaN;
          };
        }
        Release() {
          this._parent = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, C33.clearArray(this._children);
        }
        SetParent(t) {
          if (this._ownOpacity = this._owner.GetOpacity(), this._startOpacity = this._ownOpacity, this._parent = t, this._parentStartAngle = t ? t.GetAngle() : 0, this._parent) {
            const t2 = this._owner.GetRuntime();
            if (this._parent.GetInstance().GetPlugin().GetSdkVersion() < 2) {
              const e = this._parent.GetInstance().GetSdkInstance();
              e ? (this._originalSizeKnown = !!e.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? e.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? e.GetOriginalHeight() : NaN) : this._parent.GetInstance().IsDestroyed() || t2.Dispatcher().addEventListener("instancecreate", this._on_instance_create);
            } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;
          } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;
        }
        GetParent() {
          return this._parent;
        }
        HasChildren() {
          return this._children.length > 0;
        }
        GetChildren() {
          return this._children;
        }
        _MaybeSortChildren() {
          this.HasChildren() && 1 !== this._children.length && (this._tmpSceneGraphChildrenIndexes ? this._children.sort((t, e) => {
            const n = this._tmpSceneGraphChildrenIndexes.get(t.GetInstance()), s2 = this._tmpSceneGraphChildrenIndexes.get(e.GetInstance());
            return C33.IsFiniteNumber(n) && C33.IsFiniteNumber(s2) ? n - s2 : 0;
          }) : this._children.sort((t, e) => {
            const n = t._GetSceneGraphInfo()._GetIndexInParent(), s2 = e._GetSceneGraphInfo()._GetIndexInParent();
            return C33.IsFiniteNumber(n) && C33.IsFiniteNumber(s2) ? n - s2 : 0;
          }));
        }
        _GetIndexInParent() {
          return this._indexInParent;
        }
        GetStartScaleX() {
          return this._startScaleX;
        }
        SetStartScaleX(t) {
          this._startScaleX = t;
        }
        GetStartScaleY() {
          return this._startScaleY;
        }
        SetStartScaleY(t) {
          this._startScaleY = t;
        }
        GetStartOpacity() {
          return this._startOpacity;
        }
        GetOwnOpacity() {
          return this._ownOpacity;
        }
        SetOwnOpacity(t) {
          this._ownOpacity = t;
        }
        _GetStartWidth() {
          return 0 === this._startWidth ? Number.EPSILON : this._startWidth;
        }
        _GetStartHeight() {
          return 0 === this._startHeight ? Number.EPSILON : this._startHeight;
        }
        GetParentScaleX() {
          if (this._owner.GetTransformWithParentWidth()) {
            const t = this._parent;
            let e = t.GetWidth(), n = t._GetSceneGraphInfo()._GetStartWidth();
            return 0 === e && (e = Number.EPSILON), n === Number.EPSILON && e === Number.EPSILON ? 1 : n === Number.EPSILON && e !== Number.EPSILON && this._originalSizeKnown ? 1 + e / this._originalWidth : e / n;
          }
          return 1;
        }
        GetParentScaleY() {
          if (this._owner.GetTransformWithParentHeight()) {
            const t = this._parent;
            let e = t.GetHeight(), n = t._GetSceneGraphInfo()._GetStartHeight();
            return 0 === e && (e = Number.EPSILON), n === Number.EPSILON && e === Number.EPSILON ? 1 : n === Number.EPSILON && e !== Number.EPSILON && this._originalSizeKnown ? 1 + e / this._originalHeight : e / n;
          }
          return 1;
        }
        GetParentStartAngle() {
          return 0;
        }
        _SaveToJsonProperties() {
          return { "sw": this._startWidth, "sh": this._startHeight, "sx": this._startScaleX, "sy": this._startScaleY, "psa": this._parentStartAngle, "oo": this._ownOpacity, "so": this._startOpacity, "pi": this._owner.GetInstance().GetIndexInParent() };
        }
        _SaveToJson(t, e = null) {
          const n = this._SaveToJsonProperties();
          return e && e["selfOnly"] ? Object.assign(n, { "p": null, "c": [] }) : Object.assign(n, { "p": this._GetParentJson(t), "c": this._GetChildrenJson(t) });
        }
        _GetFlagsString(t) {
          let e = "";
          return t.GetTransformWithParentX() && (e += "x"), t.GetTransformWithParentY() && (e += "y"), t.GetTransformWithParentWidth() && (e += "w"), t.GetTransformWithParentHeight() && (e += "h"), t.GetTransformWithParentAngle() && (e += "a"), t.GetTransformWithParentZElevation() && (e += "z"), t.GetDestroyWithParent() && (e += "d"), t.GetTransformWithParentOpacity() && (e += "o"), t.GetTransformWithParentVisibility() && (e += "v"), e;
        }
        _GetParentJson(t) {
          return this._parent ? !this._parent.GetInstance() || this._parent.GetInstance().IsDestroyed() ? null : this._GetInstanceJson(this._parent, this._owner, t) : null;
        }
        _GetChildrenJson(t) {
          return this._children.map((e) => this._GetInstanceJson(e, e, t)).filter((t2) => t2);
        }
        _GetInstanceJson(t, e, n) {
          const s2 = t.GetInstance();
          if (s2 && s2.IsDestroyed()) return null;
          const i2 = {};
          return i2["uid"] = s2.GetUID(), i2["f"] = this._GetFlagsString(e), i2["offsets"] = e._SaveSceneGraphPropertiesToJson(), i2["data"] = C33.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(s2), i2["oci"] = s2.GetObjectClass().GetIndex(), "state" === n ? (i2["inst"] = s2.SaveToJson("full", { "selfOnly": true }), i2["instIndex"] = NaN) : (i2["instIndex"] = s2.GetObjectClass().GetInstances().indexOf(s2), i2["inst"] = null), i2;
        }
        _LoadFromJson(t) {
          this._startWidth = t["sw"], this._startHeight = t["sh"], this._startScaleX = t["sx"], this._startScaleY = t["sy"], this._parentStartAngle = t["psa"], this._ownOpacity = t["oo"], this._startOpacity = t["so"], this._indexInParent = C33.IsFiniteNumber(t["pi"]) ? t["pi"] : NaN;
        }
        _SetTmpSceneGraphChildren(t, e, n, s2) {
          if (!t && !e) {
            if (s2?.setFromJson) {
              if (this._tmpSceneGraphChildren) for (const t2 of this._tmpSceneGraphChildren) t2.IsDestroyed() || t2.HasParent() || t2.GetRuntime().DestroyInstance(t2);
            } else if (this._tmpSceneGraphChildren) {
              for (const t2 of this._tmpSceneGraphChildren) if (n["c"] && n["c"].length) {
                if (!n["c"].some((e2) => e2["uid"] === t2.GetUID())) continue;
                t2.IsDestroyed() || t2.HasParent() || t2.GetRuntime().DestroyInstance(t2);
              }
            }
          }
          this._tmpSceneGraphChildren = t, this._tmpSceneGraphChildrenIndexes = e;
        }
        _GetInstanceByUID(t) {
          const e = this._owner.GetRuntime();
          return updatedInstances.has(t) ? updatedInstances.get(t) : e.GetInstanceByUID(t);
        }
        _OnAfterLoad(t, e) {
          const n = this._owner, s2 = n.GetRuntime(), i2 = e?.processedWorldInfo ?? /* @__PURE__ */ new Set();
          if (t["p"] && !this._parent) {
            const a3 = t["p"]["uid"], r3 = this._GetInstanceByUID(a3);
            if (r3) {
              const a4 = r3.GetWorldInfo();
              if (r3.HasChild(n.GetInstance())) this._parent = a4;
              else {
                r3.HasChildWithUID(n.GetInstance().GetUID()) ? (s2.DestroyInstance(n.GetInstance()), s2._RemoveInstanceFromUIDMap(n.GetInstance().GetUID()), updatedInstances.delete(n.GetInstance().GetUID())) : r3.AddChild(n.GetInstance(), this._GetFlagsObj(t["p"]["f"])), i2.has(n) || (n._LoadSceneGraphPropertiesFromJson(t["p"]["offsets"]), this._LoadInstancePropertiesFromJson(r3, t["p"], e), this._UpdateUIDInstanceMap(r3, r3.GetUID(), n.GetRuntime(), e)), i2.add(n);
                r3.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren();
              }
            } else if (C33.IsFiniteNumber(t["p"]["oci"])) {
              const i3 = s2.CreateInstance(s2.GetObjectClassByIndex(t["p"]["oci"]), n.GetLayer(), 0, 0, true);
              if (i3) {
                const a4 = this._GetInstanceData(t["p"], s2);
                a4 && i3.LoadFromJson(a4);
                const r4 = i3.GetWorldInfo(), h = !!e?.setFromJson;
                r4.GetLayer().SortAndAddInstancesByZIndex(i3, false, h), i3.AddChild(n.GetInstance(), this._GetFlagsObj(t["p"]["f"])), updatedInstances.set(i3.GetUID(), i3), this._UpdateUIDInstanceMap(i3, i3.GetUID(), s2, e);
                i3.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren();
              }
            }
          }
          const a2 = [];
          for (const e2 of t["c"]) {
            const t2 = e2["uid"], n2 = this._GetInstanceByUID(t2);
            n2 && a2.push(n2);
          }
          let r2 = 0;
          for (const h of t["c"]) {
            const c2 = h["uid"], o2 = this._GetInstanceByUID(c2);
            if (o2) {
              if (this._tmpSceneGraphChildren) {
                if (this._tmpSceneGraphChildren.includes(o2)) {
                  const s4 = o2;
                  if (s4.GetObjectClass() !== o2.GetObjectClass()) {
                    r2++;
                    continue;
                  }
                  if (s4.IsDestroyed()) {
                    r2++;
                    continue;
                  }
                  const h2 = t["c"][r2];
                  if (!e?.setFromJson && this._HasAllChildrenOfType(s4, a2, n)) {
                    if (n.GetInstance().GetChildAt(r2)) {
                      const a3 = s4.GetObjectClass().GetIndex(), c3 = h2["oci"], o3 = n.GetInstance().GetChildAt(r2).GetObjectClass().GetIndex();
                      if (a3 !== c3 || c3 !== o3) {
                        this._RefreshAllChildren(t["c"], n, i2, e);
                        break;
                      }
                      this._UpdateInstance(r2, h2, n, i2, e);
                    } else this._UpdateInstance(r2, h2, n, i2, e);
                    r2++;
                    continue;
                  }
                  if (s4.HasParent() && s4.GetParent() !== n.GetInstance()) {
                    const t2 = this._CreateNewChildInstance(h2, e);
                    this._AddAndSetChildInstance(t2, h2, i2, e), r2++;
                    continue;
                  }
                  this._AddAndSetChildInstance(s4.GetWorldInfo(), h2, i2, e, true), r2++;
                  continue;
                }
                if (this._tmpSceneGraphChildren[r2]) {
                  const s4 = this._tmpSceneGraphChildren[r2];
                  if (s4.GetObjectClass() !== o2.GetObjectClass()) {
                    r2++;
                    continue;
                  }
                  if (s4.IsDestroyed()) {
                    r2++;
                    continue;
                  }
                  const h2 = t["c"][r2];
                  if (!e?.setFromJson && this._HasAllChildrenOfType(s4, a2, n)) {
                    if (n.GetInstance().GetChildAt(r2)) {
                      const a3 = s4.GetObjectClass().GetIndex(), c3 = h2["oci"], o3 = n.GetInstance().GetChildAt(r2).GetObjectClass().GetIndex();
                      if (a3 !== c3 || c3 !== o3) {
                        this._RefreshAllChildren(t["c"], n, i2, e);
                        break;
                      }
                      this._UpdateInstance(r2, h2, n, i2, e);
                    } else this._UpdateInstance(r2, h2, n, i2, e);
                    r2++;
                    continue;
                  }
                  if (s4.HasParent() && s4.GetParent() !== n.GetInstance()) {
                    const t2 = this._CreateNewChildInstance(h2, e);
                    this._AddAndSetChildInstance(t2, h2, i2, e), r2++;
                    continue;
                  }
                  this._AddAndSetChildInstance(s4.GetWorldInfo(), h2, i2, e, true), r2++;
                  continue;
                }
              }
              const s3 = o2.GetObjectClass();
              if (this._GetInstancesOfObjectClassCount(a2, s3) === n.GetInstance().GetChildrenOfObjectClass(s3).length) {
                for (const t2 of n.GetInstance().GetChildren()) {
                  if (t2.GetObjectClass() !== s3) continue;
                  const n2 = t2.GetWorldInfo();
                  if (n2 && !i2.has(n2)) {
                    i2.add(n2), n2._LoadSceneGraphPropertiesFromJson(h["offsets"]), this._LoadInstancePropertiesFromJson(t2, h, e);
                    break;
                  }
                }
                r2++;
                continue;
              }
              if (o2.HasParent() && o2.GetParent() !== n.GetInstance()) {
                const t2 = this._CreateNewChildInstance(h, e);
                this._AddAndSetChildInstance(t2, h, i2, e), r2++;
                continue;
              }
              this._AddAndSetChildInstance(o2.GetWorldInfo(), h, i2, e);
            } else if (this._tmpSceneGraphChildren && this._tmpSceneGraphChildren[r2]) {
              const c3 = this._tmpSceneGraphChildren[r2], o3 = s2.GetObjectClassByIndex(this._GetObjectClassIndex(h));
              if (c3.GetObjectClass() !== o3) {
                r2++;
                continue;
              }
              if (c3.IsDestroyed()) {
                r2++;
                continue;
              }
              const d2 = t["c"][r2];
              if (!e?.setFromJson && this._HasAllChildrenOfType(c3, a2, n)) {
                if (n.GetInstance().GetChildAt(r2)) {
                  const s3 = c3.GetObjectClass().GetIndex(), a3 = d2["oci"], h2 = n.GetInstance().GetChildAt(r2).GetObjectClass().GetIndex();
                  if (s3 !== a3 || a3 !== h2) {
                    this._RefreshAllChildren(t["c"], n, i2, e);
                    break;
                  }
                  this._UpdateInstance(r2, d2, n, i2, e);
                } else this._UpdateInstance(r2, d2, n, i2, e);
                r2++;
                continue;
              }
              if (c3.HasParent() && c3.GetParent() !== n.GetInstance()) {
                const t2 = this._CreateNewChildInstance(d2, e);
                this._AddAndSetChildInstance(t2, d2, i2, e), r2++;
                continue;
              }
              this._AddAndSetChildInstance(c3.GetWorldInfo(), d2, i2, e);
            } else {
              const t2 = this._CreateNewChildInstance(h, e);
              this._AddAndSetChildInstance(t2, h, i2, e);
            }
            r2++;
          }
        }
        _RefreshAllChildren(t, e, n, s2) {
          const i2 = e.GetRuntime();
          for (const t2 of e.GetInstance().children()) t2 && !t2.IsDestroyed() && (i2.DestroyInstance(t2), i2._RemoveInstanceFromUIDMap(t2.GetUID()), updatedInstances.delete(t2.GetUID()));
          this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren = []), this._tmpSceneGraphChildrenIndexes && (this._tmpSceneGraphChildrenIndexes = /* @__PURE__ */ new WeakMap());
          Object.assign({}, s2, { "assignZIndex": false });
          for (const e2 of t) {
            const t2 = this._CreateNewChildInstance(e2, s2);
            this._AddAndSetChildInstance(t2, e2, n, s2), this._tmpSceneGraphChildren.push(t2.GetInstance()), this._tmpSceneGraphChildrenIndexes.set(t2.GetInstance(), this._tmpSceneGraphChildren.length - 1);
          }
          e._GetSceneGraphInfo()._MaybeSortChildren();
        }
        _HasAllChildrenOfType(t, e, n) {
          const s2 = t.GetObjectClass();
          return this._GetInstancesOfObjectClassCount(e, s2) === n.GetInstance().GetChildrenOfObjectClass(s2).length;
        }
        _UpdateInstance(t, e, n, s2, i2) {
          const a2 = n.GetInstance().GetChildAt(t);
          if (!a2) return;
          const r2 = a2.GetWorldInfo();
          r2 && (s2.has(r2) || (r2._LoadSceneGraphPropertiesFromJson(e["offsets"]), this._LoadInstancePropertiesFromJson(a2, e, i2)), s2.add(r2));
        }
        _GetFlagsObj(t) {
          const e = {};
          return e.transformX = t.includes("x"), e.transformY = t.includes("y"), e.transformWidth = t.includes("w"), e.transformHeight = t.includes("h"), e.transformAngle = t.includes("a"), e.transformZElevation = t.includes("z"), e.destroyWithParent = t.includes("d"), e.transformOpacity = t.includes("o"), e.transformVisibility = t.includes("v"), e;
        }
        _GetObjectClassIndex(t) {
          return C33.IsFiniteNumber(t["oci"]) ? t["oci"] : t[1];
        }
        _CreateNewChildInstance(t, e) {
          if (!C33.IsFiniteNumber(t["oci"])) return;
          const n = this._owner, s2 = n.GetRuntime();
          let i2;
          const a2 = !e.hasOwnProperty("createHierarchy") || e["createHierarchy"];
          if (i2 = t["data"] ? s2.CreateInstanceFromData(t["data"], n.GetLayer(), false, 0, 0, false, a2) : s2.CreateInstance(s2.GetObjectClassByIndex(t["oci"]), n.GetLayer(), 0, 0, a2), !i2) return;
          const r2 = this._GetInstanceData(t, s2);
          r2 && i2.LoadFromJson(r2);
          const h = i2.GetWorldInfo(), c2 = !!e?.setFromJson;
          return h.GetLayer().SortAndAddInstancesByZIndex(i2, true, c2), h;
        }
        _UpdateUIDInstanceMap(t, e, n, s2) {
          if (this._GetInstanceByUID(e) && !s2?.setFromJson) {
            const s3 = this._GetInstanceByUID(e);
            s3 !== t && n.DestroyInstance(s3);
          }
          n._RemoveInstanceFromUIDMap(e), n._MapInstanceByUID(e, t);
        }
        _AddAndSetChildInstance(t, e, n, s2, i2 = true) {
          const a2 = this._owner, r2 = a2.AddChild(t, this._GetFlagsObj(e["f"]));
          r2 && i2 ? (n.has(t) || (t._LoadSceneGraphPropertiesFromJson(e["offsets"]), this._LoadInstancePropertiesFromJson(t.GetInstance(), e, s2)), n.add(t)) : r2 && (updatedInstances.set(t.GetInstance().GetUID(), t.GetInstance()), this._UpdateUIDInstanceMap(t.GetInstance(), e["uid"], a2.GetRuntime(), s2)), this._MaybeSortChildren();
        }
        _LoadInstancePropertiesFromJson(t, e, n) {
          let s2 = this._GetInstanceData(e, this._owner.GetRuntime());
          if (!s2) return;
          const i2 = !n.hasOwnProperty("clearChildren") || n["clearChildren"], a2 = !n.hasOwnProperty("assignZIndex") || n["assignZIndex"], r2 = t.GetRuntime();
          if (updatedInstances.set(t.GetUID(), t), s2 = JSON.parse(JSON.stringify(s2)), i2 && t.GetUID() !== s2["uid"]) {
            for (const e2 of t.children()) e2 && !e2.IsDestroyed() && (r2.DestroyInstance(e2), r2._RemoveInstanceFromUIDMap(e2.GetUID()), updatedInstances.delete(e2.GetUID()));
            if (s2["w"]?.["sgi"] && s2["w"]["sgi"]["c"]?.length) for (const e2 of s2["w"]["sgi"]["c"]) {
              const s3 = Object.assign({}, n, { "clearChildren": false, "createHierarchy": false }), i3 = this._CreateNewChildInstance(e2, s3);
              updatedInstances.set(i3.GetInstance().GetUID(), i3.GetInstance()), t.AddChild(i3.GetInstance(), this._GetFlagsObj(e2["f"])), i3._LoadSceneGraphPropertiesFromJson(e2["offsets"]), this._LoadInstancePropertiesFromJson(i3.GetInstance(), e2, s3);
            }
          }
          const h = s2["w"]?.["zi"], c2 = s2["w"]?.["l"];
          s2["w"] = null, t.LoadFromJson(s2), n?.setFromJson || (C33.IsFiniteNumber(h) && a2 && t.GetWorldInfo()._SetZIndex(h), C33.IsFiniteNumber(c2) && t.MoveToLayerWithSID(c2)), this._UpdateUIDInstanceMap(t, s2["uid"], r2, n);
        }
        _GetInstancesOfObjectClassCount(t, e) {
          return t.filter((t2) => t2.GetObjectClass().GetName() === e.GetName()).length;
        }
        _GetInstanceData(t, e) {
          if (C33.IsFiniteNumber(t["instIndex"])) {
            const n = e.GetObjectClassByIndex(t["oci"])._GetLoadInstancesJson();
            return n ? n[t["instIndex"]] : null;
          }
          return C33.IsString(t["inst"]) ? JSON.parse(t["inst"]) : t["inst"] ? t["inst"] : void 0;
        }
        static GetSceneGraphInstanceDataFromInstance(t) {
          let e = t.GetWorldInfo().GetLayer().GetInitialInstanceData(t.GetUID());
          if (!e) return null;
          e = JSON.parse(JSON.stringify(e));
          const n = [];
          for (const e2 of [...t.GetChildren()]) {
            const t2 = e2.GetWorldInfo();
            n.push([t2.GetLayout().GetSID(), t2.GetLayer().GetIndex(), e2.GetUID(), C33.SceneGraphInfo._GetFlagsNumber(t2), e2.GetObjectClass().IsInContainer() ? 1 : 0, t2.GetZIndex(), C33.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(e2)]);
          }
          return C33.IsArray(e[0][14]) ? e[0][14][1] = n : (e[0][14] = [], e[0][14][0] = C33.SceneGraphInfo._GetDefaultFlagsNumber(), e[0][14][1] = n, e[0][14][2] = t.GetWorldInfo().GetZIndex()), e;
        }
        static _GetFlagsNumber(t) {
          let e = 0;
          return e |= Number(t.GetTransformWithParentVisibility()) << 8, e |= Number(t.GetTransformWithParentOpacity()) << 7, e |= Number(t.GetTransformWithParentZElevation()) << 6, e |= Number(t.GetDestroyWithParent()) << 5, e |= Number(t.GetTransformWithParentAngle()) << 4, e |= Number(t.GetTransformWithParentHeight()) << 3, e |= Number(t.GetTransformWithParentWidth()) << 2, e |= Number(t.GetTransformWithParentY()) << 1, e |= Number(t.GetTransformWithParentX()) | 0, e;
        }
        static _GetDefaultFlagsNumber(t) {
          let e = 0;
          return e |= 256, e |= 128, e |= 64, e |= 32, e |= 16, e |= 8, e |= 4, e |= 2, e |= 1, 511;
        }
        static ClearUpdatedInstances() {
          updatedInstances.clear();
        }
      };
    }
    {
      const C33 = self.C3, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, vec42 = glMatrix.vec4, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad), bboxChangeEvent = C33.New(C33.Event, "bboxchange", false), tempColor = C33.New(C33.Color, 0, 0, 0, 0), tempCollisionPoly = C33.New(C33.CollisionPoly), DEFAULT_COLOR = C33.New(C33.Color, 1, 1, 1, 1), DEFAULT_RENDER_CELLS = C33.New(C33.Rect, 0, 0, -1, -1), DEFAULT_COLLISION_CELLS = C33.New(C33.Rect, 0, 0, -1, -1), VALID_SET_MESH_POINT_MODES = /* @__PURE__ */ new Set(["absolute", "relative"]), EMPTY_ARRAY = [];
      let enableUpdateRendererStateGroup = true;
      const FLAG_IS_VISIBLE = 1, FLAG_BBOX_CHANGED = 2, FLAG_ENABLE_BBOX_CHANGED_EVENT = 4, FLAG_COLLISION_ENABLED = 8, FLAG_COLLISION_CELL_CHANGED = 16, FLAG_SOLID_FILTER_INCLUSIVE = 32, FLAG_HAS_ANY_ACTIVE_EFFECT = 64, FLAG_IS_ROTATABLE = 128, FLAG_DESTROYED = 256, FLAG_DESTROY_WITH_PARENT = 512, FLAG_TRANSFORM_WITH_PARENT_X = 1024, FLAG_TRANSFORM_WITH_PARENT_Y = 2048, FLAG_TRANSFORM_WITH_PARENT_W = 4096, FLAG_TRANSFORM_WITH_PARENT_H = 8192, FLAG_TRANSFORM_WITH_PARENT_A = 16384, FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 32768, FLAG_TRANSFORM_WITH_PARENT_OPACITY = 1 << 22, FLAG_TRANSFORM_WITH_PARENT_VISIBILITY = 1 << 23, MASK_ALL_SCENE_GRAPH_FLAGS = 12647936, FLAG_MESH_CHANGED = 65536, FLAG_PHYSICS_BODY_CHANGED = 1 << 17, FLAG_SIN_COS_ANGLE_CHANGED = 1 << 18, FLAG_USE_POINTS_SHADER_PROGRAM = 1 << 19, FLAG_DRAW_BACK_FACE_ONLY = 1 << 20, FLAG_DRAW_NON_BACK_FACES_ONLY = 1 << 21, FLAG_ENABLE_BACK_FACE_CULLING = 1 << 24, FLAG_BLEND_MODE_BIT_OFFSET = 26, FLAG_BLEND_MODE_MASK = 31 << 26, sceneGraphExportDataMap = /* @__PURE__ */ new WeakMap(), sceneGraphZIndexMap = /* @__PURE__ */ new WeakMap();
      C33.WorldInfo = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._inst = t, this._objectClass = t.GetObjectClass(), this._runtime = t.GetRuntime(), this._layer = e, this._objectClass._OnWorldInstanceLayerChanged(this, null, e), this._zIndex = -1, this._htmlZIndex = -1, this._flags = 196635, this._objectClass.GetPlugin().IsRotatable() && (this._flags |= 128), this._x = NaN, this._y = NaN, this._zElevation = NaN, this._w = NaN, this._h = NaN, this._depth = NaN, this._a = NaN, this._sinA = NaN, this._cosA = NaN, this._ox = NaN, this._oy = NaN, this._boundingBox = C33.New(C33.Rect), this._boundingQuad = C33.New(C33.Quad), this._collisionCells = DEFAULT_COLLISION_CELLS, this._renderCells = DEFAULT_RENDER_CELLS, this._sourceCollisionPoly = null, this._transformedPolyInfo = null, this._solidFilterTags = null, this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR, this._stateGroup = null, this._instanceEffectList = null, this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = C33.New(C33.InstanceEffectList, this._inst, this)), this._sceneGraphInfo = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._tmpHierarchyPosition = -1, this._meshInfo = null;
        }
        _MarkDestroyed() {
          this._flags |= 256;
        }
        Release() {
          if (this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, null), this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null), this._sourceCollisionPoly = null, this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null), this._solidFilterTags && (this._solidFilterTags.clear(), this._solidFilterTags = null), this.ReleaseMesh(), this._instanceEffectList && this._instanceEffectList.Release(), this.HasParent() && this.GetParent().RemoveChild(this), this.HasChildren()) {
            const t = [...this.GetChildren()];
            for (const e of t) this.RemoveChild(e);
          }
          this._ReleaseSceneGraphInfo(), this._ReleaseTmpSceneGraphInfo(), sceneGraphExportDataMap.delete(this), sceneGraphZIndexMap.delete(this), this._inst = null, this._objectClass = null, this._runtime = null, this._layer = null;
        }
        Init(t) {
          if (enableUpdateRendererStateGroup = false, this.SetXY(t[0], t[1]), this.SetZElevation(t[2]), this.SetSize(t[3], t[4]), this._depth = 0, this.IsRotatable() ? this.SetAngle(t[6]) : this._a = 0, tempColor.setFromJSON(t[7]), this._SetColor(tempColor), this.SetOriginX(t[8]), this.SetOriginY(t[9]), this.SetBlendMode(t[10]), this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(t[12]), t[14] && sceneGraphExportDataMap.set(this, { childrenData: t[14][1], zIndexData: t[14][2] }), t[15]) {
            const e = t[15];
            this.CreateMesh(e[0], e[1]);
            const s2 = this.GetSourceMesh(), i2 = e[2];
            for (let t2 = 0, e2 = i2.length; t2 < e2; ++t2) {
              const e3 = i2[t2];
              for (let i3 = 0, n = e3.length; i3 < n; ++i3) {
                const n2 = e3[i3], r2 = s2.GetMeshPointAt(i3, t2);
                r2.SetX(n2[0]), r2.SetY(n2[1]), r2.SetZElevation(n2[2]), r2.SetU(n2[3]), r2.SetV(n2[4]);
              }
            }
          }
          if (t[16]) {
            const e = t[16][0], s2 = t[16][1], i2 = !!s2, n = !i2, r2 = this._runtime.GetTemplateManager();
            i2 && r2 && r2.MapInstanceToTemplateName(this.GetInstance(), s2), n && r2 && r2.MapInstanceToTemplateName(this.GetInstance(), e);
          }
          enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup();
        }
        InitNoData() {
          this._x = 0, this._y = 0, this._zElevation = 0, this._w = 0, this._h = 0, this._depth = 0, this._a = 0, this._sinA = 0, this._cosA = 1, this._ox = 0, this._oy = 0, this._UpdateRendererStateGroup();
        }
        GetRuntime() {
          return this._runtime;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetInstance() {
          return this._inst;
        }
        _GetParentOffsetAngle() {
          return this.GetTransformWithParentAngle() ? this._MaybeReflectAngleForMirrorFlip(this.GetParent()._GetAngleNoReflect() - this._sceneGraphInfo.GetParentStartAngle()) : 0;
        }
        SetX(t) {
          if (t = +t, this.GetTransformWithParentX()) {
            const e = this._sceneGraphInfo, s2 = t - this.GetX(), i2 = -this._GetParentOffsetAngle();
            0 === i2 ? this._x += s2 / e.GetParentScaleX() : (this._x += Math.cos(i2) * s2 / e.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(i2) * s2 / e.GetParentScaleY()));
          } else this._x = t;
        }
        OffsetX(t, e = false) {
          t = +t, e ? this._x += t : this.GetTransformWithParentX() ? this.SetX(this.GetX() + t) : this._x += t;
        }
        GetX() {
          if (this.GetTransformWithParentX()) {
            let t = this._x;
            const e = this._sceneGraphInfo, s2 = this.GetParent(), i2 = this._GetParentOffsetAngle();
            return 0 === i2 ? t *= e.GetParentScaleX() : (t = t * e.GetParentScaleX() * Math.cos(i2), this.GetTransformWithParentY() && (t -= this._y * e.GetParentScaleY() * Math.sin(i2))), s2.GetX() + t;
          }
          return this._x;
        }
        SetY(t) {
          if (t = +t, this.GetTransformWithParentY()) {
            const e = this._sceneGraphInfo, s2 = t - this.GetY(), i2 = -this._GetParentOffsetAngle();
            0 === i2 ? this._y += s2 / e.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(i2) * s2 / e.GetParentScaleX()), this._y += Math.cos(i2) * s2 / e.GetParentScaleY());
          } else this._y = t;
        }
        OffsetY(t, e = false) {
          t = +t, e ? this._y += t : this.GetTransformWithParentY() ? this.SetY(this.GetY() + t) : this._y += t;
        }
        GetY() {
          if (this.GetTransformWithParentY()) {
            let t = this._y;
            const e = this._sceneGraphInfo, s2 = this.GetParent(), i2 = this._GetParentOffsetAngle();
            return 0 === i2 ? t *= e.GetParentScaleY() : (t = t * e.GetParentScaleY() * Math.cos(i2), this.GetTransformWithParentX() && (t += this._x * e.GetParentScaleX() * Math.sin(i2))), s2.GetY() + t;
          }
          return this._y;
        }
        SetXY(t, e) {
          if (t = +t, e = +e, this.GetTransformWithParentXOrY()) {
            const s2 = this.GetTransformWithParentX(), i2 = this.GetTransformWithParentY(), n = this._sceneGraphInfo, r2 = t - this.GetX(), h = e - this.GetY(), a2 = -this._GetParentOffsetAngle();
            if (0 === a2) s2 ? this._x += r2 / n.GetParentScaleX() : this._x = t, i2 ? this._y += h / n.GetParentScaleY() : this._y = e;
            else {
              const o2 = Math.sin(a2), l2 = Math.cos(a2);
              s2 ? this._x += i2 ? (l2 * r2 - o2 * h) / n.GetParentScaleX() : l2 * r2 / n.GetParentScaleX() : this._x = t, i2 ? this._y += s2 ? (o2 * r2 + l2 * h) / n.GetParentScaleY() : l2 * h / n.GetParentScaleY() : this._y = e;
            }
          } else this._x = t, this._y = e;
        }
        GetXY() {
          return [this.GetX(), this.GetY()];
        }
        OffsetXY(t, e) {
          t = +t, e = +e, this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + t, this.GetY() + e) : (this._x += t, this._y += e);
        }
        EqualsXY(t, e) {
          return this.GetX() === t && this.GetY() === e;
        }
        SetZElevation(t) {
          if (t = +t, this.GetTransformWithParentZElevation() && (t -= this.GetParent().GetZElevation()), this._zElevation === t) return;
          this._zElevation = t, this._UpdateZElevation();
          const e = this.GetLayer();
          0 !== this._zElevation && e._SetAnyInstanceZElevated(), e.SetZIndicesChanged(this);
        }
        _UpdateZElevation() {
          if (this._UpdateRendererStateGroup(), this.HasChildren()) {
            const t = this.GetChildren();
            for (let e = 0, s2 = t.length; e < s2; e++) {
              const s3 = t[e];
              s3.GetTransformWithParentZElevation() && s3._UpdateZElevation();
            }
          }
        }
        OffsetZElevation(t) {
          this.SetZElevation(this.GetZElevation() + t);
        }
        GetZElevation() {
          return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation;
        }
        GetTotalZElevation() {
          return this.GetLayer().GetZElevation() + this.GetZElevation();
        }
        IsOriginalSizeKnown() {
          return this.GetInstance().GetPlugin().GetSdkVersion() < 2 && this.GetInstance().GetSdkInstance().IsOriginalSizeKnown();
        }
        SetWidth(t) {
          if (t = +t, this.GetTransformWithParentWidth()) {
            const e = this.GetWidth();
            0 === e ? this._w = Number.EPSILON : this._w *= t / e;
          } else this._w = t;
          this._MarkSinCosAngleChanged();
        }
        OffsetWidth(t, e) {
          t = +t, e ? this._w += t : this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + t) : this._w += t, this._MarkSinCosAngleChanged();
        }
        GetWidth() {
          if (this.GetTransformWithParentWidth()) {
            const t = this.GetParent(), e = t.GetWidth();
            return t._GetSceneGraphInfo()._GetStartWidth() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartWidth() + e) * this._w : e * this._w;
          }
          return this._w;
        }
        SetHeight(t) {
          if (t = +t, this.GetTransformWithParentHeight()) {
            const e = this.GetHeight();
            0 === e ? this._h = Number.EPSILON : this._h *= t / e;
          } else this._h = t;
          this._MarkSinCosAngleChanged();
        }
        OffsetHeight(t, e) {
          t = +t, e ? this._h += t : this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + t) : this._h += t, this._MarkSinCosAngleChanged();
        }
        GetHeight() {
          if (this.GetTransformWithParentHeight()) {
            const t = this.GetParent(), e = t.GetHeight();
            return t._GetSceneGraphInfo()._GetStartHeight() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartHeight() + e) * this._h : e * this._h;
          }
          return this._h;
        }
        SetSize(t, e) {
          if (t = +t, e = +e, this.GetTransformWithParentWidth()) {
            const e2 = this.GetWidth();
            0 === e2 ? this._w = Number.EPSILON : this._w *= t / e2;
          } else this._w = t;
          if (this.GetTransformWithParentHeight()) {
            const t2 = this.GetHeight();
            0 === t2 ? this._h = Number.EPSILON : this._h *= e / t2;
          } else this._h = e;
          this._MarkSinCosAngleChanged();
        }
        GetSize() {
          return [this.GetWidth(), this.GetHeight()];
        }
        GetDepth() {
          return this._depth;
        }
        SetDepth(t) {
          if (t < 0) throw new RangeError("invalid depth");
          this._depth = t;
        }
        GetSceneGraphScale() {
          if (this.HasParent()) {
            const t = this._sceneGraphInfo;
            return Math.min(t.GetParentScaleX(), t.GetParentScaleY());
          }
          return 1;
        }
        IsRotatable() {
          return !!(128 & this._flags);
        }
        SetAngle(t) {
          t = +t, this.IsRotatable() && (this.GetTransformWithParentAngle() && (t -= this.GetParent().GetAngle()), t = C33.clampAngle(t), this._a !== t && (this._a = t, this._MarkSinCosAngleChanged()));
        }
        OffsetAngle(t) {
          0 !== (t = +t) && this.IsRotatable() && (this._a = C33.clampAngle(this._a + t), this._MarkSinCosAngleChanged());
        }
        _MarkSinCosAngleChanged() {
          if (this._flags |= 262144, this.HasChildren()) {
            const t = this.GetChildren();
            for (let e = 0, s2 = t.length; e < s2; e++) t[e]._MarkSinCosAngleChanged();
          }
        }
        GetAngle() {
          return this.GetTransformWithParentAngle() && this.IsRotatable() ? this._MaybeReflectAngleForMirrorFlip(C33.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a)) : this._a;
        }
        _GetAngleNoReflect() {
          return this.GetTransformWithParentAngle() && this.IsRotatable() ? C33.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a) : this._a;
        }
        _MaybeReflectAngleForMirrorFlip(t) {
          return this.GetTransformWithParentWidth() && this.GetTopParent().GetWidth() < 0 && (t = C33.clampAngle(C33.angleReflect(t, this.GetTopParent().GetAngle() + Math.PI))), this.GetTransformWithParentHeight() && this.GetTopParent().GetHeight() < 0 && (t = C33.angleReflect(t, this.GetTopParent().GetAngle())), t;
        }
        _NeedsReflectAngleForMirrorOrFlip() {
          const t = this.GetParent();
          return !!(this.GetTransformWithParentWidth() && t.GetWidth() < 0) || !!(this.GetTransformWithParentHeight() && t.GetHeight() < 0);
        }
        _NeedsReflectAngleForMirrorAndFlip() {
          const t = this.GetParent();
          return !!(this.GetTransformWithParentWidth() && t.GetWidth() < 0 && this.GetTransformWithParentHeight() && t.GetHeight() < 0);
        }
        _MaybeUpdateSinCosAngle() {
          const t = this._flags;
          if (!(262144 & t)) return;
          const e = this.GetAngle();
          this._sinA = Math.sin(e), this._cosA = Math.cos(e), this._flags = -262145 & t;
        }
        GetSinAngle() {
          return this._MaybeUpdateSinCosAngle(), this._sinA;
        }
        GetCosAngle() {
          return this._MaybeUpdateSinCosAngle(), this._cosA;
        }
        SetOriginX(t) {
          this._ox = +t;
        }
        OffsetOriginX(t) {
          this._ox += +t;
        }
        GetOriginX() {
          return this._ox;
        }
        SetOriginY(t) {
          this._oy = +t;
        }
        OffsetOriginY(t) {
          this._oy += +t;
        }
        GetOriginY() {
          return this._oy;
        }
        _SetColor(t) {
          this._color.equals(t) || (this._color === DEFAULT_COLOR ? (this._color = C33.New(C33.Color, t), this._colorPremultiplied = C33.New(C33.Color, t), this._colorPremultiplied.premultiply()) : t.equalsRgba(1, 1, 1, 1) ? (this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR) : (this._color.set(t), this._colorPremultiplied.set(t), this._colorPremultiplied.premultiply()), this._UpdateRendererStateGroup());
        }
        SetOpacity(t) {
          if (t = C33.clamp(+t, 0, 1), this.GetTransformWithParentOpacity()) {
            if (this._GetSceneGraphInfo().GetOwnOpacity() === t) return;
            this._GetSceneGraphInfo().SetOwnOpacity(t), t = this.GetOpacity();
          } else if (this._color.a === t) return;
          this._SetColorWithOpacity(t);
        }
        _SetOpacityOfChildren() {
          if (!this.HasChildren()) return;
          const t = this.GetChildren();
          for (let e = 0, s2 = t.length; e < s2; e++) {
            const s3 = t[e];
            s3._SetColorWithOpacity(s3.GetOpacity());
          }
        }
        _SetColorWithOpacity(t) {
          tempColor.copyRgb(this._color), tempColor.a = t, this._SetColor(tempColor), this._SetOpacityOfChildren();
        }
        OffsetOpacity(t) {
          this.GetTransformWithParentOpacity() ? this.SetOpacity(this._GetSceneGraphInfo().GetOwnOpacity() + t) : this.SetOpacity(this.GetOpacity() + t);
        }
        GetOpacity() {
          return this.GetTransformWithParentOpacity() ? this.GetParent().GetOpacity() * this._GetSceneGraphInfo().GetOwnOpacity() : this._color.a;
        }
        SetUnpremultipliedColor(t) {
          this._color.equalsIgnoringAlpha(t) || (tempColor.copyRgb(t), tempColor.a = this.GetOpacity(), this._SetColor(tempColor));
        }
        SetUnpremultipliedColorRGB(t, e, s2) {
          tempColor.setRgb(t, e, s2), this.SetUnpremultipliedColor(tempColor);
        }
        OffsetUnpremultipliedColorRGB(t, e, s2) {
          0 === t && 0 === e && 0 === s2 || (tempColor.copyRgb(this._color), tempColor.r += t, tempColor.g += e, tempColor.b += s2, this.SetUnpremultipliedColor(tempColor));
        }
        GetUnpremultipliedColor() {
          return this._color;
        }
        GetPremultipliedColor() {
          return this._colorPremultiplied;
        }
        GetDestroyWithParent() {
          return !!(512 & this._flags);
        }
        SetDestroyWithParent(t) {
          this._SetFlag(512, t);
        }
        GetTransformWithParentX() {
          return !!(1024 & this._flags);
        }
        SetTransformWithParentX(t) {
          this._SetFlag(1024, t);
        }
        GetTransformWithParentY() {
          return !!(2048 & this._flags);
        }
        GetTransformWithParentXOrY() {
          return !!(3072 & this._flags);
        }
        SetTransformWithParentY(t) {
          this._SetFlag(2048, t);
        }
        GetTransformWithParentWidth() {
          return !!(4096 & this._flags);
        }
        SetTransformWithParentWidth(t) {
          this._SetFlag(4096, t);
        }
        GetTransformWithParentHeight() {
          return !!(8192 & this._flags);
        }
        SetTransformWithParentHeight(t) {
          this._SetFlag(8192, t);
        }
        GetTransformWithParentAngle() {
          return !!(16384 & this._flags);
        }
        SetTransformWithParentAngle(t) {
          this._SetFlag(16384, t);
        }
        GetTransformWithParentZElevation() {
          return !!(32768 & this._flags);
        }
        SetTransformWithParentZElevation(t) {
          this._SetFlag(32768, t);
        }
        GetTransformWithParentOpacity() {
          return !!(4194304 & this._flags);
        }
        SetTransformWithParentOpacity(t) {
          this._SetFlag(4194304, t);
        }
        GetTransformWithParentVisibility() {
          return !!(8388608 & this._flags);
        }
        SetTransformWithParentVisibility(t) {
          this._SetFlag(8388608, t);
        }
        _ClearAllSceneGraphFlags() {
          this._flags &= -12647937;
        }
        AddChild(t, e) {
          if (t === this) return false;
          if (t.HasParent()) return false;
          if (this._HasChildRecursive(t)) return false;
          if (this._HasAnyParent(t)) return false;
          const s2 = t.GetX(), i2 = t.GetY(), n = t.GetWidth(), r2 = t.GetHeight(), h = t.GetAngle(), a2 = t.GetZElevation(), o2 = t.GetOpacity();
          t._SetParent(this), t.SetTransformWithParentX(e.transformX), t.SetTransformWithParentY(e.transformY), t.SetTransformWithParentWidth(e.transformWidth), t.SetTransformWithParentHeight(e.transformHeight), t.SetTransformWithParentAngle(e.transformAngle), t.SetTransformWithParentZElevation(e.transformZElevation), t.SetTransformWithParentOpacity(e.transformOpacity), t.SetTransformWithParentVisibility(e.transformVisibility), t.SetDestroyWithParent(e.destroyWithParent);
          const l2 = s2 - this.GetX(), _ = i2 - this.GetY(), G = -this.GetAngle(), c2 = Math.cos(G), d2 = Math.sin(G);
          if (e.transformX && (e.transformAngle ? t._x = l2 * c2 - _ * d2 : t._x = l2, e.transformWidth)) {
            const e2 = this.GetWidth() / this._sceneGraphInfo._GetStartWidth();
            0 !== e2 && (t._x /= e2);
          }
          if (e.transformY && (e.transformAngle ? t._y = l2 * d2 + _ * c2 : t._y = _, e.transformHeight)) {
            const e2 = this.GetHeight() / this._sceneGraphInfo._GetStartHeight();
            0 !== e2 && (t._y /= e2);
          }
          if (e.transformWidth) {
            const e2 = this.GetWidth();
            0 === e2 || e2 === Number.EPSILON ? (t._w = 1, t._sceneGraphInfo.SetStartScaleX(1)) : (t._w = n / this.GetWidth(), t._sceneGraphInfo.SetStartScaleX(t._w));
          }
          if (e.transformHeight) {
            const e2 = this.GetHeight();
            0 === e2 || e2 === Number.EPSILON ? (t._h = 1, t._sceneGraphInfo.SetStartScaleY(1)) : (t._h = r2 / this.GetHeight(), t._sceneGraphInfo.SetStartScaleY(t._h));
          }
          return e.transformAngle && (t._a = h - this.GetAngle()), e.transformZElevation && (t._zElevation = a2 - this.GetZElevation()), e.transformOpacity && t._sceneGraphInfo.SetOwnOpacity(o2), e.transformVisibility && t.SetVisible(this.IsVisible()), this._AddChildToSceneGraphInfo(t), this.SetBboxChanged(), this._SetOpacityOfChildren(), true;
        }
        RemoveChild(t) {
          if (t.GetParent() !== this) return;
          const e = t.GetX(), s2 = t.GetY(), i2 = t.GetWidth(), n = t.GetHeight(), r2 = t.GetAngle(), h = t.GetZElevation(), a2 = t.GetOpacity();
          t._SetParent(null), t._ClearAllSceneGraphFlags(), t.SetXY(e, s2), t.SetSize(i2, n), t.SetAngle(r2), t.SetZElevation(h), t.SetOpacity(a2), this._RemoveChildFromSceneGraphInfo(t), this.SetBboxChanged();
        }
        GetTmpHierarchyPosition() {
          return this._tmpHierarchyPosition;
        }
        _ResetAllSceneGraphState() {
          this._BuildTmpSceneGraphData();
          const t = [...this.children()];
          for (const e2 of t) this.RemoveChild(e2);
          const e = this.GetParent();
          e && e.RemoveChild(this), this._ClearAllSceneGraphFlags();
        }
        _BuildTmpSceneGraphData() {
          if (this._SetTmpHierarchyPosition(), !this._tmpSceneGraphChildren) {
            const t2 = [...this.children()];
            t2.length && (this._tmpSceneGraphChildren = [], this._tmpSceneGraphChildrenIndexes = /* @__PURE__ */ new WeakMap());
            let e = 0;
            for (const s2 of t2) {
              const t3 = s2.GetInstance();
              this._tmpSceneGraphChildren.push(t3), this._tmpSceneGraphChildrenIndexes.set(t3, e), e++;
            }
          }
          const t = this.GetParent();
          t && t._BuildTmpSceneGraphData();
        }
        _SetTmpHierarchyPosition() {
          if (-1 !== this._tmpHierarchyPosition) return;
          const t = [...this.parents()];
          this._tmpHierarchyPosition = t.length;
          for (const e2 of t) e2._SetTmpHierarchyPosition();
          const e = [...this.children()];
          for (const t2 of e) t2._SetTmpHierarchyPosition();
        }
        _ReleaseTmpSceneGraphInfo() {
          this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren.length = 0), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null;
          const t = this.GetParent();
          t && t._ReleaseTmpSceneGraphInfo(), this._tmpHierarchyPosition = -1;
        }
        HasParent() {
          return null !== this.GetParent();
        }
        GetParent() {
          const t = this._sceneGraphInfo;
          return null !== t ? t.GetParent() : null;
        }
        GetTopParent() {
          let t = this;
          for (; t.HasParent(); ) t = t.GetParent();
          return t;
        }
        *parents() {
          let t = this.GetParent();
          for (; t; ) yield t, t = t.GetParent();
        }
        HasChild(t) {
          return this.GetChildren().includes(t);
        }
        HasChildren() {
          const t = this._sceneGraphInfo;
          return null !== t && t.HasChildren();
        }
        GetChildren() {
          const t = this._sceneGraphInfo;
          return null !== t ? t.GetChildren() : EMPTY_ARRAY;
        }
        children() {
          return this.GetChildren();
        }
        *allChildren() {
          for (const t of this.children()) yield t, yield* t.allChildren();
        }
        GetChildCount() {
          return this.GetChildren().length;
        }
        GetAllChildCount() {
          return [...this.allChildren()].length;
        }
        GetChildAt(t) {
          const e = this.GetChildren();
          return (t = Math.floor(+t)) < 0 || t >= e.length ? null : e[t];
        }
        GetChildIndex(t) {
          if (!t) return NaN;
          const e = this.GetChildren();
          if (!e) return NaN;
          for (let s2 = 0; s2 < e.length; s2++) if (t === e[s2]) return s2;
          return NaN;
        }
        _CreateSceneGraphInfo(t) {
          this._sceneGraphInfo || (this._sceneGraphInfo = C33.New(C33.SceneGraphInfo, this)), t && this._sceneGraphInfo.SetParent(t);
        }
        _GetSceneGraphInfo() {
          return this._sceneGraphInfo;
        }
        _ReleaseSceneGraphInfo() {
          this._sceneGraphInfo && (this._sceneGraphInfo.Release(), this._sceneGraphInfo = null);
        }
        _SetParent(t) {
          t ? (t._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(t)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo());
        }
        _HasAnyParent(t) {
          if (!this.HasParent()) return false;
          const e = this.GetParent();
          return e === t || e._HasAnyParent(t);
        }
        _HasChildRecursive(t) {
          if (this.HasChild(t)) return true;
          for (const e of this.GetChildren()) if (e._HasChildRecursive(t)) return true;
          return false;
        }
        _AddChildToSceneGraphInfo(t) {
          this._sceneGraphInfo.GetChildren().push(t);
        }
        _RemoveChildFromSceneGraphInfo(t) {
          const e = this._sceneGraphInfo.GetChildren(), s2 = e.indexOf(t);
          -1 !== s2 && e.splice(s2, 1), 0 !== e.length || this.HasParent() || this._ReleaseSceneGraphInfo(), t.HasChildren() || t._ReleaseSceneGraphInfo();
        }
        GetSceneGraphChildrenExportData() {
          const t = sceneGraphExportDataMap.get(this);
          return t ? t.childrenData : null;
        }
        GetSceneGraphZIndexExportData() {
          const t = sceneGraphExportDataMap.get(this);
          return t ? t.zIndexData : NaN;
        }
        GetSceneGraphZIndex() {
          const t = sceneGraphZIndexMap.get(this);
          return C33.IsFiniteNumber(t) ? t : NaN;
        }
        SetSceneGraphZIndex(t) {
          sceneGraphZIndexMap.set(this, t);
        }
        SetUsePointsShaderProgram() {
          this._SetFlag(524288, true), this._UpdateRendererStateGroup();
        }
        _UpdateRendererStateGroup() {
          if (!enableUpdateRendererStateGroup) return;
          const t = this._runtime.GetRenderer();
          let e;
          this._stateGroup && t.ReleaseStateGroup(this._stateGroup), e = 524288 & this._flags ? t.GetPointsRenderingProgram() || "<point>" : t.GetTextureFillShaderProgram() || "<default>", this._stateGroup = t.AcquireStateGroup(e, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation(), this.IsBackFaceCulling() ? 1 : 0, 0);
        }
        GetRendererStateGroup() {
          return this._stateGroup;
        }
        HasDefaultColor() {
          return this._color === DEFAULT_COLOR;
        }
        SetBlendMode(t) {
          if ((t |= 0) < 0 || t > 31) throw new RangeError("invalid blend mode");
          this.GetBlendMode() !== t && (this._flags = -2080374785 & this._flags | t << 26, this._UpdateRendererStateGroup());
        }
        GetBlendMode() {
          return (2080374784 & this._flags) >> 26;
        }
        _SetLayer(t, e) {
          const s2 = e && this._layer !== t;
          s2 && this._RemoveFromRenderCells(), this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, t), this._layer = t, s2 && this._UpdateRenderCell(), 0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated();
        }
        GetLayer() {
          return this._layer;
        }
        GetLayout() {
          return this.GetLayer().GetLayout();
        }
        _SetZIndex(t) {
          this._zIndex = 0 | t;
        }
        GetZIndex() {
          return this._layer._UpdateZIndices(), this._zIndex;
        }
        _SetHTMLZIndex(t) {
          this._htmlZIndex = 0 | t;
        }
        GetHTMLZIndex() {
          return this._layer._UpdateHTMLZIndices(), this._htmlZIndex;
        }
        _GetLastCachedZIndex() {
          return this._zIndex;
        }
        _SetFlag(t, e) {
          e ? this._flags |= t : this._flags &= ~t;
        }
        IsVisible() {
          return !!(1 & this._flags);
        }
        SetVisible(t) {
          if (this._SetFlag(1, t), this.HasChildren()) for (const e of this.GetChildren()) e.GetTransformWithParentVisibility() && e.SetVisible(t);
        }
        IsCollisionEnabled() {
          return !!(8 & this._flags);
        }
        SetCollisionEnabled(t) {
          t = !!t, this.IsCollisionEnabled() !== t && (this._SetFlag(8, t), t ? this.SetBboxChanged() : this._RemoveFromCollisionCells());
        }
        SetSolidCollisionFilter(t, e) {
          if (this._SetFlag(32, t), this._solidFilterTags && this._solidFilterTags.clear(), e.trim()) {
            this._solidFilterTags || (this._solidFilterTags = /* @__PURE__ */ new Set());
            for (const t2 of e.split(" ")) t2 && this._solidFilterTags.add(t2.toLowerCase());
          } else this._solidFilterTags = null;
        }
        IsSolidCollisionAllowed(t) {
          const e = !!(32 & this._flags), s2 = this._solidFilterTags;
          if (!t || !s2) return !e;
          for (const i2 of s2) if (t.has(i2)) return e;
          return !e;
        }
        SetBboxChanged() {
          if (this._flags |= 65554, this._objectClass._SetAnyCollisionCellChanged(true), this._runtime.UpdateRender(), this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags &= -3, this._UpdateRenderCell()), 4 & this._flags && this._inst.Dispatcher().dispatchEvent(bboxChangeEvent), null !== this._sceneGraphInfo) {
            const t = this._sceneGraphInfo.GetChildren();
            for (let e = 0, s2 = t.length; e < s2; ++e) t[e].SetBboxChanged();
          }
        }
        CalculateBbox(t, e, s2) {
          const i2 = this.GetX(), n = this.GetY(), r2 = this.GetWidth(), h = this.GetHeight(), a2 = this.GetAngle();
          t.setWH(i2 - this._ox * r2, n - this._oy * h, r2, h), s2 && this.HasMesh() && this._ExpandBboxForMesh(t), 0 === a2 ? e.setFromRect(t) : (t.offset(-i2, -n), e.setFromRotatedRectPrecalc(t, this.GetSinAngle(), this.GetCosAngle()), e.offset(i2, n), e.getBoundingBox(t)), t.normalize();
        }
        _UpdateBbox() {
          const t = this._flags;
          2 & t && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags = -3 & t);
        }
        GetBoundingBox() {
          return this._UpdateBbox(), this._boundingBox;
        }
        GetBoundingQuad() {
          return this._UpdateBbox(), this._boundingQuad;
        }
        PixelRoundQuad(t) {
          const e = this.GetX(), s2 = this.GetY(), i2 = Math.round(e) - e, n = Math.round(s2) - s2;
          return 0 === i2 && 0 === n ? t : (tempQuad.copy(t), tempQuad.offset(i2, n), tempQuad);
        }
        OverwriteBoundingBox(t) {
          this._boundingBox.copy(t), this._boundingQuad.setFromRect(this._boundingBox), this._flags &= -3, this._UpdateCollisionCell(), this._UpdateRenderCell();
        }
        SetBboxChangeEventEnabled(t) {
          this._SetFlag(4, t);
        }
        IsBboxChangeEventEnabled() {
          return !!(4 & this._flags);
        }
        IsInViewport(t, e, s2) {
          return e && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || s2 ? t.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated();
        }
        _IsInViewport_ZElevated() {
          const t = this.GetLayer(), e = this.GetTotalZElevation();
          return !(e >= t.Get2DCameraZ()) && (t.GetViewportForZ(e, tempRect), tempRect.intersectsRect(this.GetBoundingBox()));
        }
        IsInViewport3D(t) {
          const e = this.GetBoundingBox(), s2 = e.getLeft(), i2 = e.getRight(), n = e.getTop(), r2 = e.getBottom(), h = this.GetTotalZElevation(), a2 = h + this.GetDepth();
          return t.ContainsAABB(s2, n, h, i2, r2, a2);
        }
        IsInViewport2() {
          const t = this.GetLayer();
          if (t.Has3DCamera()) return this.IsInViewport3D(t._GetViewFrustum());
          {
            const e = t.GetLayout();
            return this.IsInViewport(t.GetViewport(), e.HasVanishingPointOutsideViewport(), e.IsOrthographicProjection());
          }
        }
        _SetDrawBackFaceOnly(t) {
          this._SetFlag(1048576, t);
        }
        _SetDrawNonBackFacesOnly(t) {
          this._SetFlag(2097152, t);
        }
        IsDrawBackFaceOnly() {
          return !!(1048576 & this._flags);
        }
        IsDrawNonBackFacesOnly() {
          return !!(2097152 & this._flags);
        }
        SetBackFaceCulling(t) {
          (t = !!t) !== this.IsBackFaceCulling() && (this._SetFlag(16777216, t), this._UpdateRendererStateGroup());
        }
        IsBackFaceCulling() {
          return !!(16777216 & this._flags);
        }
        SetSourceCollisionPoly(t) {
          this._sourceCollisionPoly = t, this._DiscardTransformedCollisionPoly(), this.HasMesh() && (this._meshInfo.meshPoly = null);
        }
        GetSourceCollisionPoly() {
          return this._sourceCollisionPoly;
        }
        HasOwnCollisionPoly() {
          return null !== this._sourceCollisionPoly || this.HasMesh();
        }
        GetTransformedCollisionPoly() {
          return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle());
        }
        GetCustomTransformedCollisionPoly(t, e, s2) {
          let i2 = 0, n = 1;
          return 0 !== s2 && (i2 = Math.sin(s2), n = Math.cos(s2)), this._GetCustomTransformedCollisionPolyPrecalc(t, e, s2, i2, n);
        }
        _GetCustomTransformedCollisionPolyPrecalc(t, e, s2, i2, n) {
          let r2 = this._transformedPolyInfo;
          null === r2 && (r2 = { poly: C33.New(C33.CollisionPoly), width: NaN, height: NaN, angle: NaN }, this._transformedPolyInfo = r2);
          const h = r2.poly;
          if (r2.width === t && r2.height === e && r2.angle === s2) return h;
          const a2 = this._sourceCollisionPoly;
          if (this.HasMesh()) {
            const s3 = this.GetOriginX(), r3 = this.GetOriginY(), o2 = this.GetSourceMesh();
            let l2 = this._meshInfo.meshPoly;
            l2 || (a2 ? (tempCollisionPoly.copy(a2), tempCollisionPoly.offset(s3, r3)) : tempCollisionPoly.setDefaultPoints(), l2 = o2.InsertPolyMeshVertices(tempCollisionPoly), this._meshInfo.meshPoly = l2), o2.TransformCollisionPoly(l2, h), h.offset(-s3, -r3), h.transformPrecalc(t, e, i2, n);
          } else a2 ? (h.copy(a2), h.transformPrecalc(t, e, i2, n)) : h.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
          return r2.width = t, r2.height = e, r2.angle = s2, h;
        }
        _DiscardTransformedCollisionPoly() {
          this.SetPhysicsBodyChanged(true);
          const t = this._transformedPolyInfo;
          null !== t && (t.width = NaN);
        }
        CreateMesh(t, e) {
          if (t = Math.floor(t), e = Math.floor(e), !this.GetInstance().GetPlugin().SupportsMesh()) throw new Error("object does not support mesh");
          this.ReleaseMesh(), this._meshInfo = { sourceMesh: C33.New(C33.Gfx.Mesh, t, e), transformedMesh: C33.New(C33.Gfx.Mesh, t, e), meshPoly: null };
        }
        HasMesh() {
          return null !== this._meshInfo;
        }
        GetSourceMesh() {
          if (!this.HasMesh()) throw new Error("no mesh");
          return this._meshInfo.sourceMesh;
        }
        GetTransformedMesh() {
          if (!this.HasMesh()) throw new Error("no mesh");
          return this._meshInfo.transformedMesh;
        }
        SetMeshChanged(t) {
          this._SetFlag(65536, t);
        }
        IsMeshChanged() {
          return !!(65536 & this._flags);
        }
        SetPhysicsBodyChanged(t) {
          this._SetFlag(131072, t);
        }
        IsPhysicsBodyChanged() {
          return !!(131072 & this._flags);
        }
        _ExpandBboxForMesh(t) {
          const e = this._meshInfo.sourceMesh, s2 = Math.min(e.GetMinX(), 0), i2 = Math.min(e.GetMinY(), 0), n = Math.max(e.GetMaxX(), 1), r2 = Math.max(e.GetMaxY(), 1), h = t.width(), a2 = t.height();
          t.offsetLeft(s2 * h), t.offsetTop(i2 * a2), t.offsetRight((n - 1) * h), t.offsetBottom((r2 - 1) * a2), this._depth = e.GetMaxZ();
        }
        ReleaseMesh() {
          this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly());
        }
        SetMeshPoint(t, e, s2) {
          t = Math.floor(t), e = Math.floor(e);
          const i2 = s2.mode || "absolute";
          if (!VALID_SET_MESH_POINT_MODES.has(i2)) throw new Error("invalid mode");
          const n = "relative" === i2;
          let r2 = s2.x, h = s2.y;
          const a2 = s2.zElevation;
          let o2 = "number" == typeof s2.u ? s2.u : n ? 0 : -1, l2 = "number" == typeof s2.v ? s2.v : n ? 0 : -1;
          if (!this.HasMesh()) return false;
          const _ = this.GetSourceMesh(), G = _.GetMeshPointAt(t, e);
          if (null === G) return false;
          let c2 = false;
          return "number" == typeof a2 && G.GetZElevation() !== a2 && (G.SetZElevation(a2), c2 = true), n && (r2 += t / (_.GetHSize() - 1), h += e / (_.GetVSize() - 1)), -1 !== o2 || n ? (n && (o2 += t / (_.GetHSize() - 1)), o2 = C33.clamp(o2, 0, 1)) : o2 = G.GetU(), -1 !== l2 || n ? (n && (l2 += e / (_.GetVSize() - 1)), l2 = C33.clamp(l2, 0, 1)) : l2 = G.GetV(), G.GetX() === r2 && G.GetY() === h && G.GetU() === o2 && G.GetV() === l2 ? c2 : (G.SetX(r2), G.SetY(h), G.SetU(o2), G.SetV(l2), this._DiscardTransformedCollisionPoly(), true);
        }
        HasTilemap() {
          return this._inst.HasTilemap();
        }
        ContainsPoint(t, e) {
          return !!this.GetBoundingBox().containsPoint(t, e) && (!!this.GetBoundingQuad().containsPoint(t, e) && (this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(t, e) : !this.HasOwnCollisionPoly() || this.GetTransformedCollisionPoly().containsPoint(t - this.GetX(), e - this.GetY())));
        }
        _IsCollisionCellChanged() {
          return !!(16 & this._flags);
        }
        _UpdateCollisionCell() {
          if (!this._IsCollisionCellChanged() || !this.IsCollisionEnabled() || 256 & this._flags) return;
          const t = this.GetBoundingBox(), e = this._objectClass._GetCollisionCellGrid(), s2 = this._collisionCells;
          if (tempRect.set(e.XToCell(t.getLeft()), e.YToCell(t.getTop()), e.XToCell(t.getRight()), e.YToCell(t.getBottom())), s2.equals(tempRect)) return;
          const i2 = this._inst;
          s2 === DEFAULT_COLLISION_CELLS ? (e.Update(i2, null, tempRect), this._collisionCells = C33.New(C33.Rect, tempRect)) : (e.Update(i2, s2, tempRect), s2.copy(tempRect)), this._flags &= -17;
        }
        _SetCollisionCellChanged() {
          this._flags |= 16;
        }
        _RemoveFromCollisionCells() {
          const t = this._collisionCells;
          t !== DEFAULT_COLLISION_CELLS && (this._objectClass._GetCollisionCellGrid().Update(this._inst, t, null), this._collisionCells = DEFAULT_COLLISION_CELLS);
        }
        _UpdateRenderCell() {
          const t = this.GetLayer();
          if (!t.UsesRenderCells() || 256 & this._flags) return;
          const e = t.GetRenderGrid(), s2 = this.GetBoundingBox(), i2 = this._renderCells;
          if (tempRect.set(e.XToCell(s2.getLeft()), e.YToCell(s2.getTop()), e.XToCell(s2.getRight()), e.YToCell(s2.getBottom())), i2.equals(tempRect)) return;
          const n = this._inst;
          i2 === DEFAULT_RENDER_CELLS ? (e.Update(n, null, tempRect), this._renderCells = C33.New(C33.Rect, tempRect)) : (e.Update(n, i2, tempRect), i2.copy(tempRect)), t.SetRenderListStale();
        }
        _RemoveFromRenderCells() {
          const t = this._renderCells;
          t !== DEFAULT_RENDER_CELLS && (this.GetLayer().GetRenderGrid().Update(this._inst, t, null), this._renderCells = DEFAULT_RENDER_CELLS);
        }
        GetRenderCellRange() {
          return this._renderCells;
        }
        ZOrderMoveToTop() {
          const t = this._inst, e = this._layer, s2 = e._GetInstances();
          s2.length && s2.at(-1) === t || (e._RemoveInstance(t, false), e._AddInstance(t, false), this._runtime.UpdateRender());
        }
        ZOrderMoveToBottom() {
          const t = this._inst, e = this._layer, s2 = e._GetInstances();
          s2.length && s2[0] === t || (e._RemoveInstance(t, false), e._PrependInstance(t, false), this._runtime.UpdateRender());
        }
        ZOrderMoveToLayer(t) {
          const e = this._inst, s2 = this._layer;
          if (s2.GetLayout() !== t.GetLayout()) throw new Error("layer from different layout");
          t !== s2 && (s2._RemoveInstance(e, true), this._SetLayer(t), t._AddInstance(e, true), this._runtime.UpdateRender());
        }
        ZOrderMoveAdjacentToInstance(t, e) {
          const s2 = this._inst;
          let i2 = false;
          const n = this._layer;
          if (t.GetUID() === s2.GetUID()) return;
          const r2 = t.GetWorldInfo();
          if (!r2) throw new Error("expected world instance");
          const h = r2.GetLayer();
          n.GetIndex() !== h.GetIndex() && (n._RemoveInstance(s2, true), this._SetLayer(h), h._AddInstance(s2, true), i2 = true);
          const a2 = h.MoveInstanceAdjacent(s2, t, !!e);
          (i2 || a2) && this._runtime.UpdateRender();
        }
        GetInstanceEffectList() {
          return this._instanceEffectList;
        }
        _SetHasAnyActiveEffect(t) {
          this._SetFlag(64, t);
        }
        HasAnyActiveEffect() {
          return !!(64 & this._flags);
        }
        _SaveToJson(t, e = null) {
          const s2 = { "x": this.GetX(), "y": this.GetY(), "w": this.GetWidth(), "h": this.GetHeight(), "l": this.GetLayer().GetSID(), "zi": this.GetZIndex() };
          0 !== this.GetZElevation() && (s2["ze"] = this.GetZElevation()), 0 !== this.GetAngle() && (s2["a"] = this._GetAngleNoReflect()), this.HasDefaultColor() || (s2["c"] = this._color.toJSON()), 0.5 !== this.GetOriginX() && (s2["oX"] = this.GetOriginX()), 0.5 !== this.GetOriginY() && (s2["oY"] = this.GetOriginY()), 0 !== this.GetBlendMode() && (s2["bm"] = this.GetBlendMode()), this.IsVisible() || (s2["v"] = this.IsVisible()), this.IsCollisionEnabled() || (s2["ce"] = this.IsCollisionEnabled()), this.IsBboxChangeEventEnabled() && (s2["be"] = this.IsBboxChangeEventEnabled()), this._instanceEffectList && (s2["fx"] = this._instanceEffectList._SaveToJson());
          const i2 = !!(32 & this._flags);
          return i2 && (s2["sfi"] = i2), this._solidFilterTags && (s2["sft"] = [...this._solidFilterTags].join(" ")), this._sceneGraphInfo && "visual-state" !== t && (s2["sgi"] = this._sceneGraphInfo._SaveToJson(t, e), sceneGraphExportDataMap.has(this) && (s2["sgcd"] = sceneGraphExportDataMap.get(this).childrenData, s2["sgzid"] = sceneGraphExportDataMap.get(this).zIndexData)), this.HasMesh() && (s2["mesh"] = this.GetSourceMesh().SaveToJson()), s2;
        }
        _SaveSceneGraphPropertiesToJson() {
          return { "x": this._x, "y": this._y, "z": this._zElevation, "w": this._w, "h": this._h, "a": this._a, "sgi": this._GetSceneGraphInfo() ? this._GetSceneGraphInfo()._SaveToJsonProperties() : null };
        }
        _LoadSceneGraphPropertiesFromJson(t) {
          t && (this._x = t["x"], this._y = t["y"], this._zElevation = t["z"], this._w = t["w"], this._h = t["h"], this._a = t["a"], t["sgi"] && this._GetSceneGraphInfo() && this._GetSceneGraphInfo()._LoadFromJson(t["sgi"]), this._MarkSinCosAngleChanged(), this.SetBboxChanged());
        }
        _SetupSceneGraphConnectionsOnChangeOfLayout() {
          this._ReleaseTmpSceneGraphInfo(), this._ResetAllSceneGraphState(), this._CreateSceneGraphInfo(null), this._sceneGraphInfo && this._sceneGraphInfo._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes);
        }
        _OnBeforeLoad(t) {
          "visual-state" !== t && this._ResetAllSceneGraphState();
        }
        _OnAfterLoad(t, e = "full", s2 = null) {
          if (t.hasOwnProperty("sgi") && "visual-state" !== e) {
            if (256 & this._flags) return;
            this._sceneGraphInfo._OnAfterLoad(t["sgi"], s2);
          }
        }
        _OnAfterLoad2(t, e = "full", s2 = null) {
          if ("visual-state" !== e) if (256 & this._flags) this._ReleaseTmpSceneGraphInfo();
          else {
            if (t.hasOwnProperty("sgi")) this._sceneGraphInfo._SetTmpSceneGraphChildren(null, null, t["sgi"], s2);
            else if (s2?.setFromJson && this._tmpSceneGraphChildren) for (const t2 of this._tmpSceneGraphChildren) t2.IsDestroyed() || this._runtime.DestroyInstance(t2);
            this._ReleaseTmpSceneGraphInfo(), this.SetBboxChanged();
          }
        }
        _LoadFromJson(t, e, s2 = null) {
          if (enableUpdateRendererStateGroup = false, this.SetX(t["x"]), this.SetY(t["y"]), this.SetWidth(t["w"]), this.SetHeight(t["h"]), this._SetZIndex(t["zi"]), this.SetZElevation(t.hasOwnProperty("ze") ? t["ze"] : 0), this.SetAngle(t.hasOwnProperty("a") ? t["a"] : 0), t.hasOwnProperty("c") ? tempColor.setFromJSON(t["c"]) : t.hasOwnProperty("o") ? (tempColor.copyRgb(this._color), tempColor.a = t["o"]) : tempColor.setRgba(1, 1, 1, 1), this._SetColor(tempColor), this.SetOriginX(t.hasOwnProperty("oX") ? t["oX"] : 0.5), this.SetOriginY(t.hasOwnProperty("oY") ? t["oY"] : 0.5), this.SetBlendMode(t.hasOwnProperty("bm") ? t["bm"] : 0), this.SetVisible(!t.hasOwnProperty("v") || t["v"]), this.SetCollisionEnabled(!t.hasOwnProperty("ce") || t["ce"]), this.SetBboxChangeEventEnabled(!!t.hasOwnProperty("be") && t["be"]), this.SetSolidCollisionFilter(!!t.hasOwnProperty("sfi") && t["sfi"], t.hasOwnProperty("sft") ? t["sft"] : ""), this._instanceEffectList && t.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(t["fx"]), t.hasOwnProperty("sgi") && "visual-state" !== e) {
            this._CreateSceneGraphInfo(null);
            const e2 = this._sceneGraphInfo, s3 = t["sgi"];
            e2._LoadFromJson(s3), e2._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes), this._SetSceneGraphExportData(t["sgcd"], t["sgzid"]);
          }
          if (t.hasOwnProperty("mesh")) {
            const e2 = t["mesh"];
            this.CreateMesh(e2["cols"], e2["rows"]), this.GetSourceMesh().LoadFromJson(e2);
          } else this.ReleaseMesh();
          this.SetBboxChanged(), enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup(), "visual-state" !== e && this._runtime.AddInstanceNeedingAfterLoad(this.GetInstance(), t);
        }
        _SetSceneGraphExportData(t, e) {
          t && C33.IsFiniteNumber(e) && sceneGraphExportDataMap.set(this, { childrenData: t, zIndexData: e });
        }
      };
    }
    {
      const C33 = self.C3;
      C33.BehaviorType = class extends C33.DefendedBase {
        constructor(e, t) {
          super();
          const s2 = e.GetRuntime(), i2 = s2.GetObjectReference(t[1]);
          s2.GetAddonManager()._DelayCreateBehavior(i2), this._runtime = s2, this._objectClass = e, this._behavior = C33.AddonManager.GetBehaviorByConstructorFunction(i2), this._sdkType = null, this._iBehaviorType = null, this._instSdkCtor = i2.Instance, this._sid = t[2], this._name = t[0], this._jsPropName = this._runtime.GetJsPropName(t[3]);
          const r2 = this._behavior.GetSdkVersion();
          if (r2 < 2 && (this._sdkType = C33.New(i2.Type, this), !(this._sdkType instanceof C33.SDKBehaviorTypeBase))) throw new Error("v1 sdk type must derive from SDKBehaviorBase");
          if (C33.AddonManager._PushInitObject(this, r2), r2 >= 2) {
            const e2 = i2.Type ?? globalThis.ISDKBehaviorTypeBase;
            if (this._iBehaviorType = new e2(), !(this._iBehaviorType instanceof globalThis.ISDKBehaviorTypeBase)) throw new Error("script interface class must derive from ISDKBehaviorTypeBase");
          } else this._iBehaviorType = new globalThis.IBehaviorType();
          C33.AddonManager._PopInitObject(r2), this.OnCreate();
        }
        static Create(e, t) {
          return C33.New(C33.BehaviorType, e, t);
        }
        Release() {
          this._runtime = null, this._behavior = null, this._sdkType && (this._sdkType.Release(), this._sdkType = null), this._instSdkCtor = null;
        }
        GetSdkType() {
          return this._sdkType;
        }
        OnCreate() {
          this._sdkType ? this._sdkType.OnCreate() : this._iBehaviorType && this._iBehaviorType._onCreate();
        }
        GetRuntime() {
          return this._runtime;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetBehavior() {
          return this._behavior;
        }
        GetInstanceSdkCtor() {
          return this._instSdkCtor;
        }
        GetName() {
          return this._name;
        }
        GetSID() {
          return this._sid;
        }
        GetIBehaviorType() {
          return this._iBehaviorType;
        }
        GetJsPropName() {
          return this._jsPropName;
        }
      };
    }
    {
      const C33 = self.C3, IBehaviorInstance = self.IBehaviorInstance;
      C33.BehaviorInstance = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._runtime = t.runtime, this._behaviorType = t.behaviorType, this._behavior = this._behaviorType.GetBehavior(), this._inst = t.instance, this._index = t.index, this._sdkInst = null, this._iScriptInterface = null, this._behavior._AddInstance(this._inst);
        }
        Release() {
          this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), this._behavior._RemoveInstance(this._inst), this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null), this._runtime = null, this._behaviorType = null, this._behavior = null, this._inst = null;
        }
        _CreateSdkInstance(t) {
          if (this._sdkInst) throw new Error("already got sdk instance");
          if (this.GetBehavior().GetSdkVersion() < 2) {
            if (this._sdkInst = C33.New(this._behaviorType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof C33.SDKBehaviorInstanceBase)) throw new Error("v1 sdk type must derive from SDKBehaviorInstanceBase");
          } else {
            const e = this.GetBehavior().GetScriptInterfaceClass();
            this._InitScriptInterface(e.Instance, t);
          }
        }
        GetSdkInstance() {
          return this._sdkInst ?? this._iScriptInterface;
        }
        GetObjectInstance() {
          return this._inst;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetBehaviorType() {
          return this._behaviorType;
        }
        GetBehavior() {
          return this._behavior;
        }
        _GetIndex() {
          return this._index;
        }
        PostCreate() {
          this._sdkInst ? this._sdkInst.PostCreate() : this._iScriptInterface._postCreate();
        }
        OnSpriteFrameChanged(t, e) {
          this._sdkInst && this._sdkInst.OnSpriteFrameChanged(t, e);
        }
        _GetDebuggerProperties() {
          return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();
        }
        SaveToJson(t = "full") {
          return this._sdkInst ? this._sdkInst.SaveToJson(t) : this._iScriptInterface._saveToJson(t);
        }
        LoadFromJson(t, e = "full") {
          if (this._sdkInst) return this._sdkInst.LoadFromJson(t, e);
          this._iScriptInterface._loadFromJson(t, e);
        }
        static SortByTickSequence(t, e, s2) {
          const n = globalThis.ISDKBehaviorInstanceBase;
          let i2, r2;
          i2 = e instanceof n ? t._UnwrapScriptInterface(e) : e.GetBehaviorInstance(), r2 = s2 instanceof n ? t._UnwrapScriptInterface(s2) : s2.GetBehaviorInstance();
          const a2 = i2.GetObjectInstance(), h = r2.GetObjectInstance(), c2 = a2.GetObjectClass().GetIndex(), o2 = h.GetObjectClass().GetIndex();
          if (c2 !== o2) return c2 - o2;
          const I = a2.GetPUID(), _ = h.GetPUID();
          return I !== _ ? I - _ : i2._GetIndex() - r2._GetIndex();
        }
        _InitScriptInterface(t, e) {
          const s2 = IBehaviorInstance, n = t ?? this._sdkInst.GetScriptInterfaceClass(), i2 = n || s2, r2 = this.GetBehavior().GetSdkVersion();
          if (C33.AddonManager._PushInitObject(this, r2), C33.AddonManager._PushInitProperties(e), this._iScriptInterface = new i2(), C33.AddonManager._PopInitProperties(), C33.AddonManager._PopInitObject(r2), n && !(this._iScriptInterface instanceof s2)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s2.name}'`);
          return this._iScriptInterface;
        }
        GetScriptInterface() {
          return this._iScriptInterface || this._InitScriptInterface();
        }
        HasScriptInterface() {
          return !!this._iScriptInterface;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.EffectList = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._owner = e, this._allEffectTypes = [], this._activeEffectTypes = [], this._effectTypesByName = /* @__PURE__ */ new Map(), this._effectParams = [], this._effectParamBuffers = [], this._allInstanceEffectLists = /* @__PURE__ */ new Set(), this._preservesOpaqueness = true;
          for (const e2 of t) {
            const t2 = C33.New(C33.EffectType, this, e2, this._allEffectTypes.length);
            this._allEffectTypes.push(t2), this._effectTypesByName.set(t2.GetName().toLowerCase(), t2), e2.length >= 3 && this._effectParams.push(this._LoadSingleEffectParameters(t2, e2[2]));
          }
          this.GetRuntime()._AddEffectList(this);
        }
        Release() {
          this.GetRuntime()._RemoveEffectList(this);
          for (const e of this._effectParamBuffers) e.Release();
          C33.clearArray(this._effectParamBuffers), C33.clearArray(this._allEffectTypes), C33.clearArray(this._activeEffectTypes), this._effectTypesByName.clear(), C33.clearArray(this._effectParams), this._owner = null;
        }
        _AddInstanceEffectList(e) {
          this._allInstanceEffectLists.add(e);
        }
        _RemoveInstanceEffectList(e) {
          this._allInstanceEffectLists.delete(e);
        }
        _InitRenderer(e) {
          e.IsWebGPU() && (this._effectParamBuffers = this._allEffectTypes.map((e2) => {
            const t = e2.GetShaderProgram();
            return t.GetCustomParametersByteSize() > 0 ? C33.New(C33.Gfx.WebGPUEffectCustomParamsBuffer, t) : null;
          }), this._UpdateAllEffectParamBuffers());
          for (const t of this._allInstanceEffectLists) t._InitRenderer(e);
        }
        PrependEffectTypes(e) {
          if (e.length) {
            this._allEffectTypes = e.concat(this._allEffectTypes);
            for (const t of e) this._effectTypesByName.set(t.GetName().toLowerCase(), t);
            for (let e2 = 0, t = this._allEffectTypes.length; e2 < t; ++e2) this._allEffectTypes[e2]._SetIndex(e2);
          }
        }
        _LoadSingleEffectParameters(e, t) {
          e.SetActive(t[0]);
          const s2 = t.slice(1);
          for (let e2 = 0, t2 = s2.length; e2 < t2; ++e2) {
            const t3 = s2[e2];
            if (Array.isArray(t3)) {
              const f2 = C33.New(C33.Color);
              f2.setFromJSON(t3), s2[e2] = f2;
            }
          }
          return s2;
        }
        GetOwner() {
          return this._owner;
        }
        GetRuntime() {
          return this._owner.GetRuntime();
        }
        UpdateActiveEffects() {
          C33.clearArray(this._activeEffectTypes);
          let e = true;
          for (const t of this._allEffectTypes) t.IsActive() && (this._activeEffectTypes.push(t), t.GetShaderProgram().PreservesOpaqueness() || (e = false));
          this._preservesOpaqueness = e;
        }
        GetAllEffectTypes() {
          return this._allEffectTypes;
        }
        HasAnyEffectType() {
          return this._allEffectTypes.length > 0;
        }
        GetEffectTypeByName(e) {
          return this._effectTypesByName.get(e.toLowerCase()) || null;
        }
        GetEffectTypeByIndex(e) {
          if ((e = Math.floor(+e)) < 0 || e >= this._allEffectTypes.length) throw new RangeError("invalid effect type index");
          return this._allEffectTypes[e];
        }
        IsEffectIndexActive(e) {
          return this.GetEffectTypeByIndex(e).IsActive();
        }
        SetEffectIndexActive(e, t) {
          this.GetEffectTypeByIndex(e).SetActive(t);
        }
        GetActiveEffectTypes() {
          return this._activeEffectTypes;
        }
        HasAnyActiveEffect() {
          return this._activeEffectTypes.length > 0;
        }
        PreservesOpaqueness() {
          return this._preservesOpaqueness;
        }
        GetEffectParametersForIndex(e) {
          return this._effectParams[e];
        }
        _GetEffectChainShaderParametersForIndex(e) {
          return e < this._effectParamBuffers.length ? this._effectParamBuffers[e] : this._effectParams[e];
        }
        GetEffectParameter(e, t) {
          if (e < 0 || e >= this._effectParams.length) return null;
          const s2 = this._effectParams[e];
          return t < 0 || t >= s2.length ? null : s2[t];
        }
        SetEffectParameter(e, t, s2) {
          if (e < 0 || e >= this._effectParams.length) return false;
          const f2 = this._effectParams[e];
          if (t < 0 || t >= f2.length) return false;
          const r2 = f2[t];
          if (r2 instanceof C33.Color) {
            if (r2.equalsIgnoringAlpha(s2)) return false;
            r2.copyRgb(s2);
          } else {
            if (r2 === s2) return false;
            f2[t] = s2;
          }
          return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t, s2), true;
        }
        _UpdateAllEffectParamBuffers() {
          const e = this._effectParams, t = this._effectParamBuffers;
          for (let s2 = 0, f2 = Math.min(e.length, t.length); s2 < f2; ++s2) {
            const f3 = t[s2], r2 = e[s2];
            for (let e2 = 0, t2 = r2.length; e2 < t2; ++e2) f3.SetParameterValue(e2, r2[e2]);
          }
        }
        static SaveFxParamToJson(e) {
          return e && e instanceof C33.Color ? { "t": "color", "v": e.toJSON() } : e;
        }
        static LoadFxParamFromJson(e) {
          if (null === e) return NaN;
          if ("object" == typeof e) {
            if ("color" === e["t"]) {
              const t = C33.New(C33.Color);
              return t.setFromJSON(e["v"]), t;
            }
            throw new Error("invalid effect parameter type");
          }
          return e;
        }
        static SaveFxParamsToJson(e) {
          return e.map(C33.EffectList.SaveFxParamToJson);
        }
        static LoadFxParamsFromJson(e) {
          return e.map(C33.EffectList.LoadFxParamFromJson);
        }
        SaveToJson() {
          return this._allEffectTypes.map((e) => ({ "name": e.GetName(), "active": e.IsActive(), "params": C33.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));
        }
        LoadFromJson(e) {
          for (const t of e) {
            const e2 = this.GetEffectTypeByName(t["name"]);
            e2 && (e2.SetActive(t["active"]), this._effectParams[e2.GetIndex()] = C33.EffectList.LoadFxParamsFromJson(t["params"]));
          }
          this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.EffectType = class extends C33.DefendedBase {
        constructor(e, t, r2) {
          super(), this._effectList = e, this._id = t[0], this._name = t[1], this._index = r2, this._shaderProgram = null, this._isActive = true;
        }
        Release() {
          this._effectList = null, this._shaderProgram = null;
        }
        Clone(e) {
          const t = C33.New(C33.EffectType, e, [this._id, this._name], -1);
          return t._shaderProgram = this._shaderProgram, t._isActive = this._isActive, t;
        }
        _InitRenderer(e) {
          const t = e.GetShaderProgramByName(this._id);
          if (!t) throw new Error("failed to find shader program '" + this._id + "'");
          this._shaderProgram = t;
        }
        GetEffectList() {
          return this._effectList;
        }
        GetName() {
          return this._name;
        }
        _SetIndex(e) {
          this._index = e;
        }
        GetIndex() {
          return this._index;
        }
        GetOwner() {
          return this._effectList.GetOwner();
        }
        GetRuntime() {
          return this._effectList.GetRuntime();
        }
        SetActive(e) {
          this._isActive = !!e;
        }
        IsActive() {
          return this._isActive;
        }
        GetShaderProgram() {
          return this._shaderProgram;
        }
        GetDefaultParameterValues() {
          const e = [];
          for (let t = 0, r2 = this._shaderProgram.GetParameterCount(); t < r2; ++t) {
            const r3 = this._shaderProgram.GetParameterType(t);
            if ("float" === r3 || "percent" === r3) e.push(0);
            else {
              if ("color" !== r3) throw new TypeError("unknown effect parameter type");
              e.push(C33.New(C33.Color, 1, 1, 1, 1));
            }
          }
          return e;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.InstanceEffectList = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._inst = e, this._wi = t, this._effectList = e.GetObjectClass().GetEffectList(), this._needsRebuildSteps = true, this._wasDefaultColor = true, this._was3D = false, this._wasRotatedOrNegativeSize = false, this._wasTexRotated = false, this._wasMustPreDraw = false, this._effectChain = C33.New(C33.Gfx.EffectChain, e.GetRuntime().GetCanvasManager().GetEffectChainManager(), { drawContent: (e2, t2) => {
            const s2 = t2.GetContentObject(), f2 = s2.GetWorldInfo();
            e2.SetColor(f2.GetPremultipliedColor()), e2.SetCurrentZ(f2.GetTotalZElevation()), s2.Draw(e2), e2.SetCurrentZ(0);
          }, getSourceTextureInfo: (e2) => {
            const t2 = e2.GetCurrentTexRect(), [s2, f2] = e2.GetCurrentSurfaceSize();
            return { srcTexRect: t2, srcWidth: s2, srcHeight: f2 };
          }, getShaderParameters: (e2) => this._GetEffectChainShaderParametersForIndex(e2) }), this._activeEffectFlags = [], this._activeEffectTypes = [], this._preservesOpaqueness = true, this._effectParams = [], this._effectParamBuffers = [], this._InitRenderer(e.GetRuntime().GetRenderer());
          for (let e2 = 0, t2 = this._effectList.GetAllEffectTypes().length; e2 < t2; ++e2) this._activeEffectFlags.push(true);
          this.UpdateActiveEffects(), this._effectList._AddInstanceEffectList(this);
        }
        Release() {
          this._effectList._RemoveInstanceEffectList(this);
          for (const e of this._effectParamBuffers) e && e.Release();
          C33.clearArray(this._effectParamBuffers), this._effectChain.Release(), this._effectChain = null, C33.clearArray(this._activeEffectFlags), C33.clearArray(this._activeEffectTypes), C33.clearArray(this._effectParams), this._inst = null, this._effectList = null;
        }
        _InitRenderer(e) {
          e.IsWebGPU() && (this._effectParamBuffers = this._effectList.GetAllEffectTypes().map((e2) => {
            const t = e2.GetShaderProgram();
            return t.GetCustomParametersByteSize() > 0 ? C33.New(C33.Gfx.WebGPUEffectCustomParamsBuffer, t) : null;
          }));
        }
        _LoadEffectParameters(e) {
          let t = 0;
          for (const s2 of e) this._effectParams.push(this._LoadSingleEffectParameters(t, s2)), ++t;
          this._UpdateAllEffectParamBuffers(), this.UpdateActiveEffects();
        }
        _LoadSingleEffectParameters(e, t) {
          this._activeEffectFlags[e] = t[0];
          const s2 = t.slice(1);
          for (let e2 = 0, t2 = s2.length; e2 < t2; ++e2) {
            const t3 = s2[e2];
            if (Array.isArray(t3)) {
              const f2 = C33.New(C33.Color);
              f2.setFromJSON(t3), s2[e2] = f2;
            }
          }
          return s2;
        }
        LoadDefaultEffectParameters() {
          for (const e of this._effectList.GetAllEffectTypes()) this._effectParams.push(e.GetDefaultParameterValues());
          this._UpdateAllEffectParamBuffers();
        }
        GetOwner() {
          return this._owner;
        }
        GetEffectList() {
          return this._effectList;
        }
        GetEffectChain() {
          return this._MaybeRebuildEffectChainSteps(), this._effectChain;
        }
        GetRuntime() {
          return this._inst.GetRuntime();
        }
        UpdateActiveEffects() {
          C33.clearArray(this._activeEffectTypes);
          const e = this._wi, t = this._effectList.GetAllEffectTypes(), s2 = this._activeEffectTypes, f2 = this._activeEffectFlags;
          let a2 = true;
          for (let e2 = 0, r2 = t.length; e2 < r2; ++e2) if (f2[e2]) {
            const f3 = t[e2];
            s2.push(f3), f3.GetShaderProgram().PreservesOpaqueness() || (a2 = false);
          }
          this._preservesOpaqueness = a2, e._SetHasAnyActiveEffect(!!s2.length), this._needsRebuildSteps = true;
        }
        _MaybeRebuildEffectChainSteps() {
          const e = this._inst, t = this._wi, s2 = t.HasDefaultColor(), f2 = e.GetPlugin().Is3D(), a2 = 0 !== t.GetAngle() || 0 !== t.GetLayer().GetAngle() || t.GetWidth() < 0 || t.GetHeight() < 0, r2 = e.IsCurrentTexRotated(), i2 = e.MustPreDraw();
          (this._needsRebuildSteps || s2 !== this._wasDefaultColor || f2 !== this._was3D || a2 !== this._wasRotatedOrNegativeSize || r2 !== this._wasTexRotated || i2 !== this._wasMustPreDraw || this._effectChain.NeedsRebuild()) && (this._effectChain.BuildSteps(this._activeEffectTypes.map((e2) => e2.GetShaderProgram()), { indexMap: this._activeEffectTypes.map((e2) => e2.GetIndex()), forcePreDraw: !s2 || i2, is3D: f2, isSourceTextureRotated: r2, isRotatedOrNegativeSizeInstance: a2 }), this._needsRebuildSteps = false, this._wasDefaultColor = s2, this._was3D = f2, this._wasRotatedOrNegativeSize = a2, this._wasTexRotated = r2, this._wasMustPreDraw = i2);
        }
        GetActiveEffectTypes() {
          return this._activeEffectTypes;
        }
        GetEffectParametersForIndex(e) {
          return this._effectParams[e];
        }
        _GetEffectChainShaderParametersForIndex(e) {
          return e < this._effectParamBuffers.length ? this._effectParamBuffers[e] : this._effectParams[e];
        }
        GetEffectParameter(e, t) {
          if (e < 0 || e >= this._effectParams.length) return null;
          const s2 = this._effectParams[e];
          return t < 0 || t >= s2.length ? null : s2[t];
        }
        SetEffectParameter(e, t, s2) {
          if (e < 0 || e >= this._effectParams.length) return false;
          const f2 = this._effectParams[e];
          if (t < 0 || t >= f2.length) return false;
          const a2 = f2[t];
          if (a2 instanceof C33.Color) {
            if (a2.equalsIgnoringAlpha(s2)) return false;
            a2.copyRgb(s2);
          } else {
            if (a2 === s2) return false;
            f2[t] = s2;
          }
          return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t, s2), true;
        }
        _UpdateAllEffectParamBuffers() {
          const e = this._effectParams, t = this._effectParamBuffers;
          for (let s2 = 0, f2 = t.length; s2 < f2; ++s2) {
            const f3 = t[s2], a2 = e[s2];
            for (let e2 = 0, t2 = a2.length; e2 < t2; ++e2) f3.SetParameterValue(e2, a2[e2]);
          }
        }
        PreservesOpaqueness() {
          return this._preservesOpaqueness;
        }
        HasAnyActiveBackgroundBlendingEffect() {
          return this._activeEffectTypes.some((e) => e.GetShaderProgram().BlendsBackground());
        }
        IsEffectIndexActive(e) {
          return this._activeEffectFlags[e];
        }
        SetEffectIndexActive(e, t) {
          this._activeEffectFlags[e] = !!t;
        }
        GetAllEffectTypes() {
          return this._effectList.GetAllEffectTypes();
        }
        _SaveToJson() {
          return this._effectList.GetAllEffectTypes().map((e) => ({ "name": e.GetName(), "active": this._activeEffectFlags[e.GetIndex()], "params": C33.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));
        }
        _LoadFromJson(e) {
          for (const t of e) {
            const e2 = this._effectList.GetEffectTypeByName(t["name"]);
            e2 && (this._activeEffectFlags[e2.GetIndex()] = t["active"], this._effectParams[e2.GetIndex()] = C33.EffectList.LoadFxParamsFromJson(t["params"]));
          }
          this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();
        }
      };
    }
    {
      const C33 = self.C3, tempCandidates = [], tileCollRectCandidates = [], tempJumpthruRet = [], tempPolyA = C33.New(C33.CollisionPoly), tempPolyB = C33.New(C33.CollisionPoly), tempQuad = C33.New(C33.Quad), tempRect = C33.New(C33.Rect), tempRect2 = C33.New(C33.Rect);
      let tempPolyC = null, tempRect3 = null, tempQuadB = null;
      C33.CollisionEngine = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e, this._collisionCellWidth = 0, this._collisionCellHeight = 0, this._registeredCollisions = [], this._collisionCheckCount = 0, this._collisionCheckSec = 0, this._polyCheckCount = 0, this._polyCheckSec = 0, this._iCollisionEngine = new self.ICollisionEngine(this);
        }
        Release() {
          this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetICollisionEngine() {
          return this._iCollisionEngine;
        }
        _Update1sStats() {
          this._collisionCheckSec = this._collisionCheckCount, this._collisionCheckCount = 0, this._polyCheckSec = this._polyCheckCount, this._polyCheckCount = 0;
        }
        Get1secCollisionChecks() {
          return this._collisionCheckSec;
        }
        Get1secPolyChecks() {
          return this._polyCheckSec;
        }
        RegisterCollision(e, t) {
          const s2 = e.GetWorldInfo(), n = t.GetWorldInfo();
          s2 && n && s2.IsCollisionEnabled() && n.IsCollisionEnabled() && this._registeredCollisions.push([e, t]);
        }
        AddRegisteredCollisionCandidates(e, t, s2) {
          for (const [n, l2] of this._registeredCollisions) {
            let o2 = null;
            if (e === n) o2 = l2;
            else {
              if (e !== l2) continue;
              o2 = n;
            }
            o2.BelongsToObjectClass(t) && (s2.includes(o2) || s2.push(o2));
          }
        }
        CheckRegisteredCollision(e, t) {
          if (!this._registeredCollisions.length) return false;
          for (const [s2, n] of this._registeredCollisions) if (e === s2 && t === n || e === n && t === s2) return true;
          return false;
        }
        ClearRegisteredCollisions() {
          C33.clearArray(this._registeredCollisions);
        }
        TestOverlap(e, t) {
          if (!e || !t || e === t) return false;
          const s2 = e.GetWorldInfo(), n = t.GetWorldInfo();
          if (!s2.IsCollisionEnabled() || !n.IsCollisionEnabled()) return false;
          this._collisionCheckCount++;
          const l2 = s2.GetLayer(), o2 = n.GetLayer();
          return l2.IsTransformCompatibleWith(o2) ? this._TestOverlap_SameLayers(s2, n) : this._TestOverlap_DifferentLayers(s2, n);
        }
        _TestOverlap_SameLayers(e, t) {
          if (!e.GetBoundingBox().intersectsRect(t.GetBoundingBox())) return false;
          if (this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(t.GetBoundingQuad())) return false;
          if (e.HasTilemap() && t.HasTilemap()) return false;
          if (e.HasTilemap()) return this.TestTilemapOverlap(e, t);
          if (t.HasTilemap()) return this.TestTilemapOverlap(t, e);
          if (!e.HasOwnCollisionPoly() && !t.HasOwnCollisionPoly()) return true;
          const s2 = e.GetTransformedCollisionPoly(), n = t.GetTransformedCollisionPoly();
          return s2.intersectsPoly(n, t.GetX() - e.GetX(), t.GetY() - e.GetY());
        }
        _TestOverlap_DifferentLayers(e, t) {
          const s2 = e.HasTilemap(), n = t.HasTilemap();
          if (s2 && !n) return this.TestTilemapOverlapDifferentLayers(e, t);
          if (n && !s2) return this.TestTilemapOverlapDifferentLayers(t, e);
          if (n || s2) return false;
          {
            const s3 = e.GetLayer(), n2 = t.GetLayer();
            tempPolyA.copy(e.GetTransformedCollisionPoly()), tempPolyB.copy(t.GetTransformedCollisionPoly());
            const l2 = tempPolyA.pointsArr();
            for (let t2 = 0, n3 = l2.length; t2 < n3; t2 += 2) {
              const n4 = t2 + 1, o3 = l2[t2], i2 = l2[n4], [r2, a2] = s3.LayerToCanvasCss(o3 + e.GetX(), i2 + e.GetY());
              l2[t2] = r2, l2[n4] = a2;
            }
            const o2 = tempPolyB.pointsArr();
            for (let e2 = 0, s4 = o2.length; e2 < s4; e2 += 2) {
              const s5 = e2 + 1, l3 = o2[e2], i2 = o2[s5], [r2, a2] = n2.LayerToCanvasCss(l3 + t.GetX(), i2 + t.GetY());
              o2[e2] = r2, o2[s5] = a2;
            }
            return tempPolyA.setBboxChanged(), tempPolyB.setBboxChanged(), this._polyCheckCount++, tempPolyA.intersectsPoly(tempPolyB, 0, 0);
          }
        }
        TestTilemapOverlapDifferentLayers(e, t) {
          const s2 = e.GetLayer(), n = t.GetLayer();
          tempPolyC || (tempPolyC = C33.New(C33.CollisionPoly)), tempRect3 || (tempRect3 = C33.New(C33.Rect)), tempQuadB || (tempQuadB = C33.New(C33.Quad));
          const l2 = t.GetX(), o2 = t.GetY(), [i2, r2] = n.LayerToCanvasCss(l2, o2), [a2, c2] = s2.CanvasCssToLayer(i2, r2), C = a2 - l2, d2 = c2 - o2;
          if (tempRect3.copy(t.GetBoundingBox()), tempRect3.offset(C, d2), !e.GetBoundingBox().intersectsRect(tempRect3)) return false;
          if (tempQuadB.copy(t.GetBoundingQuad()), tempQuadB.offset(C, d2), this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(tempQuadB)) return false;
          tempPolyC.copy(t.GetTransformedCollisionPoly());
          const u = tempPolyC.pointsArr();
          for (let e2 = 0, t2 = u.length; e2 < t2; e2 += 2) {
            const t3 = e2 + 1;
            u[e2] += C, u[t3] += d2;
          }
          return tempPolyC.setBboxChanged(), this.TestTilemapOverlap(e, t, a2, c2, tempPolyC, tempRect3, tempQuadB);
        }
        TestTilemapOverlap(e, t, s2, n, l2, o2, i2) {
          const r2 = void 0 !== o2 ? o2 : t.GetBoundingBox(), a2 = e.GetX(), c2 = e.GetY(), C = e.GetInstance().GetSdkInstance(), d2 = void 0 !== s2 ? s2 : t.GetX(), u = void 0 !== n ? n : t.GetY(), h = t.HasOwnCollisionPoly(), p = void 0 !== i2 ? i2 : t.GetBoundingQuad(), f2 = tileCollRectCandidates;
          C.GetCollisionRectCandidates(r2, f2);
          for (let e2 = 0, s3 = f2.length; e2 < s3; ++e2) {
            const s4 = f2[e2], n2 = s4.GetRect();
            if (this._collisionCheckCount++, r2.intersectsRectOffset(n2, a2, c2) && (tempQuad.setFromRect(n2), tempQuad.offset(a2, c2), tempQuad.intersectsQuad(p))) if (h) {
              const e3 = void 0 !== l2 ? l2 : t.GetTransformedCollisionPoly();
              let o3 = d2, i3 = u;
              void 0 !== l2 && (o3 = t.GetX(), i3 = t.GetY());
              const r3 = s4.GetPoly();
              if (r3) {
                if (this._polyCheckCount++, r3.intersectsPoly(e3, o3 - (a2 + n2.getLeft()), i3 - (c2 + n2.getTop()))) return C33.clearArray(f2), true;
              } else if (tempPolyA.setFromQuad(tempQuad, 0, 0), tempPolyA.intersectsPoly(e3, o3, i3)) return C33.clearArray(f2), true;
            } else {
              const e3 = s4.GetPoly();
              if (!e3) return C33.clearArray(f2), true;
              if (tempPolyA.setFromQuad(p, 0, 0), e3.intersectsPoly(tempPolyA, -(a2 + n2.getLeft()), -(c2 + n2.getTop()))) return C33.clearArray(f2), true;
            }
          }
          return C33.clearArray(f2), false;
        }
        TestAndSelectCanvasPointOverlap(e, t, s2) {
          const n = e.GetCurrentSol(), l2 = this._runtime.GetCurrentEvent();
          if (!l2) throw new Error("cannot call outside event");
          const o2 = l2.IsOrBlock(), i2 = new C33.LayerStateCache();
          if (n.IsSelectAll()) {
            s2 || (n._SetSelectAll(false), C33.clearArray(n._GetOwnInstances())), o2 && C33.clearArray(n._GetOwnElseInstances());
            for (const l3 of e.GetInstances()) {
              const e2 = l3.GetWorldInfo(), r2 = e2.GetLayer();
              let a2 = false;
              if (i2.IsInteractive(r2) && e2.IsInViewport2() && (a2 = t.some(([t2, s3]) => {
                const [n2, l4] = i2.CanvasCssToLayer(r2, t2, s3, e2.GetTotalZElevation());
                return e2.ContainsPoint(n2, l4);
              })), a2) {
                if (s2) return false;
                n._PushInstance(l3);
              } else o2 && n._PushElseInstance(l3);
            }
          } else {
            let e2, r2 = false;
            o2 && !l2.IsFirstConditionOfType(this._runtime.GetCurrentCondition()) ? this._runtime.IsCurrentConditionFirst() && !n._GetOwnElseInstances().length && n._GetOwnInstances().length ? e2 = n._GetOwnInstances() : (e2 = n._GetOwnElseInstances(), r2 = true) : e2 = n._GetOwnInstances();
            let a2 = 0;
            for (let l3 = 0, c2 = e2.length; l3 < c2; ++l3) {
              const c3 = e2[l3], C = c3.GetWorldInfo(), d2 = C.GetLayer();
              let u = false;
              if (i2.IsInteractive(d2) && C.IsInViewport2() && (u = t.some(([e3, t2]) => {
                const [s3, n2] = i2.CanvasCssToLayer(d2, e3, t2, C.GetTotalZElevation());
                return C.ContainsPoint(s3, n2);
              })), u) {
                if (s2) return false;
                r2 ? n._PushInstance(c3) : e2[a2++] = c3;
              } else r2 ? e2[a2++] = c3 : o2 && n._PushElseInstance(c3);
            }
            s2 || (e2.length = a2);
          }
          return e.ApplySolToContainer(), i2.Release(), !!s2 || n.HasAnyInstances();
        }
        _ObjectClassCanUseCollisionCells(e, t) {
          if (!e) return true;
          for (const s2 of t.layersHasInstancesOn()) if (!e.IsTransformCompatibleWith(s2)) return false;
          return true;
        }
        GetCollisionCandidates(e, t, s2, n) {
          if (t.IsFamily()) for (const l2 of t.GetFamilyMembers()) this._ObjectClassCanUseCollisionCells(e, l2) ? (l2._UpdateAllCollisionCells(), l2._GetCollisionCellGrid().QueryRange(s2, n)) : C33.appendArray(n, l2.GetInstances());
          else this._ObjectClassCanUseCollisionCells(e, t) ? (t._UpdateAllCollisionCells(), t._GetCollisionCellGrid().QueryRange(s2, n)) : C33.appendArray(n, t.GetInstances());
        }
        GetObjectClassesCollisionCandidates(e, t, s2, n) {
          for (const l2 of t) this.GetCollisionCandidates(e, l2, s2, n);
        }
        GetSolidCollisionCandidates(e, t, s2) {
          const n = this._runtime.GetSolidBehavior();
          n && this.GetObjectClassesCollisionCandidates(e, n.GetObjectClasses(), t, s2);
        }
        GetJumpthruCollisionCandidates(e, t, s2) {
          const n = this._runtime.GetJumpthruBehavior();
          n && this.GetObjectClassesCollisionCandidates(e, n.GetObjectClasses(), t, s2);
        }
        IsSolidCollisionAllowed(e, t) {
          return e._IsSolidEnabled() && (!t || t.GetWorldInfo().IsSolidCollisionAllowed(e.GetSavedDataMap().get("solidTags")));
        }
        TestOverlapSolid(e) {
          const t = e.GetWorldInfo();
          this.GetSolidCollisionCandidates(t.GetLayer(), t.GetBoundingBox(), tempCandidates);
          for (const t2 of tempCandidates) if (this.IsSolidCollisionAllowed(t2, e) && this.TestOverlap(e, t2)) return C33.clearArray(tempCandidates), t2;
          return C33.clearArray(tempCandidates), null;
        }
        TestRectOverlapSolid(e, t) {
          this.GetSolidCollisionCandidates(null, e, tempCandidates);
          for (const s2 of tempCandidates) if (this.IsSolidCollisionAllowed(s2, t) && this.TestRectOverlap(e, s2)) return C33.clearArray(tempCandidates), s2;
          return C33.clearArray(tempCandidates), null;
        }
        TestOverlapJumpthru(e, t) {
          let s2 = null;
          t && (s2 = tempJumpthruRet, C33.clearArray(s2));
          const n = e.GetWorldInfo();
          this.GetJumpthruCollisionCandidates(n.GetLayer(), n.GetBoundingBox(), tempCandidates);
          for (const n2 of tempCandidates) if (n2._IsJumpthruEnabled() && this.TestOverlap(e, n2)) {
            if (!t) return C33.clearArray(tempCandidates), n2;
            s2.push(n2);
          }
          return C33.clearArray(tempCandidates), s2;
        }
        PushOut(e, t, s2, n, l2) {
          n = n || 50;
          const o2 = e.GetWorldInfo(), i2 = o2.GetX(), r2 = o2.GetY();
          for (let a2 = 0; a2 < n; ++a2) if (o2.SetXY(i2 + t * a2, r2 + s2 * a2), o2.SetBboxChanged(), !this.TestOverlap(e, l2)) return true;
          return o2.SetXY(i2, r2), o2.SetBboxChanged(), false;
        }
        PushOutSolid(e, t, s2, n, l2, o2) {
          n = n || 50;
          const i2 = e.GetWorldInfo(), r2 = i2.GetX(), a2 = i2.GetY();
          let c2 = null, C = null;
          for (let d2 = 0; d2 < n; ++d2) if (i2.SetXY(r2 + t * d2, a2 + s2 * d2), i2.SetBboxChanged(), !this.TestOverlap(e, c2)) {
            if (c2 = this.TestOverlapSolid(e), c2) C = c2;
            else if (l2 && (c2 = o2 ? this.TestOverlap(e, o2) ? o2 : null : this.TestOverlapJumpthru(e), c2 && (C = c2)), !c2) return C && this.PushInFractional(e, t, s2, C, 16, true), true;
          }
          return i2.SetXY(r2, a2), i2.SetBboxChanged(), false;
        }
        PushOutSolidAxis(e, t, s2, n) {
          n = n || 50;
          const l2 = e.GetWorldInfo(), o2 = l2.GetX(), i2 = l2.GetY();
          let r2 = null, a2 = null;
          for (let c2 = 0; c2 < n; ++c2) for (let n2 = 0; n2 < 2; ++n2) {
            const C = 2 * n2 - 1;
            if (l2.SetXY(o2 + t * c2 * C, i2 + s2 * c2 * C), l2.SetBboxChanged(), !this.TestOverlap(e, r2)) {
              if (r2 = this.TestOverlapSolid(e), !r2) return a2 && this.PushInFractional(e, t * C, s2 * C, a2, 16, true), true;
              a2 = r2;
            }
          }
          return l2.SetXY(o2, i2), l2.SetBboxChanged(), false;
        }
        PushInFractional(e, t, s2, n, l2, o2) {
          let i2 = 2, r2 = false, a2 = false;
          const c2 = e.GetWorldInfo();
          let C = c2.GetX(), d2 = c2.GetY();
          for (; i2 <= l2; ) {
            const l3 = 1 / i2;
            i2 *= 2, c2.OffsetXY(t * l3 * (r2 ? 1 : -1), s2 * l3 * (r2 ? 1 : -1)), c2.SetBboxChanged(), this.TestOverlap(e, n) || o2 && this.TestOverlapSolid(e) ? (r2 = true, a2 = true) : (r2 = false, a2 = false, C = c2.GetX(), d2 = c2.GetY());
          }
          a2 && (c2.SetXY(C, d2), c2.SetBboxChanged());
        }
        PushOutSolidNearest(e, t = 100) {
          let s2 = 0;
          const n = e.GetWorldInfo(), l2 = n.GetX(), o2 = n.GetY();
          let i2 = 0, r2 = this.TestOverlapSolid(e);
          if (!r2) return true;
          for (; s2 <= t; ) {
            let t2 = 0, a2 = 0;
            switch (i2) {
              case 0:
                t2 = 0, a2 = -1, s2++;
                break;
              case 1:
                t2 = 1, a2 = -1;
                break;
              case 2:
                t2 = 1, a2 = 0;
                break;
              case 3:
                t2 = 1, a2 = 1;
                break;
              case 4:
                t2 = 0, a2 = 1;
                break;
              case 5:
                t2 = -1, a2 = 1;
                break;
              case 6:
                t2 = -1, a2 = 0;
                break;
              case 7:
                t2 = -1, a2 = -1;
            }
            if (i2 = (i2 + 1) % 8, n.SetXY(Math.floor(l2 + t2 * s2), Math.floor(o2 + a2 * s2)), n.SetBboxChanged(), !this.TestOverlap(e, r2) && (r2 = this.TestOverlapSolid(e), !r2)) return true;
          }
          return n.SetXY(l2, o2), n.SetBboxChanged(), false;
        }
        CalculateBounceAngle(e, t, s2, n) {
          const l2 = e.GetWorldInfo(), o2 = l2.GetX(), i2 = l2.GetY(), r2 = Math.max(10, C33.distanceTo(t, s2, o2, i2)), a2 = C33.angleTo(t, s2, o2, i2), c2 = n || this.TestOverlapSolid(e);
          if (!c2) return C33.clampAngle(a2 + Math.PI);
          let C = c2, d2 = 0, u = 0;
          const h = C33.toRadians(5);
          let p;
          for (p = 1; p < 36; ++p) {
            const o3 = a2 - p * h;
            if (l2.SetXY(t + Math.cos(o3) * r2, s2 + Math.sin(o3) * r2), l2.SetBboxChanged(), !this.TestOverlap(e, C) && (C = n ? null : this.TestOverlapSolid(e), !C)) {
              d2 = o3;
              break;
            }
          }
          for (36 === p && (d2 = C33.clampAngle(a2 + Math.PI)), C = c2, p = 1; p < 36; ++p) {
            const o3 = a2 + p * h;
            if (l2.SetXY(t + Math.cos(o3) * r2, s2 + Math.sin(o3) * r2), l2.SetBboxChanged(), !this.TestOverlap(e, C) && (C = n ? null : this.TestOverlapSolid(e), !C)) {
              u = o3;
              break;
            }
          }
          if (36 === p && (u = C33.clampAngle(a2 + Math.PI)), l2.SetXY(o2, i2), l2.SetBboxChanged(), u === d2) return u;
          const f2 = C33.angleDiff(u, d2) / 2;
          let G;
          G = C33.angleClockwise(u, d2) ? C33.clampAngle(d2 + f2 + Math.PI) : C33.clampAngle(u + f2);
          const m = Math.cos(a2), y = Math.sin(a2), g = Math.cos(G), T = Math.sin(G), _ = m * g + y * T, I = m - 2 * _ * g, S = y - 2 * _ * T;
          return C33.angleTo(0, 0, I, S);
        }
        TestSegmentOverlap(e, t, s2, n, l2) {
          if (!l2) return false;
          const o2 = l2.GetWorldInfo();
          if (!o2.IsCollisionEnabled()) return false;
          if (this._collisionCheckCount++, tempRect.set(Math.min(e, s2), Math.min(t, n), Math.max(e, s2), Math.max(t, n)), !o2.GetBoundingBox().intersectsRect(tempRect)) return false;
          if (l2.HasTilemap()) return this._TestSegmentOverlapTilemap(e, t, s2, n, l2, o2);
          if (this._polyCheckCount++, !o2.GetBoundingQuad().intersectsSegment(e, t, s2, n)) return false;
          if (!o2.HasOwnCollisionPoly()) return true;
          return o2.GetTransformedCollisionPoly().intersectsSegment(o2.GetX(), o2.GetY(), e, t, s2, n);
        }
        _TestSegmentOverlapTilemap(e, t, s2, n, l2, o2) {
          const i2 = o2.GetX(), r2 = o2.GetY(), a2 = l2.GetSdkInstance(), c2 = tileCollRectCandidates;
          tempRect2.set(e, t, s2, n), tempRect2.normalize(), a2.GetCollisionRectCandidates(tempRect2, c2);
          for (let l3 = 0, o3 = c2.length; l3 < o3; ++l3) {
            const o4 = c2[l3], a3 = o4.GetRect();
            if (this._collisionCheckCount++, tempRect.intersectsRectOffset(a3, i2, r2) && (tempQuad.setFromRect(a3), tempQuad.offset(i2, r2), tempQuad.intersectsSegment(e, t, s2, n))) {
              const l4 = o4.GetPoly();
              if (!l4) return C33.clearArray(c2), true;
              if (this._polyCheckCount++, l4.intersectsSegment(i2 + a3.getLeft(), r2 + a3.getTop(), e, t, s2, n)) return C33.clearArray(c2), true;
            }
          }
          return C33.clearArray(c2), false;
        }
        TestRectOverlap(e, t) {
          if (!t) return false;
          const s2 = t.GetWorldInfo();
          if (!s2.IsCollisionEnabled()) return false;
          if (this._collisionCheckCount++, !s2.GetBoundingBox().intersectsRect(e)) return false;
          if (t.HasTilemap()) return this._TestRectOverlapTilemap(e, t, s2);
          if (this._polyCheckCount++, tempQuad.setFromRect(e), !s2.GetBoundingQuad().intersectsQuad(tempQuad)) return false;
          if (!s2.HasOwnCollisionPoly()) return true;
          const n = tempPolyA;
          n.setFromRect(e, s2.GetX(), s2.GetY());
          const l2 = s2.GetTransformedCollisionPoly();
          return n.intersectsPoly(l2, 0, 0);
        }
        _TestRectOverlapTilemap(e, t, s2) {
          const n = s2.GetX(), l2 = s2.GetY(), o2 = t.GetSdkInstance(), i2 = tileCollRectCandidates;
          o2.GetCollisionRectCandidates(e, i2);
          for (let t2 = 0, s3 = i2.length; t2 < s3; ++t2) {
            const s4 = i2[t2], o3 = s4.GetRect();
            if (this._collisionCheckCount++, e.intersectsRectOffset(o3, n, l2)) {
              const t3 = s4.GetPoly();
              if (!t3) return C33.clearArray(i2), true;
              if (this._polyCheckCount++, tempPolyA.setFromRect(e, 0, 0), t3.intersectsPoly(tempPolyA, -(n + o3.getLeft()), -(l2 + o3.getTop()))) return C33.clearArray(i2), true;
            }
          }
          return C33.clearArray(i2), false;
        }
        TestRayIntersectsInstance(e, t) {
          if (!e) return;
          const s2 = e.GetWorldInfo();
          s2.IsCollisionEnabled() && (this._collisionCheckCount++, s2.GetBoundingBox().intersectsRect(t.rect) && (e.HasTilemap() ? this._TestRayIntersectsTilemap(e, s2, t) : (this._polyCheckCount++, s2.HasOwnCollisionPoly() ? t.TestInstancePoly(e, s2.GetX(), s2.GetY(), s2.GetTransformedCollisionPoly()) : t.TestInstanceQuad(e, s2.GetBoundingQuad()))));
        }
        _TestRayIntersectsTilemap(e, t, s2) {
          const n = t.GetX(), l2 = t.GetY(), o2 = tileCollRectCandidates;
          e.GetSdkInstance().GetCollisionRectCandidates(s2.rect, o2);
          for (let i2 = 0, r2 = o2.length; i2 < r2; i2++) {
            const r3 = o2[i2], a2 = r3.GetRect();
            if (this._collisionCheckCount++, s2.rect.intersectsRectOffset(a2, n, l2)) {
              const o3 = r3.GetPoly();
              this._polyCheckCount++, o3 ? s2.TestInstancePoly(e, n + a2.getLeft(), l2 + a2.getTop(), o3) : s2.TestInstanceRect(e, t.GetX(), t.GetY(), a2);
            }
          }
          C33.clearArray(o2);
        }
        SetCollisionCellSize(e, t) {
          if (e === this._collisionCellWidth && t === this._collisionCellHeight) return;
          this._collisionCellWidth = e, this._collisionCellHeight = t;
          const s2 = this._runtime.GetAllObjectClasses();
          for (const n of s2) if (n.IsWorldType()) {
            for (const e2 of n.instancesIncludingPendingCreate()) e2.GetWorldInfo()._RemoveFromCollisionCells();
            n._GetCollisionCellGrid().SetCellSize(e, t), n._SetAnyCollisionCellChanged();
            for (const e2 of n.instancesIncludingPendingCreate()) {
              const t2 = e2.GetWorldInfo();
              t2._SetCollisionCellChanged(), t2._UpdateCollisionCell();
            }
          }
        }
        GetCollisionCellSize() {
          return [this._collisionCellWidth, this._collisionCellHeight];
        }
        _InitCollisionCellSize(e, t) {
          this._collisionCellWidth = e, this._collisionCellHeight = t;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SparseGrid = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._cellWidth = t, this._cellHeight = e, this._cells = C33.New(C33.PairMap);
        }
        Release() {
          this._cells.Release(), this._cells = null;
        }
        SetCellSize(t, e) {
          if (!this._cells.IsEmpty()) throw new Error("grid not empty");
          this._cellWidth = t, this._cellHeight = e;
        }
        GetCell(t, e, l2) {
          let i2 = this._cells.Get(t, e);
          return i2 || (l2 ? (i2 = C33.New(C33.GridCell, this, t, e), this._cells.Set(t, e, i2), i2) : null);
        }
        XToCell(t) {
          const e = Math.floor(t / this._cellWidth);
          return isFinite(e) ? e : 0;
        }
        YToCell(t) {
          const e = Math.floor(t / this._cellHeight);
          return isFinite(e) ? e : 0;
        }
        Update(t, e, l2) {
          if (e) for (let i2 = e.getLeft(), s2 = e.getRight(); i2 <= s2; ++i2) for (let s3 = e.getTop(), o2 = e.getBottom(); s3 <= o2; ++s3) {
            if (l2 && l2.containsPoint(i2, s3)) continue;
            const e2 = this.GetCell(i2, s3, false);
            e2 && (e2.Remove(t), e2.IsEmpty() && this._cells.Delete(i2, s3));
          }
          if (l2) for (let i2 = l2.getLeft(), s2 = l2.getRight(); i2 <= s2; ++i2) for (let s3 = l2.getTop(), o2 = l2.getBottom(); s3 <= o2; ++s3) e && e.containsPoint(i2, s3) || this.GetCell(i2, s3, true).Insert(t);
        }
        QueryRange(t, e) {
          let l2 = this.XToCell(t.getLeft());
          const i2 = this.YToCell(t.getTop()), s2 = this.XToCell(t.getRight()), o2 = this.YToCell(t.getBottom());
          if (isFinite(s2) && isFinite(o2)) for (; l2 <= s2; ++l2) for (let t2 = i2; t2 <= o2; ++t2) {
            const i3 = this.GetCell(l2, t2, false);
            i3 && i3.Dump(e);
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.GridCell = class extends C33.DefendedBase {
        constructor(s2, e, t) {
          super(), this._grid = s2, this._x = e, this._y = t, this._instances = C33.New(C33.ArraySet);
        }
        Release() {
          this._instances.Release(), this._instances = null, this._grid = null;
        }
        IsEmpty() {
          return this._instances.IsEmpty();
        }
        Insert(s2) {
          this._instances.Add(s2);
        }
        Remove(s2) {
          this._instances.Delete(s2);
        }
        Dump(s2) {
          C33.appendArray(s2, this._instances.GetArray());
        }
      };
    }
    {
      const C33 = self.C3, PADDING = 1e-6, NO_HIT = 2;
      C33.Ray = class {
        constructor() {
          this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.dx = 0, this.dy = 0, this.rect = new C33.Rect(), this.hitFraction = 2, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0;
        }
        DidCollide() {
          return this.hitFraction < 1.000001;
        }
        Reset() {
          this.hitFraction = 2;
        }
        Set(t, i2, s2, h) {
          return this.x1 = t, this.y1 = i2, this.x2 = s2, this.y2 = h, this.dx = s2 - t, this.dy = h - i2, this.rect.set(t, i2, s2, h), this.rect.normalize(), this.hitFraction = 2, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0, this;
        }
        Complete() {
          if (false === this.DidCollide()) return;
          const t = this.dx * this.hitFraction, i2 = this.dy * this.hitFraction, s2 = C33.hypot2DFast(t, i2), h = t / s2, e = i2 / s2;
          this.distance = s2 - PADDING, this.hitX = this.x1 + h * this.distance, this.hitY = this.y1 + e * this.distance, this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2, this.normalX = Math.cos(this.hitNormal), this.normalY = Math.sin(this.hitNormal);
          const n = h * this.normalX + e * this.normalY;
          if (this.reflectionX = h - 2 * this.normalX * n, this.reflectionY = e - 2 * this.normalY * n, n > 0) {
            const t2 = Math.PI;
            this.hitNormal = C33.clampAngle(this.hitNormal + t2), this.normalX = -this.normalX, this.normalY = -this.normalY;
          }
        }
        TestInstanceSegment(t, i2, s2, h, e) {
          const n = C33.rayIntersect(this.x1, this.y1, this.x2, this.y2, i2, s2, h, e);
          n >= 0 && n < this.hitFraction && (this.hitFraction = n, this.hitUid = t.GetUID(), this.hitNormalDx = i2 - h, this.hitNormalDy = s2 - e);
        }
        TestInstanceRect(t, i2, s2, h) {
          const e = i2 + h.getLeft(), n = i2 + h.getRight(), a2 = s2 + h.getTop(), o2 = s2 + h.getBottom();
          this.TestInstanceSegment(t, e, a2, n, a2), this.TestInstanceSegment(t, n, a2, n, o2), this.TestInstanceSegment(t, n, o2, e, o2), this.TestInstanceSegment(t, e, o2, e, a2);
        }
        TestInstanceQuad(t, i2) {
          const s2 = i2.getTlx(), h = i2.getTly(), e = i2.getTrx(), n = i2.getTry(), a2 = i2.getBrx(), o2 = i2.getBry(), r2 = i2.getBlx(), l2 = i2.getBly();
          this.TestInstanceSegment(t, s2, h, e, n), this.TestInstanceSegment(t, e, n, a2, o2), this.TestInstanceSegment(t, a2, o2, r2, l2), this.TestInstanceSegment(t, r2, l2, s2, h);
        }
        TestInstancePoly(t, i2, s2, h) {
          const e = h.pointsArr();
          for (let h2 = 0, n = e.length; h2 < n; h2 += 2) {
            const a2 = (h2 + 2) % n, o2 = e[h2] + i2, r2 = e[h2 + 1] + s2, l2 = e[a2] + i2, c2 = e[a2 + 1] + s2;
            this.TestInstanceSegment(t, o2, r2, l2, c2);
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.LayerStateCache = class {
        constructor() {
          this._layerCache = /* @__PURE__ */ new Map();
        }
        Release() {
          for (const e of this._layerCache.values()) e.layerPts.Clear();
          this._layerCache.clear();
        }
        _GetLayerCache(e) {
          let a2 = this._layerCache.get(e);
          return void 0 === a2 && (a2 = { isInteractive: null, layerPts: new C33.PairMap() }, this._layerCache.set(e, a2)), a2;
        }
        IsInteractive(e) {
          const a2 = this._GetLayerCache(e);
          return null === a2.isInteractive && (a2.isInteractive = e.IsSelfAndParentsInteractive()), a2.isInteractive;
        }
        CanvasCssToLayer(e, a2, t, s2) {
          if (0 !== s2) return e.CanvasCssToLayer(a2, t, s2);
          const r2 = this._GetLayerCache(e);
          let n = r2.layerPts.Get(a2, t);
          return void 0 === n && (n = e.CanvasCssToLayer(a2, t, s2), r2.layerPts.Set(a2, t, n)), n;
        }
      };
    }
    {
      const C33 = self.C3, VALID_FULLSCREEN_MODES = /* @__PURE__ */ new Set(["off", "crop", "scale-inner", "scale-outer", "letterbox-scale", "letterbox-integer-scale"]), VALID_FULLSCREEN_SCALING_QUALITIES = /* @__PURE__ */ new Set(["high", "low"]), glMatrix = self.glMatrix, mat42 = glMatrix.mat4, vec32 = glMatrix.vec3, tempProjection = mat42.create(), PERCENTTEXT_WIDTH = 300, PERCENTTEXT_HEIGHT = 200, PROGRESSBAR_WIDTH = 120, PROGRESSBAR_HEIGHT = 8, tempQuad = C33.New(C33.Quad), tempRect = C33.New(C33.Rect), SPLASH_MIN_DISPLAY_TIME = 3e3, SPLASH_AFTER_FADEOUT_WAIT_TIME = 200, SPLASH_FADE_DURATION = 300;
      C33.CanvasManager = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e, this._canvasLayers = [], this._isWebGPUEnabled = false, this._webglRenderer = null, this._webgpuRenderer = null, this._iRenderer = null, this._gpuPreference = "high-performance", this._isLimitedToWebGL1 = false, this._multitexturingMode = "auto", this._windowInnerWidth = 0, this._windowInnerHeight = 0, this._cssDisplayMode = "", this._canvasCssWidth = 0, this._canvasCssHeight = 0, this._canvasDeviceWidth = 0, this._canvasDeviceHeight = 0, this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0, this._zAxisScale = "normalized", this._initFieldOfView = 0, this._zNear = 1, this._zFar = 1e4, this._enableMipmaps = true, this._textureAnisotropy = 0, this._drawWidth = 0, this._drawHeight = 0, this._fullscreenMode = "letterbox-scale", this._documentFullscreenMode = "letterbox-scale", this._deviceTransformOffX = 0, this._deviceTransformOffY = 0, this._defaultProjectionMatrix = mat42.create(), this._wantFullscreenScalingQuality = "high", this._fullscreenScalingQuality = this._wantFullscreenScalingQuality, this._isDocumentFullscreen = false, this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets = /* @__PURE__ */ new Set(), this._shaderData = self["C3_Shaders"], this._effectChainManager = C33.New(C33.Gfx.EffectChainManager, { getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()], getRenderTarget: () => this.GetEffectCompositorRenderTarget(), releaseRenderTarget: (e2) => this.ReleaseEffectCompositorRenderTarget(e2), getTime: () => this.GetRuntime().GetGameTime(), redraw: () => this.GetRuntime().UpdateRender() }), this._gpuTimeStartFrame = 0, this._gpuTimeEndFrame = 0, this._gpuLastUtilisation = NaN, this._gpuFrameTimingsBuffer = null, this._layersGpuProfile = /* @__PURE__ */ new Map(), this._gpuCurUtilisation = NaN, this._webgpuFrameTimings = /* @__PURE__ */ new Map(), this._snapshotFormat = "", this._snapshotQuality = 1, this._snapshotArea = C33.New(C33.Rect), this._snapshotUrl = "", this._snapshotPromise = null, this._snapshotResolve = null, this._isPastingToDrawingCanvas = 0, this._loaderStartTime = 0, this._rafId = -1, this._loadingProgress = 0, this._loadingprogress_handler = (e2) => this._loadingProgress = e2.progress, this._percentText = null, this._splashTextures = { logo: null, powered: null, website: null }, this._splashFrameNumber = 0, this._splashFadeInFinishTime = 0, this._splashFadeOutStartTime = 0, this._splashState = "fade-in", this._splashDoneResolve = null, this._splashDonePromise = new Promise((e2) => this._splashDoneResolve = e2);
        }
        _SetGPUPowerPreference(e) {
          this._gpuPreference = e;
        }
        _SetWebGPUEnabled(e) {
          this._isWebGPUEnabled = !!e;
        }
        _SetZAxisScale(e) {
          this._zAxisScale = e;
        }
        GetZAxisScale() {
          return this._zAxisScale;
        }
        _SetInitFieldOfView(e) {
          this._initFieldOfView = e;
        }
        _SetZDistances(e, t) {
          this._zNear = e, this._zFar = t;
        }
        _SetLimitedToWebGL1(e) {
          this._isLimitedToWebGL1 = !!e;
        }
        _SetMultitexturingMode(e) {
          this._multitexturingMode = e;
        }
        async CreateCanvas(e) {
          let t = e["canvas"];
          this._canvasLayers.push({ canvas: t, ctx: null }), this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", (e2) => this._OnWindowResize(e2)), this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", (e2) => this._OnFullscreenChange(e2)), this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", (e2) => this._OnFullscreenError(e2)), t.addEventListener("webglcontextlost", (e2) => this._OnWebGLContextLost(e2)), t.addEventListener("webglcontextrestored", (e2) => this._OnWebGLContextRestored(e2)), this._isDocumentFullscreen = !!e["isFullscreen"], this._cssDisplayMode = e["cssDisplayMode"];
          const s2 = navigator["gpu"] && this._isWebGPUEnabled;
          let i2 = false;
          if (s2) try {
            await this._InitWebGPUContext(true);
          } catch (e2) {
            this._MaybeLogRendererError("WebGPU", e2), this._webgpuRenderer = null;
          }
          if (!this.GetRenderer()) try {
            await this._InitWebGLContext(true);
          } catch (e2) {
            this._MaybeLogRendererError("WebGL", e2), this._webglRenderer = null;
          }
          if (this.GetRenderer() || (i2 = true), !this.GetRenderer() && s2) try {
            await this._InitWebGPUContext(false);
          } catch (e2) {
            this._MaybeLogRendererError("WebGPU", e2), this._webgpuRenderer = null;
          }
          if (!this.GetRenderer()) try {
            await this._InitWebGLContext(false);
          } catch (e2) {
            this._MaybeLogRendererError("WebGL", e2), this._webglRenderer = null;
          }
          const r2 = this.GetRenderer();
          if (!r2) throw new Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
          r2.SetHasMajorPerformanceCaveat(i2), this._webgpuRenderer && (this._webgpuRenderer.ondevicelost = () => this._OnWebGPUDeviceLost(), this._webgpuRenderer.ondevicerestored = () => this._OnWebGPUDeviceRestored()), "normalized" === this._zAxisScale ? r2.SetZAxisScaleNormalized() : (r2.SetZAxisScaleRegular(), r2.SetFovY(this._initFieldOfView)), this.SetSize(e["windowInnerWidth"], e["windowInnerHeight"], true), await this._InitRenderer();
        }
        _MaybeLogRendererError(e, t) {
          t && "string" == typeof t.message && t.message.startsWith("renderer-unavailable") || console.error(`Error creating ${e} renderer: `, t);
        }
        async _InitWebGPUContext(e) {
          const t = { nearZ: this._zNear, farZ: this._zFar };
          let s2 = true;
          "no" === this._multitexturingMode ? s2 = false : "auto" === this._multitexturingMode && (s2 = C33.Platform.IsDesktop);
          const i2 = { powerPreference: this._gpuPreference, depth: this._runtime.Uses3DFeatures(), failIfMajorPerformanceCaveat: e, usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(), canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(), canSampleDepth: this._runtime.UsesAnyDepthSampling(), isMultiTexturingAllowed: s2 };
          this._webgpuRenderer = C33.New(C33.Gfx.WebGPURenderer, t), await this._webgpuRenderer.Create(this._canvasLayers[0].canvas, i2);
        }
        async _InitWebGLContext(e) {
          const t = { alpha: true, powerPreference: this._gpuPreference, enableGpuProfiling: "xbox-uwp-webview2" !== this._runtime.GetExportType(), depth: this._runtime.Uses3DFeatures(), canSampleDepth: this._runtime.UsesAnyDepthSampling(), failIfMajorPerformanceCaveat: e, nearZ: this._zNear, farZ: this._zFar };
          this._isLimitedToWebGL1 && (t.maxWebGLVersion = 1), this._webglRenderer = C33.New(C33.Gfx.WebGLRenderer, this._canvasLayers[0].canvas, t), await this._webglRenderer.InitState();
        }
        async _InitWebGPU() {
          if (this._shaderData) {
            const e = [];
            for (const [t, s2] of Object.entries(this._shaderData)) {
              s2.src = s2.wgsl;
              const i2 = C33.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource(this._webgpuRenderer.IsColorDataF16());
              e.push(this._webgpuRenderer.CreateShaderProgram(Object.assign({ vertexSrc: i2, name: t }, s2)));
            }
            await Promise.all(e);
          }
        }
        async _InitWebGL() {
          if (this._shaderData) {
            const e = [];
            for (const [t, s2] of Object.entries(this._shaderData)) {
              let i2;
              if (s2.glslWebGL2 && this._webglRenderer.GetWebGLVersionNumber() >= 2) s2.src = s2.glslWebGL2, i2 = C33.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2();
              else {
                if (!s2.glsl) throw new Error(`shader '${t}' does not support WebGL 1`);
                s2.src = s2.glsl, i2 = C33.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();
              }
              e.push(this._webglRenderer.CreateShaderProgram(Object.assign({ vertexSrc: i2, name: t }, s2)));
            }
            await Promise.all(e), this._webglRenderer.ResetLastProgram(), this._webglRenderer.SetTextureFillMode();
          }
          this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = C33.New(C33.Gfx.WebGLQueryResultBuffer, this._webglRenderer));
        }
        async _InitRenderer() {
          this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();
          const e = this.GetRenderer();
          e.SetMipmapsEnabled(this._enableMipmaps), e.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);
          for (const t of this._runtime._GetAllEffectLists()) {
            for (const s2 of t.GetAllEffectTypes()) s2._InitRenderer(e);
            t._InitRenderer(e), t.UpdateActiveEffects();
          }
          this._iRenderer = new self.IRenderer(this._runtime, e);
        }
        Release() {
          this._runtime = null, this._webglRenderer = null, this._canvasLayers.length = 0;
        }
        IsInWorker() {
          return this._runtime.IsInWorker();
        }
        _OnWindowResize(e) {
          const t = this._runtime;
          if (t.IsExportToVideo()) return;
          const s2 = e["devicePixelRatio"];
          this.IsInWorker() && (self.devicePixelRatio = s2), t._SetDevicePixelRatio(s2), this._isDocumentFullscreen = !!e["isFullscreen"], this._cssDisplayMode = e["cssDisplayMode"], this.SetSize(e["innerWidth"], e["innerHeight"]), t.UpdateRender();
          const i2 = new C33.Event("window-resize");
          i2.data = e, t.Dispatcher().dispatchEventAndWaitAsyncSequential(i2);
          const r2 = new C33.Event("resize");
          r2.cssWidth = this.GetCssWidth(), r2.cssHeight = this.GetCssHeight(), r2.deviceWidth = this.GetDeviceWidth(), r2.deviceHeight = this.GetDeviceHeight(), t.DispatchUserScriptEvent(r2), this._runtime.GetCurrentLayout()?.BoundScrolling(), t.IsDebug() && (t.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && t.Render();
        }
        _OnFullscreenChange(e) {
          this._isDocumentFullscreen = !!e["isFullscreen"], this.SetSize(e["innerWidth"], e["innerHeight"], true), this._runtime.UpdateRender();
        }
        _OnFullscreenError(e) {
          this._isDocumentFullscreen = !!e["isFullscreen"], this.SetSize(e["innerWidth"], e["innerHeight"], true), this._runtime.UpdateRender();
        }
        SetSize(e, t, s2 = false) {
          if (e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0) throw new Error("invalid size");
          if (this._windowInnerWidth === e && this._windowInnerHeight === t && !s2) return;
          this._windowInnerWidth = e, this._windowInnerHeight = t;
          const i2 = this.GetCurrentFullscreenMode();
          "letterbox-scale" === i2 ? this._CalculateLetterboxScale(e, t) : "letterbox-integer-scale" === i2 ? this._CalculateLetterboxIntegerScale(e, t) : "off" === i2 ? this._CalculateFixedSizeCanvas(e, t) : this._CalculateFullsizeCanvas(e, t), this._UpdateFullscreenScalingQuality(i2);
          for (const { canvas: e2 } of this._canvasLayers) e2.width = this._canvasDeviceWidth, e2.height = this._canvasDeviceHeight;
          this._runtime.PostComponentMessageToDOM("canvas", "update-size", { "marginLeft": this._canvasCssOffsetX, "marginTop": this._canvasCssOffsetY, "styleWidth": this._canvasCssWidth, "styleHeight": this._canvasCssHeight, "displayScale": this.GetDisplayScale() });
          const r2 = this.GetRenderer();
          r2.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, true);
          for (const e2 of this._availableAdditionalRenderTargets) r2.DeleteRenderTarget(e2);
          C33.clearArray(this._availableAdditionalRenderTargets), this.UpdateDefaultProjectionMatrix();
          const a2 = this._runtime.GetLayoutManager();
          a2.SetAllLayerProjectionChanged(), a2.SetAllLayerMVChanged();
        }
        UpdateDefaultProjectionMatrix() {
          this.GetRenderer().CalculatePerspectiveMatrix(this._defaultProjectionMatrix, this.GetDrawWidth() / this.GetDrawHeight());
        }
        GetDefaultProjectionMatrix() {
          return this._defaultProjectionMatrix;
        }
        _CalculateLetterboxScale(e, t) {
          const s2 = this._runtime.GetDevicePixelRatio(), i2 = this._runtime.GetOriginalViewportWidth(), r2 = this._runtime.GetOriginalViewportHeight(), a2 = i2 / r2;
          if (e / t > a2) {
            const s3 = t * a2;
            this._canvasCssWidth = Math.round(s3), this._canvasCssHeight = t, this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = 0;
          } else {
            const s3 = e / a2;
            this._canvasCssWidth = e, this._canvasCssHeight = Math.round(s3), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2);
          }
          this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s2), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s2), this._runtime.SetViewportSize(i2, r2);
        }
        _CalculateLetterboxIntegerScale(e, t) {
          const s2 = this._runtime.GetDevicePixelRatio();
          1 !== s2 && (e += 1, t += 1);
          const i2 = this._runtime.GetOriginalViewportWidth(), r2 = this._runtime.GetOriginalViewportHeight(), a2 = i2 / r2;
          let n;
          if (e / t > a2) {
            n = t * a2 * s2 / i2;
          } else {
            n = e / a2 * s2 / r2;
          }
          n > 1 ? n = Math.floor(n) : n < 1 && (n = 1 / Math.ceil(1 / n)), this._canvasDeviceWidth = Math.round(i2 * n), this._canvasDeviceHeight = Math.round(r2 * n), this._canvasCssWidth = this._canvasDeviceWidth / s2, this._canvasCssHeight = this._canvasDeviceHeight / s2, this._canvasCssOffsetX = Math.max(Math.floor((e - this._canvasCssWidth) / 2), 0), this._canvasCssOffsetY = Math.max(Math.floor((t - this._canvasCssHeight) / 2), 0), this._runtime.SetViewportSize(i2, r2);
        }
        _CalculateFullsizeCanvas(e, t) {
          const s2 = this._runtime.GetDevicePixelRatio();
          this._canvasCssWidth = e, this._canvasCssHeight = t, this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s2), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s2), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0;
          const i2 = this.GetDisplayScale();
          this._runtime.SetViewportSize(this._canvasCssWidth / i2, this._canvasCssHeight / i2);
        }
        _CalculateFixedSizeCanvas(e, t) {
          const s2 = this._runtime.GetDevicePixelRatio();
          this._canvasCssWidth = this._runtime.GetViewportWidth(), this._canvasCssHeight = this._runtime.GetViewportHeight(), this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s2), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s2), this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2)) : (this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0), this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight());
        }
        _UpdateFullscreenScalingQuality(e) {
          if ("high" === this._wantFullscreenScalingQuality) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
          else {
            let t, s2;
            if ("off" === this.GetCurrentFullscreenMode() ? (t = this._runtime.GetViewportWidth(), s2 = this._runtime.GetViewportHeight()) : (t = this._runtime.GetOriginalViewportWidth(), s2 = this._runtime.GetOriginalViewportHeight()), this._canvasDeviceWidth < t || this._canvasDeviceHeight < s2) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
            else if (this._drawWidth = t, this._drawHeight = s2, this._fullscreenScalingQuality = "low", "scale-inner" === e) {
              const e2 = t / s2, i2 = this._windowInnerWidth / this._windowInnerHeight;
              i2 < e2 ? this._drawWidth = this._drawHeight * i2 : i2 > e2 && (this._drawHeight = this._drawWidth / i2);
            } else if ("scale-outer" === e) {
              const e2 = t / s2, i2 = this._windowInnerWidth / this._windowInnerHeight;
              i2 > e2 ? this._drawWidth = this._drawHeight * i2 : i2 < e2 && (this._drawHeight = this._drawWidth / i2);
            }
          }
        }
        GetRuntime() {
          return this._runtime;
        }
        GetMainCanvas() {
          return this._canvasLayers[0].canvas;
        }
        GetEffectChainManager() {
          return this._effectChainManager;
        }
        IsDocumentFullscreen() {
          return this._isDocumentFullscreen;
        }
        GetCssDisplayMode() {
          return this._cssDisplayMode;
        }
        SetFullscreenMode(e) {
          if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error("invalid fullscreen mode");
          this._fullscreenMode = e;
          const t = this._runtime.GetLayoutManager();
          t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();
        }
        GetFullscreenMode() {
          return this._fullscreenMode;
        }
        SetDocumentFullscreenMode(e) {
          if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error("invalid fullscreen mode");
          this._documentFullscreenMode = e;
          const t = this._runtime.GetLayoutManager();
          t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();
        }
        GetDocumentFullscreenMode() {
          return this._documentFullscreenMode;
        }
        GetCurrentFullscreenMode() {
          return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode();
        }
        SetFullscreenScalingQuality(e) {
          if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(e)) throw new Error("invalid fullscreen scaling quality");
          this._wantFullscreenScalingQuality = e, this._runtime.GetLayoutManager().SetAllLayerProjectionChanged();
        }
        GetSetFullscreenScalingQuality() {
          return this._wantFullscreenScalingQuality;
        }
        GetCurrentFullscreenScalingQuality() {
          return this._fullscreenScalingQuality;
        }
        static _FullscreenModeNumberToString(e) {
          switch (e) {
            case 0:
              return "off";
            case 1:
              return "crop";
            case 2:
              return "scale-inner";
            case 3:
              return "scale-outer";
            case 4:
              return "letterbox-scale";
            case 5:
              return "letterbox-integer-scale";
            default:
              throw new Error("invalid fullscreen mode");
          }
        }
        GetLastWidth() {
          return this._windowInnerWidth;
        }
        GetLastHeight() {
          return this._windowInnerHeight;
        }
        GetDrawWidth() {
          return this._drawWidth;
        }
        GetDrawHeight() {
          return this._drawHeight;
        }
        SetMipmapsEnabled(e) {
          this._enableMipmaps = !!e;
        }
        _SetTextureAnisotropy(e) {
          this._textureAnisotropy = e;
        }
        GetTextureAnisotropy() {
          return this._textureAnisotropy;
        }
        IsRendererContextLost() {
          return this.GetRenderer().IsContextLost();
        }
        _OnWebGLContextLost(e) {
          console.log("[Construct] WebGL context lost"), e.preventDefault(), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._webglRenderer.OnContextLost(), this._runtime._OnRendererContextLost();
        }
        _OnWebGPUDeviceLost() {
          console.log("[Construct] WebGPU device lost"), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._runtime._OnRendererContextLost();
        }
        async _OnWebGLContextRestored(e) {
          await this._webglRenderer.OnContextRestored(), await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log("[Construct] WebGL context restored");
        }
        async _OnWebGPUDeviceRestored() {
          await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log("[Construct] WebGPU device restored");
        }
        GetWebGLRenderer() {
          return this._webglRenderer;
        }
        GetWebGPURenderer() {
          return this._webgpuRenderer;
        }
        GetRenderer() {
          return this._webgpuRenderer || this._webglRenderer;
        }
        GetIRenderer() {
          return this._iRenderer;
        }
        GetRendererString() {
          let e = "";
          return e = this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber(), this._runtime.GetRenderer().HasMajorPerformanceCaveat() && (e += "-software"), e;
        }
        GetRendererDetailString() {
          return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();
        }
        GetRenderScale() {
          return "low" === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale();
        }
        GetDisplayScale() {
          const e = this.GetCurrentFullscreenMode();
          if ("off" === e || "crop" === e) return 1;
          const t = this._runtime.GetOriginalViewportWidth(), s2 = this._runtime.GetOriginalViewportHeight(), i2 = t / s2, r2 = this._canvasDeviceWidth / this._canvasDeviceHeight;
          return "scale-inner" !== e && r2 > i2 || "scale-inner" === e && r2 < i2 ? this._canvasCssHeight / s2 : this._canvasCssWidth / t;
        }
        GetEffectLayerScaleParam() {
          return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this.GetDisplayScale();
        }
        GetEffectDevicePixelRatioParam() {
          return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this._runtime.GetDevicePixelRatio();
        }
        SetDeviceTransformOffset(e, t) {
          this._deviceTransformOffX = e, this._deviceTransformOffY = t;
        }
        SetDeviceTransform(e, t, s2, i2 = true) {
          t = t || this._drawWidth, s2 = s2 || this._drawHeight;
          const r2 = t / 2 + this._deviceTransformOffX, a2 = s2 / 2 + this._deviceTransformOffY;
          if (i2) {
            let i3 = this.GetDefaultProjectionMatrix();
            t === this._drawWidth && s2 === this._drawHeight || (e.CalculatePerspectiveMatrix(tempProjection, t / s2), i3 = tempProjection), e.SetProjectionMatrix(i3);
          }
          const n = e.CalculateLookAtModelView2(r2, a2, e.GetDefaultCameraZ(s2), r2, a2, 0, s2);
          e.SetModelViewMatrix(n);
        }
        SetCssTransform(e, t = true) {
          const s2 = this.GetCssWidth(), i2 = this.GetCssHeight(), r2 = s2 / 2, a2 = i2 / 2;
          t && e.SetProjectionMatrix(this.GetDefaultProjectionMatrix());
          const n = e.CalculateLookAtModelView2(r2, a2, e.GetDefaultCameraZ(i2), r2, a2, 0, i2);
          e.SetModelViewMatrix(n);
        }
        GetDeviceWidth() {
          return this._canvasDeviceWidth;
        }
        GetDeviceHeight() {
          return this._canvasDeviceHeight;
        }
        GetCssWidth() {
          return this._canvasCssWidth;
        }
        GetCssHeight() {
          return this._canvasCssHeight;
        }
        GetCanvasClientX() {
          return this._canvasCssOffsetX;
        }
        GetCanvasClientY() {
          return this._canvasCssOffsetY;
        }
        GetHTMLLayerCount() {
          return this._canvasLayers.length;
        }
        _CanUseImageBitmapRenderingContext() {
          return "undefined" != typeof OffscreenCanvas && this.GetMainCanvas() instanceof OffscreenCanvas && ("Chromium" !== C33.Platform.BrowserEngine || C33.Platform.BrowserVersionNumber >= 124);
        }
        async SetHTMLLayerCount(e, t = false) {
          if (e < 1) throw new Error("invalid HTML layer count");
          if (this._canvasLayers.length === e) return;
          const s2 = { "count": e, "layersDomState": this._runtime.GetLayoutManager().GetMainRunningLayout()._GetRootLayers().filter((e2) => e2.IsHTMLElementsLayer()).map((e2) => e2._GetHTMLLayerDOMState()), "immediate": t, "marginLeft": this._canvasCssOffsetX, "marginTop": this._canvasCssOffsetY, "styleWidth": this._canvasCssWidth, "styleHeight": this._canvasCssHeight };
          let i2;
          if (i2 = this.IsInWorker() ? await this._runtime.PostComponentMessageToDOMAsync("canvas", "set-html-layer-count", s2) : self["c3_runtimeInterface"]["_OnSetHTMLLayerCount"](s2), e < this._canvasLayers.length) this._canvasLayers.length = e;
          else for (const e2 of i2["addedCanvases"]) {
            e2.width = this._canvasDeviceWidth, e2.height = this._canvasDeviceHeight;
            const t2 = this._CanUseImageBitmapRenderingContext() ? "bitmaprenderer" : "2d", s3 = e2.getContext(t2);
            if (!s3) throw new Error(`failed to acquire '${t2}' canvas context`);
            this._canvasLayers.push({ canvas: e2, ctx: s3 });
          }
          this._runtime.UpdateRender();
        }
        BlitMainCanvasToHTMLLayerCanvas(e) {
          if (e >= this._canvasLayers.length) return;
          const t = this.GetMainCanvas(), s2 = this._canvasLayers[e].ctx;
          this._CanUseImageBitmapRenderingContext() ? s2["transferFromImageBitmap"](t["transferToImageBitmap"]()) : (s2.globalCompositeOperation = "copy", s2.drawImage(t, 0, 0));
        }
        GetAdditionalRenderTarget(e) {
          e.depth = this._runtime.Uses3DFeatures();
          const t = this._availableAdditionalRenderTargets, s2 = t.findIndex((t2) => t2.IsCompatibleWithOptions(e));
          let i2;
          return -1 !== s2 ? (i2 = t[s2], t.splice(s2, 1)) : i2 = this.GetRenderer().CreateRenderTarget(e), this._usedAdditionalRenderTargets.add(i2), i2;
        }
        ReleaseAdditionalRenderTarget(e) {
          if (!this._usedAdditionalRenderTargets.has(e)) throw new Error("render target not in use");
          this._usedAdditionalRenderTargets.delete(e), this._availableAdditionalRenderTargets.push(e);
        }
        GetEffectCompositorRenderTarget() {
          const e = { sampling: this._runtime.GetSampling() };
          return "low" === this.GetCurrentFullscreenScalingQuality() && (e.width = this.GetDrawWidth(), e.height = this.GetDrawHeight()), this.GetAdditionalRenderTarget(e);
        }
        ReleaseEffectCompositorRenderTarget(e) {
          this.ReleaseAdditionalRenderTarget(e);
        }
        *activeLayersGpuProfiles() {
          for (const e of this._runtime.GetLayoutManager().runningLayouts()) for (const t of e.GetLayers()) {
            const e2 = this._layersGpuProfile.get(t);
            e2 && (yield e2);
          }
        }
        GetLayerTimingsBuffer(e) {
          if (!this.GetRenderer().SupportsGPUProfiling()) return null;
          let t = this._layersGpuProfile.get(e);
          return t || (t = { layer: e, name: e.GetName(), timingsBuffer: C33.New(C33.Gfx.WebGLQueryResultBuffer, this._webglRenderer), curUtilisation: 0, lastTotalUtilisation: 0, lastSelfUtilisation: 0 }, this._layersGpuProfile.set(e, t)), t.timingsBuffer;
        }
        _Update1sFrameRange() {
          const e = this.GetRenderer();
          if (e.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
            this._gpuTimeEndFrame = e.GetFrameNumber(), this._gpuCurUtilisation = NaN;
            for (const e2 of this.activeLayersGpuProfiles()) e2.curUtilisation = NaN;
          }
        }
        _UpdateTick() {
          this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL(), this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU();
        }
        _UpdateTick_WebGL() {
          if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), !isNaN(this._gpuCurUtilisation))) {
            if (this._runtime.IsDebug()) {
              for (const e of this.activeLayersGpuProfiles()) if (e.curUtilisation = e.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), isNaN(e.curUtilisation)) return;
            }
            if (this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1), this._runtime.IsDebug()) {
              const e = /* @__PURE__ */ new Map();
              for (const t2 of this.activeLayersGpuProfiles()) t2.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), t2.lastTotalUtilisation = Math.min(t2.curUtilisation, 1), e.set(t2.layer, t2.lastTotalUtilisation);
              for (const t2 of this.activeLayersGpuProfiles()) {
                const s3 = t2.layer, i2 = (e.get(s3) || 0) - s3.GetSubLayers().reduce((t3, s4) => t3 + (e.get(s4) || 0), 0);
                t2.lastSelfUtilisation = C33.clamp(i2, 0, 1);
              }
              const t = this._runtime.GetMainRunningLayout(), s2 = this._gpuLastUtilisation - t._GetRootLayers().reduce((t2, s3) => t2 + (e.get(s3) || 0), 0);
              self.C3Debugger.UpdateGPUProfile(C33.clamp(s2, 0, 1), this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()]);
            }
            this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;
          }
        }
        GetGPUFrameTimingsBuffer() {
          return this._gpuFrameTimingsBuffer;
        }
        _UpdateTick_WebGPU() {
          if (0 === this._gpuTimeEndFrame) return;
          for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {
            const t2 = this._webgpuFrameTimings.get(e2);
            if (t2 && !t2.HasResult()) return;
          }
          const e = this._runtime.GetMainRunningLayout(), t = C33.MakeFilledArray(e.GetLayerCount() + 1, 0);
          let s2 = 0;
          for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {
            const i2 = this._webgpuFrameTimings.get(e2);
            if (!i2) continue;
            const r2 = i2.GetResult();
            let a2 = BigInt(0), n = BigInt(0);
            const h = BigInt(0);
            for (let e3 = 0, s3 = Math.min(t.length, r2.length / 2); e3 < s3; ++e3) {
              const s4 = r2[2 * e3], i3 = r2[2 * e3 + 1];
              s4 !== h && (a2 === h || s4 < a2) && (a2 = s4), i3 > n && (n = i3);
              const o2 = Number(i3 - s4) / 1e9;
              t[e3] += o2;
            }
            s2 += Number(n - a2) / 1e9;
          }
          if (this._gpuLastUtilisation = C33.clamp(s2, 0, 1), this._runtime.IsDebug()) {
            const s3 = e.GetLayers(), i2 = /* @__PURE__ */ new Map();
            for (let e2 = 0, r3 = Math.min(s3.length, t.length - 1); e2 < r3; ++e2) {
              const r4 = t[e2 + 1];
              i2.set(s3[e2], r4);
            }
            const r2 = [], a2 = /* @__PURE__ */ new Map();
            for (const [e2, t2] of i2) {
              const s4 = [...e2.selfAndAllSubLayers()].reduce((e3, t3) => e3 + (i2.get(t3) || 0), 0);
              a2.set(e2, s4), r2.push({ name: e2.GetName(), lastSelfUtilisation: C33.clamp(t2, 0, 1), lastTotalUtilisation: C33.clamp(s4, 0, 1) });
            }
            const n = this._gpuLastUtilisation - e._GetRootLayers().reduce((e2, t2) => e2 + (a2.get(t2) || 0), 0);
            self.C3Debugger.UpdateGPUProfile(C33.clamp(n, 0, 1), this._gpuLastUtilisation, r2);
          }
          for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) this._webgpuFrameTimings.delete(e2);
          this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;
        }
        _AddWebGPUFrameTiming(e) {
          this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), e);
        }
        GetGPUUtilisation() {
          return this._gpuLastUtilisation;
        }
        SnapshotCanvas(e, t, s2, i2, r2, a2) {
          return this._snapshotFormat = e, this._snapshotQuality = t, this._snapshotArea.setWH(s2, i2, r2, a2), this._snapshotPromise || (this._snapshotPromise = new Promise((e2) => {
            this._snapshotResolve = e2;
          })), this._snapshotPromise;
        }
        _MaybeTakeSnapshot() {
          if (!this._snapshotFormat) return;
          let e = this.GetMainCanvas();
          const t = this._snapshotArea, s2 = C33.clamp(Math.floor(t.getLeft()), 0, e.width), i2 = C33.clamp(Math.floor(t.getTop()), 0, e.height);
          let r2 = t.width();
          r2 = 0 === r2 ? e.width - s2 : C33.clamp(Math.floor(r2), 0, e.width - s2);
          let a2 = t.height();
          if (a2 = 0 === a2 ? e.height - i2 : C33.clamp(Math.floor(a2), 0, e.height - i2), (0 !== s2 || 0 !== i2 || r2 !== e.width || a2 !== e.height) && r2 > 0 && a2 > 0) {
            const t2 = C33.CreateCanvas(r2, a2);
            t2.getContext("2d").drawImage(e, s2, i2, r2, a2, 0, 0, r2, a2), e = t2;
          }
          C33.CanvasToBlob(e, this._snapshotFormat, this._snapshotQuality).then((e2) => {
            this._snapshotUrl && URL.revokeObjectURL(this._snapshotUrl), this._snapshotUrl = URL.createObjectURL(e2), this._snapshotPromise = null, this._snapshotResolve(e2);
          }), this._snapshotFormat = "", this._snapshotQuality = 1;
        }
        GetCanvasSnapshotUrl() {
          return this._snapshotUrl;
        }
        SetIsPastingToDrawingCanvas(e) {
          e ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--;
        }
        IsPastingToDrawingCanvas() {
          return this._isPastingToDrawingCanvas > 0;
        }
        InitLoadingScreen(e) {
          const t = this.GetRenderer();
          if (2 === e) this._percentText = C33.New(C33.Gfx.RendererText, this.GetRenderer()), this._percentText.SetFontName("Arial"), this._percentText.SetFontSize(16), this._percentText.SetHorizontalAlignment("center"), this._percentText.SetVerticalAlignment("center"), this._percentText.SetSize(300, 200);
          else if (0 === e) {
            const e2 = this._runtime.GetLoadingLogoAsset();
            e2 && e2.LoadStaticTexture(t).catch((e3) => console.warn("[C3 runtime] Failed to create texture for loading logo: ", e3));
          } else 4 === e && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then((e2) => {
            "done" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.logo = e2;
          }).catch((e2) => console.warn("Failed to load splash image: ", e2)), this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then((e2) => {
            "done" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.powered = e2;
          }).catch((e2) => console.warn("Failed to load splash image: ", e2)), this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then((e2) => {
            "done" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.website = e2;
          }).catch((e2) => console.warn("Failed to load splash image: ", e2)));
        }
        async _LoadSvgSplashImage(e) {
          e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();
          const t = await C33.FetchBlob(e), s2 = await this._runtime.RasterSvgImage(t, 2048, 2048);
          return await this.GetRenderer().CreateStaticTextureAsync(s2, { mipMapQuality: "high" });
        }
        async _LoadBitmapSplashImage(e) {
          e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();
          const t = await C33.FetchBlob(e);
          return await this.GetRenderer().CreateStaticTextureAsync(t, { mipMapQuality: "high" });
        }
        HideCordovaSplashScreen() {
          this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash");
        }
        StartLoadingScreen() {
          this._loaderStartTime = Date.now(), this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
          3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen();
        }
        async EndLoadingScreen() {
          const e = this.GetRenderer();
          this._loadingProgress = 1;
          const t = this._runtime.GetLoaderStyle();
          4 === t && await this._splashDonePromise, this._splashDoneResolve = null, this._splashDonePromise = null, -1 !== this._rafId && (cancelAnimationFrame(this._rafId), this._rafId = -1), this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler), this._loadingprogress_handler = null, this._percentText && (this._percentText.Release(), this._percentText = null), this._runtime.ReleaseLoadingLogoAsset(), e.Start(), this._splashTextures.logo && (e.DeleteTexture(this._splashTextures.logo), this._splashTextures.logo = null), this._splashTextures.powered && (e.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered = null), this._splashTextures.website && (e.DeleteTexture(this._splashTextures.website), this._splashTextures.website = null), e.ClearRgba(0, 0, 0, 0), e.Finish(), this._splashState = "done", this._gpuTimeStartFrame = e.GetFrameNumber(), 3 === t && this.HideCordovaSplashScreen();
        }
        _DrawLoadingScreen() {
          if (-1 === this._rafId) return;
          const e = this.GetRenderer();
          e.Start(), this._rafId = -1;
          const t = this._runtime.GetAssetManager().HasHadErrorLoading(), s2 = this._runtime.GetLoaderStyle();
          if (3 !== s2 && (this.SetCssTransform(e), e.ClearRgba(0, 0, 0, 0), e.ResetColor(), e.SetTextureFillMode(), e.SetTexture(null)), 0 === s2) this._DrawProgressBarAndLogoLoadingScreen(t);
          else if (1 === s2) this._DrawProgressBarLoadingScreen(t, 120, 0);
          else if (2 === s2) this._DrawPercentTextLoadingScreen(t);
          else if (3 === s2) C33.noop();
          else {
            if (4 !== s2) throw new Error("invalid loader style");
            this._DrawSplashLoadingScreen(t);
          }
          e.Finish(), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
        }
        _DrawPercentTextLoadingScreen(e) {
          e ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(0.6, 0.6, 0.6), this._percentText.SetText(Math.round(100 * this._loadingProgress) + "%");
          const t = this._canvasCssWidth / 2, s2 = this._canvasCssHeight / 2;
          tempQuad.setRect(t - 150, s2 - 100, t + 150, s2 + 100);
          const i2 = this.GetRenderer();
          i2.SetTexture(this._percentText.GetTexture()), i2.Quad3(tempQuad, this._percentText.GetTexRect());
        }
        _DrawProgressBarLoadingScreen(e, t, s2) {
          const i2 = this.GetRenderer();
          i2.SetColorFillMode(), e ? i2.SetColorRgba(1, 0, 0, 1) : i2.SetColorRgba(0.118, 0.565, 1, 1);
          const r2 = this._canvasCssWidth / 2, a2 = this._canvasCssHeight / 2, n = t / 2;
          tempRect.setWH(r2 - n, a2 - 4 + s2, Math.floor(t * this._loadingProgress), 8), i2.Rect(tempRect), tempRect.setWH(r2 - n, a2 - 4 + s2, t, 8), tempRect.offset(-0.5, -0.5), tempRect.inflate(0.5, 0.5), i2.SetColorRgba(0, 0, 0, 1), i2.LineRect2(tempRect), tempRect.inflate(1, 1), i2.SetColorRgba(1, 1, 1, 1), i2.LineRect2(tempRect);
        }
        _DrawProgressBarAndLogoLoadingScreen(e) {
          const t = this.GetRenderer(), s2 = this._runtime.GetLoadingLogoAsset();
          if (!s2) return void this._DrawProgressBarLoadingScreen(e, 120, 0);
          const i2 = s2.GetTexture();
          if (!i2) return void this._DrawProgressBarLoadingScreen(e, 120, 0);
          const r2 = i2.GetWidth(), a2 = i2.GetHeight(), n = this._canvasCssWidth / 2, h = this._canvasCssHeight / 2, o2 = r2 / 2, l2 = a2 / 2;
          tempQuad.setRect(n - o2, h - l2, n + o2, h + l2), t.SetTexture(i2), t.Quad(tempQuad), this._DrawProgressBarLoadingScreen(e, r2, l2 + 16);
        }
        _DrawSplashLoadingScreen(e) {
          const t = this.GetRenderer(), s2 = this._splashTextures.logo, i2 = this._splashTextures.powered, r2 = this._splashTextures.website, a2 = Date.now();
          0 === this._splashFrameNumber && (this._loaderStartTime = a2);
          const n = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova(), h = n ? 0 : 200, o2 = n ? 0 : 3e3;
          let l2 = 1;
          "fade-in" === this._splashState ? l2 = Math.min((a2 - this._loaderStartTime) / 300, 1) : "fade-out" === this._splashState && (l2 = Math.max(1 - (a2 - this._splashFadeOutStartTime) / 300, 0)), t.SetColorFillMode(), t.SetColorRgba(0.231 * l2, 0.251 * l2, 0.271 * l2, l2), tempRect.set(0, 0, this._canvasCssWidth, this._canvasCssHeight), t.Rect(tempRect);
          const c2 = Math.ceil(this._canvasCssWidth), _ = Math.ceil(this._canvasCssHeight);
          let d2, u;
          this._canvasCssHeight > 256 ? (t.SetColorRgba(0.302 * l2, 0.334 * l2, 0.365 * l2, l2), d2 = c2, u = Math.max(5e-3 * _, 2), tempRect.setWH(0, 0.8 * _ - u / 2, d2, u), t.Rect(tempRect), e ? t.SetColorRgba(l2, 0, 0, l2) : t.SetColorRgba(0.161 * l2, 0.953 * l2, 0.816 * l2, l2), d2 = c2 * this._loadingProgress, tempRect.setWH(0.5 * c2 - d2 / 2, 0.8 * _ - u / 2, d2, u), t.Rect(tempRect), t.SetColorRgba(l2, l2, l2, l2), t.SetTextureFillMode(), i2 && (d2 = 1.5 * C33.clamp(0.22 * _, 105, 0.6 * c2), u = d2 / 8, tempRect.setWH(0.5 * c2 - d2 / 2, 0.2 * _ - u / 2, d2, u), t.SetTexture(i2), t.Rect(tempRect)), s2 && (d2 = Math.min(0.395 * _, 0.95 * c2), u = d2, tempRect.setWH(0.5 * c2 - d2 / 2, 0.485 * _ - u / 2, d2, u), t.SetTexture(s2), t.Rect(tempRect)), r2 && (d2 = 1.5 * C33.clamp(0.22 * _, 105, 0.6 * c2), u = d2 / 8, tempRect.setWH(0.5 * c2 - d2 / 2, 0.868 * _ - u / 2, d2, u), t.SetTexture(r2), t.Rect(tempRect))) : (t.SetColorRgba(0.302 * l2, 0.334 * l2, 0.365 * l2, l2), d2 = c2, u = Math.max(5e-3 * _, 2), tempRect.setWH(0, 0.85 * _ - u / 2, d2, u), t.Rect(tempRect), e ? t.SetColorRgba(l2, 0, 0, l2) : t.SetColorRgba(0.161 * l2, 0.953 * l2, 0.816 * l2, l2), d2 = c2 * this._loadingProgress, tempRect.setWH(0.5 * c2 - d2 / 2, 0.85 * _ - u / 2, d2, u), t.Rect(tempRect), t.SetColorRgba(l2, l2, l2, l2), t.SetTextureFillMode(), s2 && (d2 = 0.55 * _, u = d2, tempRect.setWH(0.5 * c2 - d2 / 2, 0.45 * _ - u / 2, d2, u), t.SetTexture(s2), t.Rect(tempRect))), this._splashFrameNumber++, "fade-in" === this._splashState && a2 - this._loaderStartTime >= 300 && this._splashFrameNumber >= 2 && (this._splashState = "wait", this._splashFadeInFinishTime = a2), "wait" === this._splashState && a2 - this._splashFadeInFinishTime >= o2 && this._loadingProgress >= 1 && (this._splashState = "fade-out", this._splashFadeOutStartTime = a2), ("fade-out" === this._splashState && a2 - this._splashFadeOutStartTime >= 300 + h || n && this._loadingProgress >= 1 && a2 - this._loaderStartTime < 500) && this._splashDoneResolve();
        }
      };
    }
    {
      const C33 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, ISDKBehaviorInstanceBase = self.ISDKBehaviorInstanceBase, DEFAULT_RUNTIME_OPTS = { "messagePort": null, "runtimeBaseUrl": "", "headless": false, "hasDom": true, "isInWorker": false, "useAudio": true, "exportType": "" };
      let ife = true;
      C33.Runtime = class extends C33.DefendedBase {
        constructor(e) {
          e = Object.assign({}, DEFAULT_RUNTIME_OPTS, e), super(), this._messagePort = e["messagePort"], this._runtimeBaseUrl = e["runtimeBaseUrl"], this._previewUrl = e["previewUrl"], this._isHeadless = !!e["headless"], this._hasDom = !!e["hasDom"], this._isInWorker = !!e["isInWorker"], ife = e["ife"], this._useAudio = !!e["useAudio"], this._exportType = e["exportType"], this._isNWjs = e["isNWjs"], this._isiOSCordova = !!e["isiOSCordova"], this._isiOSWebView = !!e["isiOSWebView"], this._isWindowsWebView2 = !!e["isWindowsWebView2"], this._isAnyWebView2Wrapper = !!e["isAnyWebView2Wrapper"], this._isFBInstantAvailable = !!e["isFBInstantAvailable"], this._isDebug = !("preview" !== this._exportType || !e["isDebug"]), this._breakpointsEnabled = this._isDebug, this._isDebugging = this._isDebug, this._debuggingDisabled = 0, this._additionalLoadPromises = [], this._additionalCreatePromises = [], this._isUsingCreatePromises = false, this._projectName = "", this._projectVersion = "", this._projectUniqueId = "", this._appId = "", this._exportTimestamp = 0, this._originalViewportWidth = 0, this._originalViewportHeight = 0, this._devicePixelRatio = self.devicePixelRatio, this._parallaxXorigin = 0, this._parallaxYorigin = 0, this._viewportWidth = 0, this._viewportHeight = 0, this._loaderStyle = 0, this._usesLoaderLayout = false, this._isLoading = true, this._usesAnyBackgroundBlending = false, this._usesAnyCrossSampling = false, this._usesAnyDepthSampling = false, this._loadingLogoAsset = null, this._assetManager = C33.New(C33.AssetManager, this, e), this._layoutManager = C33.New(C33.LayoutManager, this), this._eventSheetManager = C33.New(C33.EventSheetManager, this), this._addonManager = C33.New(C33.AddonManager, this, e["wrapperComponentIds"]), this._collisionEngine = C33.New(C33.CollisionEngine, this), this._timelineManager = C33.New(C33.TimelineManager, this), this._transitionManager = C33.New(C33.TransitionManager, this), this._templateManager = C33.New(C33.TemplateManager, this), this._flowchartManager = C33.New(C33.FlowchartManager, this), this._textIconManager = C33.New(C33.TextIconManager, { getIconSetMeta: (e2) => this._GetTextIconSetMeta(e2), getIconSetContent: (e2) => this._GetTextIconSetContent(e2) }), this._iconChangeHandlers = /* @__PURE__ */ new Map(), this._allObjectClasses = [], this._objectClassesByName = /* @__PURE__ */ new Map(), this._objectClassesBySid = /* @__PURE__ */ new Map(), this._familyCount = 0, this._allContainers = [], this._allEffectLists = /* @__PURE__ */ new Set(), this._currentLayoutStack = [], this._instancesPendingCreate = [], this._instancesPendingDestroy = /* @__PURE__ */ new Map(), this._hasPendingInstances = false, this._isFlushingPendingInstances = false, this._objectCount = 0, this._nextUid = 0, this._instancesByUid = /* @__PURE__ */ new Map(), this._instancesPendingRelease = /* @__PURE__ */ new Set(), this._instancesPendingReleaseAffectedObjectClasses = /* @__PURE__ */ new Set(), this._objectReferenceTable = [], this._jsPropNameTable = [], this._canvasManager = null, this._uses3dFeatures = false, this._framerateMode = "vsync", this._sampling = "trilinear", this._isPixelRoundingEnabled = false, this._needRender = true, this._pauseOnBlur = false, this._isPausedOnBlur = false, this._exportToVideo = null, this._tickCallbacks = { normal: (e2) => {
            this._rafId = -1, this._ruafId = -1, this.Tick(e2);
          }, tickOnly: (e2) => {
            this._ruafId = -1, this.Tick(e2, false, "skip-render");
          }, renderOnly: () => {
            this._rafId = -1, this.Render();
          } }, this._rafId = -1, this._ruafId = -1, this._tickCount = 0, this._tickCountNoSave = 0, this._hasStarted = false, this._isInTick = false, this._hasStartedTicking = false, this._isLayoutFirstTick = true, this._isAutoSuspendEnabled = true, this._isPageVisibilitySuspended = false, this._suspendCount = 0, this._scheduleTriggersThrottle = new C33.PromiseThrottle(1), this._randomNumberCallback = () => Math.random(), this._startTime = 0, this._lastTickTime = 0, this._dtRaw = 0, this._dt1 = 0, this._dt = 0, this._timeScale = 1, this._maxDt = 1 / 30, this._minDt = 0, this._gameTime = C33.New(C33.KahanSum), this._gameTimeRaw = C33.New(C33.KahanSum), this._wallTime = C33.New(C33.KahanSum), this._instanceTimes = /* @__PURE__ */ new Map(), this._fpsFrameCount = -1, this._fpsLastTime = 0, this._fps = 0, this._tpsTickCount = -1, this._tps = 0, this._mainThreadTimeCounter = 0, this._mainThreadTime = 0, this._isLoadingState = false, this._saveToSlotName = "", this._saveToJsonString = false, this._loadFromSlotName = "", this._loadFromJson = null, this._lastSaveJson = "", this._projectStorage = null, this._savegamesStorage = null, this._dispatcher = C33.New(C33.Event.Dispatcher), this._domEventHandlers = /* @__PURE__ */ new Map(), this._pendingResponsePromises = /* @__PURE__ */ new Map(), this._nextDomResponseId = 0, this._didRequestDeviceOrientationEvent = false, this._didRequestDeviceMotionEvent = false, this._isReadyToHandleEvents = false, this._waitingToHandleEvents = [], this._eventObjects = { "pretick": C33.New(C33.Event, "pretick", false), "tick": C33.New(C33.Event, "tick", false), "tick2": C33.New(C33.Event, "tick2", false), "instancecreate": C33.New(C33.Event, "instancecreate", false), "instancedestroy": C33.New(C33.Event, "instancedestroy", false), "beforelayoutchange": C33.New(C33.Event, "beforelayoutchange", false), "layoutchange": C33.New(C33.Event, "layoutchange", false) }, this._eventObjects["instancecreate"].instance = null, this._eventObjects["instancedestroy"].instance = null, this._userScriptDispatcher = C33.New(C33.Event.Dispatcher), this._userScriptEventObjects = null;
          const t = (e2, t2) => C33.BehaviorInstance.SortByTickSequence(this, e2, t2);
          this._behInstsToTick = C33.New(C33.RedBlackSet, t), this._behInstsToPostTick = C33.New(C33.RedBlackSet, t), this._behInstsToTick2 = C33.New(C33.RedBlackSet, t), this._jobScheduler = C33.New(C33.JobSchedulerRuntime, this, e["jobScheduler"]), e["canvas"] && (this._canvasManager = C33.New(C33.CanvasManager, this)), this._messagePort.onmessage = (e2) => this["_OnMessageFromDOM"](e2.data), this.AddDOMComponentMessageHandler("runtime", "visibilitychange", (e2) => this._OnVisibilityChange(e2)), this.AddDOMComponentMessageHandler("runtime", "wrapper-extension-message", (e2) => this._OnWrapperExtensionMessage(e2)), this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo()), this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", (e2) => this._InvokeFunctionFromJS(e2)), this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self["goToLastErrorScript"]), this.AddDOMComponentMessageHandler("runtime", "offline-audio-render-completed", (e2) => this._OnOfflineAudioRenderCompleted(e2)), this._dispatcher.addEventListener("window-blur", (e2) => this._OnWindowBlur(e2)), this._dispatcher.addEventListener("window-focus", () => this._OnWindowFocus()), this._timelineManager.AddRuntimeListeners(), this._templateManager.AddRuntimeListeners(), this._iRuntime = null, this._interfaceMap = /* @__PURE__ */ new WeakMap(), this._commonScriptInterfaces = { keyboard: null, mouse: null, touch: null, timelineController: null }, this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), this._instancesNeedingAfterLoadArray = [];
        }
        static Create(e) {
          return C33.New(C33.Runtime, e);
        }
        Release() {
          C33.clearArray(this._allObjectClasses), this._objectClassesByName.clear(), this._objectClassesBySid.clear(), this._layoutManager.Release(), this._layoutManager = null, this._eventSheetManager.Release(), this._eventSheetManager = null, this._addonManager.Release(), this._addonManager = null, this._assetManager.Release(), this._assetManager = null, this._collisionEngine.Release(), this._collisionEngine = null, this._timelineManager.Release(), this._timelineManager = null, this._transitionManager.Release(), this._transitionManager = null, this._templateManager.Release(), this._templateManager = null, this._flowchartManager.Release(), this._flowchartManager = null, this._textIconManager.Release(), this._textIconManager = null, this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null), this._dispatcher.Release(), this._dispatcher = null, this._tickEvent = null;
        }
        "_OnMessageFromDOM"(e) {
          const t = e["type"];
          if ("event" === t) this._OnEventFromDOM(e);
          else {
            if ("result" !== t) throw new Error(`unknown message '${t}'`);
            this._OnResultFromDOM(e);
          }
        }
        _OnEventFromDOM(e) {
          if (!this._isReadyToHandleEvents) return void this._waitingToHandleEvents.push(e);
          const t = e["component"], s2 = e["handler"], i2 = e["data"], n = e["dispatchOpts"], a2 = !(!n || !n["dispatchRuntimeEvent"]), r2 = !(!n || !n["dispatchUserScriptEvent"]), o2 = e["responseId"];
          if ("runtime" === t) {
            if (a2) {
              const e2 = new C33.Event(s2);
              e2.data = i2, this._dispatcher.dispatchEventAndWaitAsyncSequential(e2);
            }
            if (r2) {
              const e2 = new C33.Event(s2, true);
              for (const [t2, s3] of Object.entries(i2)) e2[t2] = s3;
              this.DispatchUserScriptEvent(e2);
            }
          }
          const h = this._domEventHandlers.get(t);
          if (!h) return void (a2 || r2 || console.warn(`[Runtime] No DOM event handlers for component '${t}'`));
          const l2 = h.get(s2);
          if (!l2) return void (a2 || r2 || console.warn(`[Runtime] No DOM handler '${s2}' for component '${t}'`));
          let c2 = null;
          try {
            c2 = l2(i2);
          } catch (e2) {
            return console.error(`Exception in '${t}' handler '${s2}':`, e2), void (null !== o2 && this._PostResultToDOM(o2, false, "" + e2));
          }
          null !== o2 && (c2 && c2.then ? c2.then((e2) => this._PostResultToDOM(o2, true, e2)).catch((e2) => {
            console.error(`Rejection from '${t}' handler '${s2}':`, e2), this._PostResultToDOM(o2, false, "" + e2);
          }) : this._PostResultToDOM(o2, true, c2));
        }
        _PostResultToDOM(e, t, s2) {
          this._messagePort.postMessage({ "type": "result", "responseId": e, "isOk": t, "result": s2 });
        }
        _OnResultFromDOM(e) {
          const t = e["responseId"], s2 = e["isOk"], i2 = e["result"], n = this._pendingResponsePromises.get(t);
          s2 ? n.resolve(i2) : n.reject(i2), this._pendingResponsePromises.delete(t);
        }
        AddDOMComponentMessageHandler(e, t, s2) {
          let i2 = this._domEventHandlers.get(e);
          if (i2 || (i2 = /* @__PURE__ */ new Map(), this._domEventHandlers.set(e, i2)), i2.has(t)) throw new Error(`[Runtime] Component '${e}' already has handler '${t}'`);
          i2.set(t, s2);
        }
        PostComponentMessageToDOM(e, t, s2, i2) {
          this._messagePort.postMessage({ "type": "event", "component": e, "handler": t, "data": s2, "responseId": null }, i2);
        }
        PostComponentMessageToDOMAsync(e, t, s2, i2) {
          const n = this._nextDomResponseId++, a2 = new Promise((e2, t2) => {
            this._pendingResponsePromises.set(n, { resolve: e2, reject: t2 });
          });
          return this._messagePort.postMessage({ "type": "event", "component": e, "handler": t, "data": s2, "responseId": n }, i2), a2;
        }
        SendWrapperExtensionMessage(e, t, s2, i2 = -1) {
          this.PostComponentMessageToDOM("runtime", "send-wrapper-extension-message", { "componentId": e, "messageId": t, "params": s2, "asyncId": i2 });
        }
        SendWrapperExtensionMessageAsync(e, t, s2) {
          const i2 = this._nextDomResponseId++, n = new Promise((e2, t2) => {
            this._pendingResponsePromises.set(i2, { resolve: e2, reject: t2 });
          });
          return this.SendWrapperExtensionMessage(e, t, s2, i2), n;
        }
        _OnWrapperExtensionMessage(e) {
          if (-1 !== e["asyncId"]) {
            const t = e["asyncId"];
            this._pendingResponsePromises.get(t).resolve(e["params"]), this._pendingResponsePromises.delete(t);
          } else this._OnEventFromDOM({ "component": "wrapper-extension:" + e["componentId"], "handler": e["messageId"], "data": e["params"], "responseId": null });
        }
        AddWrapperExtensionMessageHandler(e, t, s2) {
          this.AddDOMComponentMessageHandler("wrapper-extension:" + e, t, s2);
        }
        HasWrapperComponentId(e) {
          return this._addonManager.HasWrapperComponentId(e);
        }
        PostToDebugger(e) {
          if (!this.IsDebug()) throw new Error("not in debug mode");
          this.PostComponentMessageToDOM("runtime", "post-to-debugger", e);
        }
        async Init(e) {
          C33.CommonACES_SetRuntime(this), this.IsDebug() ? await C3Debugger.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
          const t = await this._assetManager.FetchJson("data.json");
          if (await this._LoadDataJson(t), await this._InitialiseCanvas(e), this.IsPreview() || console.info("%cMade with Construct, the game and animation creation tool. Visit: https://www.construct.net", "font-weight: bold"), this.GetWebGLRenderer()) {
            const e2 = this.GetWebGLRenderer();
            console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGL ${e2.GetWebGLVersionNumber()} [${e2.GetUnmaskedRenderer()}]`);
          } else this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGPU [${this.GetWebGPURenderer().GetAdapterInfoString()}]`);
          this.GetRenderer().HasMajorPerformanceCaveat() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance."), this._isReadyToHandleEvents = true;
          for (const e2 of this._waitingToHandleEvents) this._OnEventFromDOM(e2);
          C33.clearArray(this._waitingToHandleEvents), this._canvasManager && this._canvasManager.StartLoadingScreen();
          for (const t2 of e["runOnStartupFunctions"]) this._additionalLoadPromises.push(this._RunOnStartupFunction(t2));
          if (await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]), C33.clearArray(this._additionalLoadPromises), !this._assetManager.HasHadErrorLoading()) return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new C33.Event("beforeruntimestart")), await this.Start(), this._messagePort.postMessage({ "type": "runtime-ready" }), this;
          this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
        }
        async _RunOnStartupFunction(e) {
          try {
            await e(this._iRuntime);
          } catch (e2) {
            console.error("[C3 runtime] Error in runOnStartup function: ", e2);
          }
        }
        async _LoadDataJson(e) {
          const t = e["project"];
          this._projectName = t[0], this._projectVersion = t[16], this._projectUniqueId = t[31], this._appId = t[38], this._exportTimestamp = t[36];
          const s2 = t[39] || "loading-logo.png";
          this._isPixelRoundingEnabled = !!t[9], this._originalViewportWidth = this._viewportWidth = t[10], this._originalViewportHeight = this._viewportHeight = t[11], this._collisionEngine._InitCollisionCellSize(this._originalViewportWidth, this._originalViewportHeight), this._parallaxXorigin = this._originalViewportWidth / 2, this._parallaxYorigin = this._originalViewportHeight / 2, this._framerateMode = t[37], this._uses3dFeatures = !!t[40], this._sampling = t[14], this._usesAnyBackgroundBlending = t[15], this._usesAnyCrossSampling = t[42], this._usesAnyDepthSampling = t[17], this._usesLoaderLayout = !!t[18], this._loaderStyle = t[19], this._nextUid = t[21], this._pauseOnBlur = t[22];
          const i2 = this._assetManager;
          if (i2._SetFileStructure(t[45]), i2._SetAudioFiles(t[7], t[25]), i2._SetMediaSubfolder(t[8]), i2._SetFontsSubfolder(t[32]), i2._SetIconsSubfolder(t[28]), i2._SetWebFonts(t[29]), 0 === this._loaderStyle) {
            let e2 = "";
            e2 = "flat" === i2.GetFileStructure() ? i2.GetIconsSubfolder() + s2 : s2, e2 && (this._loadingLogoAsset = i2.LoadImage({ url: e2 }));
          }
          this._canvasManager && (this._canvasManager.SetFullscreenMode(C33.CanvasManager._FullscreenModeNumberToString(t[12])), this._canvasManager.SetFullscreenScalingQuality(t[23] ? "high" : "low"), this._canvasManager.SetMipmapsEnabled(0 !== t[24]), this._canvasManager._SetGPUPowerPreference(t[34]), this._canvasManager._SetTextureAnisotropy(t[41]), this._canvasManager._SetWebGPUEnabled(t[13]), this._canvasManager._SetZAxisScale(t[30]), this._canvasManager._SetZDistances(t[46], t[47]), this._canvasManager._SetInitFieldOfView(t[26]), this._canvasManager._SetLimitedToWebGL1(t[48]), this._canvasManager._SetMultitexturingMode(t[50]));
          const n = t[43];
          n && await this._LoadExportToVideoData(n), this._InitScriptInterfaces(), this._addonManager.CreateSystemPlugin(), this._objectReferenceTable = self.C3_GetObjectRefTable();
          const a2 = t[2];
          for (const e2 of a2[1]) this._addonManager.CreateBehavior(e2);
          for (const e2 of a2[0]) this._addonManager.CreatePlugin(e2);
          this._objectReferenceTable = self.C3_GetObjectRefTable(), this._LoadJsPropNameTable(), this._addonManager._InitAddonScriptInterfaces();
          for (const e2 of t[3]) {
            const t2 = C33.ObjectClass.Create(this, this._allObjectClasses.length, e2);
            this._allObjectClasses.push(t2), this._objectClassesByName.set(t2.GetName().toLowerCase(), t2), this._objectClassesBySid.set(t2.GetSID(), t2);
          }
          for (const e2 of t[4]) {
            this._allObjectClasses[e2[0]]._LoadFamily(e2);
          }
          for (const e2 of t[27]) {
            const t2 = e2.map((e3) => this._allObjectClasses[e3]);
            this._allContainers.push(C33.New(C33.Container, this, t2));
          }
          this._InitObjectsScriptInterface();
          for (const e2 of this._allObjectClasses) e2._OnAfterCreate();
          for (const e2 of t[5]) this._layoutManager.Create(e2);
          const r2 = t[1];
          if (r2) {
            const e2 = this._layoutManager.GetLayoutByName(r2);
            e2 && this._layoutManager.SetFirstLayout(e2);
          }
          for (const e2 of t[35]) this._transitionManager.Create(e2);
          for (const e2 of t[33]) this._timelineManager.Create(e2);
          for (const e2 of t[44]) this._templateManager.Create(e2);
          this._templateManager.HasTemplates() || (this._templateManager.Release(), this._templateManager = null);
          for (const e2 of t[49]) this._flowchartManager.Create(e2);
          this._flowchartManager.HasFlowcharts() || (this._flowchartManager.Release(), this._flowchartManager = null);
          for (const e2 of t[6]) this._eventSheetManager.Create(e2);
          this._eventSheetManager._PostInit(), this._InitGlobalVariableScriptInterface(), C33.clearArray(this._objectReferenceTable), this.FlushPendingInstances();
          let o2 = "any";
          const h = t[20];
          1 === h ? o2 = "portrait" : 2 === h && (o2 = "landscape"), this.PostComponentMessageToDOM("runtime", "set-target-orientation", { "targetOrientation": o2 });
        }
        async _LoadExportToVideoData(e) {
          const t = e["format"];
          "image-sequence" === t ? this._exportToVideo = new self.C3ExportToImageSequence(this, e) : "image-sequence-gif" === t ? this._exportToVideo = new self.C3ExportToGIF(this, e) : "webm" === t ? this._exportToVideo = new self.C3ExportToWebMVideo(this, e) : "mp4" === t && (this._exportToVideo = new self.C3ExportToMP4Video(this, e)), this._framerateMode = "unlimited-frame", this._canvasManager.SetFullscreenMode("off"), this._devicePixelRatio = 1, self.devicePixelRatio = 1, await this.PostComponentMessageToDOMAsync("runtime", "set-exporting-to-video", { "message": this._exportToVideo.GetExportingMessageForPercent(0), "duration": this._exportToVideo.GetDuration() });
        }
        GetLoaderStyle() {
          return this._loaderStyle;
        }
        IsExportToVideo() {
          return null !== this._exportToVideo;
        }
        GetExportVideoDuration() {
          return this._exportToVideo.GetDuration();
        }
        GetExportVideoFramerate() {
          return this._exportToVideo.GetFramerate();
        }
        _InitExportToVideo() {
          return this._exportToVideo.Init({ width: this._canvasManager.GetDeviceWidth(), height: this._canvasManager.GetDeviceHeight() });
        }
        _ExportToVideoAddFrame() {
          const e = this._tickCount / this.GetExportVideoFramerate();
          return this._exportToVideo.AddFrame(this._canvasManager.GetMainCanvas(), e);
        }
        _ExportToVideoAddKeyframe() {
          this._exportToVideo && this._exportToVideo.AddKeyframe();
        }
        _OnOfflineAudioRenderCompleted(e) {
          this._exportToVideo.OnOfflineAudioRenderCompleted(e);
        }
        _ExportToVideoFinish() {
          return this._exportToVideo.Finish();
        }
        IsFBInstantAvailable() {
          return this._isFBInstantAvailable;
        }
        IsLoading() {
          return this._isLoading;
        }
        AddLoadPromise(e) {
          this._additionalLoadPromises.push(e);
        }
        SetUsingCreatePromises(e) {
          this._isUsingCreatePromises = !!e;
        }
        AddCreatePromise(e) {
          this._isUsingCreatePromises && this._additionalCreatePromises.push(e);
        }
        GetCreatePromises() {
          return this._additionalCreatePromises;
        }
        _GetNextFamilyIndex() {
          return this._familyCount++;
        }
        GetFamilyCount() {
          return this._familyCount;
        }
        _AddEffectList(e) {
          this._allEffectLists.add(e);
        }
        _RemoveEffectList(e) {
          this._allEffectLists.delete(e);
        }
        _GetAllEffectLists() {
          return this._allEffectLists;
        }
        async _InitialiseCanvas(e) {
          this._canvasManager && (await this._canvasManager.CreateCanvas(e), this._canvasManager.InitLoadingScreen(this._loaderStyle));
        }
        async Start() {
          this._hasStarted = true, this._startTime = Date.now();
          let e = null;
          const t = new Promise((t2) => e = t2);
          if (this._usesLoaderLayout) {
            for (const e2 of this._allObjectClasses) e2.IsFamily() || e2.IsOnLoaderLayout() || !e2.IsWorldType() || e2.OnCreate();
            (async () => {
              await this._assetManager.WaitForAllToLoad(), await t, this._isLoading = false, this._OnLoadFinished();
            })();
          } else this._isLoading = false;
          this._assetManager.SetInitialLoadFinished(), this.IsDebug() && C3Debugger.RuntimeInit(ife);
          for (const e2 of this._layoutManager.GetAllLayouts()) e2._CreateGlobalNonWorlds();
          this.IsExportToVideo() && await this._InitExportToVideo();
          const s2 = this._layoutManager.GetFirstLayout();
          await s2._Load(null, this.GetRenderer()), await s2._StartRunning(true), this._fpsLastTime = performance.now(), e(), this._usesLoaderLayout || this._OnLoadFinished();
          (await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking"))["isSuspended"] && !this.IsExportToVideo() ? (this._suspendCount++, this._isPageVisibilitySuspended = true) : this.Tick();
        }
        _OnLoadFinished() {
          this.Trigger(C33.Plugins.System.Cnds.OnLoadFinished, null, null), this.PostComponentMessageToDOM("runtime", "register-sw");
        }
        GetObjectReference(e) {
          e = Math.floor(e);
          const t = this._objectReferenceTable;
          if (e < 0 || e >= t.length) throw new Error("invalid object reference");
          return t[e];
        }
        _LoadJsPropNameTable() {
          for (const e of self.C3_JsPropNameTable) {
            const t = C33.first(Object.keys(e));
            this._jsPropNameTable.push(t);
          }
        }
        GetJsPropName(e) {
          e = Math.floor(e);
          const t = this._jsPropNameTable;
          if (e < 0 || e >= t.length) throw new Error("invalid prop reference");
          return t[e];
        }
        HasDOM() {
          return this._hasDom;
        }
        IsHeadless() {
          return this._isHeadless;
        }
        IsInWorker() {
          return this._isInWorker;
        }
        GetRuntimeBaseURL() {
          return this._runtimeBaseUrl;
        }
        GetPreviewURL() {
          return this._previewUrl;
        }
        GetEventSheetManager() {
          return this._eventSheetManager;
        }
        GetEventStack() {
          return this._eventSheetManager.GetEventStack();
        }
        GetCurrentEventStackFrame() {
          return this._eventSheetManager.GetCurrentEventStackFrame();
        }
        GetCurrentEvent() {
          return this._eventSheetManager.GetCurrentEvent();
        }
        GetCurrentCondition() {
          return this._eventSheetManager.GetCurrentCondition();
        }
        IsCurrentConditionFirst() {
          return 0 === this.GetCurrentEventStackFrame().GetConditionIndex();
        }
        GetCurrentAction() {
          return this._eventSheetManager.GetCurrentAction();
        }
        GetAddonManager() {
          return this._addonManager;
        }
        GetSystemPlugin() {
          return this._addonManager.GetSystemPlugin();
        }
        GetObjectClassByIndex(e) {
          if ((e = Math.floor(e)) < 0 || e >= this._allObjectClasses.length) throw new RangeError("invalid index");
          return this._allObjectClasses[e];
        }
        GetObjectClassByName(e) {
          return this._objectClassesByName.get(e.toLowerCase()) || null;
        }
        GetObjectClassBySID(e) {
          return this._objectClassesBySid.get(e) || null;
        }
        GetSingleGlobalObjectClassByCtor(e) {
          const t = C33.AddonManager.GetPluginByConstructorFunction(e);
          return t ? t.GetSingleGlobalObjectClass() : null;
        }
        GetAllObjectClasses() {
          return this._allObjectClasses;
        }
        *allInstances() {
          for (const e of this._allObjectClasses) e.IsFamily() || (yield* e.instances());
        }
        Dispatcher() {
          return this._dispatcher;
        }
        UserScriptDispatcher() {
          return this._userScriptDispatcher;
        }
        DispatchUserScriptEvent(e) {
          e.runtime = this.GetIRuntime();
          const t = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
          t && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), t && C3Debugger.AddScriptTime();
        }
        DispatchUserScriptEventAsyncWait(e) {
          return e.runtime = this.GetIRuntime(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);
        }
        GetOriginalViewportWidth() {
          return this._originalViewportWidth;
        }
        GetOriginalViewportHeight() {
          return this._originalViewportHeight;
        }
        SetOriginalViewportSize(e, t) {
          if (this._originalViewportWidth === e && this._originalViewportHeight === t) return;
          this._originalViewportWidth = e, this._originalViewportHeight = t;
          const s2 = this.GetLayoutManager();
          s2.SetAllLayerProjectionChanged(), s2.SetAllLayerMVChanged();
        }
        GetViewportWidth() {
          return this._viewportWidth;
        }
        GetViewportHeight() {
          return this._viewportHeight;
        }
        SetViewportSize(e, t) {
          if (this._viewportWidth === e && this._viewportHeight === t) return;
          this._viewportWidth = e, this._viewportHeight = t;
          const s2 = this.GetLayoutManager();
          s2.SetAllLayerProjectionChanged(), s2.SetAllLayerMVChanged();
        }
        _SetDevicePixelRatio(e) {
          this.IsExportToVideo() || (this._devicePixelRatio = e);
        }
        GetDevicePixelRatio() {
          return this._devicePixelRatio;
        }
        GetParallaxXOrigin() {
          return this._parallaxXorigin;
        }
        GetParallaxYOrigin() {
          return this._parallaxYorigin;
        }
        GetCanvasManager() {
          return this._canvasManager;
        }
        GetDrawWidth() {
          return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth;
        }
        GetDrawHeight() {
          return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight;
        }
        GetRenderScale() {
          return this._canvasManager ? this._canvasManager.GetRenderScale() : 1;
        }
        GetDisplayScale() {
          return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1;
        }
        GetEffectLayerScaleParam() {
          return this._canvasManager ? this._canvasManager.GetEffectLayerScaleParam() : 1;
        }
        GetEffectDevicePixelRatioParam() {
          return this._canvasManager ? this._canvasManager.GetEffectDevicePixelRatioParam() : 1;
        }
        GetCanvasClientX() {
          return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0;
        }
        GetCanvasClientY() {
          return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0;
        }
        GetCanvasCssWidth() {
          return this._canvasManager ? this._canvasManager.GetCssWidth() : 0;
        }
        GetCanvasCssHeight() {
          return this._canvasManager ? this._canvasManager.GetCssHeight() : 0;
        }
        GetFullscreenMode() {
          return this._canvasManager ? this._canvasManager.GetFullscreenMode() : "off";
        }
        GetAdditionalRenderTarget(e) {
          return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(e) : null;
        }
        ReleaseAdditionalRenderTarget(e) {
          this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(e);
        }
        UsesAnyBackgroundBlending() {
          return this._usesAnyBackgroundBlending;
        }
        UsesAnyCrossSampling() {
          return this._usesAnyCrossSampling;
        }
        UsesAnyDepthSampling() {
          return this._usesAnyDepthSampling;
        }
        GetGPUUtilisation() {
          return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN;
        }
        IsLinearSampling() {
          return "nearest" !== this.GetSampling();
        }
        GetFramerateMode() {
          return this._framerateMode;
        }
        _SetFramerateMode(e) {
          this._framerateMode !== e && (this._framerateMode = e, -1 === this._rafId && -1 === this._ruafId || (this._CancelAnimationFrame(), this._RequestAnimationFrame()));
        }
        GetSampling() {
          return this._sampling;
        }
        UsesLoaderLayout() {
          return this._usesLoaderLayout;
        }
        GetLoadingLogoAsset() {
          return this._loadingLogoAsset;
        }
        ReleaseLoadingLogoAsset() {
          this._loadingLogoAsset && (this._loadingLogoAsset.ReleaseTexture(), this._loadingLogoAsset.Release(), this._loadingLogoAsset = null);
        }
        GetLayoutManager() {
          return this._layoutManager;
        }
        GetMainRunningLayout() {
          return this._layoutManager.GetMainRunningLayout();
        }
        GetTimelineManager() {
          return this._timelineManager;
        }
        GetTransitionManager() {
          return this._transitionManager;
        }
        GetTemplateManager() {
          return this._templateManager;
        }
        GetFlowchartManager() {
          return this._flowchartManager;
        }
        GetAssetManager() {
          return this._assetManager;
        }
        LoadImage(e) {
          return this._assetManager.LoadImage(e);
        }
        CreateInstance(e, t, s2, i2, n, a2) {
          if (a2 && this._templateManager) {
            if (e instanceof C33.ObjectClass && e.IsFamily()) {
              const r3 = e.GetFamilyMembers(), o2 = Math.floor(this.Random() * r3.length);
              return this.CreateInstance(r3[o2], t, s2, i2, n, a2);
            }
            const r2 = this._templateManager.GetTemplateData(e, a2);
            if (r2) {
              const e2 = this.CreateInstanceFromData(r2, t, false, s2, i2, false, n, void 0, n);
              return this._templateManager.MapInstanceToTemplateName(e2, a2), e2;
            }
          }
          return this.CreateInstanceFromData(e, t, false, s2, i2, false, n, void 0, n);
        }
        CreateInstanceFromData(e, t, s2, i2, n, a2, r2, o2, h) {
          let l2 = null, c2 = null;
          if (e instanceof C33.ObjectClass) {
            if (c2 = e, c2.IsFamily()) {
              const e2 = c2.GetFamilyMembers();
              c2 = e2[Math.floor(this.Random() * e2.length)];
            }
            l2 = c2.GetDefaultInstanceData();
          } else l2 = e, c2 = this.GetObjectClassByIndex(l2[1]);
          const d2 = c2.GetPlugin().IsWorldType();
          if (this._isLoading && d2 && !c2.IsOnLoaderLayout()) return null;
          const _ = t;
          let u;
          d2 || (t = null), u = s2 && !a2 && l2 && !this._instancesByUid.has(l2[2]) ? l2[2] : this._nextUid++;
          const g = l2 ? l2[0] : null, m = C33.New(C33.Instance, { runtime: this, objectType: c2, layer: t, worldData: g, instVarData: l2 ? l2[3] : null, uid: u, tags: l2 ? l2[6] : null });
          this._instancesByUid.set(u, m);
          let p = null;
          if (d2 && (p = m.GetWorldInfo(), void 0 !== i2 && void 0 !== n && (p.SetX(i2), p.SetY(n)), c2._SetAnyCollisionCellChanged(true)), t && (h || t._AddInstance(m, true), t.GetLayout().MaybeLoadTexturesFor(c2)), this._objectCount++, c2.IsInContainer() && !s2 && !a2) {
            const e2 = /* @__PURE__ */ new Set();
            for (const t2 of c2.GetContainer().objectTypes()) {
              if (t2 === c2) continue;
              const s3 = this._MaybeGetChildInstanceForObjectTypeData(t2, p, e2);
              if (s3) {
                const e3 = this.CreateInstanceFromData(s3, _, false, p ? p.GetX() : i2, p ? p.GetY() : n, true, false, void 0, h);
                m._AddSibling(e3);
              } else {
                const e3 = this.CreateInstanceFromData(t2, _, false, p ? p.GetX() : i2, p ? p.GetY() : n, true, false, void 0, h);
                m._AddSibling(e3);
              }
            }
            for (const e3 of m.siblings()) {
              e3._AddSibling(m);
              for (const t2 of m.siblings()) e3 !== t2 && e3._AddSibling(t2);
            }
          }
          if (d2 && !s2 && r2 && this._CreateChildInstancesFromData(m, g, p, t, i2, n, h), c2.IsInContainer() && !s2 && !a2 && r2) for (const e2 of m.siblings()) {
            const s3 = e2.GetWorldInfo();
            if (!s3) continue;
            const i3 = e2.GetPlugin(), n2 = e2.GetObjectClass().GetDefaultInstanceData()[0];
            i3.IsWorldType() ? this._CreateChildInstancesFromData(e2, n2, s3, t, s3.GetX(), s3.GetY(), h) : this._CreateChildInstancesFromData(e2, n2, s3, t, void 0, void 0, h);
          }
          if (!a2 && r2) {
            void 0 === i2 && (i2 = g[0]), void 0 === n && (n = g[1]);
            const e2 = p.GetTopParent(), t2 = i2 - p.GetX() + e2.GetX(), s3 = n - p.GetY() + e2.GetY();
            e2.SetXY(t2, s3);
          }
          c2._SetIIDsStale();
          const f2 = l2 ? C33.cloneArray(l2[5]) : null, C = l2 ? l2[4].map((e2) => C33.cloneArray(e2)) : null, S = d2 && g && g[13];
          if (S && m._SetHasTilemap(), m._CreateSdkInstance(f2, C), S) {
            const e2 = g[13];
            m.GetSdkInstance().LoadTilemapData(e2[2], e2[0], e2[1]);
          }
          this._instancesPendingCreate.push(m), this._hasPendingInstances = true, this.IsDebug() && C3Debugger.InstanceCreated(m);
          const I = this._eventObjects["instancecreate"];
          return I.instance = m, this._dispatcher.dispatchEvent(I), m;
        }
        _GetInstanceData(e) {
          const t = e[0], s2 = e[1], i2 = e[2], n = e[6];
          if (n) return n;
          return this._layoutManager.GetLayoutBySID(t).GetLayer(s2).GetInitialInstanceData(i2);
        }
        _MaybeGetChildInstanceForObjectTypeData(e, t, s2) {
          const i2 = t?.GetSceneGraphChildrenExportData() ?? [];
          for (const t2 of i2) {
            const i3 = this._GetInstanceData(t2), n = !!t2[4], a2 = this.GetObjectClassByIndex(i3[1]);
            if (!s2.has(i3) && (e === a2 && n)) return s2.add(i3), i3;
          }
        }
        _CreateChildInstancesFromData(e, t, s2, i2, n, a2, r2) {
          const o2 = s2.GetSceneGraphZIndexExportData(), h = s2.GetSceneGraphChildrenExportData();
          if (e.GetWorldInfo().SetSceneGraphZIndex(o2), !h) return;
          void 0 === n && (n = t[0]), void 0 === a2 && (a2 = t[1]);
          const l2 = /* @__PURE__ */ new Set(), c2 = t[0], d2 = t[1];
          for (const t2 of h) {
            const s3 = t2[0], o3 = t2[1], h2 = t2[2], _ = t2[3], u = !!t2[4], g = t2[5], m = t2[6];
            let p;
            if (m) p = m;
            else {
              p = this._layoutManager.GetLayoutBySID(s3).GetLayer(o3).GetInitialInstanceData(h2);
            }
            const f2 = this.GetObjectClassByIndex(p[1]), C = e.HasSibling(f2), S = l2.has(f2);
            if (C && !S && u) {
              const t3 = e.GetSibling(f2);
              t3.GetWorldInfo().Init(p[0]);
              const s4 = n + p[0][0] - c2, i3 = a2 + p[0][1] - d2;
              t3.GetWorldInfo().SetXY(s4, i3), t3.GetWorldInfo().SetSceneGraphZIndex(g), e.AddChild(t3, { transformX: !!(1 & _), transformY: !!(_ >> 1 & 1), transformWidth: !!(_ >> 2 & 1), transformHeight: !!(_ >> 3 & 1), transformAngle: !!(_ >> 4 & 1), destroyWithParent: !!(_ >> 5 & 1), transformZElevation: !!(_ >> 6 & 1), transformOpacity: !!(_ >> 7 & 1), transformVisibility: !!(_ >> 8 & 1) }), l2.add(f2);
            } else {
              const t3 = n + p[0][0] - c2, s4 = a2 + p[0][1] - d2, o4 = this.CreateInstanceFromData(p, i2, false, t3, s4, false, true, e, r2);
              o4.GetWorldInfo().SetSceneGraphZIndex(g), e.AddChild(o4, { transformX: !!(1 & _), transformY: !!(_ >> 1 & 1), transformWidth: !!(_ >> 2 & 1), transformHeight: !!(_ >> 3 & 1), transformAngle: !!(_ >> 4 & 1), destroyWithParent: !!(_ >> 5 & 1), transformZElevation: !!(_ >> 6 & 1), transformOpacity: !!(_ >> 7 & 1), transformVisibility: !!(_ >> 8 & 1) });
            }
          }
        }
        DestroyInstance(e) {
          if (this._instancesPendingRelease.has(e)) return;
          const t = e.GetObjectClass();
          let s2 = this._instancesPendingDestroy.get(t);
          if (s2) {
            if (s2.has(e)) return;
            s2.add(e);
          } else s2 = /* @__PURE__ */ new Set(), s2.add(e), this._instancesPendingDestroy.set(t, s2);
          if (this.IsDebug() && C3Debugger.InstanceDestroyed(e), e._MarkDestroyed(), this._hasPendingInstances = true, e.IsInContainer()) for (const t2 of e.siblings()) this.DestroyInstance(t2);
          for (const t2 of e.children()) t2.GetDestroyWithParent() && this.DestroyInstance(t2);
          if (!this._layoutManager.IsEndingLayout() && !this._isLoadingState) {
            const t2 = this.GetEventSheetManager();
            t2.BlockFlushingInstances(true), e._TriggerOnDestroyed(), t2.BlockFlushingInstances(false);
          }
          e._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout());
        }
        FlushPendingInstances() {
          this._hasPendingInstances && (this._isFlushingPendingInstances = true, this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), this._isFlushingPendingInstances = false, this._hasPendingInstances = false, this.UpdateRender());
        }
        _FlushInstancesPendingCreate() {
          for (const e of this._instancesPendingCreate) {
            const t = e.GetObjectClass();
            t._AddInstance(e);
            for (const s2 of t.GetFamilies()) s2._AddInstance(e), s2._SetIIDsStale();
          }
          C33.clearArray(this._instancesPendingCreate);
        }
        _FlushInstancesPendingDestroy() {
          this._dispatcher.SetDelayRemoveEventsEnabled(true);
          for (const [e, t] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(e, t), t.clear();
          this._instancesPendingDestroy.clear(), this._dispatcher.SetDelayRemoveEventsEnabled(false);
        }
        _FlushInstancesPendingDestroyForObjectClass(e, t) {
          for (const e2 of t) {
            const t2 = this._eventObjects["instancedestroy"];
            t2.instance = e2, this._dispatcher.dispatchEvent(t2), this._instancesByUid.delete(e2.GetUID()), this._instanceTimes.delete(e2);
            const s2 = e2.GetWorldInfo();
            s2 && (s2._RemoveFromCollisionCells(), s2._RemoveFromRenderCells(), s2._MarkDestroyed()), this._instancesPendingRelease.add(e2), this._objectCount--;
          }
          C33.arrayRemoveAllInSet(e.GetInstances(), t), e._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(e);
          for (const s2 of e.GetFamilies()) C33.arrayRemoveAllInSet(s2.GetInstances(), t), s2._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(s2);
          if (e.GetPlugin().IsWorldType()) {
            const e2 = new Set([...t].map((e3) => e3.GetWorldInfo().GetLayer()));
            for (const s2 of e2) s2._RemoveAllInstancesInSet(t);
          }
        }
        _GetInstancesPendingCreate() {
          return this._instancesPendingCreate;
        }
        *instancesPendingCreateForObjectClass(e) {
          for (const t of this._GetInstancesPendingCreate()) e.IsFamily() ? t.GetObjectClass().BelongsToFamily(e) && (yield t) : t.GetObjectClass() === e && (yield t);
        }
        _GetNewUID() {
          return this._nextUid++;
        }
        _MapInstanceByUID(e, t) {
          this._instancesByUid.set(e, t);
        }
        _SetAutoSuspendEnabled(e) {
          e = !!e, this._isAutoSuspendEnabled !== e && (this._isAutoSuspendEnabled = !!e, this._isAutoSuspendEnabled && this._isPageVisibilitySuspended && (this.SetSuspended(false), this._isPageVisibilitySuspended = false));
        }
        _IsAutoSuspendEnabled() {
          return this._isAutoSuspendEnabled;
        }
        _OnRendererContextLost() {
          this._dispatcher.dispatchEvent(C33.New(C33.Event, "renderercontextlost")), this.SetSuspended(true);
          for (const e2 of this._allObjectClasses) !e2.IsFamily() && e2.HasLoadedTextures() && e2.ReleaseTextures();
          const e = this.GetMainRunningLayout();
          e && e._OnRendererContextLost(), C33.ImageInfo.OnRendererContextLost(), C33.ImageAsset.OnRendererContextLost();
        }
        async _OnRendererContextRestored() {
          await this.GetMainRunningLayout()._Load(null, this.GetRenderer()), this._dispatcher.dispatchEvent(C33.New(C33.Event, "renderercontextrestored")), this.SetSuspended(false), this.UpdateRender();
        }
        _OnVisibilityChange(e) {
          if (!this._isAutoSuspendEnabled) return;
          const t = e["hidden"];
          this.SetSuspended(t), this._isPageVisibilitySuspended = t, t || this.UpdateRender();
        }
        _OnWindowBlur(e) {
          this.IsPreview() && this._pauseOnBlur && !C33.Platform.IsMobile && (e.data["parentHasFocus"] || (this.SetSuspended(true), this._isPausedOnBlur = true));
        }
        _OnWindowFocus() {
          this._isPausedOnBlur && (this.SetSuspended(false), this._isPausedOnBlur = false);
        }
        _RequestAnimationFrame() {
          const e = this._tickCallbacks;
          "vsync" === this._framerateMode ? -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.normal)) : "unlimited-tick" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = C33.RequestUnlimitedAnimationFrame(e.tickOnly)), -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.renderOnly))) : -1 === this._ruafId && (this._ruafId = C33.RequestUnlimitedAnimationFrame(e.normal));
        }
        _CancelAnimationFrame() {
          -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId), this._rafId = -1), -1 !== this._ruafId && (C33.CancelUnlimitedAnimationFrame(this._ruafId), this._ruafId = -1);
        }
        IsSuspended() {
          return this._suspendCount > 0;
        }
        SetSuspended(e) {
          if (this.IsExportToVideo()) return;
          const t = this.IsSuspended();
          this._suspendCount += e ? 1 : -1, this._suspendCount < 0 && (this._suspendCount = 0);
          const s2 = this.IsSuspended();
          if (!t && s2) console.log("[Construct] Suspending"), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(C33.New(C33.Event, "suspend")), this.DispatchUserScriptEvent(C33.New(C33.Event, "suspend")), this.Trigger(C33.Plugins.System.Cnds.OnSuspend, null, null);
          else if (t && !s2) {
            console.log("[Construct] Resuming");
            const e2 = performance.now();
            this._lastTickTime = e2, this._fpsLastTime = e2, this._fpsFrameCount = 0, this._fps = 0, this._tpsTickCount = 0, this._tps = 0, this._mainThreadTime = 0, this._mainThreadTimeCounter = 0, this._dispatcher.dispatchEvent(C33.New(C33.Event, "resume")), this.DispatchUserScriptEvent(C33.New(C33.Event, "resume")), this.Trigger(C33.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(e2);
          }
        }
        _AddBehInstToTick(e) {
          this._behInstsToTick.Add(e);
        }
        _AddBehInstToPostTick(e) {
          this._behInstsToPostTick.Add(e);
        }
        _AddBehInstToTick2(e) {
          this._behInstsToTick2.Add(e);
        }
        _RemoveBehInstToTick(e) {
          this._behInstsToTick.Remove(e);
        }
        _RemoveBehInstToPostTick(e) {
          this._behInstsToPostTick.Remove(e);
        }
        _RemoveBehInstToTick2(e) {
          this._behInstsToTick2.Remove(e);
        }
        _CallBehaviorTickMethod(e, t) {
          const s2 = t ? performance.now() : 0;
          let i2;
          return e instanceof ISDKBehaviorInstanceBase ? (i2 = e._tick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s2)) : (i2 = e.Tick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s2)), i2;
        }
        _BehaviorTick() {
          const e = this.IsDebug();
          this._behInstsToTick.SetQueueingEnabled(true);
          for (const t of this._behInstsToTick) this._CallBehaviorTickMethod(t, e);
          this._behInstsToTick.SetQueueingEnabled(false);
        }
        _CallBehaviorPostTickMethod(e, t) {
          const s2 = t ? performance.now() : 0;
          let i2;
          return e instanceof ISDKBehaviorInstanceBase ? (i2 = e._postTick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s2)) : (i2 = e.PostTick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s2)), i2;
        }
        _BehaviorPostTick() {
          const e = this.IsDebug();
          this._behInstsToPostTick.SetQueueingEnabled(true);
          for (const t of this._behInstsToPostTick) this._CallBehaviorPostTickMethod(t, e);
          this._behInstsToPostTick.SetQueueingEnabled(false);
        }
        _CallBehaviorTick2Method(e, t) {
          const s2 = t ? performance.now() : 0;
          let i2;
          return e instanceof ISDKBehaviorInstanceBase ? (i2 = e._tick2(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s2)) : (i2 = e.Tick2(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s2)), i2;
        }
        _BehaviorTick2() {
          const e = this.IsDebug();
          this._behInstsToTick2.SetQueueingEnabled(true);
          for (const t of this._behInstsToTick2) this._CallBehaviorTick2Method(t, e);
          this._behInstsToTick2.SetQueueingEnabled(false);
        }
        *_DebugBehaviorTick() {
          const e = this.IsDebug();
          this._behInstsToTick.SetQueueingEnabled(true);
          for (const t of this._behInstsToTick) {
            const s2 = this._CallBehaviorTickMethod(t, e);
            C33.IsIterator(s2) && (yield* s2);
          }
          this._behInstsToTick.SetQueueingEnabled(false);
        }
        *_DebugBehaviorPostTick() {
          const e = this.IsDebug();
          this._behInstsToPostTick.SetQueueingEnabled(true);
          for (const t of this._behInstsToPostTick) {
            const s2 = this._CallBehaviorPostTickMethod(t, e);
            C33.IsIterator(s2) && (yield* s2);
          }
          this._behInstsToPostTick.SetQueueingEnabled(false);
        }
        *_DebugBehaviorTick2() {
          const e = this.IsDebug();
          this._behInstsToTick2.SetQueueingEnabled(true);
          for (const t of this._behInstsToTick2) {
            const s2 = this._CallBehaviorTick2Method(t, e);
            C33.IsIterator(s2) && (yield* s2);
          }
          this._behInstsToTick2.SetQueueingEnabled(false);
        }
        async Tick(e, t, s2) {
          this._hasStartedTicking = true;
          const i2 = "background-wake" === s2, n = "background-wake" !== s2 && "skip-render" !== s2, a2 = this.GetLayoutManager(), r2 = this.GetCanvasManager();
          if (!this._hasStarted || this.IsSuspended() && !t && !i2) return;
          const o2 = performance.now();
          this._isInTick = true, this._MeasureDt(e || 0), this._tpsTickCount++, this._ReleasePendingInstances();
          const h = this.Step_BeforePreTick();
          this.IsDebugging() && await h;
          const l2 = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects["pretick"]);
          l2 instanceof Promise && await l2, this.DispatchUserScriptEvent(this._userScriptEventObjects["pretick"]);
          const c2 = this.Step_AfterPreTick();
          this.IsDebugging() && await c2, this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad(), a2.IsPendingChangeMainLayout() && await this._MaybeChangeLayout();
          const d2 = this.Step_RunEventsEtc();
          this.IsDebugging() && await d2;
          const _ = a2.GetMainRunningLayout(), u = _._GetPendingSetHTMLLayerCount();
          let g = false;
          if (-1 !== u && (_._ResetPendingHTMLLayerCount(), r2.GetHTMLLayerCount() !== u)) {
            const e2 = this.GetCanvasManager().SetHTMLLayerCount(u);
            this.IsInWorker() && (g = true, await e2);
          }
          this.PostComponentMessageToDOM("canvas", "update-html-layer-dom-state", { "layersDomState": _._GetRootLayers().filter((e2) => e2.IsHTMLElementsLayer()).map((e2) => e2._GetHTMLLayerDOMState()) }), n && this.Render(), g && this.PostComponentMessageToDOM("canvas", "cleanup-html-layers"), this.IsExportToVideo() && (await this._ExportToVideoAddFrame(), this.GetGameTime() >= this.GetExportVideoDuration()) ? this._ExportToVideoFinish() : (this.IsSuspended() || i2 || this._RequestAnimationFrame(), this._tickCount++, this._tickCountNoSave++, this._isInTick = false, this._mainThreadTimeCounter += performance.now() - o2);
        }
        async Step_BeforePreTick() {
          const e = this._eventSheetManager, t = this.IsDebug();
          this.FlushPendingInstances(), e.BlockFlushingInstances(true), this.PushCurrentLayout(this.GetMainRunningLayout()), t && C3Debugger.StartMeasuringTime(), this.IsDebugging() ? await e.DebugRunScheduledWaits() : e.RunScheduledWaits(), t && C3Debugger.AddEventsTime(), this.PopCurrentLayout(), e.BlockFlushingInstances(false), this.FlushPendingInstances(), e.BlockFlushingInstances(true);
        }
        async Step_AfterPreTick() {
          const e = this._eventSheetManager, t = this.IsDebug(), s2 = this.IsDebugging(), i2 = this._dispatcher, n = this._eventObjects, a2 = this._userScriptEventObjects;
          t && C3Debugger.StartMeasuringTime(), s2 ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick(), s2 ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick(), t && C3Debugger.AddBehaviorTotalTickTime(), t && C3Debugger.StartMeasuringTime(), s2 ? await this.DebugFireGeneratorEventAndBreak(n["tick"]) : i2.dispatchEvent(n["tick"]), t && C3Debugger.AddPluginTotalTickTime(), e.BlockFlushingInstances(false), this.DispatchUserScriptEvent(a2["tick"]);
        }
        async Step_RunEventsEtc() {
          const e = this._eventSheetManager, t = this._dispatcher, s2 = this._eventObjects, i2 = this._userScriptEventObjects, n = this.IsDebug(), a2 = this.IsDebugging();
          n && C3Debugger.StartMeasuringTime(), a2 ? await e.DebugRunEvents(this._layoutManager) : e.RunEvents(this._layoutManager), n && C3Debugger.AddEventsTime(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), this._isLayoutFirstTick = false, e.BlockFlushingInstances(true), n && C3Debugger.StartMeasuringTime(), a2 ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2(), n && C3Debugger.AddBehaviorTotalTickTime(), n && C3Debugger.StartMeasuringTime(), a2 ? await this.DebugFireGeneratorEventAndBreak(s2["tick2"]) : t.dispatchEvent(s2["tick2"]), n && C3Debugger.AddPluginTotalTickTime(), e.BlockFlushingInstances(false), this.DispatchUserScriptEvent(i2["tick2"]), a2 && await e.RunQueuedDebugTriggersAsync(), this.FlushPendingInstances(), this._ReleasePendingInstances();
        }
        _ReleasePendingInstances() {
          if (0 === this._instancesPendingRelease.size) return;
          const e = this._dispatcher;
          e.SetDelayRemoveEventsEnabled(true);
          for (const e2 of this._instancesPendingReleaseAffectedObjectClasses) e2.GetSolStack().RemoveInstances(this._instancesPendingRelease);
          this._instancesPendingReleaseAffectedObjectClasses.clear(), this._eventSheetManager._OnInstancesReleased(this._instancesPendingRelease);
          for (const e2 of this._instancesPendingRelease) e2.Release();
          this._instancesPendingRelease.clear(), e.SetDelayRemoveEventsEnabled(false);
        }
        async _MaybeChangeLayout() {
          const e = this.GetLayoutManager();
          let t = 0;
          for (; e.IsPendingChangeMainLayout() && t++ < 10; ) await this._DoChangeLayout(e.GetPendingChangeMainLayout());
        }
        _MeasureDt(e) {
          let t = 0;
          if (this.IsExportToVideo()) t = 1 / this.GetExportVideoFramerate(), this._dtRaw = t, this._dt1 = t;
          else if (0 !== this._lastTickTime) {
            t = Math.max(e - this._lastTickTime, 0) / 1e3, t > 0.5 && (t = 0), this._dtRaw = t, this._dt1 = C33.clamp(t, this._minDt, this._maxDt);
          }
          this._lastTickTime = e, this._dt = this._dt1 * this._timeScale, this._gameTime.Add(this._dt), this._gameTimeRaw.Add(t * this._timeScale), this._wallTime.Add(this._dt1);
          for (const [e2, t2] of this._instanceTimes) t2.Add(this._dt1 * e2.GetTimeScale());
          this._canvasManager && this._canvasManager._UpdateTick(), e - this._fpsLastTime >= 1e3 && (this._fpsLastTime += 1e3, e - this._fpsLastTime >= 1e3 && (this._fpsLastTime = e), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._tps = this._tpsTickCount, this._tpsTickCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1e3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug() && C3Debugger.Update1sPerfStats());
        }
        _SetTrackingInstanceTime(e, t) {
          if (t) {
            if (!this._instanceTimes.has(e)) {
              const t2 = C33.New(C33.KahanSum);
              t2.Copy(this._gameTime), this._instanceTimes.set(e, t2);
            }
          } else this._instanceTimes.delete(e);
        }
        _GetInstanceGameTime(e) {
          const t = this._instanceTimes.get(e);
          return t ? t.Get() : this.GetGameTime();
        }
        async _DoChangeLayout(e) {
          const t = this._dispatcher, s2 = this.GetLayoutManager().GetMainRunningLayout();
          await s2._StopRunning(), s2._Unload(e, this.GetRenderer()), s2 === e && this._eventSheetManager.ClearAllScheduledWaits(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), t.dispatchEvent(this._eventObjects["beforelayoutchange"]), C33.Asyncify.SetHighThroughputMode(true), await e._Load(s2, this.GetRenderer()), C33.Asyncify.SetHighThroughputMode(false), await e._StartRunning(false), t.dispatchEvent(this._eventObjects["layoutchange"]), this.UpdateRender(), this._isLayoutFirstTick = true, this.FlushPendingInstances(), this._ExportToVideoAddKeyframe();
        }
        UpdateRender() {
          this._needRender = true;
        }
        GetWebGLRenderer() {
          return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null;
        }
        GetWebGPURenderer() {
          return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null;
        }
        GetRenderer() {
          return this._canvasManager ? this._canvasManager.GetRenderer() : null;
        }
        Render() {
          const e = this._canvasManager;
          if (!e || e.IsRendererContextLost()) return;
          const t = this.GetRenderer(), s2 = t.SupportsGPUProfiling(), i2 = s2 && t.IsWebGL(), n = s2 && t.IsWebGPU();
          if (i2 && t.CheckForQueryResults(), !this._needRender && !this.IsExportToVideo()) return void t.IncrementFrameNumber();
          const a2 = this._layoutManager.GetMainRunningLayout();
          this._fpsFrameCount++, t.Start();
          const r2 = this.IsDebug();
          r2 && C3Debugger.StartMeasuringTime(), this._needRender = false;
          let o2 = null;
          i2 && (o2 = e.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), t.StartQuery(o2));
          let h = null;
          n && (h = t.StartFrameTiming(2 * (1 + a2.GetLayerCount())), t.StartMeasuringRenderPassTime(0, 1)), this.Uses3DFeatures() && "low" === e.GetCurrentFullscreenScalingQuality() ? t.SetFixedSizeDepthBuffer(e.GetDrawWidth(), e.GetDrawHeight()) : t.SetAutoSizeDepthBuffer(), this._Render(this.GetRenderer(), a2), o2 && t.EndQuery(o2), n && (t.StopMeasuringRenderPassTime(), this._canvasManager._AddWebGPUFrameTiming(h)), t.Finish(), r2 && (C3Debugger.AddDrawCallsTime(), C3Debugger.UpdateInspectHighlight()), e && e._MaybeTakeSnapshot();
        }
        _NeedsHTMLLayerCompositing(e) {
          return "low" === this.GetCanvasManager().GetCurrentFullscreenScalingQuality() || e.IsWebGL() && (this.UsesAnyBackgroundBlending() || this.Uses3DFeatures());
        }
        _Render(e, t) {
          e.SetTextureFillMode(), e.SetAlphaBlend(), e.ResetCullState(), e.SetColorRgba(1, 1, 1, 1), e.SetRenderTarget(null), e.SetTexture(null), e.SetDepthEnabled(this.Uses3DFeatures()), this._NeedsHTMLLayerCompositing(e) && t._MaybeStartDrawToOwnTexture(e);
          const s2 = t.GetHTMLLayerCount();
          for (let i2 = 1; i2 < s2; ++i2) t.DrawForHTMLLayerIndex(e, i2), e.IsWebGPU() && e.Restart();
          this._NeedsHTMLLayerCompositing(e) || t._MaybeStartDrawToOwnTexture(e), t.DrawMain(e);
        }
        Trigger(e, t, s2) {
          if (!this._hasStarted) return false;
          const i2 = !this._isInTick && !this._eventSheetManager.IsInTrigger();
          let n = 0;
          i2 && (n = performance.now());
          const a2 = this.IsDebug();
          a2 && this.SetDebuggingEnabled(false);
          const r2 = this._eventSheetManager._Trigger(this._layoutManager, e, t, s2);
          if (i2) {
            const e2 = performance.now() - n;
            this._mainThreadTimeCounter += e2, a2 && C3Debugger.AddTriggersTime(e2);
          }
          return a2 && this.SetDebuggingEnabled(true), r2;
        }
        DebugTrigger(e, t, s2) {
          if (!this.IsDebugging()) return this.Trigger(e, t, s2);
          if (this.HitBreakpoint()) throw new Error("called DebugTrigger() while stopped on breakpoint");
          if (!this._isInTick && !this._eventSheetManager.IsInTrigger()) throw new Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
          return this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, s2);
        }
        async TriggerAsync(e, t, s2) {
          if (!this.IsDebugging()) return this.Trigger(e, t, s2);
          if (!this._hasStarted) return false;
          if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(e, t, s2);
          if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(e, t, s2);
          const i2 = performance.now(), n = this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, s2);
          let a2 = n.next();
          for (; !a2.done; ) await this.DebugBreak(a2.value), a2 = n.next();
          return this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(), this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame()), this._mainThreadTimeCounter += performance.now() - i2, a2.value;
        }
        FastTrigger(e, t, s2) {
          const i2 = this.IsDebug();
          i2 && this.SetDebuggingEnabled(false);
          const n = this._eventSheetManager._FastTrigger(this._layoutManager, e, t, s2);
          return i2 && this.SetDebuggingEnabled(true), n;
        }
        DebugFastTrigger(e, t, s2) {
          return this._eventSheetManager._DebugFastTrigger(this._layoutManager, e, t, s2);
        }
        ScheduleTriggers(e) {
          return this._scheduleTriggersThrottle.Add(e);
        }
        PushCurrentLayout(e) {
          this._currentLayoutStack.push(e);
        }
        PopCurrentLayout() {
          if (!this._currentLayoutStack.length) throw new Error("layout stack empty");
          this._currentLayoutStack.pop();
        }
        GetCurrentLayout() {
          return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout();
        }
        GetDt(e) {
          return e && -1 !== e.GetTimeScale() ? this._dt1 * e.GetTimeScale() : this._dt;
        }
        _GetDtFast() {
          return this._dt;
        }
        GetDt1() {
          return this._dt1;
        }
        GetDtRaw() {
          return this._dtRaw;
        }
        GetTimeScale() {
          return this._timeScale;
        }
        SetTimeScale(e) {
          (isNaN(e) || e < 0) && (e = 0), this._timeScale = e;
        }
        SetMinDt(e) {
          this._minDt = Math.max(e, 0);
        }
        GetMinDt() {
          return this._minDt;
        }
        SetMaxDt(e) {
          this._maxDt = Math.max(e, 0);
        }
        GetMaxDt() {
          return this._maxDt;
        }
        GetFramesPerSecond() {
          return this._fps;
        }
        GetTicksPerSecond() {
          return this._tps;
        }
        GetMainThreadTime() {
          return this._mainThreadTime;
        }
        GetStartTime() {
          return this._startTime;
        }
        GetGameTime() {
          return this._gameTime.Get();
        }
        GetGameTimeRaw() {
          return this._gameTimeRaw.Get();
        }
        GetWallTime() {
          return this._wallTime.Get();
        }
        GetTickCount() {
          return this._tickCount;
        }
        GetTickCountNoSave() {
          return this._tickCountNoSave;
        }
        GetObjectCount() {
          return this._objectCount;
        }
        GetProjectName() {
          return this._projectName;
        }
        GetProjectVersion() {
          return this._projectVersion;
        }
        GetProjectUniqueId() {
          return this._projectUniqueId;
        }
        GetAppId() {
          return this._appId;
        }
        GetExportTimestamp() {
          return this._exportTimestamp;
        }
        GetInstanceByUID(e) {
          if (this._isLoadingState) throw new Error("cannot call while loading state - wait until afterload event");
          return this._instancesByUid.get(e) || null;
        }
        _RemoveInstanceFromUIDMap(e) {
          if (this._isLoadingState) throw new Error("cannot call while loading state - wait until afterload event");
          this._instancesByUid.delete(e);
        }
        _RefreshUidMap() {
          this._instancesByUid.clear();
          for (const e of this._allObjectClasses) if (!e.IsFamily()) for (const t of e.GetInstances()) this._instancesByUid.set(t.GetUID(), t);
        }
        IsPreview() {
          return "preview" === this._exportType;
        }
        IsDebug() {
          return this._isDebug;
        }
        GetExportType() {
          return this._exportType;
        }
        IsNWjs() {
          return "nwjs" === this.GetExportType() || this._isNWjs;
        }
        IsCordova() {
          return "cordova" === this._exportType;
        }
        IsAndroidWebView() {
          return "Android" === C33.Platform.OS && ("cordova" === this._exportType || "playable-ad-single-file" === this._exportType || "playable-ad-zip" === this._exportType || "instant-games" === this._exportType);
        }
        IsiOSCordova() {
          return this._isiOSCordova;
        }
        IsiOSWebView() {
          return this._isiOSWebView;
        }
        IsWindowsWebView2() {
          return this._isWindowsWebView2;
        }
        IsAnyWebView2Wrapper() {
          return this._isAnyWebView2Wrapper;
        }
        GetCollisionEngine() {
          return this._collisionEngine;
        }
        GetSolidBehavior() {
          return this._addonManager.GetSolidBehavior();
        }
        GetJumpthruBehavior() {
          return this._addonManager.GetJumpthruBehavior();
        }
        Uses3DFeatures() {
          return this._uses3dFeatures;
        }
        GetZScaleFactor() {
          return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight());
        }
        GetDefaultCameraZ(e) {
          return this.GetRenderer().GetDefaultCameraZ(e || this.GetViewportHeight());
        }
        IsLayoutFirstTick() {
          return this._isLayoutFirstTick;
        }
        SetPixelRoundingEnabled(e) {
          e = !!e, this._isPixelRoundingEnabled !== e && (this._isPixelRoundingEnabled = e, this.GetLayoutManager().SetAllLayerMVChanged(), this.UpdateRender());
        }
        IsPixelRoundingEnabled() {
          return this._isPixelRoundingEnabled;
        }
        GetTextIconSet(e) {
          if (!this._iconChangeHandlers.has(e)) {
            const t2 = () => this.DeleteTextIconSet(e);
            this._iconChangeHandlers.set(e, t2), e.Dispatcher().addEventListener("animationframeimagechange", t2);
          }
          const t = this._textIconManager.GetIconSet(e);
          return t.HasLoaded() || t.LoadContent().then(() => this.UpdateRender()), t;
        }
        DeleteTextIconSet(e) {
          this._textIconManager.DeleteIconSet(e);
        }
        _GetTextIconSetMeta(e) {
          const t = [];
          for (const s2 of e.GetAnimations()) for (const e2 of s2.GetFrames()) {
            const s3 = e2.GetImageInfo();
            t.push({ source: e2, width: s3.GetWidth(), height: s3.GetHeight(), tag: e2.GetTag() });
          }
          return { icons: t };
        }
        async _GetTextIconSetContent(e) {
          const t = C33.New(C33.PromiseThrottle), s2 = [], i2 = /* @__PURE__ */ new Map();
          for (const n2 of e.GetAnimations()) for (const e2 of n2.GetFrames()) {
            const n3 = e2.GetImageInfo().GetImageAsset();
            i2.has(n3) || (i2.set(n3, null), s2.push(t.Add(async () => {
              const e3 = await n3.LoadToDrawable();
              i2.set(n3, e3);
            })));
          }
          await Promise.all(s2);
          const n = [];
          for (const s3 of e.GetAnimations()) for (const e2 of s3.GetFrames()) n.push(t.Add(async () => {
            const t2 = e2.GetImageInfo(), s4 = i2.get(t2.GetImageAsset()), n2 = await t2.ExtractImageToCanvas(s4);
            return { drawable: await createImageBitmap(n2) };
          }));
          const a2 = await Promise.all(n);
          for (const e2 of i2.values()) e2 instanceof ImageBitmap && e2["close"] && e2["close"]();
          return { icons: a2 };
        }
        SaveToSlot(e) {
          this._saveToSlotName = e, this._saveToJsonString = false;
        }
        SaveToJsonString() {
          this._saveToSlotName = "", this._saveToJsonString = true;
        }
        LoadFromSlot(e) {
          this._loadFromSlotName = e;
        }
        LoadFromJsonString(e) {
          this._loadFromJson = e;
        }
        GetLastSaveJsonString() {
          return this._lastSaveJson;
        }
        _NeedsHandleSaveOrLoad() {
          return !!(this._saveToSlotName || this._saveToJsonString || this._loadFromSlotName || null !== this._loadFromJson);
        }
        async _HandleSaveOrLoad() {
          if (this._saveToSlotName && (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad()), this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug() && C3Debugger.StepIfPausedInDebugger()), this._saveToJsonString) {
            const e = await this._SaveToJsonString();
            this._lastSaveJson = e, await this.TriggerAsync(C33.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = "", this._ClearSaveOrLoad();
          }
          if (null !== this._loadFromJson) {
            this.FlushPendingInstances();
            try {
              await this._DoLoadFromJsonString(this._loadFromJson), this._lastSaveJson = this._loadFromJson, await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = "";
            } catch (e) {
              console.error("[Construct] Failed to load state from JSON string: ", e), await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadFailed, null);
            }
            this._ClearSaveOrLoad();
          }
        }
        _ClearSaveOrLoad() {
          this._saveToSlotName = "", this._saveToJsonString = false, this._loadFromSlotName = "", this._loadFromJson = null;
        }
        _GetProjectStorage() {
          return this._projectStorage || (this._projectStorage = localforage.createInstance({ name: "c3-localstorage-" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._projectStorage;
        }
        _GetSavegamesStorage() {
          return this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({ name: "c3-savegames-" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._savegamesStorage;
        }
        async _DoSaveToSlot(e) {
          const t = await this._SaveToJsonString();
          try {
            await this._GetSavegamesStorage().setItem(e, t), console.log("[Construct] Saved state to storage (" + t.length + " chars)"), this._lastSaveJson = t, await this.TriggerAsync(C33.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = "";
          } catch (e2) {
            console.error("[Construct] Failed to save state to storage: ", e2), await this.TriggerAsync(C33.Plugins.System.Cnds.OnSaveFailed, null);
          }
        }
        async _DoLoadFromSlot(e) {
          try {
            const t = await this._GetSavegamesStorage().getItem(e);
            if (!t) throw new Error("empty slot");
            console.log("[Construct] Loaded state from storage (" + t.length + " chars)"), await this._DoLoadFromJsonString(t), this._lastSaveJson = t, await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = "";
          } catch (e2) {
            console.error("[Construct] Failed to load state from storage: ", e2), await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadFailed, null);
          }
        }
        async _SaveToJsonString() {
          const e = { "c3save": true, "version": 1, "rt": { "time": this.GetGameTime(), "timeRaw": this.GetGameTimeRaw(), "walltime": this.GetWallTime(), "timescale": this.GetTimeScale(), "tickcount": this.GetTickCount(), "next_uid": this._nextUid, "running_layout": this.GetMainRunningLayout().GetSID(), "start_time_offset": Date.now() - this._startTime }, "types": {}, "layouts": {}, "events": this._eventSheetManager._SaveToJson(), "timelines": this._timelineManager._SaveToJson(), "user_script_data": null };
          for (const t2 of this._allObjectClasses) t2.IsFamily() || t2.HasNoSaveBehavior() || (e["types"][t2.GetSID().toString()] = t2._SaveToJson());
          for (const t2 of this._layoutManager.GetAllLayouts()) e["layouts"][t2.GetSID().toString()] = t2._SaveToJson();
          const t = this._CreateUserScriptEvent("save");
          return t.saveData = null, await this.DispatchUserScriptEventAsyncWait(t), e["user_script_data"] = t.saveData, JSON.stringify(e);
        }
        IsLoadingState() {
          return this._isLoadingState;
        }
        async _DoLoadFromJsonString(e) {
          const t = this.GetLayoutManager(), s2 = JSON.parse(e);
          if (s2["c2save"]) throw new Error("C2 saves are incompatible with C3 runtime");
          if (!s2["c3save"]) throw new Error("not valid C3 save data");
          if (s2["version"] > 1) throw new Error("C3 save data from future version");
          this.ClearIntancesNeedingAfterLoad(), this._dispatcher.dispatchEvent(C33.New(C33.Event, "beforeload"));
          for (const e2 of this.allInstances()) {
            e2.GetObjectClass().HasNoSaveBehavior() || e2._OnBeforeLoad();
          }
          const i2 = s2["rt"];
          this._gameTime.Set(i2["time"]), i2.hasOwnProperty("timeRaw") && this._gameTimeRaw.Set(i2["timeRaw"]), this._wallTime.Set(i2["walltime"]), this._timeScale = i2["timescale"], this._tickCount = i2["tickcount"], this._startTime = Date.now() - i2["start_time_offset"];
          const n = i2["running_layout"];
          this._isLoadingState = true;
          let a2 = false;
          if (n !== this.GetMainRunningLayout().GetSID()) {
            const e2 = t.GetLayoutBySID(n);
            if (!e2) return;
            await this._DoChangeLayout(e2), a2 = true;
          }
          for (const [e2, i3] of Object.entries(s2["layouts"])) {
            const s3 = parseInt(e2, 10), n2 = t.GetLayoutBySID(s3);
            n2 && n2._LoadFromJson(i3);
          }
          const r2 = /* @__PURE__ */ new Set();
          for (const [e2, t2] of Object.entries(s2["types"])) {
            const s3 = parseInt(e2, 10), i3 = this.GetObjectClassBySID(s3);
            !i3 || i3.IsFamily() || i3.HasNoSaveBehavior() || i3._LoadFromJson(t2, r2);
          }
          for (const e2 of this._layoutManager.GetAllLayouts()) for (const t2 of e2.allLayers()) t2._LoadFromJsonAfterInstances();
          if (this.FlushPendingInstances(), this._RefreshUidMap(), this._isLoadingState = false, a2) {
            for (const e2 of this.allInstances()) e2.SetupInitialSceneGraphConnections();
            for (const [e2, t2] of Object.entries(s2["types"])) {
              const s3 = parseInt(e2, 10), i3 = this.GetObjectClassBySID(s3);
              !i3 || i3.IsFamily() || i3.HasNoSaveBehavior() || i3._SetupSceneGraphConnectionsOnChangeOfLayout(t2);
            }
          }
          this._nextUid = i2["next_uid"], this._eventSheetManager._LoadFromJson(s2["events"]);
          for (const e2 of this._allObjectClasses) if (!e2.IsFamily() && e2.IsInContainer()) for (const t2 of e2.GetInstances()) {
            const s3 = t2.GetIID();
            t2._ClearSiblings();
            for (const i3 of e2.GetContainer().objectTypes()) {
              if (i3 === e2) continue;
              const n2 = i3.GetInstances();
              if (s3 < 0 || s3 >= n2.length) throw new Error("missing sibling instance");
              t2._AddSibling(n2[s3]);
            }
          }
          this._timelineManager._LoadFromJson(s2["timelines"]), t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();
          for (const e2 of r2) e2._OnCreatedForLoadingSavegame();
          this.DoAfterLoad(), this._dispatcher.dispatchEvent(C33.New(C33.Event, "afterload")), this.DispatchUserScriptEvent(this._CreateUserScriptEvent("afterload"));
          for (const [e2, t2] of Object.entries(s2["types"])) {
            const t3 = parseInt(e2, 10), s3 = this.GetObjectClassBySID(t3);
            s3 && s3._ClearLoadInstancesJson();
          }
          const o2 = this._CreateUserScriptEvent("load");
          o2.saveData = s2["user_script_data"], await this.DispatchUserScriptEventAsyncWait(o2), this.UpdateRender();
        }
        SortOnTmpHierarchyPosition(e, t) {
          return t.GetWorldInfo().GetTmpHierarchyPosition() - e.GetWorldInfo().GetTmpHierarchyPosition();
        }
        AddInstanceNeedingAfterLoad(e, t) {
          e.GetWorldInfo() && (this._instancesNeedingAfterLoadMap.has(e) || (this._instancesNeedingAfterLoadMap.set(e, t), this._instancesNeedingAfterLoadArray.push(e)));
        }
        ClearIntancesNeedingAfterLoad() {
          this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), C33.clearArray(this._instancesNeedingAfterLoadArray), C33.SceneGraphInfo.ClearUpdatedInstances();
        }
        DoAfterLoad(e = "full", t = null) {
          this._instancesNeedingAfterLoadArray.sort(this.SortOnTmpHierarchyPosition), t || (t = {}), t.processedWorldInfo = /* @__PURE__ */ new Set();
          const s2 = this._instancesNeedingAfterLoadArray.length;
          for (const s3 of this._instancesNeedingAfterLoadArray) s3._OnAfterLoad(this._instancesNeedingAfterLoadMap.get(s3), e, t);
          for (const s3 of this._instancesNeedingAfterLoadArray) s3._OnAfterLoad2(this._instancesNeedingAfterLoadMap.get(s3), e, t);
          if (this.ClearIntancesNeedingAfterLoad(), s2) {
            this.FlushPendingInstances(), this._RefreshUidMap();
            for (const e2 of this._layoutManager.GetAllLayouts()) for (const t2 of e2.allLayers()) t2._SortInstancesByLastCachedZIndex(), t2.SetZIndicesChanged();
          }
        }
        async AddJobWorkerScripts(e) {
          const t = await Promise.all(e.map(async (e2) => {
            if (this.IsCordova() && this._assetManager.IsFileProtocol() || "playable-ad-single-file" === this.GetExportType()) {
              const t2 = await this._assetManager.FetchBlob(e2);
              return URL.createObjectURL(t2);
            }
            return new URL(e2, location.href).toString();
          }));
          this._jobScheduler.ImportScriptsToJobWorkers(t);
        }
        AddJobWorkerBlob(e, t) {
          this._jobScheduler.SendBlobToJobWorkers(e, t);
        }
        AddJobWorkerBuffer(e, t) {
          this._jobScheduler.SendBufferToJobWorkers(e, t);
        }
        AddJob(e, t, s2, i2) {
          return this._jobScheduler.AddJob(e, t, s2, null, null, i2);
        }
        BroadcastJob(e, t, s2, i2) {
          return this._jobScheduler.BroadcastJob(e, t, s2, i2);
        }
        GetMaxNumJobWorkers() {
          return this._jobScheduler.GetMaxNumWorkers();
        }
        InvokeDownload(e, t) {
          this.PostComponentMessageToDOM("runtime", "invoke-download", { "url": e, "filename": t });
        }
        async RasterSvgImage(e, t, s2, i2, n, a2) {
          if (i2 = i2 || t, n = n || s2, this.IsInWorker()) {
            return (await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", { "blob": e, "imageWidth": t, "imageHeight": s2, "surfaceWidth": i2, "surfaceHeight": n, "imageBitmapOpts": a2 }))["imageBitmap"];
          }
          {
            const r2 = await self["C3_RasterSvgImageBlob"](e, t, s2, i2, n);
            return a2 ? await self.createImageBitmap(r2, a2) : r2;
          }
        }
        async GetSvgImageSize(e) {
          return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync("runtime", "get-svg-image-size", { "blob": e }) : await self["C3_GetSvgImageSize"](e);
        }
        RequestDeviceOrientationEvent() {
          this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = true, this.PostComponentMessageToDOM("runtime", "enable-device-orientation"));
        }
        RequestDeviceMotionEvent() {
          this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = true, this.PostComponentMessageToDOM("runtime", "enable-device-motion"));
        }
        Random() {
          return this._randomNumberCallback();
        }
        SetRandomNumberGeneratorCallback(e) {
          this._randomNumberCallback = e;
        }
        _GetRemotePreviewStatusInfo() {
          const e = this.GetRenderer();
          return { "fps": this.GetFramesPerSecond(), "tps": this.GetTicksPerSecond(), "cpu": this.GetMainThreadTime(), "gpu": this.GetGPUUtilisation(), "layout": this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "", "renderer": e.IsWebGL() ? e.GetUnmaskedRenderer() : e.GetAdapterInfoString() };
        }
        HitBreakpoint() {
          return !!this.IsDebug() && C3Debugger.HitBreakpoint();
        }
        DebugBreak(e) {
          return this.IsDebugging() ? C3Debugger.DebugBreak(e) : Promise.resolve();
        }
        DebugBreakNext() {
          return !!this.IsDebugging() && C3Debugger.BreakNext();
        }
        SetDebugBreakpointsEnabled(e) {
          this._breakpointsEnabled = !!e, this._UpdateDebuggingFlag();
        }
        AreDebugBreakpointsEnabled() {
          return this._breakpointsEnabled;
        }
        IsDebugging() {
          return this._isDebugging;
        }
        SetDebuggingEnabled(e) {
          e ? this._debuggingDisabled-- : this._debuggingDisabled++, this._UpdateDebuggingFlag();
        }
        _UpdateDebuggingFlag() {
          this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled;
        }
        IsCPUProfiling() {
          return this.IsDebug() && C3Debugger.IsCPUProfiling();
        }
        IsGPUProfiling() {
          return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && C3Debugger.IsGPUProfiling();
        }
        async DebugIterateAndBreak(e) {
          if (e) for (const t of e) await this.DebugBreak(t);
        }
        DebugFireGeneratorEventAndBreak(e) {
          return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(e));
        }
        _InvokeFunctionFromJS(e) {
          return this._eventSheetManager._InvokeFunctionFromJS(e["name"], e["params"]);
        }
        _GetHTMLLayerWrapElement(e) {
          if (this.IsInWorker()) throw new Error("not supported in worker mode");
          return self["c3_runtimeInterface"]["_GetHTMLWrapElement"](e);
        }
        GetIRuntime() {
          return this._iRuntime;
        }
        _CreateUserScriptEvent(e) {
          const t = C33.New(C33.Event, e, false);
          return t.runtime = this._iRuntime, t;
        }
        _InitScriptInterfaces() {
          this._iRuntime = new self.IRuntime(this), this._userScriptEventObjects = { "pretick": this._CreateUserScriptEvent("pretick"), "tick": this._CreateUserScriptEvent("tick"), "tick2": this._CreateUserScriptEvent("tick2") };
        }
        _InitObjectsScriptInterface() {
          const e = {};
          for (const t of this._allObjectClasses) e[t.GetJsPropName()] = { value: t.GetIObjectClass(), enumerable: true, writable: false };
          this._iRuntime._InitObjects(e);
        }
        _InitGlobalVariableScriptInterface() {
          const e = {};
          for (const t of this.GetEventSheetManager().GetAllGlobalVariables()) e[t.GetJsPropName()] = t._GetScriptInterfaceDescriptor();
          this._iRuntime._InitGlobalVars(e);
        }
        _GetCommonScriptInterfaces() {
          return this._commonScriptInterfaces;
        }
        _MapScriptInterface(e, t) {
          this._interfaceMap.set(e, t);
        }
        _UnwrapScriptInterface(e) {
          return this._interfaceMap.get(e);
        }
        _UnwrapIObjectClass(e) {
          if (!(e instanceof self.IObjectClass)) throw new TypeError("expected IObjectClass");
          const t = this._UnwrapScriptInterface(e);
          if (!(t && t instanceof C33.ObjectClass)) throw new Error("invalid IObjectClass");
          return t;
        }
        _UnwrapIInstance(e) {
          if (!(e instanceof self.IInstance)) throw new TypeError("expected IInstance");
          const t = this._UnwrapScriptInterface(e);
          if (!(t && t instanceof C33.Instance)) throw new Error("invalid IInstance");
          return t;
        }
        _UnwrapIWorldInstance(e) {
          if (!(e instanceof self.IWorldInstance)) throw new TypeError("expected IWorldInstance");
          const t = this._UnwrapScriptInterface(e);
          if (!(t && t instanceof C33.Instance)) throw new Error("invalid IInstance");
          return t;
        }
      }, self["C3_CreateRuntime"] = C33.Runtime.Create, self["C3_InitRuntime"] = (e, t) => e.Init(t);
    }
    {
      const C33 = self.C3;
      C33.JobSchedulerRuntime = class extends C33.DefendedBase {
        constructor(r2, e) {
          super(), this._runtime = r2, this._jobPromises = /* @__PURE__ */ new Map(), this._nextJobId = 0, this._inputPort = e["inputPort"], e["outputPort"].onmessage = (r3) => this._OnJobWorkerMessage(r3), this._maxNumWorkers = e["maxNumWorkers"], this._jobWorkerCount = 1, this._isCreatingWorker = false, this._hadErrorCreatingWorker = false;
        }
        GetMaxNumWorkers() {
          return this._maxNumWorkers;
        }
        ImportScriptsToJobWorkers(r2) {
          this._inputPort.postMessage({ "type": "_import_scripts", "scripts": r2 });
        }
        SendBlobToJobWorkers(r2, e) {
          this._inputPort.postMessage({ "type": "_send_blob", "blob": r2, "id": e });
        }
        SendBufferToJobWorkers(r2, e) {
          this._inputPort.postMessage({ "type": "_send_buffer", "buffer": r2, "id": e }, [r2]);
        }
        AddJob(r2, e, o2, s2, t, i2) {
          if (o2 || (o2 = []), "number" == typeof i2 && (i2 = Math.floor(i2)) <= 0) throw new Error("invalid maxWorkerNum");
          const n = this._nextJobId++, a2 = { "type": r2, "isBroadcast": false, "maxWorkerNum": i2, "jobId": n, "params": e, "transferables": o2 }, _ = new Promise((r3, e2) => {
            this._jobPromises.set(n, { resolve: r3, progress: s2, reject: e2, cancelled: false, maxWorkerNum: i2 });
          });
          return t && t.SetAction(() => this._CancelJob(n)), this._inputPort.postMessage(a2, o2), this._MaybeCreateExtraWorker(), _;
        }
        BroadcastJob(r2, e, o2, s2) {
          if (o2 || (o2 = []), "number" == typeof s2 && (s2 = Math.floor(s2)) <= 0) throw new Error("invalid maxWorkerNum");
          const t = { "type": r2, "isBroadcast": true, "maxWorkerNum": s2, "jobId": this._nextJobId++, "params": e, "transferables": o2 };
          this._inputPort.postMessage(t, o2);
        }
        _CancelJob(r2) {
          const e = this._jobPromises.get(r2);
          e && (e.cancelled = true, e.resolve = null, e.progress = null, e.reject = null, this._inputPort.postMessage({ "type": "_cancel", "jobId": r2 }));
        }
        _OnJobWorkerMessage(r2) {
          const e = r2.data, o2 = e["type"], s2 = e["jobId"];
          switch (o2) {
            case "result":
              this._OnJobResult(s2, e["result"]);
              break;
            case "progress":
              this._OnJobProgress(s2, e["progress"]);
              break;
            case "error":
              this._OnJobError(s2, e["error"]);
              break;
            case "ready":
              this._OnJobWorkerReady();
              break;
            default:
              throw new Error(`unknown message from worker '${o2}'`);
          }
        }
        _OnJobResult(r2, e) {
          const o2 = this._jobPromises.get(r2);
          if (!o2) throw new Error("invalid job ID");
          o2.cancelled || o2.resolve(e), this._jobPromises.delete(r2);
        }
        _OnJobProgress(r2, e) {
          const o2 = this._jobPromises.get(r2);
          if (!o2) throw new Error("invalid job ID");
          !o2.cancelled && o2.progress && o2.progress(e);
        }
        _OnJobError(r2, e) {
          const o2 = this._jobPromises.get(r2);
          if (!o2) throw new Error("invalid job ID");
          o2.cancelled || o2.reject(e), this._jobPromises.delete(r2);
        }
        _OnJobWorkerReady() {
          this._isCreatingWorker && (this._isCreatingWorker = false, this._jobWorkerCount++, this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({ "type": "_no_more_workers" }));
        }
        _GetWorkerCountNeededForPendingJobs() {
          let r2 = 0;
          const e = [...this._jobPromises.values()].sort((r3, e2) => (r3.maxWorkerNum || 1 / 0) - (e2.maxWorkerNum || 1 / 0));
          for (const o2 of e) {
            r2 < (o2.maxWorkerNum || 1 / 0) && r2++;
          }
          return r2;
        }
        async _MaybeCreateExtraWorker() {
          if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._GetWorkerCountNeededForPendingJobs() <= this._jobWorkerCount)) try {
            this._isCreatingWorker = true;
            (await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker"))["outputPort"].onmessage = (r2) => this._OnJobWorkerMessage(r2);
          } catch (r2) {
            this._hadErrorCreatingWorker = true, this._isCreatingWorker = false, console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, r2);
          }
        }
      };
    }
    {
      self["C3_Shaders"] = {};
      self["C3_Shaders"]["replacecolor"] = {
        glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp vec3 sourceColor;\nuniform lowp vec3 destColor;\nuniform lowp float tolerance;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\nlowp float a = front.a;\nif (a != 0.0)\nfront.rgb /= a;\nlowp float diff = length(front.rgb - sourceColor);\nif (diff <= tolerance)\n{\nfront.rgb = mix(front.rgb, destColor, 1.0 - diff / tolerance);\n}\nfront.rgb *= a;\ngl_FragColor = front;\n}",
        glslWebGL2: "",
        wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nsourceColor : vec3<f32>,\ndestColor : vec3<f32>,\ntolerance : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\nvar rgb : vec3<f32> = front.rgb;\nvar diff : f32 = length(rgb - shaderParams.sourceColor);\nif (diff <= shaderParams.tolerance)\n{\nrgb = mix(rgb, shaderParams.destColor, 1.0 - diff / shaderParams.tolerance);\n}\nvar output : FragmentOutput;\noutput.color = vec4<f32>(rgb * front.a, front.a);\nreturn output;\n}",
        blendsBackground: false,
        usesDepth: false,
        extendBoxHorizontal: 0,
        extendBoxVertical: 0,
        crossSampling: false,
        mustPreDraw: false,
        preservesOpaqueness: true,
        supports3dDirectRendering: false,
        animated: false,
        parameters: [["sourceColor", 0, "color"], ["destColor", 0, "color"], ["tolerance", 0, "percent"]]
      };
      self["C3_Shaders"]["brightness"] = {
        glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp float brightness;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\nlowp float a = front.a;\nif (a != 0.0)\nfront.rgb /= front.a;\nfront.rgb += (brightness - 1.0);\nfront.rgb *= a;\ngl_FragColor = front;\n}",
        glslWebGL2: "",
        wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nbrightness : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\nvar output : FragmentOutput;\noutput.color = vec4<f32>((front.rgb + (shaderParams.brightness - 1.0)) * front.a, front.a);\nreturn output;\n}",
        blendsBackground: false,
        usesDepth: false,
        extendBoxHorizontal: 0,
        extendBoxVertical: 0,
        crossSampling: false,
        mustPreDraw: false,
        preservesOpaqueness: true,
        supports3dDirectRendering: false,
        animated: false,
        parameters: [["brightness", 0, "percent"]]
      };
      self["C3_Shaders"]["skymen_BetterOutline"] = {
        glsl: "uniform lowp vec3 outlinecolor;\nuniform lowp float width;\nuniform lowp float precisionStep;\nuniform lowp float samples;\nuniform lowp float outlineOpacity;\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nuniform mediump vec2 layoutStart;\nuniform mediump vec2 layoutEnd;\nuniform lowp sampler2D samplerBack;\nuniform mediump vec2 destStart;\nuniform mediump vec2 destEnd;\nuniform mediump float seconds;\nuniform mediump vec2 pixelSize;\nuniform mediump float layerScale;\nuniform mediump float layerAngle;\n#define PI 3.14159265359\n#define SAMPLES 96\n#define PASSES 64\nvoid main(void)\n{\nif (width <= 0.0 || outlineOpacity <= 0.0) {\ngl_FragColor = texture2D( samplerFront, vTex );\nreturn;\n}\nmediump float outlineAlpha = 0.0;\nmediump vec2 actualWidth;\nmediump float widthCopy = width;\nmediump vec4 color = vec4(outlinecolor.x, outlinecolor.y, outlinecolor.z, 1.0);\nmediump float angle;\nmediump vec2 layoutSize = abs(vec2(layoutEnd.x-layoutStart.x,(layoutEnd.y-layoutStart.y)));\nmediump vec2 texelSize = abs(srcOriginEnd-srcOriginStart)/layoutSize;\nmediump vec4 fragColor;\nmediump vec2 testPoint;\nmediump float sampledAlpha;\nint passes = int(clamp(width / precisionStep, 1.0, float(PASSES)));\nfor (int j=0; j<PASSES; j++) {\nif (j >= passes ) break;\nwidthCopy = mix(0.0, width, float(j)/float(passes));\nactualWidth = widthCopy * texelSize;\nangle = 0.0;\nfor( int i=0; i<SAMPLES; i++ ){\nif (i >= int(samples)) break;\nangle += 1.0/(clamp(samples, 0.0, float(SAMPLES))/2.0) * PI;\ntestPoint = vTex + actualWidth * vec2(cos(angle), sin(angle));\nsampledAlpha = texture2D( samplerFront,  testPoint ).a;\noutlineAlpha = max( outlineAlpha, sampledAlpha );\n}\n}\nfragColor = color * outlineAlpha * outlineOpacity;\nmediump vec4 tex0 = texture2D( samplerFront, vTex );\ngl_FragColor = fragColor * (1. - tex0.a) + tex0;\n}",
        glslWebGL2: "#version 300 es\nin mediump vec2 vTex;\nout lowp vec4 outColor;\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nprecision lowp float;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nuniform mediump vec2 layoutStart;\nuniform mediump vec2 layoutEnd;\nuniform lowp sampler2D samplerBack;\nuniform lowp sampler2D samplerDepth;\nuniform mediump vec2 destStart;\nuniform mediump vec2 destEnd;\nuniform highmedp float seconds;\nuniform mediump vec2 pixelSize;\nuniform mediump float layerScale;\nuniform mediump float layerAngle;\nuniform mediump float devicePixelRatio;\nuniform mediump float zNear;\nuniform mediump float zFar;\nuniform lowp vec3 outlinecolor;\nuniform lowp float width;\nuniform lowp float precisionStep;\nuniform lowp float samples;\nuniform lowp float outlineOpacity;\n#define PI 3.14159265359\n#define SAMPLES 96\n#define PASSES 64\nvoid main(void)\n{\nif (width <= 0.0 || outlineOpacity <= 0.0) {\noutColor = texture( samplerFront, vTex );\nreturn;\n}\nmediump float outlineAlpha = 0.0;\nmediump vec2 actualWidth;\nmediump float widthCopy = width;\nmediump vec4 color = vec4(outlinecolor.x, outlinecolor.y, outlinecolor.z, 1.0);\nmediump float angle;\nmediump vec2 layoutSize = abs(vec2(layoutEnd.x-layoutStart.x,(layoutEnd.y-layoutStart.y)));\nmediump vec2 texelSize = abs(srcOriginEnd-srcOriginStart)/layoutSize;\nmediump vec4 fragColor;\nmediump vec2 testPoint;\nmediump float sampledAlpha;\nint passes = int(clamp(width / precisionStep, 1.0, float(PASSES)));\nint sampleCount = int(clamp(samples, 0.0, float(SAMPLES)));\nfor (int j = 0; j <= passes; j++) {\nwidthCopy = mix(0.0, width, float(j)/float(passes));\nactualWidth = widthCopy * texelSize;\nangle = 0.0;\nfor( int i = 0; i < sampleCount; i++ ) {\nangle += 1.0/(float(sampleCount)/2.0) * PI;\ntestPoint = vTex + actualWidth * vec2(cos(angle), sin(angle));\nsampledAlpha = texture( samplerFront,  testPoint ).a;\noutlineAlpha = max( outlineAlpha, sampledAlpha );\n}\n}\nfragColor = color * outlineAlpha * outlineOpacity;\nmediump vec4 tex0 = texture( samplerFront, vTex );\noutColor = fragColor * (1. - tex0.a) + tex0;\n}",
        wgsl: "%%FRAGMENTINPUT_STRUCT%%\n/* input struct contains the following fields:\nfragUV : vec2<f32>\nfragPos : vec4<f32>\nfn c3_getBackUV(fragPos : vec2<f32>, texBack : texture_2d<f32>) -> vec2<f32>\nfn c3_getDepthUV(fragPos : vec2<f32>, texDepth : texture_depth_2d) -> vec2<f32>\n*/\n%%FRAGMENTOUTPUT_STRUCT%%\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\noutlinecolor : vec3<f32>,\nwidth : f32,\nprecisionStep : f32,\nsamples : f32,\noutlineOpacity : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3PARAMS_STRUCT%%\n/* c3Params struct contains the following fields:\nsrcStart : vec2<f32>,\nsrcEnd : vec2<f32>,\nsrcOriginStart : vec2<f32>,\nsrcOriginEnd : vec2<f32>,\nlayoutStart : vec2<f32>,\nlayoutEnd : vec2<f32>,\ndestStart : vec2<f32>,\ndestEnd : vec2<f32>,\ndevicePixelRatio : f32,\nlayerScale : f32,\nlayerAngle : f32,\nseconds : f32,\nzNear : f32,\nzFar : f32,\nisSrcTexRotated : u32\nfn c3_srcToNorm(p : vec2<f32>) -> vec2<f32>\nfn c3_normToSrc(p : vec2<f32>) -> vec2<f32>\nfn c3_srcOriginToNorm(p : vec2<f32>) -> vec2<f32>\nfn c3_normToSrcOrigin(p : vec2<f32>) -> vec2<f32>\nfn c3_clampToSrc(p : vec2<f32>) -> vec2<f32>\nfn c3_clampToSrcOrigin(p : vec2<f32>) -> vec2<f32>\nfn c3_getLayoutPos(p : vec2<f32>) -> vec2<f32>\nfn c3_srcToDest(p : vec2<f32>) -> vec2<f32>\nfn c3_clampToDest(p : vec2<f32>) -> vec2<f32>\nfn c3_linearizeDepth(depthSample : f32) -> f32\n*/\n/*\nfn c3_premultiply(c : vec4<f32>) -> vec4<f32>\nfn c3_unpremultiply(c : vec4<f32>) -> vec4<f32>\nfn c3_grayscale(rgb : vec3<f32>) -> f32\nfn c3_getPixelSize(t : texture_2d<f32>) -> vec2<f32>\nfn c3_RGBtoHSL(color : vec3<f32>) -> vec3<f32>\nfn c3_HSLtoRGB(hsl : vec3<f32>) -> vec3<f32>\n*/\nconst PI:f32 = 3.14159265359;\nconst SAMPLES:i32 = 96;\nconst PASSES:i32 = 64;\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar output : FragmentOutput;\nif (shaderParams.width <= 0.0 || shaderParams.outlineOpacity <= 0.0) {\noutput.color = textureSample(textureFront, samplerFront, input.fragUV );\nreturn output;\n}\nvar outlineAlpha: f32 = 0.0;\nvar actualWidth: vec2<f32>;\nvar widthCopy: f32 = shaderParams.width;\nvar color: vec4<f32> = vec4<f32>(shaderParams.outlinecolor.x, shaderParams.outlinecolor.y, shaderParams.outlinecolor.z, 1.0);\nvar angle: f32;\nlet layoutSize: vec2<f32> = abs(vec2<f32>(c3Params.layoutEnd.x - c3Params.layoutStart.x, c3Params.layoutEnd.y - c3Params.layoutStart.y));\nlet texelSize: vec2<f32> = abs(c3Params.srcOriginEnd - c3Params.srcOriginStart) / layoutSize;\nvar fragColor: vec4<f32>;\nvar testPoint: vec2<f32>;\nvar sampledAlpha: f32;\nlet passes: u32 = u32(clamp(shaderParams.width / shaderParams.precisionStep, 1.0, f32(SAMPLES)));\nlet sampleCount: u32 = u32(clamp(shaderParams.samples, 0.0, f32(SAMPLES)));\nfor (var j: u32 = 0u; j <= passes; j = j + 1u) {\nwidthCopy = mix(0.0, shaderParams.width, f32(j) / f32(passes));\nactualWidth = widthCopy * texelSize;\nangle = 0.0;\nfor (var i: u32 = 0u; i < sampleCount; i = i + 1u) {\nangle = angle + 1.0 / (f32(sampleCount) / 2.0) * PI;\ntestPoint = input.fragUV + actualWidth * vec2<f32>(cos(angle), sin(angle));\nsampledAlpha = textureSample(textureFront, samplerFront, testPoint).a; // Assuming 'samplerFrontSampler' is the sampler associated with 'samplerFront'\noutlineAlpha = max(outlineAlpha, sampledAlpha);\n}\n}\nfragColor = color * outlineAlpha * shaderParams.outlineOpacity;\nvar tex0 : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV );\noutput.color = fragColor * (1. - tex0.a) + tex0;\nreturn output;\n}",
        blendsBackground: false,
        usesDepth: false,
        extendBoxHorizontal: 50,
        extendBoxVertical: 50,
        crossSampling: true,
        mustPreDraw: true,
        preservesOpaqueness: false,
        supports3dDirectRendering: false,
        animated: false,
        parameters: [["outlinecolor", 0, "color"], ["width", 0, "float"], ["precisionStep", 0, "float"], ["samples", 0, "float"], ["outlineOpacity", 0, "percent"]]
      };
      self["C3_Shaders"]["blurvertical"] = {
        glsl: "varying mediump vec2 vTex;\nuniform mediump sampler2D samplerFront;\nuniform mediump vec2 pixelSize;\nuniform mediump float intensity;\nvoid main(void)\n{\nmediump vec4 sum = vec4(0.0);\nmediump float pixelHeight = pixelSize.y;\nmediump float halfPixelHeight = pixelHeight / 2.0;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\nmediump vec4 front = texture2D(samplerFront, vTex);\nsum += front * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\ngl_FragColor = mix(front, sum, intensity);\n}",
        glslWebGL2: "",
        wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nintensity : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar pixelHeight : f32 = c3_getPixelSize(textureFront).y;\nvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\nvar sum : vec4<f32> =\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 7.5)) * 0.06 +\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 5.5)) * 0.10 +\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 3.5)) * 0.13 +\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 1.5)) * 0.16 +\nfront * 0.10 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 1.5)) * 0.16 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 3.5)) * 0.13 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 5.5)) * 0.10 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 7.5)) * 0.06;\nvar output : FragmentOutput;\noutput.color = mix(front, sum, shaderParams.intensity);\nreturn output;\n}",
        blendsBackground: false,
        usesDepth: false,
        extendBoxHorizontal: 0,
        extendBoxVertical: 8,
        crossSampling: false,
        mustPreDraw: false,
        preservesOpaqueness: false,
        supports3dDirectRendering: false,
        animated: false,
        parameters: [["intensity", 0, "percent"]]
      };
      self["C3_Shaders"]["blurhorizontal"] = {
        glsl: "varying mediump vec2 vTex;\nuniform mediump sampler2D samplerFront;\nuniform mediump vec2 pixelSize;\nuniform mediump float intensity;\nvoid main(void)\n{\nmediump vec4 sum = vec4(0.0);\nmediump float pixelWidth = pixelSize.x;\nmediump float halfPixelWidth = pixelWidth / 2.0;\nsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 7.0 + halfPixelWidth, 0.0)) * 0.06;\nsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 5.0 + halfPixelWidth, 0.0)) * 0.10;\nsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 3.0 + halfPixelWidth, 0.0)) * 0.13;\nsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 1.0 + halfPixelWidth, 0.0)) * 0.16;\nmediump vec4 front = texture2D(samplerFront, vTex);\nsum += front * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 1.0 + halfPixelWidth, 0.0)) * 0.16;\nsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 3.0 + halfPixelWidth, 0.0)) * 0.13;\nsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 5.0 + halfPixelWidth, 0.0)) * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 7.0 + halfPixelWidth, 0.0)) * 0.06;\ngl_FragColor = mix(front, sum, intensity);\n}",
        glslWebGL2: "",
        wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nintensity : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar pixelWidth : f32 = c3_getPixelSize(textureFront).x;\nvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\nvar sum : vec4<f32> =\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 7.5, 0.0)) * 0.06 +\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 5.5, 0.0)) * 0.10 +\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 3.5, 0.0)) * 0.13 +\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 1.5, 0.0)) * 0.16 +\nfront * 0.10 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 1.5, 0.0)) * 0.16 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 3.5, 0.0)) * 0.13 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 5.5, 0.0)) * 0.10 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 7.5, 0.0)) * 0.06;\nvar output : FragmentOutput;\noutput.color = mix(front, sum, shaderParams.intensity);\nreturn output;\n}",
        blendsBackground: false,
        usesDepth: false,
        extendBoxHorizontal: 8,
        extendBoxVertical: 0,
        crossSampling: false,
        mustPreDraw: false,
        preservesOpaqueness: false,
        supports3dDirectRendering: false,
        animated: false,
        parameters: [["intensity", 0, "percent"]]
      };
      self["C3_Shaders"]["radialblur"] = {
        glsl: "precision mediump float;\nvarying vec2 vTex;\nuniform sampler2D samplerFront;\nuniform vec2 srcStart;\nuniform vec2 srcEnd;\nuniform float devicePixelRatio;\nuniform float layerScale;\nuniform float intensity;\nuniform float radius;\nvoid main(void)\n{\nvec2 dir = ((srcStart + srcEnd) / 2.0 - vTex) / (length(srcEnd - srcStart) / 2.0);\nfloat dist = sqrt(dir.x*dir.x + dir.y*dir.y);\ndir = dir/dist;\nvec4 front = texture2D(samplerFront, vTex);\nvec4 sum = front;\nfloat scaledRadius = radius * devicePixelRatio * layerScale;\nsum += texture2D(samplerFront, vTex + dir * -0.08 * scaledRadius);\nsum += texture2D(samplerFront, vTex + dir * -0.05 * scaledRadius);\nsum += texture2D(samplerFront, vTex + dir * -0.03 * scaledRadius);\nsum += texture2D(samplerFront, vTex + dir * -0.02 * scaledRadius);\nsum += texture2D(samplerFront, vTex + dir * -0.01 * scaledRadius);\nsum += texture2D(samplerFront, vTex + dir * 0.01 * scaledRadius);\nsum += texture2D(samplerFront, vTex + dir * 0.02 * scaledRadius);\nsum += texture2D(samplerFront, vTex + dir * 0.03 * scaledRadius);\nsum += texture2D(samplerFront, vTex + dir * 0.05 * scaledRadius);\nsum += texture2D(samplerFront, vTex + dir * 0.08 * scaledRadius);\nsum /= 11.0;\nfloat t = dist * 2.2;\nt = clamp(t, 0.0, 1.0);\ngl_FragColor = mix(front, mix(front, sum, t), intensity);\n}",
        glslWebGL2: "",
        wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nradius : f32,\nintensity : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3PARAMS_STRUCT%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\nvar dir : vec2<f32> = ((c3Params.srcStart + c3Params.srcEnd) / 2.0 - input.fragUV) / (length(c3Params.srcEnd - c3Params.srcStart) / 2.0);\nvar dist : f32 = length(dir);\ndir = dir / dist;\nvar scaledRadius = shaderParams.radius * c3Params.devicePixelRatio * c3Params.layerScale;\nvar sum : vec4<f32> =\nfront +\ntextureSample(textureFront, samplerFront, input.fragUV + dir * -0.08 * scaledRadius) +\ntextureSample(textureFront, samplerFront, input.fragUV + dir * -0.05 * scaledRadius) +\ntextureSample(textureFront, samplerFront, input.fragUV + dir * -0.03 * scaledRadius) +\ntextureSample(textureFront, samplerFront, input.fragUV + dir * -0.02 * scaledRadius) +\ntextureSample(textureFront, samplerFront, input.fragUV + dir * -0.01 * scaledRadius) +\ntextureSample(textureFront, samplerFront, input.fragUV + dir *  0.01 * scaledRadius) +\ntextureSample(textureFront, samplerFront, input.fragUV + dir *  0.02 * scaledRadius) +\ntextureSample(textureFront, samplerFront, input.fragUV + dir *  0.03 * scaledRadius) +\ntextureSample(textureFront, samplerFront, input.fragUV + dir *  0.05 * scaledRadius) +\ntextureSample(textureFront, samplerFront, input.fragUV + dir *  0.08 * scaledRadius);\nsum = sum / 11.0;\nvar t : f32 = clamp(dist * 2.2, 0.0, 1.0);\nvar output : FragmentOutput;\noutput.color = mix(front, mix(front, sum, t), shaderParams.intensity);\nreturn output;\n}",
        blendsBackground: false,
        usesDepth: false,
        extendBoxHorizontal: 50,
        extendBoxVertical: 50,
        crossSampling: false,
        mustPreDraw: false,
        preservesOpaqueness: false,
        supports3dDirectRendering: false,
        animated: false,
        parameters: [["radius", 0, "percent"], ["intensity", 0, "percent"]]
      };
    }
    {
      {
        let ForEachOrdered_SortInstances2 = function(e2, t2) {
          const n2 = e2[1], r3 = t2[1];
          if ("number" == typeof n2 && "number" == typeof r3) return n2 - r3;
          {
            const e3 = "" + n2, t3 = "" + r3;
            return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
          }
        };
        ForEachOrdered_SortInstances = ForEachOrdered_SortInstances2;
        const e = self.C3;
        let t = null, n = "", r2 = "", a2 = [], i2 = "", s2 = "", o2 = "";
        const u = e.New(e.ArrayStack);
        e.Plugins.System = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2), this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack(), this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._imagesLoadingTotal = 0, this._imagesLoadingComplete = 0, this._functionMaps = /* @__PURE__ */ new Map();
          }
          Release() {
            super.Release();
          }
          UpdateRender() {
            this._runtime.UpdateRender();
          }
          Trigger(e2) {
            this._runtime.Trigger(e2, null, null);
          }
          GetRegex(e2, a3) {
            return t && e2 === n && a3 === r2 || (t = new RegExp(e2, a3), n = e2, r2 = a3), t.lastIndex = 0, t;
          }
          GetRegexMatches(e2, t2, n2) {
            if (e2 === i2 && t2 === s2 && n2 === o2) return a2;
            const r3 = this.GetRegex(t2, n2);
            return a2 = e2.match(r3), i2 = e2, s2 = t2, o2 = n2, a2;
          }
          async _LoadTexturesForObjectClasses(t2, n2) {
            if (!n2.length) return;
            this._imagesLoadingTotal += n2.length;
            const r3 = [];
            for (const e2 of n2) r3.push(t2.MaybeLoadTexturesFor(e2));
            await e.PromiseAllWithProgress(r3, () => {
              this._imagesLoadingComplete++;
            }), this._imagesLoadingComplete++, this._imagesLoadingComplete === this._imagesLoadingTotal && (this._imagesLoadingComplete = 0, this._imagesLoadingTotal = 0, this._runtime.Trigger(e.Plugins.System.Cnds.OnImageLoadingComplete, null, null));
          }
          GetImageLoadingProgress() {
            return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal;
          }
          _UnloadTexturesForObjectClasses(e2, t2) {
            for (const n2 of t2) 0 === n2.GetInstanceCount() && e2.MaybeUnloadTexturesFor(n2);
          }
          _GetForEachStack() {
            return u;
          }
          _Repeat(e2) {
            const t2 = this._runtime.GetEventSheetManager(), n2 = t2.GetEventStack(), r3 = n2.GetCurrentStackFrame(), a3 = r3.GetCurrentEvent(), i3 = a3.GetSolModifiers(), s3 = r3.IsSolModifierAfterCnds(), o3 = n2.Push(a3), u2 = t2.GetLoopStack(), l2 = u2.Push();
            if (l2.SetEnd(e2), s3) for (let n3 = 0; n3 < e2 && !l2.IsStopped(); ++n3) t2.PushCopySol(i3), l2.SetIndex(n3), a3.Retrigger(r3, o3), t2.PopSol(i3);
            else for (let t3 = 0; t3 < e2 && !l2.IsStopped(); ++t3) l2.SetIndex(t3), a3.Retrigger(r3, o3);
            return n2.Pop(), u2.Pop(), false;
          }
          *_DebugRepeat(e2) {
            const t2 = this._runtime.GetEventSheetManager(), n2 = t2.GetEventStack(), r3 = n2.GetCurrentStackFrame(), a3 = r3.GetCurrentEvent(), i3 = a3.GetSolModifiers(), s3 = r3.IsSolModifierAfterCnds(), o3 = n2.Push(a3), u2 = t2.GetLoopStack(), l2 = u2.Push();
            if (l2.SetEnd(e2), s3) for (let n3 = 0; n3 < e2 && !l2.IsStopped(); ++n3) t2.PushCopySol(i3), l2.SetIndex(n3), yield* a3.DebugRetrigger(r3, o3), t2.PopSol(i3);
            else for (let t3 = 0; t3 < e2 && !l2.IsStopped(); ++t3) l2.SetIndex(t3), yield* a3.DebugRetrigger(r3, o3);
            return n2.Pop(), u2.Pop(), false;
          }
          _While() {
            const e2 = this._runtime.GetEventSheetManager(), t2 = e2.GetEventStack(), n2 = t2.GetCurrentStackFrame(), r3 = n2.GetCurrentEvent(), a3 = r3.GetSolModifiers(), i3 = n2.IsSolModifierAfterCnds(), s3 = t2.Push(r3), o3 = e2.GetLoopStack(), u2 = o3.Push();
            if (i3) for (let t3 = 0; !u2.IsStopped(); ++t3) e2.PushCopySol(a3), u2.SetIndex(t3), r3.Retrigger(n2, s3) || u2.Stop(), e2.PopSol(a3);
            else for (let e3 = 0; !u2.IsStopped(); ++e3) u2.SetIndex(e3), r3.Retrigger(n2, s3) || u2.Stop();
            return t2.Pop(), o3.Pop(), false;
          }
          *_DebugWhile() {
            const e2 = this._runtime.GetEventSheetManager(), t2 = e2.GetEventStack(), n2 = t2.GetCurrentStackFrame(), r3 = n2.GetCurrentEvent(), a3 = r3.GetSolModifiers(), i3 = n2.IsSolModifierAfterCnds(), s3 = t2.Push(r3), o3 = e2.GetLoopStack(), u2 = o3.Push();
            if (i3) for (let t3 = 0; !u2.IsStopped(); ++t3) {
              e2.PushCopySol(a3), u2.SetIndex(t3);
              (yield* r3.DebugRetrigger(n2, s3)) || u2.Stop(), e2.PopSol(a3);
            }
            else for (let e3 = 0; !u2.IsStopped(); ++e3) {
              u2.SetIndex(e3);
              (yield* r3.DebugRetrigger(n2, s3)) || u2.Stop();
            }
            return t2.Pop(), o3.Pop(), false;
          }
          _For(e2, t2, n2) {
            const r3 = this._runtime.GetEventSheetManager(), a3 = r3.GetEventStack(), i3 = a3.GetCurrentStackFrame(), s3 = i3.GetCurrentEvent(), o3 = s3.GetSolModifiers(), u2 = i3.IsSolModifierAfterCnds(), l2 = a3.Push(s3), c2 = r3.GetLoopStack(), h = c2.Push();
            if (h.SetName(e2), h.SetEnd(n2), n2 < t2) if (u2) for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) r3.PushCopySol(o3), h.SetIndex(e3), s3.Retrigger(i3, l2), r3.PopSol(o3);
            else for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) h.SetIndex(e3), s3.Retrigger(i3, l2);
            else if (u2) for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) r3.PushCopySol(o3), h.SetIndex(e3), s3.Retrigger(i3, l2), r3.PopSol(o3);
            else for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) h.SetIndex(e3), s3.Retrigger(i3, l2);
            return a3.Pop(), c2.Pop(), false;
          }
          *_DebugFor(e2, t2, n2) {
            const r3 = this._runtime.GetEventSheetManager(), a3 = r3.GetEventStack(), i3 = a3.GetCurrentStackFrame(), s3 = i3.GetCurrentEvent(), o3 = s3.GetSolModifiers(), u2 = i3.IsSolModifierAfterCnds(), l2 = a3.Push(s3), c2 = r3.GetLoopStack(), h = c2.Push();
            if (h.SetName(e2), h.SetEnd(n2), n2 < t2) if (u2) for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) r3.PushCopySol(o3), h.SetIndex(e3), yield* s3.DebugRetrigger(i3, l2), r3.PopSol(o3);
            else for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) h.SetIndex(e3), yield* s3.DebugRetrigger(i3, l2);
            else if (u2) for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) r3.PushCopySol(o3), h.SetIndex(e3), yield* s3.DebugRetrigger(i3, l2), r3.PopSol(o3);
            else for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) h.SetIndex(e3), yield* s3.DebugRetrigger(i3, l2);
            return a3.Pop(), c2.Pop(), false;
          }
          _ForEach(t2) {
            const n2 = t2.GetCurrentSol(), r3 = n2.GetInstances();
            if (0 === r3.length) return false;
            const a3 = this._runtime.GetEventSheetManager(), i3 = a3.GetEventStack(), s3 = i3.GetCurrentStackFrame(), o3 = s3.GetCurrentEvent(), l2 = o3.GetSolModifiers(), c2 = s3.IsSolModifierAfterCnds(), h = i3.Push(o3), g = a3.GetLoopStack(), S = g.Push(), d2 = t2.IsInContainer(), p = u.Push();
            if (e.shallowAssignArray(p, r3), S.SetEnd(p.length), c2) for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {
              a3.PushCopySol(l2);
              const n4 = p[e2];
              t2.GetCurrentSol().SetSinglePicked(n4), d2 && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), o3.Retrigger(s3, h), a3.PopSol(l2);
            }
            else {
              n2._SetSelectAll(false);
              const t3 = n2._GetOwnInstances();
              e.clearArray(t3), t3.push(null);
              for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {
                const n4 = p[e2];
                t3[0] = n4, d2 && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), o3.Retrigger(s3, h);
              }
            }
            return i3.Pop(), g.Pop(), e.clearArray(p), u.Pop(), false;
          }
          *_DebugForEach(t2) {
            const n2 = t2.GetCurrentSol(), r3 = n2.GetInstances();
            if (0 === r3.length) return false;
            const a3 = this._runtime.GetEventSheetManager(), i3 = a3.GetEventStack(), s3 = i3.GetCurrentStackFrame(), o3 = s3.GetCurrentEvent(), l2 = o3.GetSolModifiers(), c2 = s3.IsSolModifierAfterCnds(), h = i3.Push(o3), g = a3.GetLoopStack(), S = g.Push(), d2 = t2.IsInContainer(), p = u.Push();
            if (e.shallowAssignArray(p, r3), S.SetEnd(p.length), c2) for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {
              a3.PushCopySol(l2);
              const n4 = p[e2];
              t2.GetCurrentSol().SetSinglePicked(n4), d2 && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), yield* o3.DebugRetrigger(s3, h), a3.PopSol(l2);
            }
            else {
              n2._SetSelectAll(false);
              const t3 = n2._GetOwnInstances();
              e.clearArray(t3), t3.push(null);
              for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {
                const n4 = p[e2];
                t3[0] = n4, d2 && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), yield* o3.DebugRetrigger(s3, h);
              }
            }
            return i3.Pop(), g.Pop(), e.clearArray(p), u.Pop(), false;
          }
          _ForEachOrdered(t2, n2) {
            const r3 = t2.GetCurrentSol(), a3 = r3.GetInstances();
            if (0 === a3.length) return false;
            const i3 = this._runtime.GetEventSheetManager(), s3 = i3.GetEventStack(), o3 = i3.GetCurrentCondition(), l2 = s3.GetCurrentStackFrame(), c2 = l2.GetCurrentEvent(), h = c2.GetSolModifiers(), g = l2.IsSolModifierAfterCnds(), S = s3.Push(c2), d2 = i3.GetLoopStack(), p = d2.Push(), m = t2.IsInContainer(), G = u.Push();
            e.clearArray(G), p.SetEnd(a3.length);
            for (let e2 = 0, t3 = a3.length; e2 < t3; ++e2) G.push([a3[e2], o3.ReevaluateParameter(1, e2)]);
            if (G.sort(ForEachOrdered_SortInstances2), 1 === n2 && G.reverse(), g) for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {
              i3.PushCopySol(h);
              const n4 = G[e2][0];
              t2.GetCurrentSol().SetSinglePicked(n4), m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), c2.Retrigger(l2, S), i3.PopSol(h);
            }
            else {
              r3._SetSelectAll(false);
              const t3 = r3._GetOwnInstances();
              e.clearArray(t3), t3.push(null);
              for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {
                const n4 = G[e2][0];
                t3[0] = n4, m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), c2.Retrigger(l2, S);
              }
            }
            return s3.Pop(), d2.Pop(), e.clearArray(G), u.Pop(), false;
          }
          *_DebugForEachOrdered(t2, n2) {
            const r3 = t2.GetCurrentSol(), a3 = r3.GetInstances();
            if (0 === a3.length) return false;
            const i3 = this._runtime.GetEventSheetManager(), s3 = i3.GetEventStack(), o3 = i3.GetCurrentCondition(), l2 = s3.GetCurrentStackFrame(), c2 = l2.GetCurrentEvent(), h = c2.GetSolModifiers(), g = l2.IsSolModifierAfterCnds(), S = s3.Push(c2), d2 = i3.GetLoopStack(), p = d2.Push(), m = t2.IsInContainer(), G = u.Push();
            e.clearArray(G), p.SetEnd(a3.length);
            for (let e2 = 0, t3 = a3.length; e2 < t3; ++e2) G.push([a3[e2], o3.ReevaluateParameter(1, e2)]);
            if (G.sort(ForEachOrdered_SortInstances2), 1 === n2 && G.reverse(), g) for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {
              i3.PushCopySol(h);
              const n4 = G[e2][0];
              t2.GetCurrentSol().SetSinglePicked(n4), m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), yield* c2.DebugRetrigger(l2, S), i3.PopSol(h);
            }
            else {
              r3._SetSelectAll(false);
              const t3 = r3._GetOwnInstances();
              e.clearArray(t3), t3.push(null);
              for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {
                const n4 = G[e2][0];
                t3[0] = n4, m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), yield* c2.DebugRetrigger(l2, S);
              }
            }
            return s3.Pop(), d2.Pop(), e.clearArray(G), u.Pop(), false;
          }
          _GetFunctionMap(e2, t2) {
            let n2 = this._functionMaps.get(e2);
            return n2 || (t2 ? (n2 = { defaultFunc: null, strMap: /* @__PURE__ */ new Map() }, this._functionMaps.set(e2, n2), n2) : null);
          }
          _DoCallMappedFunction(e2, t2, n2, r3, a3) {
            t2.GetEventBlock().RunAsMappedFunctionCall(n2, t2.IsCopyPicked()), r3 && e2.PopSol(a3);
          }
          *_DebugDoCallMappedFunction(e2, t2, n2, r3, a3) {
            yield* t2.GetEventBlock().DebugRunAsMappedFunctionCall(n2, t2.IsCopyPicked()), r3 && e2.PopSol(a3);
          }
        };
      }
      {
        const l2 = self.C3;
        l2.Plugins.System.Type = class extends l2.DefendedBase {
          constructor(e) {
            super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();
          }
          OnCreate() {
          }
          Release() {
            this._objectClass = null, this._runtime = null, this._plugin = null;
          }
        };
      }
      {
        const c2 = self.C3;
        c2.Plugins.System.Instance = class extends c2.DefendedBase {
          constructor(e, t) {
            super(), this._inst = e, this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._runtime = this._inst.GetRuntime();
          }
          Release() {
            this._inst = null, this._objectClass = null, this._sdkType = null, this._runtime = null;
          }
        };
      }
      {
        const h = self.C3, g = [];
        h.Plugins.System.Cnds = { EveryTick: () => true, OnLayoutStart: () => true, OnLayoutEnd: () => true, OnSuspend: () => true, OnResume: () => true, IsSuspended() {
          return this._runtime.IsSuspended();
        }, Else() {
          const e = this._runtime.GetCurrentEventStackFrame();
          return !e.GetElseBranchRan() && !e.GetLastEventTrue();
        }, TriggerOnce() {
          const e = this._runtime.GetCurrentCondition().GetSavedDataMap();
          let t = e.get("TriggerOnce_lastTick");
          void 0 === t && (t = -1, e.set("TriggerOnce_lastTick", -1));
          const n = this._runtime.GetTickCount();
          return e.set("TriggerOnce_lastTick", n), this._runtime.IsLayoutFirstTick() || t !== n - 1;
        }, Every(e) {
          const t = this._runtime.GetCurrentCondition().GetSavedDataMap(), n = t.get("Every_lastTime") || 0, r2 = this._runtime.GetGameTime();
          t.has("Every_seconds") || t.set("Every_seconds", e);
          const a2 = t.get("Every_seconds");
          return r2 >= n + a2 ? (t.set("Every_lastTime", n + a2), r2 >= t.get("Every_lastTime") + 0.04 && t.set("Every_lastTime", r2), t.set("Every_seconds", e), true) : (r2 < n - 0.1 && t.set("Every_lastTime", r2), false);
        }, IsGroupActive(e) {
          const t = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
          return t && t.IsGroupActive();
        }, IsPreview() {
          return this._runtime.IsPreview();
        }, IsMobile: () => h.Platform.IsMobile, OnLoadFinished: () => true, OnCanvasSnapshot: () => true, EffectsSupported: () => true, OnSaveComplete: () => true, OnSaveFailed: () => true, OnLoadComplete: () => true, OnLoadFailed: () => true, ObjectUIDExists(e) {
          return !!this._runtime.GetInstanceByUID(e);
        }, IsOnPlatform(e) {
          switch (e) {
            case 0:
              return "browser" === h.Platform.Context;
            case 1:
              return "iOS" === h.Platform.OS;
            case 2:
              return "Android" === h.Platform.OS;
            case 8:
              return "cordova" === h.Platform.Context;
            case 9:
              return "scirra-arcade" === this._runtime.GetExportType();
            case 10:
              return "nwjs" === h.Platform.Context;
            case 13:
              return "windows-uwp" === this._runtime.GetExportType();
            default:
              return false;
          }
        }, RegexTest(e, t, n) {
          return this.GetRegex(t, n).test(e);
        }, Compare: (e, t, n) => h.compare(e, t, n), CompareBetween: (e, t, n) => e >= t && e <= n, CompareVar: (e, t, n) => h.compare(e.GetValue(), t, n), CompareBoolVar: (e) => !!e.GetValue(), CompareTime(e, t) {
          const n = this._runtime.GetGameTime();
          if (0 === e) {
            const e2 = this._runtime.GetCurrentCondition().GetSavedDataMap();
            return !e2.get("CompareTime_executed") && n >= t && (e2.set("CompareTime_executed", true), true);
          }
          return h.compare(n, e, t);
        }, IsNaN: (e) => isNaN(e), AngleWithin: (e, t, n) => h.angleDiff(h.toRadians(e), h.toRadians(n)) <= h.toRadians(t), IsClockwiseFrom: (e, t) => h.angleClockwise(h.toRadians(e), h.toRadians(t)), IsBetweenAngles(e, t, n) {
          let r2 = h.toRadians(e), a2 = h.toRadians(t), i2 = h.toRadians(n);
          return !h.angleClockwise(i2, a2) ? !(!h.angleClockwise(r2, a2) && h.angleClockwise(r2, i2)) : h.angleClockwise(r2, a2) && !h.angleClockwise(r2, i2);
        }, IsValueType: (e, t) => "number" == typeof e ? 0 === t : 1 === t, EvaluateExpression: (e) => !!e, OnSignal(e) {
          return e.toLowerCase() === this._runtime.GetEventSheetManager().GetCurrentSignalTag();
        }, PickByComparison(e, t, n, r2) {
          if (!e) return false;
          const a2 = this._GetForEachStack(), i2 = a2.Push(), s2 = e.GetCurrentSol();
          h.shallowAssignArray(i2, s2.GetInstances()), s2.IsSelectAll() && h.clearArray(s2._GetOwnElseInstances());
          const o2 = this._runtime.GetCurrentCondition();
          let u = 0;
          for (let e2 = 0, a3 = i2.length; e2 < a3; ++e2) {
            const a4 = i2[e2];
            i2[u] = a4, t = o2.ReevaluateParameter(1, e2), r2 = o2.ReevaluateParameter(3, e2), h.compare(t, n, r2) ? ++u : s2._PushElseInstance(a4);
          }
          h.truncateArray(i2, u), s2.SetArrayPicked(i2);
          const l2 = !!i2.length;
          return h.clearArray(i2), a2.Pop(), e.ApplySolToContainer(), l2;
        }, PickByEvaluate(e, t) {
          if (!e) return false;
          const n = this._GetForEachStack(), r2 = n.Push(), a2 = e.GetCurrentSol();
          h.shallowAssignArray(r2, a2.GetInstances()), a2.IsSelectAll() && h.clearArray(a2._GetOwnElseInstances());
          const i2 = this._runtime.GetCurrentCondition();
          let s2 = 0;
          for (let e2 = 0, t2 = r2.length; e2 < t2; ++e2) {
            const t3 = r2[e2];
            r2[s2] = t3, i2.ReevaluateParameter(1, e2) ? ++s2 : a2._PushElseInstance(t3);
          }
          h.truncateArray(r2, s2), a2.SetArrayPicked(r2);
          const o2 = !!r2.length;
          return h.clearArray(r2), n.Pop(), e.ApplySolToContainer(), o2;
        }, PickByHighestLowestValue(e, t, n) {
          if (!e) return false;
          const r2 = e.GetCurrentSol(), a2 = r2.GetInstances();
          if (0 === a2.length) return false;
          const i2 = this._runtime.GetCurrentCondition();
          let s2 = null, o2 = 0;
          for (let e2 = 0, r3 = a2.length; e2 < r3; ++e2) {
            const r4 = a2[e2];
            n = i2.ReevaluateParameter(2, e2), (null === s2 || 0 === t && n < o2 || 1 === t && n > o2) && (o2 = n, s2 = r4);
          }
          return r2.PickOne(s2), e.ApplySolToContainer(), true;
        }, PickNth(e, t) {
          if (!e) return false;
          const n = e.GetCurrentSol(), r2 = n.GetInstances();
          if ((t = Math.floor(t)) >= r2.length) return false;
          const a2 = r2[t];
          return n.PickOne(a2), e.ApplySolToContainer(), true;
        }, PickRandom(e) {
          if (!e) return false;
          const t = e.GetCurrentSol(), n = t.GetInstances(), r2 = Math.floor(this._runtime.Random() * n.length);
          if (r2 >= n.length) return false;
          const a2 = n[r2];
          return t.PickOne(a2), e.ApplySolToContainer(), true;
        }, PickAll(e) {
          if (!e) return false;
          if (!e.GetInstanceCount()) return false;
          return e.GetCurrentSol()._SetSelectAll(true), e.ApplySolToContainer(), true;
        }, PickOverlappingPoint(e, t, n) {
          if (!e) return false;
          const r2 = e.GetCurrentSol(), a2 = r2.GetInstances(), i2 = this._runtime.GetCurrentEvent().IsOrBlock(), s2 = this._runtime.GetCurrentCondition().IsInverted();
          r2.IsSelectAll() ? (h.shallowAssignArray(g, a2), r2.ClearArrays(), r2._SetSelectAll(false)) : i2 ? (h.shallowAssignArray(g, r2._GetOwnElseInstances()), h.clearArray(r2._GetOwnElseInstances())) : (h.shallowAssignArray(g, r2._GetOwnInstances()), h.clearArray(r2._GetOwnInstances()));
          for (let e2 = 0, a3 = g.length; e2 < a3; ++e2) {
            const a4 = g[e2];
            h.xor(a4.GetWorldInfo().ContainsPoint(t, n), s2) ? r2._PushInstance(a4) : r2._PushElseInstance(a4);
          }
          return e.ApplySolToContainer(), h.xor(!!r2._GetOwnInstances().length, s2);
        }, PickLastCreated(e) {
          if (!e) return false;
          const t = e.IsFamily();
          let n = null;
          const r2 = this._runtime._GetInstancesPendingCreate();
          for (let a2 = r2.length - 1; a2 >= 0; --a2) {
            const i2 = r2[a2];
            if (t) {
              if (i2.GetObjectClass().BelongsToFamily(e)) {
                n = i2;
                break;
              }
            } else if (i2.GetObjectClass() === e) {
              n = i2;
              break;
            }
          }
          if (!n) {
            const t2 = e.GetInstances();
            t2.length && (n = t2.at(-1));
          }
          if (!n) return false;
          return e.GetCurrentSol().PickOne(n), e.ApplySolToContainer(), true;
        }, Repeat(e) {
          return this._runtime.IsDebugging() ? this._DebugRepeat(e) : this._Repeat(e);
        }, While() {
          return this._runtime.IsDebugging() ? this._DebugWhile() : this._While();
        }, For(e, t, n) {
          return this._runtime.IsDebugging() ? this._DebugFor(e, t, n) : this._For(e, t, n);
        }, ForEach(e) {
          return this._runtime.IsDebugging() ? this._DebugForEach(e) : this._ForEach(e);
        }, ForEachOrdered(e, t, n) {
          return this._runtime.IsDebugging() ? this._DebugForEachOrdered(e, n) : this._ForEachOrdered(e, n);
        }, LayerVisible: (e) => !!e && e.IsVisible(), LayerInteractive: (e) => !!e && e.IsSelfAndParentsInteractive(), LayerIsHTML: (e) => !!e && e.IsHTMLElementsLayer(), LayerEmpty: (e) => !!e && !e.GetInstanceCount(), LayerCmpOpacity: (e, t, n) => !!e && h.compare(100 * e.GetOpacity(), t, n), LayerNameExists(e) {
          const t = this._runtime.GetMainRunningLayout();
          return !!t && t.HasLayerByName(e);
        }, OnImageLoadingComplete: () => true, IsLoadingImages() {
          return this._imagesLoadingTotal > 0;
        }, TemplateExists(e, t) {
          const n = this._runtime.GetTemplateManager();
          return !!n && (!!t && !!n.GetTemplateData(e, t));
        } };
      }
      {
        let SortZOrderList2 = function(e, t) {
          const n = e[0] - t[0];
          if (0 !== n) return n;
          return e[1] - t[1];
        }, SortInstancesByValue2 = function(e, t) {
          return e[1] - t[1];
        };
        SortZOrderList = SortZOrderList2, SortInstancesByValue = SortInstancesByValue2;
        const S = self.C3;
        const d2 = [], p = [], m = S.New(S.Rect), G = S.New(S.Color), y = [];
        S.Plugins.System.Acts = { SetVar(e, t) {
          e.SetValue(t);
        }, AddVar(e, t) {
          e.IsNumber() && "number" != typeof t && (t = parseFloat(t)), e.SetValue(e.GetValue() + t);
        }, SubVar(e, t) {
          e.IsNumber() && e.SetValue(e.GetValue() - t);
        }, SetBoolVar(e, t) {
          e.SetValue(!!t);
        }, ToggleBoolVar(e) {
          e.SetValue(!e.GetValue());
        }, ResetEventVar(e) {
          e.SetValue(e.GetInitialValue());
        }, ResetGlobals(e) {
          this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue(e);
        }, CreateObject(e, t, n, r2, a2, i2) {
          if (!e || !t) return;
          const s2 = this._runtime.CreateInstance(e, t, n, r2, a2, i2);
          if (!s2) return;
          a2 && t.SortAndAddInstancesByZIndex(s2);
          const o2 = this._runtime.GetEventSheetManager();
          o2.BlockFlushingInstances(true), s2._TriggerOnCreatedOnSelfAndRelated(), o2.BlockFlushingInstances(false);
          const u = /* @__PURE__ */ new Map();
          s2.CollectInstancesToPick(u, e, a2);
          for (const [e2, t2] of u) e2.GetCurrentSol().SetSetPicked(t2);
        }, CreateObjectByName(e, t, n, r2, a2, i2) {
          if (!e || !t) return;
          const s2 = this._runtime.GetObjectClassByName(e);
          s2 && S.Plugins.System.Acts.CreateObject.call(this, s2, t, n, r2, a2, i2);
        }, RecreateInitialObjects(e, t, n, r2, a2, i2, s2, o2, u, l2, c2) {
          if (!e) return;
          const h = this._runtime.GetCurrentLayout();
          let g = h;
          if (i2) {
            const e2 = this._runtime.GetLayoutManager().GetLayoutByName(i2);
            if (!e2) return;
            g = e2;
          }
          let S2 = null;
          if (("number" != typeof s2 || s2 >= 0) && (S2 = g.GetLayer(s2), !S2)) return;
          let d3 = null;
          if (("number" != typeof o2 || o2 >= 0) && (d3 = h.GetLayer(o2), !d3)) return;
          m.set(t, n, r2, a2);
          const p2 = g.RecreateInitialObjects(e, m, S2, d3, u, l2, c2);
          e.GetCurrentSol().SetArrayPicked(p2), e.ApplySolToContainer();
        }, StopLoop() {
          const e = this._loopStack;
          e.IsInLoop() && e.GetCurrent().Stop();
        }, SetGroupActive(e, t) {
          const n = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
          n && (0 === t ? n.SetGroupActive(false) : 1 === t ? n.SetGroupActive(true) : n.SetGroupActive(!n.IsGroupActive()));
        }, SetTimescale(e) {
          this._runtime.SetTimeScale(e);
        }, SetObjectTimescale(e, t) {
          if (t < 0 && (t = 0), !e) return;
          const n = e.GetCurrentSol().GetInstances();
          for (const e2 of n) e2.SetTimeScale(t);
        }, RestoreObjectTimescale(e) {
          if (!e) return;
          const t = e.GetCurrentSol().GetInstances();
          for (const e2 of t) e2.RestoreTimeScale();
        }, Wait(e, t) {
          if (e < 0) return;
          const n = this._runtime.GetEventSheetManager().AddScheduledWait();
          return t ? n.InitTimer(e) : n.InitWallTimer(e), true;
        }, WaitForSignal(e) {
          return this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(e), true;
        }, WaitForPreviousActions() {
          const e = this._runtime.GetEventSheetManager();
          return e.AddScheduledWait().InitPromise(e.GetPromiseForAllAsyncActions()), true;
        }, Signal(e) {
          this._runtime.GetEventSheetManager().Signal(e);
        }, async SnapshotCanvas(e, t, n, r2, a2, i2) {
          const s2 = this._runtime.GetCanvasManager();
          s2 && (this.UpdateRender(), await s2.SnapshotCanvas(0 === e ? "image/png" : "image/jpeg", t / 100, n, r2, a2, i2), await this._runtime.TriggerAsync(S.Plugins.System.Cnds.OnCanvasSnapshot, null));
        }, SetCanvasSize(e, t) {
          if (e <= 0 || t <= 0) return;
          this._runtime.SetViewportSize(e, t), this._runtime.GetCurrentLayout().BoundScrolling();
          const n = this._runtime.GetCanvasManager();
          n && ("off" === n.GetCurrentFullscreenMode() || this._runtime.SetOriginalViewportSize(e, t), n.SetSize(n.GetLastWidth(), n.GetLastHeight(), true), this._runtime.UpdateRender());
        }, SetFullscreenQuality(e) {
          const t = this._runtime.GetCanvasManager();
          t && "off" !== t.GetCurrentFullscreenMode() && (t.SetFullscreenScalingQuality(0 !== e ? "high" : "low"), t.SetSize(t.GetLastWidth(), t.GetLastHeight(), true));
        }, SaveState(e) {
          this._runtime.SaveToSlot(e);
        }, SaveStateJSON() {
          this._runtime.SaveToJsonString();
        }, LoadState(e) {
          this._runtime.LoadFromSlot(e);
        }, LoadStateJSON(e) {
          this._runtime.LoadFromJsonString(e);
        }, SetHalfFramerateMode(e) {
        }, ResetPersisted() {
          for (const e of this._runtime.GetLayoutManager().GetAllLayouts()) e.ResetPersistData();
        }, SetPixelRounding(e) {
          this._runtime.SetPixelRoundingEnabled(0 !== e);
        }, SetFramerateMinMax(e, t) {
          this._runtime.SetMaxDt(1 / e), this._runtime.SetMinDt(1 / t);
        }, SetDeltaTimeMinMax(e, t) {
          this._runtime.SetMinDt(e), this._runtime.SetMaxDt(t);
        }, SetFramerateMode(e) {
          this._runtime._SetFramerateMode(["vsync", "unlimited-tick", "unlimited-frame"][e]);
        }, SortZOrderByInstVar(e, t) {
          if (!e) return;
          const n = e.GetCurrentSol().GetInstances(), r2 = d2, a2 = p, i2 = this._runtime.GetCurrentLayout(), s2 = e.IsFamily(), o2 = e.GetFamilyIndex();
          for (let e2 = 0, i3 = n.length; e2 < i3; ++e2) {
            const i4 = n[e2], u2 = i4.GetWorldInfo();
            if (!u2) continue;
            let l2;
            l2 = s2 ? i4.GetInstanceVariableValue(t + i4.GetObjectClass().GetFamilyInstanceVariableOffset(o2)) : i4.GetInstanceVariableValue(t), r2.push([u2.GetLayer().GetIndex(), u2.GetZIndex()]), a2.push([i4, l2]);
          }
          if (!r2.length) return;
          r2.sort(SortZOrderList2), a2.sort(SortInstancesByValue2);
          let u = false;
          for (let e2 = 0, t2 = r2.length; e2 < t2; ++e2) {
            const t3 = a2[e2][0], n2 = i2.GetLayerByIndex(r2[e2][0]), s3 = r2[e2][1], o3 = n2._GetInstances();
            o3[s3] !== t3 && (o3[s3] = t3, t3.GetWorldInfo()._SetLayer(n2, true), n2.SetZIndicesChanged(t3), u = true);
          }
          u && this._runtime.UpdateRender(), S.clearArray(d2), S.clearArray(p);
        }, SetCollisionCellSize(e, t) {
          e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0 || !Number.isFinite(e) || !Number.isFinite(t) || this._runtime.GetCollisionEngine().SetCollisionCellSize(e, t);
        }, GoToLayout(e) {
          if (this._runtime.IsLoading()) return;
          const t = this._runtime.GetLayoutManager();
          t.IsPendingChangeMainLayout() || t.ChangeMainLayout(e);
        }, GoToLayoutByName(e) {
          if (this._runtime.IsLoading()) return;
          const t = this._runtime.GetLayoutManager();
          if (t.IsPendingChangeMainLayout()) return;
          const n = t.GetLayoutByName(e);
          n && t.ChangeMainLayout(n);
        }, NextPrevLayout(e) {
          if (this._runtime.IsLoading()) return;
          const t = this._runtime.GetLayoutManager();
          if (t.IsPendingChangeMainLayout()) return;
          const n = t.GetAllLayouts(), r2 = n.indexOf(t.GetMainRunningLayout());
          if (e && 0 === r2) return;
          if (!e && r2 === n.length - 1) return;
          const a2 = n[r2 + (e ? -1 : 1)];
          t.ChangeMainLayout(a2);
        }, RestartLayout() {
          if (this._runtime.IsLoading()) return;
          const e = this._runtime.GetLayoutManager();
          e.IsPendingChangeMainLayout() || (e.ChangeMainLayout(e.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation());
        }, SetLayerVisible(e, t) {
          e && e.SetVisible(t);
        }, SetLayerInteractive(e, t) {
          e && e.SetInteractive(t);
        }, SetLayerHTML(e, t) {
          e && e.SetIsHTMLElementsLayer(t);
        }, SetLayerOpacity(e, t) {
          e && e.SetOpacity(t / 100);
        }, SetLayerScale(e, t) {
          e && e.SetOwnScale(t);
        }, SetLayerScaleRate(e, t) {
          e && e.SetScaleRate(t);
        }, SetLayerAngle(e, t) {
          e && e.SetAngle(S.toRadians(+t));
        }, SetLayerScroll(e, t, n) {
          e && (e.SetOwnScrollPositionEnabled(true), e.SetScrollX(t), e.SetScrollY(n));
        }, RestoreLayerScroll(e) {
          e && e.SetOwnScrollPositionEnabled(false);
        }, SetLayerParallax(e, t, n) {
          e && e.SetParallax(t / 100, n / 100);
        }, SetLayerZElevation(e, t) {
          e && e.SetZElevation(+t);
        }, SetLayerRenderingMode(e, t) {
          e && e.SetRenderAs3D(1 === t);
        }, SetLayerBackground(e, t) {
          if (!e) return;
          G.setFromRgbValue(t), G.clamp();
          const n = e.GetBackgroundColor();
          n.equalsIgnoringAlpha(G) || (n.copyRgb(G), this.UpdateRender());
        }, SetLayerTransparent(e, t) {
          e && e.SetTransparent(t);
        }, SetLayerBlendMode(e, t) {
          e && e.SetBlendMode(t);
        }, SetLayerEffectEnabled(e, t, n) {
          if (!e) return;
          const r2 = e.GetEffectList().GetEffectTypeByName(n);
          if (!r2) return;
          const a2 = 1 === t;
          r2.IsActive() !== a2 && (r2.SetActive(a2), e.UpdateActiveEffects(), this._runtime.UpdateRender());
        }, SetLayerEffectParam(e, t, n, r2) {
          if (!e) return;
          const a2 = e.GetEffectList(), i2 = a2.GetEffectTypeByName(t);
          if (!i2) return;
          n = Math.floor(n);
          const s2 = i2.GetShaderProgram().GetParameterType(n);
          if (!s2) return;
          "color" === s2 ? (G.setFromRgbValue(r2), r2 = G) : "percent" === s2 && (r2 /= 100);
          a2.SetEffectParameter(i2.GetIndex(), n, r2) && i2.IsActive() && this._runtime.UpdateRender();
        }, SetLayerForceOwnTexture(e, t) {
          e && e.SetForceOwnTexture(t);
        }, SetLayoutScale(e) {
          this._runtime.GetCurrentLayout().SetScale(+e);
        }, SetLayoutAngle(e) {
          this._runtime.GetCurrentLayout().SetAngle(S.toRadians(+e));
        }, SetLayoutEffectEnabled(e, t) {
          const n = this._runtime.GetCurrentLayout(), r2 = n.GetEffectList().GetEffectTypeByName(t);
          if (!r2) return;
          const a2 = 1 === e;
          r2.IsActive() !== a2 && (r2.SetActive(a2), n.UpdateActiveEffects(), this._runtime.UpdateRender());
        }, SetLayoutEffectParam(e, t, n) {
          const r2 = this._runtime.GetCurrentLayout().GetEffectList(), a2 = r2.GetEffectTypeByName(e);
          if (!a2) return;
          t = Math.floor(t);
          const i2 = a2.GetShaderProgram().GetParameterType(t);
          if (!i2) return;
          "color" === i2 ? (G.setFromRgbValue(n), n = G) : "percent" === i2 && (n /= 100);
          r2.SetEffectParameter(a2.GetIndex(), t, n) && a2.IsActive() && this._runtime.UpdateRender();
        }, SetLayoutVanishingPoint(e, t) {
          this._runtime.GetCurrentLayout().SetVanishingPointXY(e / 100, t / 100);
        }, SetLayoutProjection(e) {
          const t = this._runtime.GetCurrentLayout();
          0 === e ? t.SetPerspectiveProjection() : t.SetOrthographicProjection();
        }, ScrollX(e) {
          this._runtime.GetCurrentLayout().SetScrollX(e);
        }, ScrollY(e) {
          this._runtime.GetCurrentLayout().SetScrollY(e);
        }, Scroll(e, t) {
          const n = this._runtime.GetCurrentLayout();
          n.SetScrollX(e), n.SetScrollY(t);
        }, ScrollToObject(e) {
          if (!e) return;
          const t = e.GetFirstPicked();
          if (!t) return;
          const n = t.GetWorldInfo();
          if (!n) return;
          const r2 = this._runtime.GetCurrentLayout();
          r2.SetScrollX(n.GetX()), r2.SetScrollY(n.GetY());
        }, AddLayer(e, t, n) {
          const r2 = this._runtime.GetCurrentLayout();
          try {
            r2.AddLayer(e, t, n);
          } catch (e2) {
            console.warn("[Construct] Cannot add layer: ", e2);
          }
        }, MoveLayer(e, t, n) {
          if (!e) return;
          const r2 = this._runtime.GetCurrentLayout();
          try {
            r2.MoveLayer(e, t, n);
          } catch (e2) {
            console.warn("[Construct] Cannot move layer: ", e2);
          }
        }, RemoveLayer(e) {
          if (!e) return;
          this._runtime.GetCurrentLayout().RemoveLayer(e);
        }, RemoveAllDynamicLayers() {
          this._runtime.GetCurrentLayout().RemoveAllDynamicLayers();
        }, async LoadObjectTextures(e) {
          const t = this._runtime.GetMainRunningLayout();
          if (!t || !e || this._runtime.IsLoading()) return;
          const n = e.IsFamily() ? e.GetFamilyMembers() : [e];
          await this._LoadTexturesForObjectClasses(t, n);
        }, async LoadObjectTexturesByName(e) {
          await S.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));
        }, UnloadObjectTextures(e) {
          const t = this._runtime.GetMainRunningLayout();
          if (!t || !e) return;
          const n = e.IsFamily() ? e.GetFamilyMembers() : [e];
          this._UnloadTexturesForObjectClasses(t, n);
        }, UnloadObjectTexturesByName(e) {
          S.Plugins.System.Acts.UnloadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));
        }, UnloadUnusedTextures() {
          const e = this._runtime.GetMainRunningLayout();
          if (!e) return;
          const t = e._GetTextureLoadedObjectTypes();
          this._UnloadTexturesForObjectClasses(e, t);
        }, async LoadLayoutTextures(e) {
          const t = this._runtime.GetMainRunningLayout();
          e && t && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t, e._GetInitialObjectClasses());
        }, async LoadLayoutTexturesByName(e) {
          const t = this._runtime.GetMainRunningLayout(), n = this._runtime.GetLayoutManager().GetLayoutByName(e);
          n && t && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t, n._GetInitialObjectClasses());
        }, SetFunctionReturnValue(e) {
          const t = this._eventStack.GetCurrentExpFuncStackFrame();
          if (t) switch (t.GetFunctionReturnType()) {
            case 1:
              "number" == typeof e && t.SetFunctionReturnValue(e);
              break;
            case 2:
              "string" == typeof e && t.SetFunctionReturnValue(e);
              break;
            case 3:
              t.SetFunctionReturnValue(e);
          }
        }, MapFunction(e, t, n) {
          const r2 = this._GetFunctionMap(e.toLowerCase(), true), a2 = r2.strMap, i2 = t.toLowerCase();
          a2.has(i2) && console.warn(`[Construct] Function map '${e}' string '${t}' already in map; overwriting entry`);
          const s2 = S.first(a2.values()) || r2.defaultFunc;
          if (s2) {
            if (0 !== s2.GetReturnType() !== (0 !== n.GetReturnType())) return void console.error(`[Construct] Function map '${e}' string '${t}' function return type not compatible with other functions in the map; entry ignored`);
          }
          a2.set(i2, n);
        }, MapFunctionDefault(e, t) {
          const n = this._GetFunctionMap(e.toLowerCase(), true);
          n.defaultFunc && console.warn(`[Construct] Function map '${e}' already has a default; overwriting entry`);
          const r2 = S.first(n.strMap.values()) || n.defaultFunc;
          if (r2) {
            if (0 !== r2.GetReturnType() !== (0 !== t.GetReturnType())) return void console.error(`[Construct] Function map '${e}' default: function return type not compatible with other functions in the map; entry ignored`);
          }
          n.defaultFunc = t;
        }, CallMappedFunction(e, t, n) {
          const r2 = this._runtime, a2 = r2.IsDebugging() ? y : null;
          n = Math.floor(n);
          const i2 = this._GetFunctionMap(e.toLowerCase(), false);
          if (!i2) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; call ignored`), a2;
          let s2 = i2.strMap.get(t.toLowerCase());
          if (!s2) {
            if (!i2.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t}'; call ignored (consider setting a default)`), a2;
            s2 = i2.defaultFunc, n = 0;
          }
          if (!s2.IsEnabled()) return a2;
          if (0 !== s2.GetReturnType()) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t}' has a return type so cannot be called`), a2;
          const o2 = r2.GetEventSheetManager(), u = o2.GetCurrentEvent(), l2 = u.GetSolModifiersIncludingParents(), c2 = l2.length > 0;
          c2 && (s2.IsCopyPicked() ? o2.PushCopySol(l2) : o2.PushCleanSol(l2));
          const h = [], g = o2.FindFirstFunctionBlockParent(u);
          if (g) {
            const e2 = g.GetFunctionParameters();
            for (let t2 = n, r3 = e2.length; t2 < r3; ++t2) h.push(e2[t2].GetValue());
          }
          const S2 = s2.GetFunctionParameters();
          for (let e2 = h.length, t2 = S2.length; e2 < t2; ++e2) h.push(S2[e2].GetInitialValue());
          return r2.IsDebugging() ? this._DebugDoCallMappedFunction(o2, s2, h, c2, l2) : this._DoCallMappedFunction(o2, s2, h, c2, l2);
        } };
      }
      {
        const f2 = self.C3;
        f2.Plugins.System.Exps = { int: function(e) {
          return "string" == typeof e && (e = parseInt(e, 10), isNaN(e) && (e = 0)), Math.floor(e);
        }, float: function(e) {
          return "string" == typeof e && (e = parseFloat(e), isNaN(e) && (e = 0)), e;
        }, str: (e) => e.toString(), len: (e) => "string" == typeof e ? e.length : 0, random(e, t) {
          return void 0 === t ? this._runtime.Random() * e : this._runtime.Random() * (t - e) + e;
        }, choose(...e) {
          return e[Math.floor(this._runtime.Random() * e.length)];
        }, chooseindex: (e, ...t) => ("number" != typeof e && (e = 0), t[e = f2.clamp(Math.floor(e), 0, t.length - 1)]), pi: () => Math.PI, infinity: () => 1 / 0, sqrt: (e) => Math.sqrt(e), abs: (e) => Math.abs(e), round: (e) => Math.round(e), roundtodp(e, t) {
          t = Math.max(Math.floor(t), 0);
          const n = Math.pow(10, t);
          return Math.round((e + Number.EPSILON) * n) / n;
        }, floor: (e) => Math.floor(e), ceil: (e) => Math.ceil(e), sign: (e) => Math.sign(e), sin: (e) => Math.sin(f2.toRadians(e)), cos: (e) => Math.cos(f2.toRadians(e)), tan: (e) => Math.tan(f2.toRadians(e)), asin: (e) => f2.toDegrees(Math.asin(e)), acos: (e) => f2.toDegrees(Math.acos(e)), atan: (e) => f2.toDegrees(Math.atan(e)), exp: (e) => Math.exp(e), ln: (e) => Math.log(e), log10: (e) => Math.log10(e), max(...e) {
          let t = e[0];
          "number" != typeof t && (t = 0);
          for (let n = 1, r2 = e.length; n < r2; ++n) {
            let r3 = e[n];
            "number" == typeof r3 && (t < r3 && (t = r3));
          }
          return t;
        }, min(...e) {
          let t = e[0];
          "number" != typeof t && (t = 0);
          for (let n = 1, r2 = e.length; n < r2; ++n) {
            let r3 = e[n];
            "number" == typeof r3 && (t > r3 && (t = r3));
          }
          return t;
        }, clamp: (e, t, n) => f2.clamp(e, t, n), distance: (e, t, n, r2) => f2.distanceTo(e, t, n, r2), angle: (e, t, n, r2) => f2.toDegrees(f2.angleTo(e, t, n, r2)), lerp: (e, t, n) => f2.lerp(e, t, n), unlerp: (e, t, n) => f2.unlerp(e, t, n), qarp: (e, t, n, r2) => f2.qarp(e, t, n, r2), cubic: (e, t, n, r2, a2) => f2.cubic(e, t, n, r2, a2), cosp: (e, t, n) => f2.cosp(e, t, n), anglediff: (e, t) => f2.toDegrees(f2.angleDiff(f2.toRadians(e), f2.toRadians(t))), anglelerp: (e, t, n) => f2.toDegrees(f2.angleLerp(f2.toRadians(e), f2.toRadians(t), n)), anglerotate: (e, t, n) => f2.toDegrees(f2.angleRotate(f2.toRadians(e), f2.toRadians(t), f2.toRadians(n))), setbit: (e, t, n) => (e |= 0) & ~(1 << (t |= 0)) | (n = 0 !== n ? 1 : 0) << t, togglebit: (e, t) => (e |= 0) ^ 1 << (t |= 0), getbit: (e, t) => (e |= 0) & 1 << (t |= 0) ? 1 : 0, newline: () => "\n", uppercase: (e) => "string" == typeof e ? e.toUpperCase() : "", lowercase: (e) => "string" == typeof e ? e.toLowerCase() : "", left: (e, t) => "string" == typeof e ? e.substr(0, t) : "", mid: (e, t, n) => "string" != typeof e ? "" : n < 0 ? e.substr(t) : e.substr(t, n), right: (e, t) => "string" == typeof e ? e.substr(Math.max(e.length - t, 0)) : "", trim: (e) => "string" == typeof e ? e.trim() : "", tokenat(e, t, n) {
          if ("string" != typeof e || "string" != typeof n) return "";
          let r2 = e.split(n);
          return (t = Math.floor(t)) < 0 || t >= r2.length ? "" : r2[t];
        }, tokencount: (e, t) => "string" == typeof e && "string" == typeof t && e.length ? e.split(t).length : 0, find: (e, t) => "string" == typeof e && "string" == typeof t ? e.search(new RegExp(f2.EscapeRegex(t), "i")) : -1, findcase: (e, t) => "string" == typeof e && "string" == typeof t ? e.search(new RegExp(f2.EscapeRegex(t), "")) : -1, replace: (e, t, n) => "string" == typeof e && "string" == typeof t && "string" == typeof n ? e.replace(new RegExp(f2.EscapeRegex(t), "gi"), n) : "string" == typeof e ? e : "", stringsub(e, ...t) {
          let n = e;
          for (let e2 = 0, r2 = t.length; e2 < r2; ++e2) n = n.replaceAll(`{${e2}}`, t[e2].toString());
          return n;
        }, regexsearch(e, t, n) {
          const r2 = this.GetRegex(t, n);
          return e ? e.search(r2) : -1;
        }, regexreplace(e, t, n, r2) {
          const a2 = this.GetRegex(t, n);
          return e ? e.replace(a2, r2) : "";
        }, regexmatchcount(e, t, n) {
          const r2 = this.GetRegexMatches(e.toString(), t, n);
          return r2 ? r2.length : 0;
        }, regexmatchat(e, t, n, r2) {
          r2 = Math.floor(r2);
          const a2 = this.GetRegexMatches(e.toString(), t, n);
          return !a2 || r2 < 0 || r2 >= a2.length ? "" : a2[r2];
        }, zeropad(e, t) {
          let n = e < 0 ? "-" : "";
          e < 0 && (e = -e);
          const r2 = t - e.toString().length;
          return n += "0".repeat(Math.max(r2, 0)), n + e.toString();
        }, urlencode: (e) => encodeURIComponent(e), urldecode: (e) => decodeURIComponent(e), dt() {
          return this._runtime._GetDtFast();
        }, wallclockdt() {
          return this._runtime.GetDt1();
        }, timescale() {
          return this._runtime.GetTimeScale();
        }, wallclocktime() {
          return (Date.now() - this._runtime.GetStartTime()) / 1e3;
        }, unixtime: () => Date.now(), time() {
          return this._runtime.GetGameTime();
        }, tickcount() {
          return this._runtime.GetTickCount();
        }, objectcount() {
          return this._runtime.GetObjectCount();
        }, fps() {
          return this._runtime.GetFramesPerSecond();
        }, cpuutilisation() {
          return this._runtime.GetMainThreadTime();
        }, gpuutilisation() {
          return this._runtime.GetGPUUtilisation();
        }, windowwidth() {
          return this._runtime.GetCanvasManager().GetDeviceWidth();
        }, windowheight() {
          return this._runtime.GetCanvasManager().GetDeviceHeight();
        }, originalwindowwidth() {
          return this._runtime.GetOriginalViewportWidth();
        }, originalwindowheight() {
          return this._runtime.GetOriginalViewportHeight();
        }, originalviewportwidth() {
          return this._runtime.GetOriginalViewportWidth();
        }, originalviewportheight() {
          return this._runtime.GetOriginalViewportHeight();
        }, scrollx() {
          return this._runtime.GetCurrentLayout().GetScrollX();
        }, scrolly() {
          return this._runtime.GetCurrentLayout().GetScrollY();
        }, layoutname() {
          return this._runtime.GetCurrentLayout().GetName();
        }, layoutscale() {
          return this._runtime.GetCurrentLayout().GetScale();
        }, layoutangle() {
          return f2.toDegrees(this._runtime.GetCurrentLayout().GetAngle());
        }, layoutwidth() {
          return this._runtime.GetCurrentLayout().GetWidth();
        }, layoutheight() {
          return this._runtime.GetCurrentLayout().GetHeight();
        }, vanishingpointx() {
          return 100 * this._runtime.GetCurrentLayout().GetVanishingPointX();
        }, vanishingpointy() {
          return 100 * this._runtime.GetCurrentLayout().GetVanishingPointY();
        }, viewportleft(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().getLeft() : 0;
        }, viewporttop(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().getTop() : 0;
        }, viewportright(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().getRight() : 0;
        }, viewportbottom(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().getBottom() : 0;
        }, viewportwidth(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().width() : 0;
        }, viewportheight(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().height() : 0;
        }, viewportmidx(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          if (t) {
            const e2 = t.GetViewport3D();
            return (e2.getLeft() + e2.getRight()) / 2;
          }
          return 0;
        }, viewportmidy(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          if (t) {
            const e2 = t.GetViewport3D();
            return (e2.getTop() + e2.getBottom()) / 2;
          }
          return 0;
        }, canvastolayerx(e, t, n) {
          const r2 = this._runtime.GetCurrentLayout().GetLayer(e);
          return r2 ? r2.CanvasCssToLayer(t, n)[0] : 0;
        }, canvastolayery(e, t, n) {
          const r2 = this._runtime.GetCurrentLayout().GetLayer(e);
          return r2 ? r2.CanvasCssToLayer(t, n)[1] : 0;
        }, layertocanvasx(e, t, n) {
          const r2 = this._runtime.GetCurrentLayout().GetLayer(e);
          return r2 ? r2.LayerToCanvasCss(t, n)[0] : 0;
        }, layertocanvasy(e, t, n) {
          const r2 = this._runtime.GetCurrentLayout().GetLayer(e);
          return r2 ? r2.LayerToCanvasCss(t, n)[1] : 0;
        }, layertolayerx(e, t, n, r2) {
          const a2 = this._runtime.GetCurrentLayout(), i2 = a2.GetLayer(e), s2 = a2.GetLayer(t);
          if (!i2 || !s2 || i2 === s2) return n;
          const [o2, u] = i2.LayerToCanvasCss(n, r2);
          return s2.CanvasCssToLayer(o2, u)[0];
        }, layertolayery(e, t, n, r2) {
          const a2 = this._runtime.GetCurrentLayout(), i2 = a2.GetLayer(e), s2 = a2.GetLayer(t);
          if (!i2 || !s2 || i2 === s2) return r2;
          const [o2, u] = i2.LayerToCanvasCss(n, r2);
          return s2.CanvasCssToLayer(o2, u)[1];
        }, layerscale(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetOwnScale() : 0;
        }, layerangle(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? f2.toDegrees(t.GetOwnAngle()) : 0;
        }, layeropacity(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? 100 * t.GetOpacity() : 0;
        }, layerscalerate(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetScaleRate() : 0;
        }, layerscrollx(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetScrollX() : 0;
        }, layerscrolly(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetScrollY() : 0;
        }, layerparallaxx(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? 100 * t.GetParallaxX() : 0;
        }, layerparallaxy(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? 100 * t.GetParallaxY() : 0;
        }, layerzelevation(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetZElevation() : 0;
        }, layerindex(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetIndex() : -1;
        }, canvassnapshot() {
          const e = this._runtime.GetCanvasManager();
          return e ? e.GetCanvasSnapshotUrl() : "";
        }, loopindex(e) {
          const t = this._loopStack;
          if (!t.IsInLoop()) return 0;
          if (e) {
            const n = t.FindByName(e);
            return n ? n.GetIndex() : 0;
          }
          return t.GetCurrent().GetIndex();
        }, savestatejson() {
          return this._runtime.GetLastSaveJsonString();
        }, callmapped(e, t, ...n) {
          const r2 = this._GetFunctionMap(e.toLowerCase(), false);
          if (!r2) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; returning 0`), 0;
          let a2 = r2.strMap.get(t.toLowerCase());
          if (!a2) {
            if (!r2.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t}'; returning 0 (consider setting a default)`), 0;
            a2 = r2.defaultFunc;
          }
          const i2 = a2.GetReturnType(), s2 = a2.GetDefaultReturnValue();
          if (0 === i2) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t}' has no return type so cannot be called from an expression; returning 0`), 0;
          if (!a2.IsEnabled()) return s2;
          const o2 = this._runtime.GetEventSheetManager(), u = o2.GetCurrentEvent().GetSolModifiersIncludingParents(), l2 = u.length > 0;
          l2 && (a2.IsCopyPicked() ? o2.PushCopySol(u) : o2.PushCleanSol(u));
          const c2 = a2.GetFunctionParameters();
          for (let e2 = n.length, t2 = c2.length; e2 < t2; ++e2) n.push(c2[e2].GetInitialValue());
          const h = a2.GetEventBlock(), g = h.RunAsExpressionFunctionCall(h.GetSolModifiersIncludingParents(), a2.IsCopyPicked(), i2, s2, ...n);
          return l2 && o2.PopSol(u), g;
        }, loadingprogress() {
          return this._runtime.GetAssetManager().GetLoadProgress();
        }, imageloadingprogress() {
          return this.GetImageLoadingProgress();
        }, renderer() {
          return this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl";
        }, rendererdetail() {
          return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();
        }, imagememoryusage() {
          let e = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();
          return Math.round(100 * e / 1048576) / 100;
        }, rgb: (e, t, n) => f2.PackRGB(e, t, n), rgbex: (e, t, n) => f2.PackRGBEx(e / 100, t / 100, n / 100), rgba: (e, t, n, r2) => f2.PackRGBAEx(e / 100, t / 100, n / 100, r2 / 100), rgbex255: (e, t, n) => f2.PackRGBEx(e / 255, t / 255, n / 255), rgba255: (e, t, n, r2) => f2.PackRGBAEx(e / 255, t / 255, n / 255, r2 / 255), projectname() {
          return this._runtime.GetProjectName();
        }, projectversion() {
          return this._runtime.GetProjectVersion();
        }, projectid() {
          return this._runtime.GetAppId();
        }, projectuniqueid() {
          return this._runtime.GetProjectUniqueId();
        }, currenteventsheetname() {
          return this._runtime.GetCurrentEvent().GetEventSheet().GetName();
        }, currenteventnumber() {
          return this._runtime.GetCurrentEvent().GetDisplayNumber();
        } };
      }
    }
    var ForEachOrdered_SortInstances;
    var SortZOrderList;
    var SortInstancesByValue;
    {
      {
        const e = self.C3;
        e.Plugins.AdvancedRandom = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        let GetSdkInstance2 = function() {
          return a2.GetSingleGlobalInstance().GetSdkInstance();
        };
        GetSdkInstance = GetSdkInstance2;
        const t = self.C3, r2 = self.C3X;
        t.Plugins.AdvancedRandom.Type = class extends t.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
          GetScriptInterfaceClass() {
            return self.IAdvancedRandomObjectType;
          }
        };
        const i2 = /* @__PURE__ */ new Set(["rgb", "float"]);
        let a2 = null;
        self.IAdvancedRandomObjectType = class extends self.IObjectType {
          constructor(e) {
            super(e), a2 = e;
          }
          set seed(e) {
            r2.RequireString(e), GetSdkInstance2()._UpdateSeed(e);
          }
          get seed() {
            return GetSdkInstance2()._GetCurrentSeed();
          }
          set octaves(e) {
            r2.RequireFiniteNumber(e), GetSdkInstance2()._SetOctaves(e);
          }
          get octaves() {
            return GetSdkInstance2()._GetOctaves();
          }
          classic2d(e, t2) {
            return r2.RequireNumber(e), r2.RequireNumber(t2), GetSdkInstance2()._GetClassic2d(e, t2);
          }
          classic3d(e, t2, i3) {
            return r2.RequireNumber(e), r2.RequireNumber(t2), r2.RequireNumber(i3), GetSdkInstance2()._GetClassic3d(e, t2, i3);
          }
          billow2d(e, t2) {
            return r2.RequireNumber(e), r2.RequireNumber(t2), GetSdkInstance2()._GetBillow2d(e, t2);
          }
          billow3d(e, t2, i3) {
            return r2.RequireNumber(e), r2.RequireNumber(t2), r2.RequireNumber(i3), GetSdkInstance2()._GetBillow3d(e, t2, i3);
          }
          ridged2d(e, t2) {
            return r2.RequireNumber(e), r2.RequireNumber(t2), GetSdkInstance2()._GetRidged2d(e, t2);
          }
          ridged3d(e, t2, i3) {
            return r2.RequireNumber(e), r2.RequireNumber(t2), r2.RequireNumber(i3), GetSdkInstance2()._GetRidged3d(e, t2, i3);
          }
          cellular2d(e, t2) {
            return r2.RequireNumber(e), r2.RequireNumber(t2), GetSdkInstance2()._GetCellular2d(e, t2);
          }
          cellular3d(e, t2, i3) {
            return r2.RequireNumber(e), r2.RequireNumber(t2), r2.RequireNumber(i3), GetSdkInstance2()._GetCellular3d(e, t2, i3);
          }
          voronoi2d(e, t2) {
            return r2.RequireNumber(e), r2.RequireNumber(t2), GetSdkInstance2()._GetVoronoi2d(e, t2);
          }
          voronoi3d(e, t2, i3) {
            return r2.RequireNumber(e), r2.RequireNumber(t2), r2.RequireNumber(i3), GetSdkInstance2()._GetVoronoi3d(e, t2, i3);
          }
          createGradient(e, t2) {
            if (r2.RequireString(e), !i2.has(t2)) throw new Error("invalid mode");
            GetSdkInstance2()._CreateGradient(e, t2);
          }
          setCurrentGradient(e) {
            r2.RequireString(e), GetSdkInstance2()._SetGradient(e);
          }
          addGradientStop(e, t2) {
            r2.RequireNumber(e), r2.RequireNumber(t2), GetSdkInstance2()._AddGradientStop(e, t2);
          }
          sampleGradient(e, t2) {
            return r2.RequireOptionalString(e), r2.RequireNumber(t2), e ? GetSdkInstance2()._SampleGradientByName(e, t2) : GetSdkInstance2()._SampleCurrentGradient(t2);
          }
          createProbabilityTable(e) {
            r2.RequireString(e), GetSdkInstance2()._CreateProbabilityTable(e);
          }
          createProbabilityTableFromJSON(e, t2) {
            r2.RequireString(e), r2.RequireString(t2), GetSdkInstance2()._CreateProbabilityTableFromJSON(e, t2);
          }
          getProbabilityTableAsJSON() {
            return GetSdkInstance2()._GetProbabilityTableAsJSON();
          }
          setCurrentProbabilityTable(e) {
            r2.RequireString(e), GetSdkInstance2()._SetProbabilityTable(e);
          }
          addProbabilityTableEntry(e, t2) {
            if (r2.RequireNumber(e), "number" != typeof t2 && "string" != typeof t2) throw new TypeError("invalid value");
            GetSdkInstance2()._AddProbabilityEntry(e, t2);
          }
          removeProbabilityTableEntry(e, t2) {
            if (r2.RequireNumber(e), "number" != typeof t2 && "string" != typeof t2) throw new TypeError("invalid value");
            GetSdkInstance2()._RemoveProbabilityEntry(e, t2);
          }
          sampleProbabilityTable(e) {
            return r2.RequireOptionalString(e), e ? GetSdkInstance2()._SampleProbabilityTableByName(e) : GetSdkInstance2()._SampleCurrentProbabilityTable();
          }
          createPermutationTable(e, t2) {
            r2.RequireFiniteNumber(e), r2.RequireNumber(t2), GetSdkInstance2()._CreatePermutationTable(e, t2);
          }
          shufflePermutationTable() {
            GetSdkInstance2()._ShufflePermutationTable();
          }
          getPermutation(e) {
            return r2.RequireFiniteNumber(e), GetSdkInstance2()._GetPermutation(e);
          }
        };
      }
      {
        let shuffle2 = function(e, t) {
          let r2 = e.length;
          for (; r2 > 0; ) {
            const i2 = Math.floor(t(0, r2--)), a2 = e[r2];
            e[r2] = e[i2], e[i2] = a2;
          }
          return e;
        };
        shuffle = shuffle2;
        const n = self.C3;
        class s2 {
          constructor(e, t) {
            this.mode = e, this.name = t, this.stops = [];
          }
          GetName() {
            return this.name;
          }
          AddStop(e, t) {
            switch (this.mode) {
              case "rgb":
                t = this._CreateStopRGB(t);
                break;
              case "float":
                t = this._CreateStopFloat(t);
            }
            let r2 = this.stops.length;
            for (; r2--; ) if (e > this.stops[r2][0]) return void this.stops.splice(r2 + 1, 0, [e, t]);
            this.stops.push([e, t]);
          }
          _CreateStopFloat(e) {
            return [e];
          }
          _CreateStopRGB(e) {
            return [e, n.GetRValue(e), n.GetGValue(e), n.GetBValue(e), n.GetAValue(e)];
          }
          _SampleFloat(e, t, r2) {
            return n.lerp(e[0], t[0], r2);
          }
          _SampleRGB(e, t, r2) {
            return n.PackRGBAEx(n.lerp(e[1], t[1], r2), n.lerp(e[2], t[2], r2), n.lerp(e[3], t[3], r2), n.lerp(e[4], t[4], r2));
          }
          Sample(e) {
            const t = this.stops, r2 = t[0], i2 = t.length, a2 = t[i2 - 1];
            if (e < r2[0]) return r2[1][0];
            if (e > a2[0]) return a2[1][0];
            let s3 = null, l2 = r2;
            for (let r3 = 1; r3 < i2 && (s3 = l2, l2 = t[r3], !(l2[0] > e)); r3++) ;
            switch (e = n.clamp((e - s3[0]) / (l2[0] - s3[0]), 0, 1), this.mode) {
              case "rgb":
                return this._SampleRGB(s3[1], l2[1], e);
              case "float":
                return this._SampleFloat(s3[1], l2[1], e);
            }
          }
          asJSON(e = false) {
            return "rgb" === this.mode ? JSON.stringify(this.stops.map(([t, r2]) => [t, e ? r2.slice(1) : r2[0]])) : JSON.stringify(this.stops);
          }
        }
        n.Plugins.AdvancedRandom.Instance = class extends n.SDKInstanceBase {
          constructor(e, t) {
            super(e), this._currentSeed = "", this._octaves = 1, this._lacunarity = 2, this._persistence = 0.5, this._gradients = /* @__PURE__ */ new Map(), this._probabilityTables = /* @__PURE__ */ new Map(), this._currentGradient = null, this._currentProbabilityTable = null, this._permutation = [0];
            let r2 = t[0];
            this._replaceSystemPRNG = t[1], this._funcs = n.Plugins.AdvancedRandom.NoiseFuncs, this._CreateGradient("default", "rgb"), this._AddGradientStop(0, n.PackRGBEx(0, 0, 0)), this._AddGradientStop(1, n.PackRGBEx(1, 1, 1)), this._CreateProbabilityTable("default"), "" === r2 && (r2 = this._RandomSeed(10)), this._UpdateSeed(r2), this._replaceSystemPRNG && this._runtime.SetRandomNumberGeneratorCallback(() => this._funcs.randomXorshiro(0, 1));
          }
          Release() {
            super.Release();
          }
          SaveToJson() {
            return { "prng": this._funcs.saveToJson() };
          }
          LoadFromJson(e) {
            this._funcs.loadFromJson(e["prng"]);
          }
          _RandomSeed(e) {
            const t = [];
            for (; e--; ) t.push(String.fromCharCode(Math.round(25 * Math.random()) + 65));
            return t.join("");
          }
          _UpdateSeed(e) {
            this._currentSeed = e;
            let t = 5381;
            for (let r2 = 0, i2 = e.length; r2 < i2; r2++) t = (t << 5) + t + e.charCodeAt(r2);
            t >>>= 0, this._funcs.seed(t);
          }
          _GetCurrentSeed() {
            return this._currentSeed;
          }
          _SetOctaves(e) {
            this._octaves = n.clamp(0 | e, 1, 16);
          }
          _GetOctaves() {
            return this._octaves;
          }
          _GetClassic2d(e, t) {
            return this._funcs.classic2d(e, t, this._octaves);
          }
          _GetClassic3d(e, t, r2) {
            return this._funcs.classic3d(e, t, r2, this._octaves);
          }
          _GetBillow2d(e, t) {
            return this._funcs.billow2d(e, t, this._octaves);
          }
          _GetBillow3d(e, t, r2) {
            return this._funcs.billow3d(e, t, r2, this._octaves);
          }
          _GetRidged2d(e, t) {
            return this._funcs.ridged2d(e, t, this._octaves);
          }
          _GetRidged3d(e, t, r2) {
            return this._funcs.ridged3d(e, t, r2, this._octaves);
          }
          _GetCellular2d(e, t) {
            return this._funcs.cellular2d(e, t);
          }
          _GetCellular3d(e, t, r2) {
            return this._funcs.cellular3d(e, t, r2);
          }
          _GetVoronoi2d(e, t) {
            return this._funcs.voronoi2d(e, t);
          }
          _GetVoronoi3d(e, t, r2) {
            return this._funcs.voronoi3d(e, t, r2);
          }
          _CreateGradient(e, t) {
            const r2 = new s2(t, e);
            this._gradients.set(e.toLowerCase(), r2), this._currentGradient = r2;
          }
          _SetGradient(e) {
            this._currentGradient = this._gradients.get(e.toLowerCase()) || null;
          }
          _AddGradientStop(e, t) {
            const r2 = this._currentGradient;
            null !== r2 && r2.AddStop(e, t);
          }
          _SampleCurrentGradient(e) {
            const t = this._currentGradient;
            return t ? t.Sample(e) : 0;
          }
          _SampleGradientByName(e, t) {
            const r2 = this._gradients.get(e.toLowerCase());
            return r2 ? r2.Sample(t) : 0;
          }
          _CreateProbabilityTable(e) {
            const t = new n.ProbabilityTable(e);
            this._probabilityTables.set(e.toLowerCase(), t), this._currentProbabilityTable = t;
          }
          _CreateProbabilityTableFromJSON(e, t) {
            const r2 = n.ProbabilityTable.fromJSON(t, e);
            this._probabilityTables.set(e.toLowerCase(), r2), this._currentProbabilityTable = r2;
          }
          _GetProbabilityTableAsJSON() {
            return this._currentProbabilityTable ? this._currentProbabilityTable.asJSON() : "";
          }
          _SetProbabilityTable(e) {
            this._currentProbabilityTable = this._probabilityTables.get(e.toLowerCase()) || null;
          }
          _AddProbabilityEntry(e, t) {
            const r2 = this._currentProbabilityTable;
            r2 && r2.AddItem(e, t);
          }
          _RemoveProbabilityEntry(e, t) {
            const r2 = this._currentProbabilityTable;
            r2 && r2.RemoveItem(e, t);
          }
          _SampleCurrentProbabilityTable() {
            const e = this._currentProbabilityTable;
            return e ? e.Sample(this._funcs.randomXorshiro(0, e.GetTotalWeight())) : 0;
          }
          _SampleProbabilityTableByName(e) {
            const t = this._probabilityTables.get(e.toLowerCase());
            return t ? t.Sample(this._funcs.randomXorshiro(0, t.GetTotalWeight())) : 0;
          }
          _CreatePermutationTable(e, t) {
            if (e < 2) this._permutation = [t];
            else {
              this._permutation = [];
              for (let r2 = 0; r2 < e; r2++) this._permutation.push(r2 + t);
              shuffle2(this._permutation, this._funcs.randomXorshiro);
            }
          }
          _ShufflePermutationTable() {
            shuffle2(this._permutation, this._funcs.randomXorshiro);
          }
          _GetPermutation(e) {
            e = Math.floor(e);
            const t = this._permutation, r2 = t.length;
            return (e %= r2) < 0 && (e += r2), t[e];
          }
          GetDebuggerProperties() {
            const e = "plugins.advancedrandom.debugger", t = [], r2 = [], i2 = (e2) => e2.toString().replace(/,/g, ", ");
            for (const e2 of this._probabilityTables.values()) {
              const t2 = e2.asJSON();
              r2.push({ name: "$" + e2.GetName(), value: i2(t2.slice(1, -1)) });
            }
            for (const e2 of this._gradients.values()) {
              const r3 = e2.asJSON(true);
              t.push({ name: "$" + e2.GetName(), value: i2(r3.slice(1, -1)) });
            }
            return [{ title: e + ".title", properties: [{ name: e + ".seed", value: this._GetCurrentSeed(), onedit: (e2) => this._UpdateSeed(e2) }, { name: e + ".replace-system", value: this._replaceSystemPRNG }, { name: e + ".noise-octaves", value: this._GetOctaves() }, { name: e + ".noise-lacunarity", value: this._lacunarity }, { name: e + ".noise-persistence", value: this._persistence }, { name: e + ".current-probability-table", value: this._currentProbabilityTable ? this._currentProbabilityTable.GetName() : "" }, { name: e + ".current-gradient", value: this._currentGradient ? this._currentGradient.GetName() : "" }, { name: e + ".permutation-table", value: i2(this._permutation) }] }, { title: e + ".gradients", properties: t }, { title: e + ".probability-tables", properties: r2 }];
          }
        };
      }
      self.C3.Plugins.AdvancedRandom.Cnds = {};
      self.C3.Plugins.AdvancedRandom.Acts = { SetSeed(e) {
        this._UpdateSeed(e);
      }, SetOctaves(e) {
        this._SetOctaves(e);
      }, CreateGradient(e, t) {
        const r2 = ["rgb", "float"][t];
        this._CreateGradient(e, r2);
      }, SetGradient(e) {
        this._SetGradient(e);
      }, AddStop(e, t) {
        this._AddGradientStop(e, t);
      }, CreateProbabilityTable(e) {
        this._CreateProbabilityTable(e);
      }, CreateProbabilityTableFromJSON(e, t) {
        try {
          this._CreateProbabilityTableFromJSON(e, t);
        } catch (e2) {
          console.warn("Failed to create probability table from JSON String", e2);
        }
      }, SetProbabilityTable(e) {
        this._SetProbabilityTable(e);
      }, AddProbabilityEntry(e, t) {
        this._AddProbabilityEntry(t, e);
      }, RemoveProbabilityEntry(e, t) {
        this._RemoveProbabilityEntry(t, e);
      }, CreatePermutationTable(e, t) {
        this._CreatePermutationTable(e, t);
      }, ShufflePermutationTable() {
        this._ShufflePermutationTable();
      } };
      self.C3.Plugins.AdvancedRandom.Exps = { Classic2d(e, t) {
        return this._GetClassic2d(e, t);
      }, Classic3d(e, t, r2) {
        return this._GetClassic3d(e, t, r2);
      }, Billow2d(e, t) {
        return this._GetBillow2d(e, t);
      }, Billow3d(e, t, r2) {
        return this._GetBillow3d(e, t, r2);
      }, Ridged2d(e, t) {
        return this._GetRidged2d(e, t);
      }, Ridged3d(e, t, r2) {
        return this._GetRidged3d(e, t, r2);
      }, Cellular2d(e, t) {
        return this._GetCellular2d(e, t);
      }, Cellular3d(e, t, r2) {
        return this._GetCellular3d(e, t, r2);
      }, Voronoi2d(e, t) {
        return this._GetVoronoi2d(e, t);
      }, Voronoi3d(e, t, r2) {
        return this._GetVoronoi3d(e, t, r2);
      }, Gradient(e) {
        return this._SampleCurrentGradient(e);
      }, GradientByName(e, t) {
        return this._SampleGradientByName(e, t);
      }, Weighted() {
        return this._SampleCurrentProbabilityTable();
      }, WeightedByName(e) {
        return this._SampleProbabilityTableByName(e);
      }, RandomSeed() {
        return this._RandomSeed(10);
      }, Seed() {
        return this._GetCurrentSeed();
      }, Octaves() {
        return this._GetOctaves();
      }, Permutation(e) {
        return this._GetPermutation(e);
      }, ProbabilityTableAsJSON() {
        return this._GetProbabilityTableAsJSON();
      } };
    }
    var GetSdkInstance;
    var shuffle;
    {
      let pickGradient22 = function(t, i2) {
        return permutation[permutation[255 & t] + (255 & i2)];
      }, pickGradient32 = function(t, i2, n) {
        return permutation[permutation[permutation[255 & t] + (255 & i2)] + (255 & n)];
      }, dot22 = function(t, i2, n) {
        const r2 = grads2[t];
        return r2.x * i2 + r2.y * n;
      }, dot32 = function(t, i2, n, r2) {
        const e = grads3[t];
        return e.x * i2 + e.y * n + e.z * r2;
      }, quintic2 = function(t) {
        return 6 * t * t * t * t * t - 15 * t * t * t * t + 10 * t * t * t;
      }, fract2 = function(t) {
        return t % 1;
      }, sq2 = function(t) {
        return t * t;
      }, swap2 = function(t, i2, n) {
        const r2 = t[i2];
        t[i2] = t[n], t[n] = r2;
      }, uint642 = function(t) {
        return BigInt.asUintN(64, t);
      }, splitmix642 = function() {
        splitstate = uint642(splitstate + BigInt("0x9e3779b97f4a7c15"));
        let t = splitstate;
        return t = uint642((t ^ t >> BigInt(30)) * BigInt("0xbf58476d1ce4e5b9")), t = uint642((t ^ t >> BigInt(27)) * BigInt("0x94d049bb133111eb")), uint642(t ^ t >> BigInt(31));
      }, rotl2 = function(t, i2) {
        return uint642(t << i2 | t >> BigInt(64) - i2);
      }, next2 = function() {
        const t = uint642(rotl2(uint642(s2[1] * BigInt(5)), BigInt(7)) * BigInt(9)), i2 = uint642(s2[1] << BigInt(17));
        return s2[2] = uint642(s2[2] ^ s2[0]), s2[3] = uint642(s2[3] ^ s2[1]), s2[1] = uint642(s2[1] ^ s2[2]), s2[0] = uint642(s2[0] ^ s2[3]), s2[2] = uint642(s2[2] ^ i2), s2[3] = rotl2(s2[3], BigInt(45)), t;
      }, nextFloat2 = function() {
        return Number(next2() >> BigInt(11)) / _1_SHL_53;
      };
      pickGradient2 = pickGradient22, pickGradient3 = pickGradient32, dot2 = dot22, dot3 = dot32, quintic = quintic2, fract = fract2, sq = sq2, swap = swap2, uint64 = uint642, splitmix64 = splitmix642, rotl = rotl2, next = next2, nextFloat = nextFloat2;
      const C33 = self.C3, _1_SHL_53 = 9007199254740992;
      let splitstate = BigInt(0), s2 = [BigInt(0), BigInt(0), BigInt(0), BigInt(0)], persistence = 0.5, lacunarity = 2;
      const scale2 = 0.013, tableSize = 256, tableSizeMask = 255, permutation = Array.from({ length: 512 }, () => 0), grads2 = Array.from({ length: 256 }, () => ({ x: 0, y: 0 })), grads3 = Array.from({ length: 256 }, () => ({ x: 0, y: 0, z: 0 }));
      C33.Plugins.AdvancedRandom.NoiseFuncs = { setLacunarity(t) {
        lacunarity = t;
      }, setPersistence(t) {
        persistence = t;
      }, saveToJson: () => ({ "splitstate": splitstate.toString(), "s": s2.map((t) => t.toString()) }), loadFromJson(t) {
        splitstate = BigInt(t["splitstate"]);
        for (let i2 = 0, n = s2.length; i2 < n; ++i2) s2[i2] = BigInt(t["s"][i2]);
      }, noise2d(t, i2) {
        const n = Math.floor(t), r2 = Math.floor(i2), e = t - n, s3 = i2 - r2, a2 = dot22(pickGradient22(n, r2), e, s3), o2 = dot22(pickGradient22(n + 1, r2), e - 1, s3), l2 = dot22(pickGradient22(n, r2 + 1), e, s3 - 1), u = dot22(pickGradient22(n + 1, r2 + 1), e - 1, s3 - 1), c2 = quintic2(e), d2 = quintic2(s3);
        return C33.lerp(C33.lerp(a2, l2, d2), C33.lerp(o2, u, d2), c2);
      }, noise3d(t, i2, n) {
        const r2 = Math.floor(t), e = Math.floor(i2), s3 = Math.floor(n), a2 = t - r2, o2 = i2 - e, l2 = n - s3, u = dot32(pickGradient32(r2, e, s3), a2, o2, l2), c2 = dot32(pickGradient32(r2 + 1, e, s3), a2 - 1, o2, l2), d2 = dot32(pickGradient32(r2, e + 1, s3), a2, o2 - 1, l2), p = dot32(pickGradient32(r2 + 1, e + 1, s3), a2 - 1, o2 - 1, l2), h = dot32(pickGradient32(r2, e, s3 + 1), a2, o2, l2 - 1), f2 = dot32(pickGradient32(r2 + 1, e, s3 + 1), a2 - 1, o2, l2 - 1), M = dot32(pickGradient32(r2, e + 1, s3 + 1), a2, o2 - 1, l2 - 1), g = dot32(pickGradient32(r2 + 1, e + 1, s3 + 1), a2 - 1, o2 - 1, l2 - 1), m = quintic2(a2), b = quintic2(o2), x = quintic2(l2);
        return C33.lerp(C33.lerp(C33.lerp(u, c2, m), C33.lerp(d2, p, m), b), C33.lerp(C33.lerp(h, f2, m), C33.lerp(M, g, m), b), x);
      }, randomXorshiro: (t, i2) => nextFloat2() * (i2 - t) + t, randomSplitMix: (t, i2) => Number(splitmix642() >> 11) / _1_SHL_53 * (i2 - t) + t, seed(t) {
        splitstate = BigInt(t), s2[0] = splitmix642(), s2[1] = splitmix642(), s2[2] = splitmix642(), s2[3] = splitmix642(), splitmix642(), splitmix642();
        for (let t2 = 0; t2 < 256; ++t2) {
          const i2 = nextFloat2(), n = Math.acos(2 * i2 - 1), r2 = 2 * nextFloat2() * Math.PI;
          grads3[t2].x = Math.cos(r2) * Math.sin(n), grads3[t2].y = Math.sin(r2) * Math.sin(n), grads3[t2].z = Math.cos(n), grads2[t2].x = Math.cos(r2), grads2[t2].y = Math.sin(r2), permutation[t2] = t2;
        }
        for (let t2 = 0; t2 < 256; ++t2) swap2(permutation, t2, Number(next2() & BigInt(255)));
        for (let t2 = 0; t2 < 256; ++t2) permutation[256 + t2] = permutation[t2];
      }, classic3d(t, i2, n, r2) {
        if (1 == r2) return 0.5 * (this.noise3d(0.013 * t, 0.013 * i2, 0.013 * n) + 1);
        let e, s3 = 1, a2 = 0.013, o2 = 0, l2 = 0;
        for (let u = 0; u < r2; u++) e = this.noise3d(a2 * t, a2 * i2, a2 * n), o2 += s3 * e, l2 += s3, a2 *= lacunarity, s3 *= persistence;
        return (o2 / l2 + 1) / 2;
      }, billow3d(t, i2, n, r2) {
        if (1 == r2) return Math.abs(this.noise3d(0.013 * t, 0.013 * i2, 0.013 * n));
        let e, s3 = 1, a2 = 0.013, o2 = 0, l2 = 0;
        for (let u = 0; u < r2; u++) e = this.noise3d(a2 * t, a2 * i2, a2 * n), e = Math.abs(e), o2 += s3 * e, l2 += s3, a2 *= lacunarity, s3 *= persistence;
        return o2 / l2;
      }, ridged3d(t, i2, n, r2) {
        if (1 == r2) return sq2(1 - Math.abs(this.noise3d(0.013 * t, 0.013 * i2, 0.013 * n)));
        let e, s3 = 1, a2 = 0.013, o2 = 0, l2 = 0;
        for (let u = 0; u < r2; u++) e = this.noise3d(a2 * t, a2 * i2, a2 * n), e = sq2(1 - Math.abs(e)), o2 += s3 * e, l2 += s3, a2 *= lacunarity, s3 *= persistence;
        return o2 / l2;
      }, classic2d(t, i2, n) {
        if (1 == n) return 0.5 * (this.noise2d(0.013 * t, 0.013 * i2) + 1);
        let r2, e = 1, s3 = 0.013, a2 = 0, o2 = 0;
        for (let l2 = 0; l2 < n; l2++) r2 = this.noise2d(s3 * t, s3 * i2), a2 += e * r2, o2 += e, s3 *= lacunarity, e *= persistence;
        return (a2 / o2 + 1) / 2;
      }, billow2d(t, i2, n) {
        if (1 == n) return Math.abs(this.noise2d(0.013 * t, 0.013 * i2));
        let r2, e = 1, s3 = 0.013, a2 = 0, o2 = 0;
        for (let l2 = 0; l2 < n; l2++) r2 = this.noise2d(s3 * t, s3 * i2), r2 = Math.abs(r2), a2 += e * r2, o2 += e, s3 *= lacunarity, e *= persistence;
        return a2 / o2;
      }, ridged2d(t, i2, n) {
        if (1 == n) return sq2(1 - Math.abs(this.noise2d(0.013 * t, 0.013 * i2)));
        let r2, e = 1, s3 = 0.013, a2 = 0, o2 = 0;
        for (let l2 = 0; l2 < n; l2++) r2 = this.noise2d(s3 * t, s3 * i2), r2 = 1 - Math.abs(r2), r2 *= r2, a2 += e * r2, o2 += e, s3 *= lacunarity, e *= persistence;
        return a2 / o2;
      }, cellular2d(t, i2) {
        t *= 0.013, i2 *= 0.013;
        const n = Math.floor(t), r2 = Math.floor(i2), e = t - n, s3 = i2 - r2;
        let a2 = 1e5;
        for (let t2 = -1; t2 <= 1; t2++) for (let i3 = -1; i3 <= 1; i3++) {
          const o2 = grads2[pickGradient22(n + i3, r2 + t2)], l2 = i3 + Math.abs(o2.x) - e, u = t2 + Math.abs(o2.y) - s3, c2 = l2 * l2 + u * u;
          a2 = Math.min(c2, a2);
        }
        return C33.clamp(Math.sqrt(a2), 0, 1);
      }, cellular3d(t, i2, n) {
        t *= 0.013, i2 *= 0.013, n *= 0.013;
        const r2 = Math.floor(t), e = Math.floor(i2), s3 = Math.floor(n), a2 = t - r2, o2 = i2 - e, l2 = n - s3;
        let u = 1e5;
        for (let t2 = -1; t2 <= 1; t2++) for (let i3 = -1; i3 <= 1; i3++) for (let n2 = -1; n2 <= 1; n2++) {
          const c2 = grads3[pickGradient32(r2 + i3, e + t2, s3 + n2)], d2 = i3 + Math.abs(c2.x) - a2, p = t2 + Math.abs(c2.y) - o2, h = n2 + Math.abs(c2.z) - l2, f2 = d2 * d2 + p * p + h * h;
          u = Math.min(f2, u);
        }
        return C33.clamp(Math.sqrt(u), 0, 1);
      }, voronoi2d(t, i2) {
        t *= 0.013, i2 *= 0.013;
        const n = Math.floor(t), r2 = Math.floor(i2), e = t - n, s3 = i2 - r2;
        let a2, o2 = 1e5;
        for (let t2 = -1; t2 <= 1; t2++) for (let i3 = -1; i3 <= 1; i3++) {
          const l2 = n + i3, u = r2 + t2, c2 = grads2[pickGradient22(l2, u)], d2 = i3 + Math.abs(c2.x) - e, p = t2 + Math.abs(c2.y) - s3, h = d2 * d2 + p * p;
          h < o2 && (o2 = h, a2 = permutation[permutation[255 & l2] + (255 & u)]);
        }
        return a2 / 255;
      }, voronoi3d(t, i2, n) {
        t *= 0.013, i2 *= 0.013, n *= 0.013;
        const r2 = Math.floor(t), e = Math.floor(i2), s3 = Math.floor(n), a2 = t - r2, o2 = i2 - e, l2 = n - s3;
        let u, c2 = 1e5;
        for (let t2 = -1; t2 <= 1; t2++) for (let i3 = -1; i3 <= 1; i3++) for (let n2 = -1; n2 <= 1; n2++) {
          const d2 = r2 + i3, p = e + t2, h = s3 + n2, f2 = grads3[pickGradient32(d2, p, h)], M = i3 + Math.abs(f2.x) - a2, g = t2 + Math.abs(f2.y) - o2, m = n2 + Math.abs(f2.z) - l2, b = M * M + g * g + m * m;
          b < c2 && (c2 = b, u = permutation[permutation[permutation[255 & d2] + (255 & p)] + (255 & h)]);
        }
        return u / 255;
      } };
    }
    var pickGradient2;
    var pickGradient3;
    var dot2;
    var dot3;
    var quintic;
    var fract;
    var sq;
    var swap;
    var uint64;
    var splitmix64;
    var rotl;
    var next;
    var nextFloat;
    {
      {
        const e = self.C3;
        e.Plugins.AJAX = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.AJAX.Type = class extends e.SDKTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.AJAX.Instance = class extends e.SDKInstanceBase {
          constructor(e2, t) {
            if (super(e2), this._lastData = "", this._lastStatusCode = 0, this._curTag = "", this._progress = 0, this._timeout = -1, this._nextRequestHeaders = /* @__PURE__ */ new Map(), this._nextReponseBinaryData = null, this._nextRequestOverrideMimeType = "", this._nextRequestWithCredentials = false, this._nwjsFs = null, this._nwjsPath = null, this._nwjsAppFolder = null, this._isNWjs = this._runtime.IsNWjs(), this._isNWjs) {
              this._nwjsFs = __require("fs"), this._nwjsPath = __require("path");
              const e3 = self["process"] || nw["process"];
              this._nwjsAppFolder = this._nwjsPath["dirname"](e3["execPath"]) + "\\";
            }
          }
          Release() {
            super.Release();
          }
          async _TriggerError(t, s2, r2) {
            console.error(`[Construct] AJAX request to '${s2}' (tag '${t}') failed: `, r2), this._curTag = t, await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnAnyError), this._curTag = t, await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnError);
          }
          async _TriggerComplete(t) {
            this._curTag = t, await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnAnyComplete), this._curTag = t, await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnComplete);
          }
          async _OnProgress(t, s2) {
            s2["lengthComputable"] && (this._progress = s2["loaded"] / s2["total"], this._curTag = t, await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnProgress));
          }
          async _OnUploadProgress(t, s2) {
            s2["lengthComputable"] && (this._progress = s2["loaded"] / s2["total"], this._curTag = t, await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnUploadProgress));
          }
          _OnError(e2, t, s2) {
            if (!this._isNWjs) return void this._TriggerError(e2, t, s2);
            const r2 = this._nwjsFs, a2 = this._nwjsAppFolder + t;
            r2["existsSync"](a2) ? r2["readFile"](a2, { "encoding": "utf8" }, (s3, r3) => {
              s3 ? this._TriggerError(e2, t, s3) : (this._lastData = r3.replace(/\r\n/g, "\n"), this._TriggerComplete(e2));
            }) : this._TriggerError(e2, t, s2);
          }
          async _DoCordovaRequest(e2, t) {
            const s2 = this._runtime.GetAssetManager(), r2 = this._nextReponseBinaryData;
            this._nextReponseBinaryData = null;
            try {
              if (r2) {
                const a2 = await s2.CordovaFetchLocalFileAsArrayBuffer(t);
                r2.SetArrayBufferTransfer(a2), this._lastData = "", this._lastStatusCode = 0, this._TriggerComplete(e2);
              } else {
                const r3 = await s2.CordovaFetchLocalFileAsText(t);
                this._lastData = r3.replace(/\r\n/g, "\n"), this._lastStatusCode = 0, this._TriggerComplete(e2);
              }
            } catch (s3) {
              this._TriggerError(e2, t, s3);
            }
          }
          _DoRequest(e2, t, s2, r2) {
            return new Promise((a2) => {
              const i2 = (s3) => {
                this._OnError(e2, t, s3), a2();
              }, n = this._nextReponseBinaryData;
              this._nextReponseBinaryData = null;
              try {
                const o2 = new XMLHttpRequest();
                o2.onreadystatechange = () => {
                  if (4 === o2.readyState) {
                    if (this._lastData = n ? "" : (o2.responseText || "").replace(/\r\n/g, "\n"), this._lastStatusCode = o2.status, o2.status >= 400) this._TriggerError(e2, t, o2.status + o2.statusText);
                    else {
                      const t2 = this._lastData.length || n && o2.response instanceof ArrayBuffer;
                      this._isNWjs && !t2 || !this._isNWjs && 0 === o2.status && !t2 || (n && n.SetArrayBufferTransfer(o2.response), this._TriggerComplete(e2));
                    }
                    a2();
                  }
                }, o2.onerror = i2, o2.ontimeout = i2, o2.onabort = i2, o2["onprogress"] = (t2) => this._OnProgress(e2, t2), o2["upload"]["onprogress"] = (t2) => this._OnUploadProgress(e2, t2), o2.open(s2, t), this._timeout >= 0 && void 0 !== o2["timeout"] && (o2["timeout"] = this._timeout), o2.responseType = n ? "arraybuffer" : "text", r2 && !this._nextRequestHeaders.has("Content-Type") && ("string" != typeof r2 ? o2["setRequestHeader"]("Content-Type", "application/octet-stream") : o2["setRequestHeader"]("Content-Type", "application/x-www-form-urlencoded"));
                for (const [e3, t2] of this._nextRequestHeaders) try {
                  o2["setRequestHeader"](e3, t2);
                } catch (s3) {
                  console.error(`[Construct] AJAX: Failed to set header '${e3}: ${t2}': `, s3);
                }
                if (this._nextRequestHeaders.clear(), this._nextRequestOverrideMimeType) {
                  try {
                    o2["overrideMimeType"](this._nextRequestOverrideMimeType);
                  } catch (e3) {
                    console.error("[Construct] AJAX: failed to override MIME type: ", e3);
                  }
                  this._nextRequestOverrideMimeType = "";
                }
                this._nextRequestWithCredentials && (o2.withCredentials = true, this._nextRequestWithCredentials = false), r2 ? o2.send(r2) : o2.send();
              } catch (e3) {
                i2(e3);
              }
            });
          }
          GetDebuggerProperties() {
            const e2 = "plugins.ajax.debugger";
            return [{ title: e2 + ".title", properties: [{ name: e2 + ".last-status-code", value: this._lastStatusCode }, { name: e2 + ".last-data", value: this._lastData }] }];
          }
          SaveToJson() {
            return { "lastData": this._lastData, "lastStatusCode": this._lastStatusCode };
          }
          LoadFromJson(e2) {
            this._lastData = e2["lastData"], this._lastStatusCode = e2.hasOwnProperty("lastStatusCode") ? e2["lastStatusCode"] : 0, this._curTag = "", this._progress = 0;
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.AJAX.Cnds = { OnComplete(t) {
          return e.equalsNoCase(this._curTag, t);
        }, OnAnyComplete: () => true, OnError(t) {
          return e.equalsNoCase(this._curTag, t);
        }, OnAnyError: () => true, OnProgress(t) {
          return e.equalsNoCase(this._curTag, t);
        }, OnUploadProgress(t) {
          return e.equalsNoCase(this._curTag, t);
        } };
      }
      {
        const e = self.C3;
        e.Plugins.AJAX.Acts = { async Request(t, s2) {
          this._runtime.IsCordova() && e.IsRelativeURL(s2) && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(t, s2) : await this._DoRequest(t, s2, "GET", null);
        }, async RequestFile(e2, t) {
          this._runtime.IsCordova() && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(e2, t) : await this._DoRequest(e2, t, "GET", null);
        }, async Post(e2, t, s2, r2) {
          await this._DoRequest(e2, t, r2, s2);
        }, async PostBinary(e2, t, s2, r2) {
          if (!s2) return;
          const a2 = s2.GetFirstPicked(this._inst);
          if (!a2) return;
          const i2 = a2.GetSdkInstance().GetArrayBufferReadOnly();
          await this._DoRequest(e2, t, r2, i2);
        }, SetTimeout(e2) {
          this._timeout = 1e3 * e2;
        }, SetHeader(e2, t) {
          this._nextRequestHeaders.set(e2, t);
        }, SetResponseBinary(e2) {
          if (!e2) return;
          const t = e2.GetFirstPicked(this._inst);
          t && (this._nextReponseBinaryData = t.GetSdkInstance());
        }, OverrideMIMEType(e2) {
          this._nextRequestOverrideMimeType = e2;
        }, SetWithCredentials(e2) {
          this._nextRequestWithCredentials = !!e2;
        } };
      }
      self.C3.Plugins.AJAX.Exps = { LastData() {
        return this._lastData;
      }, LastStatusCode() {
        return this._lastStatusCode;
      }, Progress() {
        return this._progress;
      }, Tag() {
        return this._curTag;
      } };
    }
    {
      {
        const t = self.C3, e = [];
        t.Plugins.Audio = class extends t.SDKPluginBase {
          constructor(t2) {
            super(t2);
          }
          _AddActionPromise(t2) {
            e.push(t2);
          }
          static async WaitForAllActionPromises() {
            await Promise.all(e), t.clearArray(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        let GetAudioSdkInstance2 = function() {
          return a2.GetSingleGlobalInstance().GetSdkInstance();
        }, GetAudioDOMInterface2 = function() {
          if (self["C3Audio_DOMInterface"]) return self["C3Audio_DOMInterface"];
          throw new Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
        };
        GetAudioSdkInstance = GetAudioSdkInstance2, GetAudioDOMInterface = GetAudioDOMInterface2;
        const s2 = self.C3, i2 = self.C3X;
        s2.Plugins.Audio.Type = class extends s2.SDKTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
          GetScriptInterfaceClass() {
            return self.IAudioObjectType;
          }
        };
        let a2 = null;
        self.IAudioObjectType = class extends self.IObjectType {
          constructor(t) {
            super(t), a2 = t;
          }
          get audioContext() {
            return GetAudioDOMInterface2()["GetAudioContextExtern"]();
          }
          get destinationNode() {
            return GetAudioDOMInterface2()["GetDestinationNodeExtern"]();
          }
          get isSilent() {
            return GetAudioSdkInstance2()._IsSilent();
          }
          set isSilent(t) {
            GetAudioSdkInstance2()._SetSilent(t);
          }
          get masterVolume() {
            return GetAudioSdkInstance2()._GetMasterVolume();
          }
          set masterVolume(t) {
            i2.RequireFiniteNumber(t), GetAudioSdkInstance2()._SetMasterVolume(t);
          }
          stopAll() {
            GetAudioSdkInstance2()._StopAll();
          }
        };
      }
      {
        const n = self.C3, r2 = "audio", o2 = ["interactive", "balanced", "playback"];
        n.Plugins.Audio.Instance = class extends n.SDKInstanceBase {
          constructor(t, e) {
            super(t, r2), this._nextPlayTime = 0, this._nextPlayOffset = 0, this._triggerTags = [], this._enableMultiTags = true, this._timeScaleMode = 0, this._saveLoadMode = 0, this._playInBackground = false, this._panningModel = 1, this._distanceModel = 1, this._listenerPos = [this._runtime.GetViewportWidth() / 2, this._runtime.GetViewportHeight() / 2, 600], this._listenerForwardVec = [0, 0, -1], this._listenerUpVec = [0, 1, 0], this._referenceDistance = 600, this._maxDistance = 1e4, this._rolloffFactor = 1, this._listenerInst = null, this._loadListenerUid = -1, this._masterVolume = 1, this._isSilent = false, this._sampleRate = 0, this._audioContextState = "suspended", this._outputLatency = 0, this._effectCount = /* @__PURE__ */ new Map(), this._preloadTotal = 0, this._preloadCount = 0, this._bufferMetadata = /* @__PURE__ */ new Map(), this._remoteUrls = /* @__PURE__ */ new Map();
            let s2 = "interactive";
            e && (this._timeScaleMode = e[0], this._saveLoadMode = e[1], this._playInBackground = e[2], s2 = o2[e[3]], this._enableMultiTags = e[4], this._panningModel = e[5], this._distanceModel = e[6], this._listenerPos[2] = e[7], this._referenceDistance = e[8], this._maxDistance = e[9], this._rolloffFactor = e[10]), this._lastAIState = [], this._lastFxState = [], this._lastAnalysersData = [], this.AddDOMMessageHandlers([["state", (t2) => this._OnUpdateState(t2)], ["audiocontext-state", (t2) => this._OnAudioContextStateChanged(t2)], ["fxstate", (t2) => this._OnUpdateFxState(t2)], ["trigger", (t2) => this._OnTrigger(t2)], ["buffer-metadata", (t2) => this._OnBufferMetadata(t2)]]);
            const i2 = this.GetRuntime().Dispatcher();
            this._disposables = new n.CompositeDisposable(n.Disposable.From(i2, "instancedestroy", (t2) => this._OnInstanceDestroyed(t2.instance)), n.Disposable.From(i2, "afterload", () => this._OnAfterLoad()), n.Disposable.From(i2, "suspend", () => this._OnSuspend()), n.Disposable.From(i2, "resume", () => this._OnResume()));
            const a2 = this._runtime.GetExportType(), l2 = "Safari" === n.Platform.Browser, h = this._runtime.IsiOSWebView() || "macos-wkwebview" === a2, u = this._runtime.GetAssetManager().IsFileProtocol(), c2 = "playable-ad-single-file" === a2, d2 = "cordova" === a2 && "Android" === n.Platform.OS, _ = l2 || h || u || c2 || d2;
            this._runtime.AddLoadPromise(this.PostToDOMAsync("create-audio-context", { "preloadList": this._runtime.GetAssetManager().GetAudioToPreload().map((t2) => ({ "originalUrl": t2.originalUrl, "url": t2.url, "type": t2.type, "fileSize": t2.fileSize })), "timeScaleMode": this._timeScaleMode, "latencyHint": s2, "panningModel": this._panningModel, "distanceModel": this._distanceModel, "refDistance": this._referenceDistance, "maxDistance": this._maxDistance, "rolloffFactor": this._rolloffFactor, "listenerPos": this._listenerPos, "usePlayMusicAsSoundWorkaround": _ }).then((t2) => {
              this._sampleRate = t2["sampleRate"], this._audioContextState = t2["audioContextState"], this._outputLatency = t2["outputLatency"];
            })), this._StartTicking();
          }
          Release() {
            this._listenerInst = null, super.Release();
          }
          _SplitTags(t) {
            return this._enableMultiTags ? t.split(" ").filter((t2) => !!t2) : t ? [t] : [];
          }
          _MatchTagLists(t, e) {
            for (const s2 of e) {
              let e2 = false;
              for (const i2 of t) if (n.equalsNoCase(i2, s2)) {
                e2 = true;
                break;
              }
              if (!e2) return false;
            }
            return true;
          }
          _MatchTagListToStr(t, e) {
            return this._MatchTagLists(t, this._SplitTags(e));
          }
          _AddActionPromise(t) {
            this.GetPlugin()._AddActionPromise(t);
          }
          _OnInstanceDestroyed(t) {
            this._listenerInst === t && (this._listenerInst = null);
          }
          DbToLinearNoCap(t) {
            return Math.pow(10, t / 20);
          }
          DbToLinear(t) {
            const e = this.DbToLinearNoCap(t);
            return isFinite(e) ? Math.max(Math.min(e, 1), 0) : 0;
          }
          LinearToDbNoCap(t) {
            return Math.log(t) / Math.log(10) * 20;
          }
          LinearToDb(t) {
            return this.LinearToDbNoCap(Math.max(Math.min(t, 1), 0));
          }
          _GetScheduledPlayInfo() {
            let t = 0;
            const e = !!self["C3_GetAudioContextCurrentTime"];
            return t = e ? this._nextPlayTime : this._nextPlayOffset, this._nextPlayTime = 0, this._nextPlayOffset = 0, { playOffset: t, isTrueClock: e };
          }
          _OnSuspend() {
            this._playInBackground || this.PostToDOM("set-suspended", { "isSuspended": true });
          }
          _OnResume() {
            this._playInBackground || this.PostToDOM("set-suspended", { "isSuspended": false });
          }
          _OnUpdateState(t) {
            const e = t["tickCount"];
            this._outputLatency = t["outputLatency"];
            const s2 = this._lastAIState.filter((t2) => t2.hasOwnProperty("placeholder") && (t2["placeholder"] > e || -1 === t2["placeholder"]));
            this._lastAIState = t["audioInstances"], this._lastAnalysersData = t["analysers"], s2.length > 0 && n.appendArray(this._lastAIState, s2);
          }
          _OnBufferMetadata(t) {
            this._bufferMetadata.set(t["originalUrl"], { duration: t["duration"] });
          }
          _OnAudioContextStateChanged(t) {
            this._audioContextState = t["audioContextState"];
          }
          GetAudioContextState() {
            return this._runtime.IsExportToVideo() ? "running" : this._audioContextState;
          }
          _OnUpdateFxState(t) {
            this._lastFxState = t["fxstate"];
          }
          _GetFirstAudioStateByTags(t) {
            const e = this._SplitTags(t);
            for (const t2 of this._lastAIState) if (this._MatchTagLists(t2["tags"], e)) return t2;
            return null;
          }
          _IsTagPlaying(t) {
            const e = this._SplitTags(t);
            return this._lastAIState.some((t2) => this._MatchTagLists(t2["tags"], e) && t2["isPlaying"]);
          }
          _MaybeMarkAsPlaying(t, e, s2, i2, a2) {
            if (this._IsTagPlaying(e)) return null;
            const n2 = this._bufferMetadata.get(t), r3 = { "tags": this._SplitTags(e), "duration": n2 ? n2.duration : 0, "volume": a2, "isPlaying": true, "playbackTime": 0, "playbackRate": 1, "uid": -1, "bufferOriginalUrl": t, "bufferUrl": "", "bufferType": "", "isMusic": s2, "isLooping": i2, "isMuted": false, "resumePosition": 0, "pan": null, "placeholder": -1 };
            return this._lastAIState.push(r3), r3;
          }
          _MaybeMarkAsStopped(t) {
            const e = this._SplitTags(t);
            for (const t2 of this._lastAIState) this._MatchTagLists(t2["tags"], e) && (t2["isPlaying"] = false);
          }
          async _OnTrigger(t) {
            const e = t["type"];
            this._triggerTags = t["tags"];
            const s2 = t["aiid"];
            if ("ended" === e) {
              for (const t2 of this._lastAIState) if (t2["aiid"] === s2) {
                t2["isPlaying"] = false;
                break;
              }
              await this.TriggerAsync(n.Plugins.Audio.Cnds.OnEnded);
            } else "fade-ended" === e && await this.TriggerAsync(n.Plugins.Audio.Cnds.OnFadeEnded);
          }
          _MatchTriggerTag(t) {
            return this._MatchTagListToStr(this._triggerTags, t);
          }
          Tick() {
            const t = { "timeScale": this._runtime.GetTimeScale(), "gameTime": this._runtime.GetGameTimeRaw(), "instPans": this.GetInstancePans(), "tickCount": this._runtime.GetTickCountNoSave() };
            if (this._listenerInst) {
              const e = this._listenerInst.GetWorldInfo();
              this._listenerPos[0] = e.GetX(), this._listenerPos[1] = e.GetY(), t["listenerPos"] = this._listenerPos, t["listenerOrientation"] = [...this._listenerForwardVec, ...this._listenerUpVec];
            }
            this.PostToDOM("tick", t);
          }
          rotatePtAround(t, e, s2, i2, a2) {
            if (0 === s2) return [t, e];
            const n2 = Math.sin(s2), r3 = Math.cos(s2), o3 = (t -= i2) * n2;
            return t = t * r3 - (e -= a2) * n2, e = e * r3 + o3, [t += i2, e += a2];
          }
          GetInstancePans() {
            return this._lastAIState.filter((t) => -1 !== t["uid"]).map((t) => this._runtime.GetInstanceByUID(t["uid"])).filter((t) => t).map((t) => {
              const e = t.GetWorldInfo(), s2 = e.GetLayer().GetAngle(), [i2, a2] = this.rotatePtAround(e.GetX(), e.GetY(), -s2, this._listenerPos[0], this._listenerPos[1]);
              return { "uid": t.GetUID(), "x": i2, "y": a2, "z": e.GetTotalZElevation(), "angle": e.GetAngle() - s2 };
            });
          }
          GetAnalyserData(t, e) {
            for (const s2 of this._lastAnalysersData) if (s2.index === e && n.equalsNoCase(s2["tag"], t)) return s2;
            return null;
          }
          _IncrementEffectCount(t) {
            for (const e of this._SplitTags(t)) {
              const t2 = e.toLowerCase();
              this._effectCount.set(t2, (this._effectCount.get(t2) || 0) + 1);
            }
          }
          _IsSilent() {
            return this._isSilent;
          }
          _SetSilent(t) {
            t = !!t, this._isSilent !== t && (this._isSilent = t, this.PostToDOM("set-silent", { "isSilent": t }));
          }
          _GetMasterVolume() {
            return this._masterVolume;
          }
          _SetMasterVolume(t) {
            this._masterVolume !== t && (this._masterVolume = t, this.PostToDOM("set-master-volume", { "vol": t }));
          }
          _StopAll() {
            this.PostToDOM("stop-all");
            for (const t of this._lastAIState) t["isPlaying"] = false;
          }
          _ShouldSave(t) {
            return !t.hasOwnProperty("placeholder") && (3 !== this._saveLoadMode && ((!t["isMusic"] || 1 !== this._saveLoadMode) && !(!t["isMusic"] && 2 === this._saveLoadMode)));
          }
          SaveToJson() {
            return { "isSilent": this._isSilent, "masterVolume": this._masterVolume, "listenerZ": this._listenerPos[2], "listenerForwardVec": this._listenerForwardVec, "listenerUpVec": this._listenerUpVec, "listenerUid": this._listenerInst ? this._listenerInst.GetUID() : -1, "remoteUrls": [...this._remoteUrls.entries()], "playing": this._lastAIState.filter((t) => this._ShouldSave(t)), "effects": this._lastFxState, "analysers": this._lastAnalysersData };
          }
          LoadFromJson(t) {
            if (this._isSilent = t["isSilent"], this._masterVolume = t["masterVolume"], this._listenerPos[2] = t["listenerZ"], this._listenerInst = null, this._loadListenerUid = t["listenerUid"], t.hasOwnProperty("listenerForwardVec") ? this._listenerForwardVec = t["listenerForwardVec"] : this._listenerForwardVec = [0, 0, -1], t.hasOwnProperty("listenerUpVec") ? this._listenerUpVec = t["listenerUpVec"] : this._listenerUpVec = [0, 1, 0], this._remoteUrls.clear(), t["remoteUrls"]) for (const [e, s2] of t["remoteUrls"]) this._remoteUrls.set(e, s2);
            this._lastAIState = t["playing"];
            for (const t2 of this._lastAIState) t2.hasOwnProperty("tag") && !t2.hasOwnProperty("tags") && (t2["tags"] = [t2["tag"]].filter((t3) => !!t3));
            this._lastFxState = t["effects"], this._lastAnalysersData = t["analysers"];
          }
          _OnAfterLoad() {
            if (-1 !== this._loadListenerUid && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid), this._loadListenerUid = -1, this._listenerInst)) {
              const t = this._listenerInst.GetWorldInfo();
              this._listenerPos[0] = t.GetX(), this._listenerPos[1] = t.GetY();
            }
            for (const t of this._lastAIState) {
              const e = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t["bufferOriginalUrl"]);
              e ? (t["bufferUrl"] = e.url, t["bufferType"] = e.type) : t["bufferUrl"] = null;
            }
            for (const t of Object.values(this._lastFxState)) for (const e of t) if (e.hasOwnProperty("bufferOriginalUrl")) {
              const t2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e["bufferOriginalUrl"]);
              t2 && (e["bufferUrl"] = t2.url, e["bufferType"] = t2.type);
            }
            this.PostToDOM("load-state", { "saveLoadMode": this._saveLoadMode, "timeScale": this._runtime.GetTimeScale(), "gameTime": this._runtime.GetGameTimeRaw(), "listenerPos": this._listenerPos, "listenerOrientation": [...this._listenerForwardVec, ...this._listenerUpVec], "isSilent": this._isSilent, "masterVolume": this._masterVolume, "playing": this._lastAIState.filter((t) => null !== t["bufferUrl"]), "effects": this._lastFxState });
          }
          GetDebuggerProperties() {
            const t = [];
            for (const [e2, s2] of Object.entries(this._lastFxState)) t.push({ name: "$" + e2, value: s2.map((t2) => t2["type"]).join(", ") });
            const e = "plugins.audio.debugger";
            return [{ title: e + ".tag-effects", properties: t }, { title: e + ".currently-playing", properties: [{ name: e + ".currently-playing-count", value: this._lastAIState.length }, ...this._lastAIState.map((t2, e2) => ({ name: "$#" + e2, value: `${t2["bufferOriginalUrl"]} ("${t2["tags"]}") ${Math.round(10 * t2["playbackTime"]) / 10} / ${Math.round(10 * t2["duration"]) / 10}` }))] }];
          }
        };
      }
      self.C3.Plugins.Audio.Cnds = { OnEnded(t) {
        return this._MatchTriggerTag(t);
      }, OnFadeEnded(t) {
        return this._MatchTriggerTag(t);
      }, PreloadsComplete() {
        return this._preloadCount === this._preloadTotal;
      }, AdvancedAudioSupported: () => true, IsSilent() {
        return this._IsSilent();
      }, IsAnyPlaying() {
        for (const t of this._lastAIState) if (t["isPlaying"]) return true;
        return false;
      }, IsTagPlaying(t) {
        return this._IsTagPlaying(t);
      } };
      {
        const l2 = self.C3, h = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass"];
        l2.Plugins.Audio.Acts = { Play(t, e, s2, i2, a2) {
          const n = l2.Plugins.Audio.Acts._DoPlay.call(this, t, e, s2, i2, a2);
          return this._AddActionPromise(n), n;
        }, PlayFromTimeline(t, e, s2, i2) {
          l2.Plugins.Audio.Acts._DoPlay.call(this, t, 0, e, 0, s2, i2);
        }, async _DoPlay(t, e, s2, i2, a2, n) {
          if (this._isSilent) return;
          const r2 = t[1], o2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
          if (!o2) return;
          const { playOffset: h2, isTrueClock: u } = this._GetScheduledPlayInfo(), c2 = this._MaybeMarkAsPlaying(t[0], a2, r2, 0 !== e, this.DbToLinear(s2));
          try {
            await this.PostToDOMAsync("play", { "originalUrl": t[0], "url": o2.url, "type": o2.type, "isMusic": r2, "tags": this._SplitTags(a2), "isLooping": 0 !== e, "vol": this.DbToLinear(s2), "stereoPan": l2.clamp(i2 / 100, -1, 1), "pos": n || 0, "off": h2, "trueClock": u });
          } finally {
            c2 && (c2["placeholder"] = this._runtime.GetTickCountNoSave());
          }
        }, async PlayAtPosition(t, e, s2, i2, a2, n, r2, o2, h2, u, c2) {
          if (this._isSilent) return;
          const d2 = t[1], _ = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
          if (!_) return;
          const { playOffset: f2, isTrueClock: p } = this._GetScheduledPlayInfo(), g = this._MaybeMarkAsPlaying(t[0], c2, d2, 0 !== e, this.DbToLinear(s2));
          try {
            await this.PostToDOMAsync("play", { "originalUrl": t[0], "url": _.url, "type": _.type, "isMusic": d2, "tags": this._SplitTags(c2), "isLooping": 0 !== e, "vol": this.DbToLinear(s2), "pos": 0, "off": f2, "trueClock": p, "panning": { "x": i2, "y": a2, "z": n, "angle": l2.toRadians(r2), "innerAngle": l2.toRadians(o2), "outerAngle": l2.toRadians(h2), "outerGain": this.DbToLinear(u) } });
          } finally {
            g && (g["placeholder"] = this._runtime.GetTickCountNoSave());
          }
        }, async PlayAtObject(t, e, s2, i2, a2, n, r2, o2) {
          if (this._isSilent) return;
          if (!i2) return;
          const h2 = i2.GetFirstPicked();
          if (!h2 || !h2.GetWorldInfo()) return;
          const u = h2.GetWorldInfo(), c2 = u.GetLayer().GetAngle(), [d2, _] = this.rotatePtAround(u.GetX(), u.GetY(), -c2, this._listenerPos[0], this._listenerPos[1]), f2 = t[1], p = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
          if (!p) return;
          const { playOffset: g, isTrueClock: y } = this._GetScheduledPlayInfo(), m = this._MaybeMarkAsPlaying(t[0], o2, f2, 0 !== e, this.DbToLinear(s2));
          try {
            await this.PostToDOMAsync("play", { "originalUrl": t[0], "url": p.url, "type": p.type, "isMusic": f2, "tags": this._SplitTags(o2), "isLooping": 0 !== e, "vol": this.DbToLinear(s2), "pos": 0, "off": g, "trueClock": y, "panning": { "x": d2, "y": _, "z": u.GetTotalZElevation(), "angle": u.GetAngle() - c2, "innerAngle": l2.toRadians(a2), "outerAngle": l2.toRadians(n), "outerGain": this.DbToLinear(r2), "uid": h2.GetUID() } });
          } finally {
            m && (m["placeholder"] = this._runtime.GetTickCountNoSave());
          }
        }, async PlayByName(t, e, s2, i2, a2, n) {
          if (this._isSilent) return;
          const r2 = 1 === t, o2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
          if (!o2) return;
          const { playOffset: h2, isTrueClock: u } = this._GetScheduledPlayInfo(), c2 = this._MaybeMarkAsPlaying(e, n, r2, 0 !== s2, this.DbToLinear(i2));
          try {
            await this.PostToDOMAsync("play", { "originalUrl": e, "url": o2.url, "type": o2.type, "isMusic": r2, "tags": this._SplitTags(n), "isLooping": 0 !== s2, "vol": this.DbToLinear(i2), "stereoPan": l2.clamp(a2 / 100, -1, 1), "pos": 0, "off": h2, "trueClock": u });
          } finally {
            c2 && (c2["placeholder"] = this._runtime.GetTickCountNoSave());
          }
        }, async PlayAtPositionByName(t, e, s2, i2, a2, n, r2, o2, h2, u, c2, d2) {
          if (this._isSilent) return;
          const _ = 1 === t, f2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
          if (!f2) return;
          const { playOffset: p, isTrueClock: g } = this._GetScheduledPlayInfo(), y = this._MaybeMarkAsPlaying(e, d2, _, 0 !== s2, this.DbToLinear(i2));
          try {
            await this.PostToDOMAsync("play", { "originalUrl": e, "url": f2.url, "type": f2.type, "isMusic": _, "tags": this._SplitTags(d2), "isLooping": 0 !== s2, "vol": this.DbToLinear(i2), "pos": 0, "off": p, "trueClock": g, "panning": { "x": a2, "y": n, "z": r2, "angle": l2.toRadians(o2), "innerAngle": l2.toRadians(h2), "outerAngle": l2.toRadians(u), "outerGain": this.DbToLinear(c2) } });
          } finally {
            y && (y["placeholder"] = this._runtime.GetTickCountNoSave());
          }
        }, async PlayAtObjectByName(t, e, s2, i2, a2, n, r2, o2, h2) {
          if (this._isSilent) return;
          if (this._isSilent) return;
          if (!a2) return;
          const u = a2.GetFirstPicked();
          if (!u || !u.GetWorldInfo()) return;
          const c2 = u.GetWorldInfo(), d2 = c2.GetLayer().GetAngle(), [_, f2] = this.rotatePtAround(c2.GetX(), c2.GetY(), -d2, this._listenerPos[0], this._listenerPos[1]), p = 1 === t, g = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
          if (!g) return;
          const { playOffset: y, isTrueClock: m } = this._GetScheduledPlayInfo(), T = this._MaybeMarkAsPlaying(e, h2, p, 0 !== s2, this.DbToLinear(i2));
          try {
            await this.PostToDOMAsync("play", { "originalUrl": e, "url": g.url, "type": g.type, "isMusic": p, "tags": this._SplitTags(h2), "isLooping": 0 !== s2, "vol": this.DbToLinear(i2), "pos": 0, "off": y, "trueClock": m, "panning": { "x": _, "y": f2, "z": c2.GetTotalZElevation(), "angle": c2.GetAngle() - d2, "innerAngle": l2.toRadians(n), "outerAngle": l2.toRadians(r2), "outerGain": this.DbToLinear(o2), "uid": u.GetUID() } });
          } finally {
            T && (T["placeholder"] = this._runtime.GetTickCountNoSave());
          }
        }, SetLooping(t, e) {
          this.PostToDOM("set-looping", { "tags": this._SplitTags(t), "isLooping": 0 === e });
        }, SetMuted(t, e) {
          this.PostToDOM("set-muted", { "tags": this._SplitTags(t), "isMuted": 0 === e });
        }, SetVolume(t, e) {
          this.PostToDOM("set-volume", { "tags": this._SplitTags(t), "vol": this.DbToLinear(e) });
        }, FadeVolume(t, e, s2, i2) {
          this.PostToDOM("fade-volume", { "tags": this._SplitTags(t), "vol": this.DbToLinear(e), "duration": s2, "stopOnEnd": 0 === i2 });
        }, SetStereoPan(t, e) {
          this.PostToDOM("set-stereo-pan", { "tags": this._SplitTags(t), "p": l2.clamp(e / 100, -1, 1) });
        }, async Preload(t) {
          const e = t[1], s2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
          s2 && (this._preloadTotal++, await this.PostToDOMAsync("preload", { "originalUrl": t[0], "url": s2.url, "type": s2.type, "isMusic": e }), this._preloadCount++);
        }, async PreloadByName(t, e) {
          const s2 = 1 === t, i2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
          i2 && (this._preloadTotal++, await this.PostToDOMAsync("preload", { "originalUrl": e, "url": i2.url, "type": i2.type, "isMusic": s2 }), this._preloadCount++);
        }, SetPlaybackRate(t, e) {
          this.PostToDOM("set-playback-rate", { "tags": this._SplitTags(t), "rate": Math.max(e, 0) });
        }, Stop(t) {
          this._MaybeMarkAsStopped(t), this.PostToDOM("stop", { "tags": this._SplitTags(t) });
        }, StopAll() {
          this._StopAll();
        }, SetPaused(t, e) {
          this.PostToDOM("set-paused", { "tags": this._SplitTags(t), "paused": 0 === e });
        }, Seek(t, e) {
          this.PostToDOM("seek", { "tags": this._SplitTags(t), "pos": e });
        }, SetSilent(t) {
          2 === t && (t = this._IsSilent() ? 1 : 0), this._SetSilent(0 === t);
        }, SetMasterVolume(t) {
          const e = this.DbToLinear(t);
          this._SetMasterVolume(e);
        }, AddFilterEffect(t, e, s2, i2, a2, n, r2) {
          const o2 = h[e];
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "filter", "tags": this._SplitTags(t), "params": [o2, s2, i2, a2, n, l2.clamp(r2 / 100, 0, 1)] });
        }, AddDelayEffect(t, e, s2, i2) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "delay", "tags": this._SplitTags(t), "params": [e, this.DbToLinear(s2), l2.clamp(i2 / 100, 0, 1)] });
        }, AddFlangerEffect(t, e, s2, i2, a2, n) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "flanger", "tags": this._SplitTags(t), "params": [e / 1e3, s2 / 1e3, i2, a2 / 100, l2.clamp(n / 100, 0, 1)] });
        }, AddPhaserEffect(t, e, s2, i2, a2, n, r2) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "phaser", "tags": this._SplitTags(t), "params": [e, s2, i2, a2, n, l2.clamp(r2 / 100, 0, 1)] });
        }, AddConvolutionEffect(t, e, s2, i2) {
          const a2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e[0]);
          a2 && (this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "convolution", "tags": this._SplitTags(t), "bufferOriginalUrl": e[0], "bufferUrl": a2.url, "bufferType": a2.type, "params": [0 === s2, l2.clamp(i2 / 100, 0, 1)] }));
        }, AddGainEffect(t, e) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "gain", "tags": this._SplitTags(t), "params": [this.DbToLinear(e)] });
        }, AddStereoPanEffect(t, e) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "stereopan", "tags": this._SplitTags(t), "params": [l2.clamp(e / 100, -1, 1)] });
        }, AddMuteEffect(t) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "gain", "tags": this._SplitTags(t), "params": [0] });
        }, AddTremoloEffect(t, e, s2) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "tremolo", "tags": this._SplitTags(t), "params": [e, l2.clamp(s2 / 100, 0, 1)] });
        }, AddRingModEffect(t, e, s2) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "ringmod", "tags": this._SplitTags(t), "params": [e, l2.clamp(s2 / 100, 0, 1)] });
        }, AddDistortionEffect(t, e, s2, i2, a2, n) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "distortion", "tags": this._SplitTags(t), "params": [this.DbToLinearNoCap(e), this.DbToLinearNoCap(s2), i2, this.DbToLinearNoCap(a2), l2.clamp(n / 100, 0, 1)] });
        }, AddCompressorEffect(t, e, s2, i2, a2, n) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "compressor", "tags": this._SplitTags(t), "params": [e, s2, i2, a2 / 1e3, n / 1e3] });
        }, AddAnalyserEffect(t, e, s2) {
          this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "analyser", "tags": this._SplitTags(t), "params": [e, s2] });
        }, RemoveEffects(t) {
          const e = this._SplitTags(t);
          for (const t2 of e) this._effectCount.set(t2.toLowerCase(), 0);
          this.PostToDOM("remove-effects", { "tags": e }), this._lastFxState = {};
        }, SetEffectParameter(t, e, s2, i2, a2, n) {
          this.PostToDOM("set-effect-param", { "tags": this._SplitTags(t), "index": Math.floor(e), "param": s2, "value": i2, "ramp": a2, "time": n });
        }, SetListenerObject(t) {
          if (!t) return;
          const e = t.GetFirstPicked();
          e && e.GetWorldInfo() && (this._listenerInst = e);
        }, SetListenerZ(t) {
          this._listenerPos[2] = t;
        }, SetListenerOrientation(t, e, s2, i2, a2, n) {
          this._listenerForwardVec[0] = t, this._listenerForwardVec[1] = e, this._listenerForwardVec[2] = -s2, this._listenerUpVec[0] = i2, this._listenerUpVec[1] = a2, this._listenerUpVec[2] = -n;
        }, ScheduleNextPlay(t) {
          this._nextPlayTime = Math.max(t, 0), this._nextPlayOffset = Math.max(t - performance.now() / 1e3, 0);
        }, UnloadAudio(t) {
          const e = t[1], s2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
          s2 && this.PostToDOM("unload", { "url": s2.url, "type": s2.type, "isMusic": e });
        }, UnloadAudioByName(t, e) {
          const s2 = 1 === t, i2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
          i2 && this.PostToDOM("unload", { "url": i2.url, "type": i2.type, "isMusic": s2 });
        }, UnloadAll() {
          this.PostToDOM("unload-all");
        }, AddRemoteURL(t, e, s2) {
          this._remoteUrls.set(s2.toLowerCase(), { url: t, type: e });
        } };
      }
      {
        const u = self.C3;
        u.Plugins.Audio.Exps = { Duration(t) {
          const e = this._GetFirstAudioStateByTags(t);
          return e ? e["duration"] : 0;
        }, PlaybackTime(t) {
          const e = this._GetFirstAudioStateByTags(t);
          return e ? e["playbackTime"] : 0;
        }, PlaybackRate(t) {
          const e = this._GetFirstAudioStateByTags(t);
          return e ? e["playbackRate"] : 0;
        }, Volume(t) {
          const e = this._GetFirstAudioStateByTags(t);
          return e ? this.LinearToDb(e["volume"]) : 0;
        }, MasterVolume() {
          return this.LinearToDb(this._GetMasterVolume());
        }, EffectCount(t) {
          return this._effectCount.get(t.toLowerCase()) || 0;
        }, AnalyserFreqBinCount(t, e) {
          const s2 = this.GetAnalyserData(t, Math.floor(e));
          return s2 ? s2["binCount"] : 0;
        }, AnalyserFreqBinAt(t, e, s2) {
          const i2 = this.GetAnalyserData(t, Math.floor(e));
          return i2 ? (s2 = Math.floor(s2)) < 0 || s2 >= i2["binCount"] ? 0 : i2["freqBins"][s2] : 0;
        }, AnalyserPeakLevel(t, e) {
          const s2 = this.GetAnalyserData(t, Math.floor(e));
          return s2 ? s2["peak"] : 0;
        }, AnalyserRMSLevel(t, e) {
          const s2 = this.GetAnalyserData(t, Math.floor(e));
          return s2 ? s2["rms"] : 0;
        }, SampleRate() {
          return this._sampleRate;
        }, CurrentTime: () => self["C3_GetAudioContextCurrentTime"] ? self["C3_GetAudioContextCurrentTime"]() : performance.now() / 1e3, OutputLatency() {
          return this._outputLatency;
        }, NormalizedVolume(t, e) {
          return 0 === (t = u.clamp(+t, 0, 100) / 100) ? -1 / 0 : t < 0.1 ? this.LinearToDb(u.lerp(0, this.DbToLinear(e), 10 * t)) : u.lerp(e, 0, (t - 0.1) / 0.9);
        } };
      }
    }
    var GetAudioSdkInstance;
    var GetAudioDOMInterface;
    {
      {
        const e = self.C3;
        e.Plugins.Browser = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.Browser.Type = class extends e.SDKTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3, t = "browser";
        e.Plugins.Browser.Instance = class extends e.SDKInstanceBase {
          constructor(s2, n) {
            super(s2, t), this._initLocationStr = "", this._isOnline = false, this._referrer = "", this._docTitle = "", this._isCookieEnabled = false, this._screenWidth = 0, this._screenHeight = 0, this._windowOuterWidth = 0, this._windowOuterHeight = 0, this._windowHasFocus = false, this._isConstructArcade = false, this._cssStyleMap = /* @__PURE__ */ new Map(), this._isInstallAvailable = false, this._installResult = "", this._isWarnOnCloseEnabled = false, this.AddDOMMessageHandlers([["online-state", (e2) => this._OnOnlineStateChanged(e2)], ["backbutton", () => this._OnBackButton()], ["sw-message", (e2) => this._OnSWMessage(e2)], ["hashchange", (e2) => this._OnHashChange(e2)], ["install-available", () => this._OnInstallAvailable()], ["app-installed", (e2) => this._OnAppInstalled(e2)]]);
            const i2 = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(i2, "afterfirstlayoutstart", () => this._OnAfterFirstLayoutStart()), e.Disposable.From(i2, "window-resize", () => this._OnWindowResize()), e.Disposable.From(i2, "window-focus", () => this._OnWindowFocus()), e.Disposable.From(i2, "window-blur", () => this._OnWindowBlur()), e.Disposable.From(i2, "suspend", () => this._OnSuspend()), e.Disposable.From(i2, "resume", () => this._OnResume())), this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state", { "exportType": this._runtime.GetExportType() }).then((e2) => {
              this._initLocationStr = e2["location"], this._isOnline = e2["isOnline"], this._referrer = e2["referrer"], this._docTitle = e2["title"], this._isCookieEnabled = e2["isCookieEnabled"], this._screenWidth = e2["screenWidth"], this._screenHeight = e2["screenHeight"], this._windowOuterWidth = e2["windowOuterWidth"], this._windowOuterHeight = e2["windowOuterHeight"], this._windowHasFocus = e2["windowHasFocus"], this._isConstructArcade = e2["isConstructArcade"];
            }));
          }
          Release() {
            super.Release();
          }
          _OnAfterFirstLayoutStart() {
            this.PostToDOM("ready-for-sw-messages");
          }
          async _OnOnlineStateChanged(t2) {
            const s2 = !!t2["isOnline"];
            this._isOnline !== s2 && (this._isOnline = s2, this._isOnline ? await this.TriggerAsync(e.Plugins.Browser.Cnds.OnOnline) : await this.TriggerAsync(e.Plugins.Browser.Cnds.OnOffline));
          }
          async _OnWindowResize() {
            await this.TriggerAsync(e.Plugins.Browser.Cnds.OnResize);
          }
          async _OnWindowFocus() {
            this._windowHasFocus = true, await this.TriggerAsync(e.Plugins.Browser.Cnds.OnWindowFocus);
          }
          async _OnWindowBlur() {
            this._windowHasFocus = false, await this.TriggerAsync(e.Plugins.Browser.Cnds.OnWindowBlur);
          }
          _OnSuspend() {
            this.Trigger(e.Plugins.Browser.Cnds.OnPageHidden);
          }
          _OnResume() {
            this.Trigger(e.Plugins.Browser.Cnds.OnPageVisible);
          }
          async _OnBackButton() {
            await this.TriggerAsync(e.Plugins.Browser.Cnds.OnBackButton);
          }
          _OnSWMessage(t2) {
            const s2 = t2["type"];
            "downloading-update" === s2 ? this.Trigger(e.Plugins.Browser.Cnds.OnUpdateFound) : "update-ready" === s2 || "update-pending" === s2 ? this.Trigger(e.Plugins.Browser.Cnds.OnUpdateReady) : "offline-ready" === s2 && this.Trigger(e.Plugins.Browser.Cnds.OnOfflineReady);
          }
          _OnHashChange(t2) {
            this._initLocationStr = t2["location"], this.Trigger(e.Plugins.Browser.Cnds.OnHashChange);
          }
          _OnInstallAvailable() {
            this._isInstallAvailable = true, this.Trigger(e.Plugins.Browser.Cnds.OnInstallAvailable);
          }
          _OnAppInstalled(t2) {
            this._isInstallAvailable = false, this.Trigger(e.Plugins.Browser.Cnds.OnAppInstalled);
          }
          _IsWarnOnCloseEnabled() {
            return this._isWarnOnCloseEnabled;
          }
          _SetWarnOnCloseEnabled(e2) {
            e2 = !!e2, this._isWarnOnCloseEnabled !== e2 && (this._isWarnOnCloseEnabled = e2, this.PostToDOM("set-warn-on-close", { "enabled": e2 }));
          }
          GetDebuggerProperties() {
            const e2 = "plugins.browser.debugger";
            return [{ title: "plugins.browser.name", properties: [{ name: e2 + ".user-agent", value: navigator.userAgent }, { name: e2 + ".is-online", value: this._isOnline }, { name: e2 + ".is-fullscreen", value: this._runtime.GetCanvasManager().IsDocumentFullscreen() }] }];
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.Browser.Cnds = { IsOnline() {
          return this._isOnline;
        }, OnOnline: () => true, OnOffline: () => true, OnResize: () => true, OnWindowFocus: () => true, OnWindowBlur: () => true, WindowHasFocus() {
          return this._windowHasFocus;
        }, CookiesEnabled() {
          return this._isCookieEnabled;
        }, IsFullscreen() {
          return this._runtime.GetCanvasManager().IsDocumentFullscreen();
        }, OnBackButton: () => true, IsPortraitLandscape(e2) {
          return (this._runtime.GetCanvasManager().GetLastWidth() <= this._runtime.GetCanvasManager().GetLastHeight() ? 0 : 1) === e2;
        }, OnUpdateFound: () => true, OnUpdateReady: () => true, OnOfflineReady: () => true, OnHashChange: () => true, OnInstallAvailable: () => true, IsInstallAvailable() {
          return this._isInstallAvailable;
        }, OnInstallResult(e2) {
          switch (e2) {
            case 0:
              return "accepted" === this._installResult;
            case 1:
              return "dismissed" === this._installResult;
            case 2:
              return "error" === this._installResult;
            case 3:
              return true;
            default:
              return false;
          }
        }, OnAppInstalled: () => true, CompareDisplayMode(e2) {
          const t = this._runtime.GetCanvasManager().GetCssDisplayMode();
          switch (e2) {
            case 0:
              return "browser" === t;
            case 1:
              return "minimal-ui" === t;
            case 2:
              return "standalone" === t;
            case 3:
              return "fullscreen" === t;
            default:
              return false;
          }
        }, IsWarnOnCloseEnabled() {
          return this._IsWarnOnCloseEnabled();
        }, PageVisible() {
          return !this._runtime.IsSuspended();
        }, OnPageHidden: () => true, OnPageVisible: () => true, HasJava: () => false, IsDownloadingUpdate: () => false, OnMenuButton: () => false, OnSearchButton: () => false, IsMetered: () => false, IsCharging: () => true, SupportsFullscreen: () => true };
      }
      {
        const C3 = self.C3, ORIENTATIONS = ["portrait", "landscape", "portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"];
        C3.Plugins.Browser.Acts = { Alert(e) {
          this.PostToDOM("alert", { "message": e.toString() });
        }, Close() {
          this._isConstructArcade || (this._runtime.IsDebug() ? self.C3Debugger.CloseWindow() : this.PostToDOM("close"));
        }, Focus() {
          this.PostToDOM("set-focus", { "isFocus": true });
        }, Blur() {
          this.PostToDOM("set-focus", { "isFocus": false });
        }, GoBack() {
          this._isConstructArcade || this.PostToDOM("navigate", { "type": "back" });
        }, GoForward() {
          this._isConstructArcade || this.PostToDOM("navigate", { "type": "forward" });
        }, GoHome() {
        }, Reload() {
          this._isConstructArcade || (this._runtime.IsDebug() ? this._runtime.PostToDebugger({ "type": "reload" }) : this.PostToDOM("navigate", { "type": "reload" }));
        }, GoToURL(e, t) {
          this._PostToDOMMaybeSync("navigate", { "type": "url", "url": e, "target": t, "exportType": this._runtime.GetExportType() });
        }, GoToURLWindow(e, t) {
          this._PostToDOMMaybeSync("navigate", { "type": "new-window", "url": e, "tag": t, "exportType": this._runtime.GetExportType() });
        }, RequestFullScreen(e, t) {
          e >= 2 && (e += 1), 6 === e && (e = 2), 1 === e && (e = 0);
          const s2 = C3.CanvasManager._FullscreenModeNumberToString(e);
          this._runtime.GetCanvasManager().SetDocumentFullscreenMode(s2), this._PostToDOMMaybeSync("request-fullscreen", { "navUI": t });
        }, CancelFullScreen() {
          this._PostToDOMMaybeSync("exit-fullscreen");
        }, Vibrate(e) {
          const t = e.split(",");
          for (let e2 = 0, s2 = t.length; e2 < s2; ++e2) t[e2] = parseInt(t[e2], 10);
          this._PostToDOMMaybeSync("vibrate", { "pattern": t });
        }, async InvokeDownload(e, t) {
          if (!e || !t) return;
          const s2 = await this._runtime.GetAssetManager().GetProjectFileUrl(e);
          this._runtime.InvokeDownload(s2, t);
        }, InvokeDownloadString(e, t, s2) {
          if (!s2) return;
          const n = `data:${t},${encodeURIComponent(e)}`;
          this._runtime.InvokeDownload(n, s2);
        }, ConsoleLog(e, t) {
          t = t.toString(), 0 === e ? console.log(t) : 1 === e ? console.warn(t) : 2 === e && console.error(t);
        }, ConsoleGroup(e) {
          console.group(e);
        }, ConsoleGroupEnd() {
          console.groupEnd();
        }, ExecJs(jsStr) {
          try {
            eval(jsStr);
          } catch (e) {
            console.error("Error executing JavaScript: ", e);
          }
        }, LockOrientation(e) {
          if ((e = Math.floor(e)) < 0 || e >= ORIENTATIONS.length) return;
          const t = ORIENTATIONS[e];
          this._PostToDOMMaybeSync("lock-orientation", { "orientation": t });
        }, UnlockOrientation() {
          this._PostToDOMMaybeSync("unlock-orientation");
        }, LoadStyleSheet(e) {
          this._runtime.GetAssetManager().LoadStyleSheet(e);
        }, async SetDocumentCSSStyle(e, t, s2, n) {
          await this.PostToDOMAsync("set-document-css-style", { "prop": C3.CSSToCamelCase(e), "value": t, "selector": s2, "is-all": 0 !== n });
        }, async GetDocumentCSSStyle(e, t, s2) {
          const n = await this.PostToDOMAsync("get-document-css-style", { "prop": e, "selector": t });
          n["isOk"] && this._cssStyleMap.set(s2.toLowerCase(), n["result"].trim());
        }, SetHash(e) {
          this.PostToDOM("set-hash", { "hash": e });
        }, SetWindowSize(e, t) {
          this.PostToDOM("set-window-size", { "windowWidth": e, "windowHeight": t });
        }, SetWindowPosition(e, t) {
          this.PostToDOM("set-window-position", { "windowX": e, "windowY": t });
        }, async RequestInstall() {
          const e = await this.PostToDOMAsync("request-install");
          this._installResult = e["result"], this.Trigger(C3.Plugins.Browser.Cnds.OnInstallResult);
        }, SetWarnOnClose(e) {
          this._SetWarnOnCloseEnabled(e);
        } };
      }
      {
        const C3 = self.C3;
        C3.Plugins.Browser.Exps = { URL() {
          return this._runtime.IsInWorker() ? this._initLocationStr : location.toString();
        }, Protocol() {
          return this._runtime.IsInWorker() ? new URL(this._initLocationStr).protocol : location.protocol;
        }, Domain() {
          return this._runtime.IsInWorker() ? new URL(this._initLocationStr).hostname : location.hostname;
        }, Port() {
          return this._runtime.IsInWorker() ? new URL(this._initLocationStr).port : location.port;
        }, PathName() {
          return this._runtime.IsInWorker() ? new URL(this._initLocationStr).pathname : location.pathname;
        }, Hash() {
          return this._runtime.IsInWorker() ? new URL(this._initLocationStr).hash : location.hash;
        }, QueryString() {
          return this._runtime.IsInWorker() ? new URL(this._initLocationStr).search : location.search;
        }, QueryParam(e) {
          const t = this._runtime.IsInWorker() ? new URL(this._initLocationStr).search : location.search, s2 = RegExp("[?&]" + e + "=([^&]*)").exec(t);
          return s2 ? decodeURIComponent(s2[1].replace(/\+/g, " ")) : "";
        }, Referrer() {
          return this._referrer;
        }, Title() {
          return this._docTitle;
        }, Language: () => navigator.language, Platform: () => navigator.platform, UserAgent: () => navigator.userAgent, ExecJS(jsStr) {
          let result = 0;
          try {
            result = eval(jsStr);
          } catch (e) {
            console.error("Error executing JavaScript: ", e);
          }
          return "number" == typeof result || "string" == typeof result ? result : "boolean" == typeof result && result ? 1 : 0;
        }, CSSStyleValue(e) {
          return this._cssStyleMap.get(e) || "";
        }, Name: () => navigator.appName, Version: () => navigator.appVersion, Product: () => navigator.product, Vendor: () => navigator.vendor, BatteryLevel: () => 1, BatteryTimeLeft: () => 1 / 0, Bandwidth() {
          const e = navigator["connection"];
          return e && (e["downlink"] || e["downlinkMax"] || e["bandwidth"]) || 1 / 0;
        }, ConnectionType() {
          const e = navigator["connection"];
          return e && e["type"] || "unknown";
        }, DevicePixelRatio: () => self.devicePixelRatio, ScreenWidth() {
          return this._screenWidth;
        }, ScreenHeight() {
          return this._screenHeight;
        }, WindowInnerWidth() {
          return this._runtime.GetCanvasManager().GetLastWidth();
        }, WindowInnerHeight() {
          return this._runtime.GetCanvasManager().GetLastHeight();
        }, WindowOuterWidth() {
          return this._windowOuterWidth;
        }, WindowOuterHeight() {
          return this._windowOuterWidth;
        }, DisplayMode() {
          return this._runtime.GetCanvasManager().GetCssDisplayMode();
        }, InstallResult() {
          return this._installResult;
        } };
      }
    }
    {
      {
        const e = self.C3, t = "button";
        e.Plugins.Button = class extends e.SDKDOMPluginBase {
          constructor(e2) {
            super(e2, t), this.AddElementMessageHandler("click", (e3, t2) => e3._OnClick(t2));
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.Button.Type = class extends e.SDKTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3, t = self.C3X, s2 = 0, i2 = 1, n = 2, h = 3, a2 = 4, l2 = 5, c2 = 6, r2 = 7, _ = 8, d2 = "button";
        e.Plugins.Button.Instance = class extends e.SDKDOMInstanceBase {
          constructor(e2, t2) {
            super(e2, d2), this._text = "OK", this._isCheckbox = false, this._isChecked = false, this._title = "", this._id = "", this._className = "", this._isEnabled = true, this._autoFontSize = true, t2 && (this._isCheckbox = 1 === t2[s2], this._text = t2[i2], this._title = t2[n], this.GetWorldInfo().SetVisible(t2[h]), this._isEnabled = t2[a2], this._autoFontSize = t2[l2], this._isChecked = t2[c2], this._id = t2[r2], this._className = t2[_]), this.CreateElement({ "id": this._id, "className": this._className });
          }
          Release() {
            super.Release();
          }
          GetElementState() {
            return { "text": this._text, "isCheckbox": this._isCheckbox, "isChecked": this._isChecked, "title": this._title, "isVisible": this.GetWorldInfo().IsVisible(), "isEnabled": this._isEnabled };
          }
          async _OnClick(t2) {
            this._isChecked = t2["isChecked"], this.DispatchScriptEvent("click", true), await this.TriggerAsync(e.Plugins.Button.Cnds.OnClicked);
          }
          _SetText(e2) {
            this._text !== e2 && (this._text = e2, this.UpdateElementState());
          }
          _GetText() {
            return this._text;
          }
          _SetTooltip(e2) {
            this._title !== e2 && (this._title = e2, this.UpdateElementState());
          }
          _GetTooltip() {
            return this._title;
          }
          _SetEnabled(e2) {
            e2 = !!e2, this._isEnabled !== e2 && (this._isEnabled = e2, this.UpdateElementState());
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          _SetChecked(e2) {
            this._isCheckbox && (e2 = !!e2, this._isChecked !== e2 && (this._isChecked = e2, this.UpdateElementState()));
          }
          _IsChecked() {
            return this._isChecked;
          }
          Draw(e2) {
          }
          SaveToJson() {
            return { "text": this._text, "checked": this._isChecked, "title": this._title, "enabled": this._isEnabled };
          }
          LoadFromJson(e2) {
            this._text = e2["text"], this._isChecked = e2["checked"], this._title = e2["title"], this._isEnabled = e2["enabled"], this.UpdateElementState();
          }
          GetPropertyValueByIndex(e2) {
            switch (e2) {
              case i2:
                return this._GetText();
              case n:
                return this._GetTooltip();
              case a2:
                return this._IsEnabled();
              case l2:
                return this._autoFontSize;
              case c2:
                return this._IsChecked();
            }
          }
          SetPropertyValueByIndex(e2, t2) {
            switch (e2) {
              case i2:
                this._SetText(t2);
                break;
              case n:
                this._SetTooltip(t2);
                break;
              case a2:
                this._SetEnabled(!!t2);
                break;
              case l2:
                this._autoFontSize = !!t2;
                break;
              case c2:
                this._SetChecked(!!t2);
            }
          }
          GetDebuggerProperties() {
            const e2 = "plugins.button";
            return [{ title: e2 + ".name", properties: [{ name: e2 + ".properties.text.name", value: this._GetText(), onedit: (e3) => this._SetText(e3) }, { name: e2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e3) => this._SetEnabled(e3) }, { name: e2 + ".properties.checked.name", value: this._IsChecked(), onedit: (e3) => this._SetChecked(e3) }] }];
          }
          GetScriptInterfaceClass() {
            return self.IButtonInstance;
          }
        };
        const o2 = /* @__PURE__ */ new WeakMap();
        self.IButtonInstance = class extends self.IDOMInstance {
          constructor() {
            super(), o2.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          set text(e2) {
            t.RequireString(e2), o2.get(this)._SetText(e2);
          }
          get text() {
            return o2.get(this)._GetText();
          }
          set tooltip(e2) {
            t.RequireString(e2), o2.get(this)._SetTooltip(e2);
          }
          get tooltip() {
            return o2.get(this)._GetTooltip();
          }
          set isEnabled(e2) {
            o2.get(this)._SetEnabled(e2);
          }
          get isEnabled() {
            return o2.get(this)._IsEnabled();
          }
          set isChecked(e2) {
            o2.get(this)._SetChecked(e2);
          }
          get isChecked() {
            return o2.get(this)._IsChecked();
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.Button.Cnds = { OnClicked: () => true, IsChecked() {
          return this._isChecked;
        }, CompareText(t, s2) {
          return s2 ? this._text === t : e.equalsNoCase(this._text, t);
        } };
      }
      self.C3.Plugins.Button.Acts = { SetText(e) {
        this._SetText(e);
      }, SetTooltip(e) {
        this._SetTooltip(e);
      }, SetChecked(e) {
        this._SetChecked(0 !== e);
      }, ToggleChecked() {
        this._isCheckbox && (this._isChecked = !this._isChecked, this.UpdateElementState());
      } };
      self.C3.Plugins.Button.Exps = { Text() {
        return this._text;
      } };
    }
    {
      {
        const t = self.C3;
        t.Plugins.Json = class extends t.SDKPluginBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.Json.Type = class extends t.SDKTypeBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const t = self.C3, e = self.C3X, a2 = self.IInstance;
        t.Plugins.Json.Instance = class extends t.SDKInstanceBase {
          constructor(t2, e2) {
            super(t2), this._valueCache = [null, null], this._locationCache = [null, null], this._data = {}, this._path = [], this._currentKey = "", this._currentValue = 0;
          }
          Release() {
            super.Release();
          }
          _InvalidateValueCache() {
            this._valueCache[0] = null, this._valueCache[1] = null;
          }
          _HasValueCache(e2, a3) {
            const s3 = this._valueCache[0];
            if (null === e2 || null === s3) return false;
            if (s3 === e2 || t.arraysEqual(s3, e2)) return true;
            if (a3 && s3.length > 0) {
              for (let t2 = 0, a4 = Math.min(e2.length, s3.length); t2 < a4; ++t2) if (e2[t2] !== s3[t2]) return false;
              return true;
            }
            return false;
          }
          _GetValueCache() {
            return this._valueCache[1];
          }
          _UpdateValueCache(t2, e2) {
            this._valueCache[0] = t2, this._valueCache[1] = e2;
          }
          _InvalidateLocationCache() {
            this._locationCache[0] = null, this._locationCache[1] = null;
          }
          _HasLocationCache(t2) {
            return this._locationCache[0] === t2;
          }
          _GetLocationCache() {
            return this._locationCache[1];
          }
          _UpdateLocationCache(t2, e2) {
            this._locationCache[0] = t2, this._locationCache[1] = e2;
          }
          _SetData(t2) {
            this._data = t2, this._InvalidateValueCache(), this._SetPath("");
          }
          _GetData() {
            return this._data;
          }
          _SetPath(t2) {
            this._path = this._ParsePathUnsafe(t2), this._InvalidateLocationCache();
          }
          _ParsePath(e2) {
            return t.cloneArray(this._ParsePathUnsafe(e2));
          }
          _ParsePathUnsafe(e2) {
            const a3 = [];
            let s3, r2 = false;
            if (this._HasLocationCache(e2)) return this._GetLocationCache();
            "." === e2[0] ? (s3 = t.cloneArray(this._path), e2 = e2.slice(1)) : s3 = [];
            for (const n of e2) r2 ? (a3.push(n), r2 = false) : "\\" === n ? r2 = true : "." === n ? (s3.push(a3.join("")), t.clearArray(a3)) : a3.push(n);
            return 0 !== a3.length && s3.push(a3.join("")), this._UpdateLocationCache(e2, s3), s3;
          }
          _GetValueAtFullPath(t2, e2) {
            if (this._HasValueCache(t2, false)) return this._GetValueCache();
            let a3 = this._data;
            for (const s3 of t2) if (Array.isArray(a3)) {
              const t3 = parseInt(s3, 10);
              if (t3 < 0 || t3 >= a3.length || !isFinite(t3)) {
                a3 = null;
                break;
              }
              a3 = a3[t3];
            } else {
              if ("object" != typeof a3 || null === a3) {
                a3 = null;
                break;
              }
              if (a3.hasOwnProperty(s3)) a3 = a3[s3];
              else {
                if (!e2) {
                  a3 = null;
                  break;
                }
                {
                  const t3 = {};
                  a3[s3] = t3, a3 = t3;
                }
              }
            }
            return this._UpdateValueCache(t2, a3), a3;
          }
          _GetValue(t2) {
            const e2 = this._ParsePath(t2);
            if (!e2.length) return this._data;
            const a3 = e2.pop(), s3 = this._GetValueAtFullPath(e2, false);
            if (Array.isArray(s3)) {
              const t3 = parseInt(a3, 10);
              return t3 >= 0 && t3 < s3.length ? s3[t3] : null;
            }
            return "object" == typeof s3 && null !== s3 && s3.hasOwnProperty(a3) ? s3[a3] : null;
          }
          _JSONTypeOf(t2) {
            return null === t2 ? "null" : Array.isArray(t2) ? "array" : typeof t2;
          }
          _GetTypeOf(t2) {
            const e2 = this._GetValue(t2);
            return this._JSONTypeOf(e2);
          }
          _ToSafeValue(t2) {
            const e2 = typeof t2;
            return "number" === e2 || "string" === e2 ? t2 : "boolean" === e2 && t2 ? 1 : 0;
          }
          _GetSafeValue(t2) {
            return this._ToSafeValue(this._GetValue(t2));
          }
          _HasKey(t2) {
            const e2 = this._ParsePath(t2);
            if (!e2.length) return false;
            const a3 = e2.pop(), s3 = this._GetValueAtFullPath(e2, false);
            if (Array.isArray(s3)) {
              const t3 = parseInt(a3, 10);
              return t3 >= 0 && t3 < s3.length;
            }
            return "object" == typeof s3 && null !== s3 && s3.hasOwnProperty(a3);
          }
          _SetValue(t2, e2) {
            const a3 = this._ParsePath(t2);
            if (!a3.length) return false;
            this._HasValueCache(a3, true) && this._InvalidateValueCache();
            const s3 = a3.pop(), r2 = this._GetValueAtFullPath(a3, true);
            if (Array.isArray(r2)) {
              const t3 = parseInt(s3, 10);
              return !(!isFinite(t3) || t3 < 0 || t3 >= r2.length) && (r2[t3] = e2, true);
            }
            return "object" == typeof r2 && null !== r2 && (r2[s3] = e2, true);
          }
          _DeleteKey(t2) {
            const e2 = this._ParsePath(t2);
            if (!e2.length) return false;
            this._HasValueCache(e2, true) && this._InvalidateValueCache();
            const a3 = e2.pop(), s3 = this._GetValueAtFullPath(e2, false);
            return !Array.isArray(s3) && ("object" == typeof s3 && null !== s3 && (delete s3[a3], true));
          }
          SaveToJson() {
            return { "path": this._path, "data": this._data };
          }
          LoadFromJson(t2) {
            this._InvalidateValueCache(), this._InvalidateLocationCache(), this._path = t2["path"], this._data = t2["data"];
          }
          _SanitizeValue(t2) {
            return "number" === typeof t2 ? isFinite(t2) ? t2 : 0 : "object" == typeof t2 ? JSON.stringify(t2) : t2 + "";
          }
          GetDebuggerProperties() {
            const t2 = "plugins.json.debugger";
            let e2;
            try {
              e2 = this._SanitizeValue(this._data);
            } catch (t3) {
              e2 = '"invalid"';
            }
            return [{ title: t2 + ".title", properties: [{ name: t2 + ".data", value: e2, onedit: (t3) => {
              try {
                const e3 = JSON.parse(t3);
                this._SetData(e3);
              } catch (t4) {
              }
            } }, { name: t2 + ".path", value: this._path.map((t3) => t3.replace(/\./g, "\\.")).join(".") }] }];
          }
          GetScriptInterfaceClass() {
            return self.IJSONInstance;
          }
        };
        const s2 = /* @__PURE__ */ new WeakMap();
        self.IJSONInstance = class extends a2 {
          constructor() {
            super(), s2.set(this, a2._GetInitInst().GetSdkInstance());
          }
          getJsonDataCopy() {
            const t2 = s2.get(this)._GetData();
            return JSON.parse(JSON.stringify(t2));
          }
          setJsonDataCopy(t2) {
            try {
              const e2 = JSON.parse(JSON.stringify(t2));
              s2.get(this)._SetData(e2);
            } catch (t3) {
              throw console.error("[JSON plugin] setJsonData: object is not valid JSON: ", t3), t3;
            }
          }
          setJsonString(t2) {
            e.RequireString(t2);
            try {
              const e2 = JSON.parse(t2);
              s2.get(this)._SetData(e2);
            } catch (t3) {
              throw console.error("[JSON plugin] setJsonString: string is not valid JSON: ", t3), t3;
            }
          }
          toCompactString() {
            return JSON.stringify(s2.get(this)._GetData());
          }
          toBeautifiedString() {
            return JSON.stringify(s2.get(this)._GetData(), null, 4);
          }
        };
      }
      {
        const t = self.C3, e = ["null", "boolean", "number", "string", "object", "array"];
        t.Plugins.Json.Cnds = { HasKey(t2) {
          return this._HasKey(t2);
        }, CompareType(t2, a2) {
          return this._GetTypeOf(t2) === e[a2];
        }, CompareValue(e2, a2, s2) {
          return t.compare(this._GetSafeValue(e2), a2, s2);
        }, IsBooleanSet(t2) {
          return true === this._GetValue(t2);
        }, ForEach(e2) {
          const a2 = this._GetValue(e2);
          if ("object" != typeof a2 || null === a2) return false;
          const s2 = this._runtime, r2 = s2.GetEventSheetManager(), n = s2.GetCurrentEvent(), i2 = n.GetSolModifiers(), l2 = s2.GetEventStack(), u = l2.GetCurrentStackFrame(), h = l2.Push(n), o2 = this._path, c2 = this._currentKey, _ = this._currentValue, p = this._ParsePathUnsafe(e2);
          s2.SetDebuggingEnabled(false);
          for (const [e3, s3] of Object.entries(a2)) {
            this._path = t.cloneArray(p), this._path.push(e3), this._currentKey = e3, this._currentValue = s3, r2.PushCopySol(i2);
            this.GetObjectClass().GetCurrentSol().PickOne(this.GetInstance()), n.Retrigger(u, h), r2.PopSol(i2);
          }
          return s2.SetDebuggingEnabled(true), this._path = o2, this._InvalidateLocationCache(), this._currentKey = c2, this._currentValue = _, l2.Pop(), false;
        }, OnParseError: () => true, OnParseSuccess: () => true };
      }
      {
        const t = self.C3;
        t.Plugins.Json.Acts = { Parse(e) {
          try {
            this._SetData(JSON.parse(e)), this.Trigger(t.Plugins.Json.Cnds.OnParseSuccess);
          } catch (e2) {
            console.warn("[JSON plugin] Failed to parse JSON data: ", e2), this._SetData({}), this.Trigger(t.Plugins.Json.Cnds.OnParseError);
          }
        }, SetPath(t2) {
          this._SetPath(t2);
        }, SetValue(t2, e) {
          this._SetValue(t2, e);
        }, SetArray(e, a2) {
          let s2 = this._GetValue(e);
          Array.isArray(s2) ? t.resizeArray(s2, a2, 0) : (s2 = [], t.extendArray(s2, a2, 0), this._SetValue(e, s2));
        }, SetObject(t2) {
          this._SetValue(t2, {});
        }, SetJSON(e, a2) {
          let s2 = null;
          try {
            s2 = JSON.parse(a2), this.Trigger(t.Plugins.Json.Cnds.OnParseSuccess);
          } catch (e2) {
            console.warn("[JSON plugin] Failed to parse JSON data: ", e2), this.Trigger(t.Plugins.Json.Cnds.OnParseError);
          }
          this._SetValue(e, s2);
        }, SetNull(t2) {
          this._SetValue(t2, null);
        }, SetBoolean(t2, e) {
          this._SetValue(t2, 0 !== e);
        }, ToggleBoolean(t2) {
          const e = this._GetValue(t2);
          "boolean" == typeof e && this._SetValue(t2, !e);
        }, AddTo(t2, e) {
          const a2 = this._GetValue(t2);
          "number" == typeof a2 && this._SetValue(t2, a2 + e);
        }, SubtractFrom(t2, e) {
          const a2 = this._GetValue(t2);
          "number" == typeof a2 && this._SetValue(t2, a2 - e);
        }, DeleteKey(t2) {
          this._DeleteKey(t2);
        }, PushValue(t2, e, a2) {
          const s2 = this._GetValue(e);
          Array.isArray(s2) && (0 === t2 ? s2.push(a2) : s2.unshift(a2), this._InvalidateValueCache());
        }, PopValue(t2, e) {
          const a2 = this._GetValue(e);
          Array.isArray(a2) && (0 === t2 ? a2.pop() : a2.shift(), this._InvalidateValueCache());
        }, InsertValue(t2, e, a2) {
          const s2 = this._GetValue(e);
          Array.isArray(s2) && (s2.splice(a2, 0, t2), this._InvalidateValueCache());
        }, RemoveValues(t2, e, a2) {
          const s2 = this._GetValue(e);
          Array.isArray(s2) && t2 > 0 && (s2.splice(a2, t2), this._InvalidateValueCache());
        } };
      }
      self.C3.Plugins.Json.Exps = { ToCompactString() {
        try {
          return JSON.stringify(this._data);
        } catch (t) {
          return "";
        }
      }, ToBeautifiedString() {
        try {
          return JSON.stringify(this._data, null, 4);
        } catch (t) {
          return "";
        }
      }, Get(t) {
        return this._GetSafeValue(t);
      }, GetAsCompactString(t) {
        const e = this._GetValue(t);
        return JSON.stringify(e);
      }, GetAsBeautifiedString(t) {
        const e = this._GetValue(t);
        return JSON.stringify(e, null, 4);
      }, Front(t) {
        const e = this._GetValue(t);
        if (Array.isArray(e)) {
          const t2 = e[0];
          return this._ToSafeValue(t2);
        }
        return -1;
      }, Back(t) {
        const e = this._GetValue(t);
        if (Array.isArray(e)) {
          const t2 = e.at(-1);
          return this._ToSafeValue(t2);
        }
        return -1;
      }, Type(t) {
        return this._GetTypeOf(t);
      }, ArraySize(t) {
        const e = this._GetValue(t);
        return Array.isArray(e) ? e.length : -1;
      }, Path() {
        return this._path.map((t) => t.replace(/\./g, "\\.")).join(".");
      }, CurrentKey() {
        return this._currentKey;
      }, CurrentValue() {
        return this._ToSafeValue(this._currentValue);
      }, CurrentType() {
        return this._JSONTypeOf(this._currentValue);
      } };
    }
    {
      {
        const t = self.C3;
        t.Plugins.Arr = class extends t.SDKPluginBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.Arr.Type = class extends e.SDKTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        let ResizeArray2 = function(t, e, s3) {
          if (e < t.length) r2.truncateArray(t, e);
          else if (e > t.length) if ("function" == typeof s3) for (let r3 = t.length; r3 < e; ++r3) t.push(s3());
          else for (let r3 = t.length; r3 < e; ++r3) t.push(s3);
        };
        ResizeArray = ResizeArray2;
        const r2 = self.C3, s2 = self.C3X, i2 = self.IInstance;
        r2.Plugins.Arr.Instance = class extends r2.SDKInstanceBase {
          constructor(t, e) {
            super(t), this._cx = 10, this._cy = 1, this._cz = 1, this._arr = null, this._forX = [], this._forY = [], this._forZ = [], this._forDepth = -1, e && (this._cx = e[0], this._cy = e[1], this._cz = e[2]), this._arr = r2.MakeFilledArray(this._cx, () => r2.MakeFilledArray(this._cy, () => r2.MakeFilledArray(this._cz, 0)));
          }
          Release() {
            this._arr = null, super.Release();
          }
          At(t, e, r3) {
            return t = Math.floor(t), e = Math.floor(e), r3 = Math.floor(r3), t >= 0 && t < this._cx && e >= 0 && e < this._cy && r3 >= 0 && r3 < this._cz ? this._arr[t][e][r3] : 0;
          }
          Set(t, e, r3, s3) {
            t = Math.floor(t), e = Math.floor(e), r3 = Math.floor(r3), t >= 0 && t < this._cx && e >= 0 && e < this._cy && r3 >= 0 && r3 < this._cz && (this._arr[t][e][r3] = s3);
          }
          SetSize(t, e, s3) {
            if (t = Math.floor(t), e = Math.floor(e), s3 = Math.floor(s3), t < 0 && (t = 0), e < 0 && (e = 0), s3 < 0 && (s3 = 0), this._cx === t && this._cy === e && this._cz === s3) return;
            this._cx = t, this._cy = e, this._cz = s3;
            const i3 = this._arr;
            ResizeArray2(i3, t, () => r2.MakeFilledArray(e, () => r2.MakeFilledArray(s3, 0)));
            for (let h2 = 0; h2 < t; ++h2) {
              ResizeArray2(i3[h2], e, () => r2.MakeFilledArray(s3, 0));
              for (let t2 = 0; t2 < e; ++t2) ResizeArray2(i3[h2][t2], s3, 0);
            }
          }
          GetWidth() {
            return this._cx;
          }
          GetHeight() {
            return this._cy;
          }
          GetDepth() {
            return this._cz;
          }
          _ShuffleHelper(t, e, r3, s3, i3) {
            for (; e > 0; ) {
              const h2 = Math.floor(this._runtime.Random() * e);
              if (--e, 0 === t) {
                const t2 = this.At(e, s3, i3), r4 = this.At(h2, s3, i3);
                this.Set(e, s3, i3, r4), this.Set(h2, s3, i3, t2);
              } else if (1 === t) {
                const t2 = this.At(r3, e, i3), s4 = this.At(r3, h2, i3);
                this.Set(r3, e, i3, s4), this.Set(r3, h2, i3, t2);
              } else if (2 === t) {
                const t2 = this.At(r3, s3, e), i4 = this.At(r3, s3, h2);
                this.Set(r3, s3, e, i4), this.Set(r3, s3, h2, t2);
              }
            }
          }
          GetDebuggerProperties() {
            const t = "plugins.arr.debugger", e = "plugins.arr.properties", r3 = [{ title: t + ".array-properties.title", properties: [{ name: e + ".width.name", value: this._cx, onedit: (t2) => this.SetSize(t2, this._cy, this._cz) }, { name: e + ".height.name", value: this._cy, onedit: (t2) => this.SetSize(this._cx, t2, this._cz) }, { name: e + ".depth.name", value: this._cz, onedit: (t2) => this.SetSize(this._cx, this._cy, t2) }, { name: e + ".elements.name", value: this._cx * this._cy * this._cz }] }], s3 = [];
            if (1 === this._cy && 1 === this._cz) for (let t2 = 0; t2 < this._cx; ++t2) s3.push({ name: "$" + t2, value: this._arr[t2][0][0], onedit: (e2) => this._arr[t2][0][0] = e2 });
            else for (let t2 = 0; t2 < this._cx; ++t2) s3.push({ name: "$" + t2, value: this._arr[t2].toString() });
            return s3.length && r3.push({ title: t + ".array-data.title", properties: s3 }), r3;
          }
          GetAsJsonString() {
            return JSON.stringify({ "c2array": true, "size": [this._cx, this._cy, this._cz], "data": this._arr });
          }
          SaveToJson() {
            return { "size": [this._cx, this._cy, this._cz], "data": this._arr };
          }
          LoadFromJson(t) {
            const e = t["size"];
            this._cx = e[0], this._cy = e[1], this._cz = e[2], this._arr = t["data"];
          }
          _GetForX() {
            return this._forDepth >= 0 && this._forDepth < this._forX.length ? this._forX[this._forDepth] : 0;
          }
          _GetForY() {
            return this._forDepth >= 0 && this._forDepth < this._forY.length ? this._forY[this._forDepth] : 0;
          }
          _GetForZ() {
            return this._forDepth >= 0 && this._forDepth < this._forZ.length ? this._forZ[this._forDepth] : 0;
          }
          GetScriptInterfaceClass() {
            return self.IArrayInstance;
          }
        };
        const h = /* @__PURE__ */ new WeakMap();
        self.IArrayInstance = class extends i2 {
          constructor() {
            super(), h.set(this, i2._GetInitInst().GetSdkInstance());
          }
          get width() {
            return h.get(this).GetWidth();
          }
          get height() {
            return h.get(this).GetHeight();
          }
          get depth() {
            return h.get(this).GetDepth();
          }
          setSize(t, e = 1, r3 = 1) {
            s2.RequireFiniteNumber(t), s2.RequireFiniteNumber(e), s2.RequireFiniteNumber(r3), h.get(this).SetSize(t, e, r3);
          }
          getAt(t, e = 0, r3 = 0) {
            return s2.RequireFiniteNumber(t), s2.RequireFiniteNumber(e), s2.RequireFiniteNumber(r3), h.get(this).At(t, e, r3);
          }
          setAt(t, e, r3 = 0, i3 = 0) {
            if (s2.RequireFiniteNumber(e), s2.RequireFiniteNumber(r3), s2.RequireFiniteNumber(i3), "number" != typeof t && "string" != typeof t) throw new TypeError("invalid type");
            h.get(this).Set(e, r3, i3, t);
          }
        };
      }
      {
        let DoForEachTrigger2 = function(t, e, r2, s2, i2, h) {
          t.PushCopySol(r2);
          h.GetObjectClass().GetCurrentSol().PickOne(h.GetInstance()), e.Retrigger(s2, i2), t.PopSol(r2);
        };
        DoForEachTrigger = DoForEachTrigger2;
        const o2 = self.C3;
        o2.Plugins.Arr.Cnds = { CompareX(t, e, r2) {
          return o2.compare(this.At(t, 0, 0), e, r2);
        }, CompareXY(t, e, r2, s2) {
          return o2.compare(this.At(t, e, 0), r2, s2);
        }, CompareXYZ(t, e, r2, s2, i2) {
          return o2.compare(this.At(t, e, r2), s2, i2);
        }, ArrForEach(t) {
          const e = this._runtime, r2 = e.GetEventSheetManager(), s2 = e.GetCurrentEvent(), i2 = s2.GetSolModifiers(), h = e.GetEventStack(), o3 = h.GetCurrentStackFrame(), n = h.Push(s2), l2 = ++this._forDepth, c2 = this._forX, a2 = this._forY, f2 = this._forZ, _ = this._cx, u = this._cy, p = this._cz;
          if (l2 === this._forX.length ? (c2.push(0), a2.push(0), f2.push(0)) : (c2[l2] = 0, a2[l2] = 0, f2[l2] = 0), e.SetDebuggingEnabled(false), 0 === t) for (let t2 = 0; t2 < _; ++t2) for (let e2 = 0; e2 < u; ++e2) for (let h2 = 0; h2 < p; ++h2) c2[l2] = t2, a2[l2] = e2, f2[l2] = h2, DoForEachTrigger2(r2, s2, i2, o3, n, this);
          else if (1 === t) for (let t2 = 0; t2 < _; ++t2) for (let e2 = 0; e2 < u; ++e2) c2[l2] = t2, a2[l2] = e2, DoForEachTrigger2(r2, s2, i2, o3, n, this);
          else for (let t2 = 0; t2 < _; ++t2) c2[l2] = t2, DoForEachTrigger2(r2, s2, i2, o3, n, this);
          return e.SetDebuggingEnabled(true), this._forDepth--, h.Pop(), false;
        }, CompareCurrent(t, e) {
          return o2.compare(this.At(this._GetForX(), this._GetForY(), this._GetForZ()), t, e);
        }, Contains(t) {
          const e = this._cx, r2 = this._cy, s2 = this._cz, i2 = this._arr;
          for (let h = 0; h < e; ++h) for (let e2 = 0; e2 < r2; ++e2) for (let r3 = 0; r3 < s2; ++r3) if (i2[h][e2][r3] === t) return true;
          return false;
        }, IsEmpty() {
          return 0 === this._cx || 0 === this._cy || 0 === this._cz;
        }, CompareSize(t, e, r2) {
          let s2 = 0;
          switch (t) {
            case 0:
              s2 = this._cx;
              break;
            case 1:
              s2 = this._cy;
              break;
            case 2:
              s2 = this._cz;
          }
          return o2.compare(s2, e, r2);
        } };
      }
      {
        let CompareValues2 = function(t, e) {
          if ("number" == typeof t && "number" == typeof e) return t - e;
          {
            const r2 = t.toString(), s2 = e.toString();
            return r2 < s2 ? -1 : r2 > s2 ? 1 : 0;
          }
        };
        CompareValues = CompareValues2;
        const n = self.C3;
        n.Plugins.Arr.Acts = { Clear(t) {
          const e = this._cx, r2 = this._cy, s2 = this._cz, i2 = this._arr;
          for (let h = 0; h < e; ++h) for (let e2 = 0; e2 < r2; ++e2) for (let r3 = 0; r3 < s2; ++r3) i2[h][e2][r3] = t;
        }, SetSize(t, e, r2) {
          this.SetSize(t, e, r2);
        }, SetX(t, e) {
          this.Set(t, 0, 0, e);
        }, SetXY(t, e, r2) {
          this.Set(t, e, 0, r2);
        }, SetXYZ(t, e, r2, s2) {
          this.Set(t, e, r2, s2);
        }, Push(t, e, r2) {
          const s2 = this._cx, i2 = this._cy, h = this._cz, o2 = this._arr;
          if (0 === r2) {
            const r3 = n.MakeFilledArray(i2, () => n.MakeFilledArray(h, e));
            0 === t ? o2.push(r3) : o2.unshift(r3), this._cx++;
          } else if (1 === r2) {
            for (let r3 = 0; r3 < s2; ++r3) {
              const s3 = n.MakeFilledArray(h, e);
              0 === t ? o2[r3].push(s3) : o2[r3].unshift(s3);
            }
            this._cy++;
          } else {
            for (let r3 = 0; r3 < s2; ++r3) for (let s3 = 0; s3 < i2; ++s3) 0 === t ? o2[r3][s3].push(e) : o2[r3][s3].unshift(e);
            this._cz++;
          }
        }, Pop(t, e) {
          const r2 = this._cx, s2 = this._cy, i2 = this._cz, h = this._arr;
          if (0 === e) {
            if (0 === r2) return;
            0 === t ? h.pop() : h.shift(), this._cx--;
          } else if (1 === e) {
            if (0 === s2) return;
            for (let e2 = 0; e2 < r2; ++e2) 0 === t ? h[e2].pop() : h[e2].shift();
            this._cy--;
          } else {
            if (0 === i2) return;
            for (let e2 = 0; e2 < r2; ++e2) for (let r3 = 0; r3 < s2; ++r3) 0 === t ? h[e2][r3].pop() : h[e2][r3].shift();
            this._cz--;
          }
        }, Reverse(t) {
          const e = this._cx, r2 = this._cy, s2 = this._cz, i2 = this._arr;
          if (0 !== e && 0 !== r2 && 0 !== s2) if (0 === t) i2.reverse();
          else if (1 === t) for (let t2 = 0; t2 < e; ++t2) i2[t2].reverse();
          else for (let t2 = 0; t2 < e; ++t2) for (let e2 = 0; e2 < r2; ++e2) i2[t2][e2].reverse();
        }, Sort(t) {
          const e = this._cx, r2 = this._cy, s2 = this._cz, i2 = this._arr;
          if (0 !== e && 0 !== r2 && 0 !== s2) if (0 === t) i2.sort((t2, e2) => CompareValues2(t2[0][0], e2[0][0]));
          else if (1 === t) for (let t2 = 0; t2 < e; ++t2) i2[t2].sort((t3, e2) => CompareValues2(t3[0], e2[0]));
          else for (let t2 = 0; t2 < e; ++t2) for (let e2 = 0; e2 < r2; ++e2) i2[t2][e2].sort(CompareValues2);
        }, Sort2(t) {
          const e = this._cx, r2 = this._cy, s2 = this._cz, i2 = this._arr;
          if (0 !== e && 0 !== r2 && 0 !== s2) if (0 === t) i2.sort((t2, e2) => {
            for (let s3 = 0; s3 < r2; ++s3) {
              const r3 = CompareValues2(t2[s3][0], e2[s3][0]);
              if (0 !== r3) return r3;
            }
            return 0;
          });
          else if (1 === t) for (let t2 = 0; t2 < r2; ++t2) {
            const r3 = [];
            for (let s3 = 0; s3 < e; ++s3) r3.push(i2[s3][t2]);
            r3.sort((t3, e2) => CompareValues2(t3[0], e2[0]));
            for (let s3 = 0; s3 < e; ++s3) i2[s3][t2] = r3[s3];
          }
          else if (2 === t) {
            const t2 = [];
            for (let e2 = 0; e2 < r2; ++e2) t2.push(e2);
            t2.sort((t3, r3) => {
              for (let s3 = 0; s3 < e; ++s3) {
                const e2 = CompareValues2(i2[s3][t3], i2[s3][r3]);
                if (0 !== e2) return e2;
              }
              return 0;
            });
            for (let r3 = 0; r3 < e; ++r3) {
              let e2 = [];
              for (const s3 of t2) e2.push(i2[r3][s3]);
              i2[r3] = e2;
            }
          } else if (3 === t) for (let t2 = 0; t2 < e; ++t2) i2[t2].sort((t3, e2) => CompareValues2(t3[0], e2[0]));
          else for (let t2 = 0; t2 < e; ++t2) for (let e2 = 0; e2 < r2; ++e2) i2[t2][e2].sort(CompareValues2);
        }, Shuffle(t) {
          const e = this._cx, r2 = this._cy, s2 = this._cz;
          if (0 !== e && 0 !== r2 && 0 !== s2) if (0 === t) for (let i2 = 0; i2 < r2; ++i2) for (let r3 = 0; r3 < s2; ++r3) this._ShuffleHelper(t, e, 0, i2, r3);
          else if (1 === t) for (let i2 = 0; i2 < e; ++i2) for (let e2 = 0; e2 < s2; ++e2) this._ShuffleHelper(t, r2, i2, 0, e2);
          else for (let i2 = 0; i2 < e; ++i2) for (let e2 = 0; e2 < r2; ++e2) this._ShuffleHelper(t, s2, i2, e2, 0);
        }, Delete(t, e) {
          if ((t = Math.floor(t)) < 0) return;
          const r2 = this._cx, s2 = this._cy, i2 = this._cz, h = this._arr;
          if (0 === e) {
            if (t >= r2) return;
            h.splice(t, 1), this._cx--;
          } else if (1 === e) {
            if (t >= s2) return;
            for (let e2 = 0; e2 < r2; ++e2) h[e2].splice(t, 1);
            this._cy--;
          } else {
            if (t >= i2) return;
            for (let e2 = 0; e2 < r2; ++e2) for (let r3 = 0; r3 < s2; ++r3) h[e2][r3].splice(t, 1);
            this._cz--;
          }
        }, Insert(t, e, r2) {
          if ((e = Math.floor(e)) < 0) return;
          const s2 = this._cx, i2 = this._cy, h = this._cz, o2 = this._arr;
          if (0 === r2) {
            if (e > s2) return;
            o2.splice(e, 0, n.MakeFilledArray(i2, () => n.MakeFilledArray(h, t))), this._cx++;
          } else if (1 === r2) {
            if (e > i2) return;
            for (let r3 = 0; r3 < s2; ++r3) o2[r3].splice(e, 0, n.MakeFilledArray(h, t));
            this._cy++;
          } else {
            if (e > h) return;
            for (let r3 = 0; r3 < s2; ++r3) for (let s3 = 0; s3 < i2; ++s3) o2[r3][s3].splice(e, 0, t);
            this._cz++;
          }
        }, SplitString(t, e, r2) {
          const s2 = t.split(e);
          this.SetSize(s2.length, 1, 1);
          for (let t2 = 0, e2 = s2.length; t2 < e2; ++t2) {
            let e3 = s2[t2];
            0 === r2 ? String(Number(e3)) === e3 && (e3 = Number(e3)) : 2 === r2 && (e3 = Number(e3)), this.Set(t2, 0, 0, e3);
          }
        }, JSONLoad(t) {
          let e = null;
          try {
            e = JSON.parse(t);
          } catch (t2) {
            return void console.error("[Construct] Failed to parse JSON: ", t2);
          }
          if (!e["c2array"]) return void console.warn("[Array] Attempted to load JSON that does not appear to be Construct array data - no data loaded");
          const r2 = e["size"];
          this._cx = r2[0], this._cy = r2[1], this._cz = r2[2], this._arr = e["data"];
        }, JSONDownload(t) {
          const e = URL.createObjectURL(new Blob([this.GetAsJsonString()], { type: "application/json" }));
          this._runtime.InvokeDownload(e, t);
        } };
      }
      self.C3.Plugins.Arr.Exps = { At(t, e, r2) {
        return this.At(t, e || 0, r2 || 0);
      }, Width() {
        return this._cx;
      }, Height() {
        return this._cy;
      }, Depth() {
        return this._cz;
      }, CurX() {
        return this._GetForX();
      }, CurY() {
        return this._GetForY();
      }, CurZ() {
        return this._GetForZ();
      }, CurValue() {
        return this.At(this._GetForX(), this._GetForY(), this._GetForZ());
      }, Front() {
        return this.At(0, 0, 0);
      }, Back() {
        return this.At(this._cx - 1, 0, 0);
      }, IndexOf(t) {
        const e = this._arr;
        for (let r2 = 0, s2 = this._cx; r2 < s2; ++r2) if (e[r2][0][0] === t) return r2;
        return -1;
      }, LastIndexOf(t) {
        const e = this._arr;
        for (let r2 = this._cx - 1; r2 >= 0; --r2) if (e[r2][0][0] === t) return r2;
        return -1;
      }, JoinString(t) {
        let e = [];
        for (let t2 = 0; t2 < this._cx; ++t2) e.push(this.At(t2, 0, 0));
        return e.join(t);
      }, AsJSON() {
        return this.GetAsJsonString();
      } };
    }
    var ResizeArray;
    var DoForEachTrigger;
    var CompareValues;
    {
      {
        const t = self.C3;
        t.Plugins.Touch = class extends t.SDKPluginBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        let GetTouchSdkInstance2 = function() {
          return i2.GetSingleGlobalInstance().GetSdkInstance();
        };
        GetTouchSdkInstance = GetTouchSdkInstance2;
        const e = self.C3, s2 = self.C3X;
        e.Plugins.Touch.Type = class extends e.SDKTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
          GetScriptInterfaceClass() {
            return self.ITouchObjectType;
          }
        };
        let i2 = null;
        self.ITouchObjectType = class extends self.IObjectType {
          constructor(t) {
            super(t), i2 = t, t.GetRuntime()._GetCommonScriptInterfaces().touch = this;
          }
          requestPermission(t) {
            s2.RequireString(t);
            const e2 = GetTouchSdkInstance2();
            if ("orientation" === t) return e2._RequestPermission(0);
            if ("motion" === t) return e2._RequestPermission(1);
            throw new Error("invalid type");
          }
        };
      }
      {
        const n = self.C3, r2 = "touch";
        n.Plugins.Touch.Instance = class extends n.SDKInstanceBase {
          constructor(t, e) {
            super(t, r2), this._touches = /* @__PURE__ */ new Map(), this._useMouseInput = false, this._isMouseDown = false, this._orientCompassHeading = 0, this._orientAlpha = 0, this._orientBeta = 0, this._orientGamma = 0, this._accX = 0, this._accY = 0, this._accZ = 0, this._accWithGX = 0, this._accWithGY = 0, this._accWithGZ = 0, this._triggerIndex = 0, this._triggerId = 0, this._triggerPermission = 0, this._curTouchX = 0, this._curTouchY = 0, this._getTouchIndex = 0, this._triggerType = 0, this._permissionPromises = [], e && (this._useMouseInput = e[0]), this.AddDOMMessageHandler("permission-result", (t2) => this._OnPermissionResult(t2));
            const s2 = this.GetRuntime().Dispatcher();
            this._disposables = new n.CompositeDisposable(n.Disposable.From(s2, "pointerdown", (t2) => this._OnPointerDown(t2.data)), n.Disposable.From(s2, "pointermove", (t2) => this._OnPointerMove(t2.data)), n.Disposable.From(s2, "pointerup", (t2) => this._OnPointerUp(t2.data, false)), n.Disposable.From(s2, "pointercancel", (t2) => this._OnPointerUp(t2.data, true)), n.Disposable.From(s2, "deviceorientation", (t2) => this._OnDeviceOrientation(t2.data)), n.Disposable.From(s2, "deviceorientationabsolute", (t2) => this._OnDeviceOrientationAbsolute(t2.data)), n.Disposable.From(s2, "devicemotion", (t2) => this._OnDeviceMotion(t2.data)), n.Disposable.From(s2, "tick2", (t2) => this._OnTick2()));
          }
          Release() {
            this._touches.clear(), super.Release();
          }
          _OnPointerDown(t) {
            if ("mouse" === t["pointerType"]) {
              if (!this._useMouseInput) return;
              this._isMouseDown = true;
            }
            const e = t["pointerId"];
            if (this._touches.has(e)) return;
            const s2 = t["pageX"] - this._runtime.GetCanvasClientX(), i2 = t["pageY"] - this._runtime.GetCanvasClientY(), r3 = performance.now(), o2 = this._touches.size;
            this._triggerIndex = o2, this._triggerId = e;
            const u = n.New(n.Plugins.Touch.TouchInfo);
            u.Init(r3, s2, i2, e, o2), this._touches.set(e, u), this.Trigger(n.Plugins.Touch.Cnds.OnNthTouchStart), this.Trigger(n.Plugins.Touch.Cnds.OnTouchStart), this._curTouchX = s2, this._curTouchY = i2, this._triggerType = 0, this.Trigger(n.Plugins.Touch.Cnds.OnTouchObject);
          }
          _OnPointerMove(t) {
            if ("mouse" === t["pointerType"] && !this._isMouseDown) return;
            const e = this._touches.get(t["pointerId"]);
            if (!e) return;
            const s2 = performance.now();
            if (s2 - e.GetTime() < 2) return;
            const i2 = t["pageX"] - this._runtime.GetCanvasClientX(), n2 = t["pageY"] - this._runtime.GetCanvasClientY();
            e.Update(s2, i2, n2, t["width"], t["height"], t["pressure"]);
          }
          _OnPointerUp(t, e) {
            if ("mouse" === t["pointerType"]) {
              if (!this._isMouseDown) return;
              this._isMouseDown = false;
            }
            const s2 = performance.now(), i2 = t["pointerId"], r3 = this._touches.get(i2);
            if (r3) {
              if (this._triggerIndex = r3.GetStartIndex(), this._triggerId = r3.GetId(), !e) {
                const e2 = t["pageX"] - this._runtime.GetCanvasClientX(), s3 = t["pageY"] - this._runtime.GetCanvasClientY();
                this._curTouchX = e2, this._curTouchY = s3, this._triggerType = 1, this.Trigger(n.Plugins.Touch.Cnds.OnTouchObject);
              }
              if (this.Trigger(n.Plugins.Touch.Cnds.OnNthTouchEnd), this.Trigger(n.Plugins.Touch.Cnds.OnTouchEnd), !e) {
                const t2 = r3.ShouldTriggerTap(s2);
                "single-tap" === t2 ? (this.Trigger(n.Plugins.Touch.Cnds.OnTapGesture), this._curTouchX = r3.GetX(), this._curTouchY = r3.GetY(), this.Trigger(n.Plugins.Touch.Cnds.OnTapGestureObject)) : "double-tap" === t2 && (this.Trigger(n.Plugins.Touch.Cnds.OnDoubleTapGesture), this._curTouchX = r3.GetX(), this._curTouchY = r3.GetY(), this.Trigger(n.Plugins.Touch.Cnds.OnDoubleTapGestureObject));
              }
              r3.Release(), this._touches.delete(i2);
            }
          }
          _RequestPermission(t) {
            return this._PostToDOMMaybeSync("request-permission", { "type": t }), new Promise((e, s2) => {
              this._permissionPromises.push({ type: t, resolve: e, reject: s2 });
            });
          }
          _OnPermissionResult(t) {
            const e = t["result"], s2 = t["type"];
            this._triggerPermission = s2;
            const i2 = this._permissionPromises.filter((t2) => t2.type === s2);
            for (const t2 of i2) t2.resolve(e ? "granted" : "denied");
            this._permissionPromises = this._permissionPromises.filter((t2) => t2.type !== s2), e ? (this.Trigger(n.Plugins.Touch.Cnds.OnPermissionGranted), 0 === s2 ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(n.Plugins.Touch.Cnds.OnPermissionDenied);
          }
          _OnDeviceOrientation(t) {
            "number" == typeof t["webkitCompassHeading"] ? this._orientCompassHeading = t["webkitCompassHeading"] : t["absolute"] && (this._orientCompassHeading = t["alpha"]), this._orientAlpha = t["alpha"], this._orientBeta = t["beta"], this._orientGamma = t["gamma"];
          }
          _OnDeviceOrientationAbsolute(t) {
            this._orientCompassHeading = t["alpha"];
          }
          _OnDeviceMotion(t) {
            const e = t["acceleration"];
            e && (this._accX = e["x"], this._accY = e["y"], this._accZ = e["z"]);
            const s2 = t["accelerationIncludingGravity"];
            s2 && (this._accWithGX = s2["x"], this._accWithGY = s2["y"], this._accWithGZ = s2["z"]);
          }
          _OnTick2() {
            const t = performance.now();
            let e = 0;
            for (const s2 of this._touches.values()) s2.GetTime() <= t - 50 && s2._SetLastTime(t), s2.ShouldTriggerHold(t) && (this._triggerIndex = s2.GetStartIndex(), this._triggerId = s2.GetId(), this._getTouchIndex = e, this.Trigger(n.Plugins.Touch.Cnds.OnHoldGesture), this._curTouchX = s2.GetX(), this._curTouchY = s2.GetY(), this.Trigger(n.Plugins.Touch.Cnds.OnHoldGestureObject), this._getTouchIndex = 0), ++e;
          }
          _GetTouchByIndex(t) {
            t = Math.floor(t);
            for (const e of this._touches.values()) {
              if (0 === t) return e;
              --t;
            }
            return null;
          }
          _IsClientPosOnCanvas(t, e) {
            return t >= 0 && e >= 0 && t < this._runtime.GetCanvasCssWidth() && e < this._runtime.GetCanvasCssHeight();
          }
          GetDebuggerProperties() {
            return [{ title: "plugins.touch.debugger.touches", properties: [...this._touches.values()].map((t) => ({ name: "$" + t.GetId(), value: t.GetX() + ", " + t.GetY() })) }];
          }
        };
      }
      {
        const o2 = self.C3;
        o2.Plugins.Touch.Cnds = { OnTouchStart: () => true, OnTouchEnd: () => true, IsInTouch() {
          return this._touches.size > 0;
        }, OnTouchObject(t, e) {
          return !!t && (e === this._triggerType && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false)));
        }, IsTouchingObject(t) {
          if (!t) return false;
          const e = this._runtime.GetCurrentCondition().IsInverted(), s2 = [...this._touches.values()].filter((t2) => this._IsClientPosOnCanvas(t2.GetX(), t2.GetY())).map((t2) => [t2.GetX(), t2.GetY()]);
          return o2.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, s2, e), e);
        }, CompareTouchSpeed(t, e, s2) {
          const i2 = this._GetTouchByIndex(t);
          return !!i2 && o2.compare(i2.GetSpeed(), e, s2);
        }, OrientationSupported: () => true, MotionSupported: () => true, CompareOrientation(t, e, s2) {
          this._runtime.RequestDeviceOrientationEvent();
          let i2 = 0;
          return i2 = 0 === t ? this._orientAlpha : 1 === t ? this._orientBeta : this._orientGamma, o2.compare(i2, e, s2);
        }, CompareAcceleration(t, e, s2) {
          this._runtime.RequestDeviceMotionEvent();
          let i2 = 0;
          return i2 = 0 === t ? this._accWithGX : 1 === t ? this._accWithGY : 2 === t ? this._accWithGZ : 3 === t ? this._accX : 4 === t ? this._accY : this._accZ, o2.compare(i2, e, s2);
        }, OnNthTouchStart(t) {
          return (t = Math.floor(t)) === this._triggerIndex;
        }, OnNthTouchEnd(t) {
          return (t = Math.floor(t)) === this._triggerIndex;
        }, HasNthTouch(t) {
          return t = Math.floor(t), this._touches.size >= t + 1;
        }, OnHoldGesture: () => true, OnTapGesture: () => true, OnDoubleTapGesture: () => true, OnHoldGestureObject(t) {
          return !!t && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false));
        }, OnTapGestureObject(t) {
          return !!t && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false));
        }, OnDoubleTapGestureObject(t) {
          return !!t && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false));
        }, OnPermissionGranted(t) {
          return this._triggerPermission === t;
        }, OnPermissionDenied(t) {
          return this._triggerPermission === t;
        } };
      }
      self.C3.Plugins.Touch.Acts = { RequestPermission(t) {
        this._RequestPermission(t);
      } };
      {
        const u = self.C3;
        u.Plugins.Touch.Exps = { TouchCount() {
          return this._touches.size;
        }, X(t) {
          const e = this._GetTouchByIndex(this._getTouchIndex);
          return e ? e.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, true) : 0;
        }, Y(t) {
          const e = this._GetTouchByIndex(this._getTouchIndex);
          return e ? e.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, false) : 0;
        }, XAt(t, e) {
          const s2 = this._GetTouchByIndex(t);
          return s2 ? s2.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, true) : 0;
        }, YAt(t, e) {
          const s2 = this._GetTouchByIndex(t);
          return s2 ? s2.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, false) : 0;
        }, XForID(t, e) {
          const s2 = this._touches.get(t);
          return s2 ? s2.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, true) : 0;
        }, YForID(t, e) {
          const s2 = this._touches.get(t);
          return s2 ? s2.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, false) : 0;
        }, AbsoluteX() {
          const t = this._GetTouchByIndex(0);
          return t ? t.GetX() : 0;
        }, AbsoluteY() {
          const t = this._GetTouchByIndex(0);
          return t ? t.GetY() : 0;
        }, AbsoluteXAt(t) {
          const e = this._GetTouchByIndex(t);
          return e ? e.GetX() : 0;
        }, AbsoluteYAt(t) {
          const e = this._GetTouchByIndex(t);
          return e ? e.GetY() : 0;
        }, AbsoluteXForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetX() : 0;
        }, AbsoluteYForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetY() : 0;
        }, SpeedAt(t) {
          const e = this._GetTouchByIndex(t);
          return e ? e.GetSpeed() : 0;
        }, SpeedForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetSpeed() : 0;
        }, AngleAt(t) {
          const e = this._GetTouchByIndex(t);
          return e ? u.toDegrees(e.GetAngle()) : 0;
        }, AngleForID(t) {
          const e = this._touches.get(t);
          return e ? u.toDegrees(e.GetAngle()) : 0;
        }, CompassHeading() {
          return this._runtime.RequestDeviceOrientationEvent(), this._orientCompassHeading;
        }, Alpha() {
          return this._runtime.RequestDeviceOrientationEvent(), this._orientAlpha;
        }, Beta() {
          return this._runtime.RequestDeviceOrientationEvent(), this._orientBeta;
        }, Gamma() {
          return this._runtime.RequestDeviceOrientationEvent(), this._orientGamma;
        }, AccelerationXWithG() {
          return this._runtime.RequestDeviceMotionEvent(), this._accWithGX;
        }, AccelerationYWithG() {
          return this._runtime.RequestDeviceMotionEvent(), this._accWithGY;
        }, AccelerationZWithG() {
          return this._runtime.RequestDeviceMotionEvent(), this._accWithGZ;
        }, AccelerationX() {
          return this._runtime.RequestDeviceMotionEvent(), this._accX;
        }, AccelerationY() {
          return this._runtime.RequestDeviceMotionEvent(), this._accY;
        }, AccelerationZ() {
          return this._runtime.RequestDeviceMotionEvent(), this._accZ;
        }, TouchIndex() {
          return this._triggerIndex;
        }, TouchID() {
          return this._triggerId;
        }, WidthForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetWidth() : 0;
        }, HeightForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetHeight() : 0;
        }, PressureForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetPressure() : 0;
        } };
      }
    }
    var GetTouchSdkInstance;
    {
      const C33 = self.C3, GESTURE_HOLD_THRESHOLD = 15, GESTURE_HOLD_TIMEOUT = 500, GESTURE_TAP_TIMEOUT = 333, GESTURE_DOUBLETAP_THRESHOLD = 25;
      let lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4;
      C33.Plugins.Touch.TouchInfo = class extends C33.DefendedBase {
        constructor() {
          super(), this._pointerId = 0, this._startIndex = 0, this._startTime = 0, this._time = 0, this._lastTime = 0, this._startX = 0, this._startY = 0, this._x = 0, this._y = 0, this._lastX = 0, this._lastY = 0, this._width = 0, this._height = 0, this._pressure = 0, this._hasTriggeredHold = false, this._isTooFarForHold = false;
        }
        Release() {
        }
        Init(t, s2, i2, e, h) {
          this._pointerId = e, this._startIndex = h, this._time = t, this._lastTime = t, this._startTime = t, this._startX = s2, this._startY = i2, this._x = s2, this._y = i2, this._lastX = s2, this._lastY = i2;
        }
        Update(t, s2, i2, e, h, _) {
          this._lastTime = this._time, this._time = t, this._lastX = this._x, this._lastY = this._y, this._x = s2, this._y = i2, this._width = e, this._height = h, this._pressure = _, !this._isTooFarForHold && C33.distanceTo(this._startX, this._startY, this._x, this._y) >= 15 && (this._isTooFarForHold = true);
        }
        GetId() {
          return this._pointerId;
        }
        GetStartIndex() {
          return this._startIndex;
        }
        GetTime() {
          return this._time;
        }
        _SetLastTime(t) {
          this._lastTime = t;
        }
        GetX() {
          return this._x;
        }
        GetY() {
          return this._y;
        }
        GetSpeed() {
          const t = C33.distanceTo(this._x, this._y, this._lastX, this._lastY), s2 = (this._time - this._lastTime) / 1e3;
          return s2 > 0 ? t / s2 : 0;
        }
        GetAngle() {
          return C33.angleTo(this._lastX, this._lastY, this._x, this._y);
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        GetPressure() {
          return this._pressure;
        }
        ShouldTriggerHold(t) {
          return !this._hasTriggeredHold && (t - this._startTime >= 500 && !this._isTooFarForHold && C33.distanceTo(this._startX, this._startY, this._x, this._y) < 15 && (this._hasTriggeredHold = true, true));
        }
        ShouldTriggerTap(t) {
          return this._hasTriggeredHold ? "" : t - this._startTime <= 333 && !this._isTooFarForHold && C33.distanceTo(this._startX, this._startY, this._x, this._y) < 15 ? t - lastTapTime <= 666 && C33.distanceTo(lastTapX, lastTapY, this._x, this._y) < 25 ? (lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4, "double-tap") : (lastTapX = this._x, lastTapY = this._y, lastTapTime = t, "single-tap") : "";
        }
        GetPositionForLayer(t, s2, i2) {
          if (void 0 === s2) {
            return t.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(this._x, this._y)[i2 ? 0 : 1];
          }
          {
            const e = t.GetLayer(s2);
            return e ? e.CanvasCssToLayer(this._x, this._y)[i2 ? 0 : 1] : 0;
          }
        }
      };
    }
    {
      {
        const e = self.C3;
        e.Plugins.LocalStorage = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.LocalStorage.Type = class extends t.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const s2 = self.C3, r2 = "localstorage";
        s2.Plugins.LocalStorage.Instance = class extends s2.SDKInstanceBase {
          constructor(e, t) {
            super(e, r2), this._currentKey = "", this._lastValue = "", this._keyNamesList = [], this._errorMessage = "", this._isPersistent = false, this._pendingGets = 0, this._pendingSets = 0, this._isInMemoryOnly = false, t && (this._isInMemoryOnly = t[0]);
            const s3 = this._runtime._GetProjectStorage();
            this._storage = null, this._isInMemoryOnly ? this._storage = s3.createInstance({ forceInMemoryFallback: true }) : this._storage = s3, this._debugCache = /* @__PURE__ */ new Map(), this._isLoadingDebugCache = false, this._runtime.AddLoadPromise(this._Init());
          }
          async _Init() {
            const e = await Promise.race([this.PostToDOMAsync("init"), s2.Wait(3e3)]);
            e && (this._isPersistent = e["isPersistent"]);
          }
          Release() {
            super.Release();
          }
          async _TriggerStorageError(e) {
            this._errorMessage = this._GetErrorString(e), await this.TriggerAsync(s2.Plugins.LocalStorage.Cnds.OnError);
          }
          _GetErrorString(e) {
            return e ? "string" == typeof e ? e : "string" == typeof e.message ? e.message : "string" == typeof e.name ? e.name : "string" == typeof e.data ? e.data : "unknown error" : "unknown error";
          }
          GetDebuggerProperties() {
            return this._isLoadingDebugCache || this._DebugCacheStorage(), [{ title: "plugins.localstorage.name", properties: [...this._debugCache.entries()].map((e) => ({ name: "$" + e[0], value: e[1], onedit: (t) => this._storage.setItem(e[0], t) })) }];
          }
          async _DebugCacheStorage() {
            this._isLoadingDebugCache = true;
            try {
              const e = await this._storage.keys();
              e.sort((e2, t2) => {
                const s3 = e2.toLowerCase(), r3 = t2.toLowerCase();
                return s3 < r3 ? -1 : r3 < s3 ? 1 : 0;
              });
              const t = await Promise.all(e.map((e2) => this._storage.getItem(e2)));
              this._debugCache.clear();
              for (let s3 = 0, r3 = e.length; s3 < r3; ++s3) this._debugCache.set(e[s3], t[s3]);
            } catch (e) {
              console.warn("[C3 debugger] Error displaying local storage: ", e);
            } finally {
              this._isLoadingDebugCache = false;
            }
          }
        };
      }
      {
        const i2 = self.C3;
        i2.Plugins.LocalStorage.Cnds = { OnItemSet(e) {
          return this._currentKey === e;
        }, OnAnyItemSet: () => true, OnItemGet(e) {
          return this._currentKey === e;
        }, OnAnyItemGet: () => true, OnItemRemoved(e) {
          return this._currentKey === e;
        }, OnAnyItemRemoved: () => true, OnCleared: () => true, OnAllKeyNamesLoaded: () => true, OnError: () => true, OnItemExists(e) {
          return this._currentKey === e;
        }, OnItemMissing(e) {
          return this._currentKey === e;
        }, CompareKey(e, t) {
          return i2.compare(this._currentKey, e, t);
        }, CompareValue(e, t) {
          return i2.compare(this._lastValue, e, t);
        }, IsProcessingSets() {
          return this._pendingSets > 0;
        }, IsProcessingGets() {
          return this._pendingGets > 0;
        }, OnAllSetsComplete: () => true, OnAllGetsComplete: () => true, IsPersistent() {
          return this._isPersistent;
        } };
      }
      {
        let IsExpressionType2 = function(e) {
          return "string" == typeof e || "number" == typeof e;
        };
        IsExpressionType = IsExpressionType2;
        const a2 = self.C3;
        a2.Plugins.LocalStorage.Acts = { async SetItem(e, t) {
          this._pendingSets++;
          try {
            const s2 = await this._storage.setItem(e, t);
            await this.ScheduleTriggers(async () => {
              this._currentKey = e, this._lastValue = s2, await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnAnyItemSet), await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnItemSet);
            });
          } catch (e2) {
            await this._TriggerStorageError(e2);
          } finally {
            this._pendingSets--, 0 === this._pendingSets && await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnAllSetsComplete);
          }
        }, async SetBinaryItem(e, t) {
          if (!t) return;
          const s2 = t.GetFirstPicked(this._inst);
          if (!s2) return;
          const r2 = s2.GetSdkInstance();
          if (!r2) return;
          const i2 = r2.GetArrayBufferReadOnly();
          this._pendingSets++;
          try {
            await this._storage.setItem(e, i2), await this.ScheduleTriggers(async () => {
              this._currentKey = e, this._lastValue = "", await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnAnyItemSet), await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnItemSet);
            });
          } catch (e2) {
            await this._TriggerStorageError(e2);
          } finally {
            this._pendingSets--, 0 === this._pendingSets && await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnAllSetsComplete);
          }
        }, async GetItem(e) {
          this._pendingGets++;
          try {
            const t = await this._storage.getItem(e);
            await this.ScheduleTriggers(async () => {
              this._currentKey = e, this._lastValue = IsExpressionType2(t) ? t : "", await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnAnyItemGet), await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnItemGet);
            });
          } catch (e2) {
            await this._TriggerStorageError(e2);
          } finally {
            this._pendingGets--, 0 === this._pendingGets && await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnAllGetsComplete);
          }
        }, async GetBinaryItem(e, t) {
          if (!t) return;
          const s2 = t.GetFirstPicked(this._inst);
          if (!s2) return;
          const r2 = s2.GetSdkInstance();
          this._pendingGets++;
          try {
            let t2 = await this._storage.getItem(e);
            t2 = t2 instanceof ArrayBuffer ? t2 : new ArrayBuffer(0), await this.ScheduleTriggers(async () => {
              this._lastValue = "", this._currentKey = e, r2.SetArrayBufferTransfer(t2), await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnAnyItemGet), await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnItemGet);
            });
          } catch (e2) {
            await this._TriggerStorageError(e2);
          } finally {
            this._pendingGets--, 0 === this._pendingGets && await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnAllGetsComplete);
          }
        }, async CheckItemExists(e) {
          try {
            const t = await this._storage.getItem(e);
            await this.ScheduleTriggers(async () => {
              this._currentKey = e, null == t ? (this._lastValue = "", await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnItemMissing)) : (this._lastValue = IsExpressionType2(t) ? t : "", await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnItemExists));
            });
          } catch (e2) {
            await this._TriggerStorageError(e2);
          }
        }, async RemoveItem(e) {
          try {
            await this._storage.removeItem(e), await this.ScheduleTriggers(async () => {
              this._currentKey = e, this._lastValue = "", await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnAnyItemRemoved), await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnItemRemoved);
            });
          } catch (e2) {
            await this._TriggerStorageError(e2);
          }
        }, async ClearStorage() {
          try {
            await this._storage.clear(), await this.ScheduleTriggers(async () => {
              this._currentKey = "", this._lastValue = "", a2.clearArray(this._keyNamesList), await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnCleared);
            });
          } catch (e) {
            await this._TriggerStorageError(e);
          }
        }, async GetAllKeyNames() {
          try {
            const e = await this._storage.keys();
            await this.ScheduleTriggers(async () => {
              this._keyNamesList = e, await this.TriggerAsync(a2.Plugins.LocalStorage.Cnds.OnAllKeyNamesLoaded);
            });
          } catch (e) {
            await this._TriggerStorageError(e);
          }
        }, async RequestPersistent() {
          const e = await this.PostToDOMAsync("request-persistent");
          e["isOk"] && (this._isPersistent = e["isPersistent"]);
        }, LoadMemoryFromJSON(e) {
          if (!this._isInMemoryOnly) return;
          let t;
          try {
            t = JSON.parse(e);
          } catch (e2) {
            return void console.error("[Local Storage] Failed to parse memory storage JSON: ", e2);
          }
          t && t["is-c3-storage"] && Array.isArray(t["items"]) || console.error("[Local Storage] Failed to load memory storage JSON: invalid data"), this._storage.SetMemoryStorage(new Map(t["items"]));
        } };
      }
      self.C3.Plugins.LocalStorage.Exps = { ItemValue() {
        return this._lastValue;
      }, Key() {
        return this._currentKey;
      }, KeyCount() {
        return this._keyNamesList.length;
      }, KeyAt(e) {
        return (e = Math.floor(e)) < 0 || e >= this._keyNamesList.length ? "" : this._keyNamesList[e];
      }, ErrorMessage() {
        return this._errorMessage;
      }, MemoryStorageAsJSON() {
        return this._isInMemoryOnly ? JSON.stringify({ "is-c3-storage": true, "items": [...this._storage.GetMemoryStorage()] }) : "";
      } };
    }
    var IsExpressionType;
    {
      {
        const e = self.C3;
        e.Plugins.Date = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.Date.Type = class extends e.SDKTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.Date.Instance = class extends e.SDKInstanceBase {
          constructor(e2, t) {
            super(e2);
          }
        };
      }
      {
        const e = self.C3, t = [];
        t[0] = [(t2) => e.Plugins.Date.Exps.GetYear(t2), (t2) => e.Plugins.Date.Exps.GetMonth(t2), (t2) => e.Plugins.Date.Exps.GetDate(t2), (t2) => e.Plugins.Date.Exps.GetDay(t2), (t2) => e.Plugins.Date.Exps.GetHours(t2), (t2) => e.Plugins.Date.Exps.GetMinutes(t2), (t2) => e.Plugins.Date.Exps.GetSeconds(t2), (t2) => e.Plugins.Date.Exps.GetMilliseconds(t2)], t[1] = [(t2) => e.Plugins.Date.Exps.GetUTCYear(t2), (t2) => e.Plugins.Date.Exps.GetUTCMonth(t2), (t2) => e.Plugins.Date.Exps.GetUTCDate(t2), (t2) => e.Plugins.Date.Exps.GetUTCDay(t2), (t2) => e.Plugins.Date.Exps.GetUTCHours(t2), (t2) => e.Plugins.Date.Exps.GetUTCMinutes(t2), (t2) => e.Plugins.Date.Exps.GetUTCSeconds(t2), (t2) => e.Plugins.Date.Exps.GetUTCMilliseconds(t2)];
        const s2 = (t2) => e.Plugins.Date.Exps.Parse(t2);
        e.Plugins.Date.Cnds = { CompareTimeStamps: (t2, s3, n) => e.compare(t2, s3, n), CompareDateStrings: (t2, n, a2) => e.compare(s2(t2), n, s2(a2)), CompareTimestampParts: (s3, n, a2, l2) => e.compare(t[1][l2](s3), n, t[1][l2](a2)), CompareDateStringParts: (n, a2, l2, i2, o2) => e.compare(t[o2][i2](s2(n)), a2, t[o2][i2](s2(l2))) };
      }
      self.C3.Plugins.Date.Acts = {};
      {
        const e = self.C3, t = self.Intl, s2 = /* @__PURE__ */ new Map();
        s2.set("local", /* @__PURE__ */ new Map([["year", (e2) => new Date(e2).getFullYear()], ["month", (e2) => new Date(e2).getMonth()], ["date", (e2) => new Date(e2).getDate()], ["day", (e2) => new Date(e2).getDay()], ["hours", (e2) => new Date(e2).getHours()], ["minutes", (e2) => new Date(e2).getMinutes()], ["seconds", (e2) => new Date(e2).getSeconds()], ["milliseconds", (e2) => new Date(e2).getMilliseconds()]])), s2.set("universal", /* @__PURE__ */ new Map([["year", (e2) => new Date(e2).getUTCFullYear()], ["month", (e2) => new Date(e2).getUTCMonth()], ["date", (e2) => new Date(e2).getUTCDate()], ["day", (e2) => new Date(e2).getUTCDay()], ["hours", (e2) => new Date(e2).getUTCHours()], ["minutes", (e2) => new Date(e2).getUTCMinutes()], ["seconds", (e2) => new Date(e2).getUTCSeconds()], ["milliseconds", (e2) => new Date(e2).getUTCMilliseconds()]]));
        const n = /* @__PURE__ */ new Map();
        n.set("local", /* @__PURE__ */ new Map([["year", (e2, t2) => new Date(e2).setFullYear(t2)], ["month", (e2, t2) => new Date(e2).setMonth(t2)], ["date", (e2, t2) => new Date(e2).setDate(t2)], ["hours", (e2, t2) => new Date(e2).setHours(t2)], ["minutes", (e2, t2) => new Date(e2).setMinutes(t2)], ["seconds", (e2, t2) => new Date(e2).setSeconds(t2)], ["milliseconds", (e2, t2) => new Date(e2).setMilliseconds(t2)]])), n.set("universal", /* @__PURE__ */ new Map([["year", (e2, t2) => new Date(e2).setUTCFullYear(t2)], ["month", (e2, t2) => new Date(e2).setUTCMonth(t2)], ["date", (e2, t2) => new Date(e2).setUTCDate(t2)], ["hours", (e2, t2) => new Date(e2).setUTCHours(t2)], ["minutes", (e2, t2) => new Date(e2).setUTCMinutes(t2)], ["seconds", (e2, t2) => new Date(e2).setUTCSeconds(t2)], ["milliseconds", (e2, t2) => new Date(e2).setUTCMilliseconds(t2)]]));
        const a2 = function(e2, t2, s3, n2) {
          s3.includes(e2) && (n2[t2] = e2);
        }, l2 = function(e2, t2) {
          e2 && ("12" === e2 ? t2["hour12"] = true : "24" === e2 && (t2["hour12"] = false));
        }, i2 = function(e2) {
          try {
            return t.getCanonicalLocales(e2);
          } catch (e3) {
            return self.navigator.language;
          }
        }, o2 = ["full", "long", "medium", "short"], g = ["full", "long", "medium", "short"], r2 = ["long", "short", "narrow"], u = ["numeric", "2-digit"], c2 = ["numeric", "2-digit", "long", "short", "narrow"], D = ["numeric", "2-digit"], T = ["numeric", "2-digit"], C = ["numeric", "2-digit"], m = ["numeric", "2-digit"];
        e.Plugins.Date.Exps = { ToString: (e2) => new Date(e2).toString(), ToDateString: (e2) => new Date(e2).toDateString(), ToTimeString: (e2) => new Date(e2).toTimeString(), ToLocaleString: (e2) => new Date(e2).toLocaleString(), ToLocaleDateString: (e2) => new Date(e2).toLocaleDateString(), ToLocaleTimeString: (e2) => new Date(e2).toLocaleTimeString(), ToUTCString: (e2) => new Date(e2).toUTCString(), Parse: (e2) => Date.parse(e2), Get: (e2, t2, s3, n2, a3, l3, i3) => Date.UTC(e2, t2, s3, n2, a3, l3, i3), Now: () => Date.now(), ExportTimestamp() {
          return this.GetRuntime().GetExportTimestamp();
        }, TimezoneOffset: () => new Date(Date.now()).getTimezoneOffset(), GetYear: (e2) => s2.get("local").get("year")(e2), GetUTCYear: (e2) => s2.get("universal").get("year")(e2), GetMonth: (e2) => s2.get("local").get("month")(e2), GetUTCMonth: (e2) => s2.get("universal").get("month")(e2), GetDate: (e2) => s2.get("local").get("date")(e2), GetUTCDate: (e2) => s2.get("universal").get("date")(e2), GetDay: (e2) => s2.get("local").get("day")(e2), GetUTCDay: (e2) => s2.get("universal").get("day")(e2), GetHours: (e2) => s2.get("local").get("hours")(e2), GetUTCHours: (e2) => s2.get("universal").get("hours")(e2), GetMinutes: (e2) => s2.get("local").get("minutes")(e2), GetUTCMinutes: (e2) => s2.get("universal").get("minutes")(e2), GetSeconds: (e2) => s2.get("local").get("seconds")(e2), GetUTCSeconds: (e2) => s2.get("universal").get("seconds")(e2), GetMilliseconds: (e2) => s2.get("local").get("milliseconds")(e2), GetUTCMilliseconds: (e2) => s2.get("universal").get("milliseconds")(e2), ChangeYear: (e2, t2) => n.get("local").get("year")(e2, t2), ChangeUTCYear: (e2, t2) => n.get("universal").get("year")(e2, t2), ChangeMonth: (e2, t2) => n.get("local").get("month")(e2, t2), ChangeUTCMonth: (e2, t2) => n.get("universal").get("month")(e2, t2), ChangeDate: (e2, t2) => n.get("local").get("date")(e2, t2), ChangeUTCDate: (e2, t2) => n.get("universal").get("date")(e2, t2), ChangeDay(t2, s3) {
          const n2 = e.Plugins.Date.Exps.GetYear(t2), a3 = e.Plugins.Date.Exps.GetMonth(t2), l3 = e.Plugins.Date.Exps.GetDate(t2), i3 = e.Plugins.Date.Exps.GetHours(t2), o3 = e.Plugins.Date.Exps.GetMinutes(t2), g2 = e.Plugins.Date.Exps.GetSeconds(t2), r3 = e.Plugins.Date.Exps.GetMilliseconds(t2), u2 = e.Plugins.Date.Exps.GetDay(t2);
          return new Date(n2, a3, l3 + (s3 - u2), i3, o3, g2, r3).getTime();
        }, ChangeUTCDay(t2, s3) {
          const n2 = e.Plugins.Date.Exps.GetUTCYear(t2), a3 = e.Plugins.Date.Exps.GetUTCMonth(t2), l3 = e.Plugins.Date.Exps.GetUTCDate(t2), i3 = e.Plugins.Date.Exps.GetUTCHours(t2), o3 = e.Plugins.Date.Exps.GetUTCMinutes(t2), g2 = e.Plugins.Date.Exps.GetUTCSeconds(t2), r3 = e.Plugins.Date.Exps.GetUTCMilliseconds(t2), u2 = s3 - e.Plugins.Date.Exps.GetUTCDay(t2);
          return e.Plugins.Date.Exps.Get(n2, a3, l3 + u2, i3, o3, g2, r3);
        }, ChangeHours: (e2, t2) => n.get("local").get("hours")(e2, t2), ChangeUTCHours: (e2, t2) => n.get("universal").get("hours")(e2, t2), ChangeMinutes: (e2, t2) => n.get("local").get("minutes")(e2, t2), ChangeUTCMinutes: (e2, t2) => n.get("universal").get("minutes")(e2, t2), ChangeSeconds: (e2, t2) => n.get("local").get("seconds")(e2, t2), ChangeUTCSeconds: (e2, t2) => n.get("universal").get("seconds")(e2, t2), ChangeMilliseconds: (e2, t2) => n.get("local").get("milliseconds")(e2, t2), ChangeUTCMilliseconds: (e2, t2) => n.get("universal").get("milliseconds")(e2, t2), Difference: (e2, t2) => t2 - e2, ToTimerHours: (t2) => Math.trunc(e.Plugins.Date.Exps.ToTotalHours(t2)), ToTimerMinutes: (t2) => Math.trunc(e.Plugins.Date.Exps.ToTotalMinutes(t2)) % 60, ToTimerSeconds: (t2) => Math.trunc(e.Plugins.Date.Exps.ToTotalSeconds(t2)) % 60, ToTimerMilliseconds: (e2) => e2 % 1e3, ToTotalHours: (e2) => e2 / 36e5, ToTotalMinutes: (e2) => e2 / 6e4, ToTotalSeconds: (e2) => e2 / 1e3, FormatDateWithStyles(e2, s3, n2, r3, u2) {
          const c3 = i2(e2);
          if (!c3) return;
          let D2 = {};
          return a2.call(this, n2, "dateStyle", o2, D2), a2.call(this, r3, "timeStyle", g, D2), l2.call(this, u2, D2), new t.DateTimeFormat(c3, D2).format(s3);
        }, FormatDateWithComponents(e2, s3, n2, o3, g2, d2, h, p, w, G) {
          const U = i2(e2);
          if (!U) return;
          const M = {};
          return a2.call(this, n2, "weekday", r2, M), a2.call(this, o3, "year", u, M), a2.call(this, g2, "month", c2, M), a2.call(this, d2, "day", D, M), a2.call(this, h, "hour", T, M), a2.call(this, p, "minute", C, M), a2.call(this, w, "second", m, M), l2.call(this, G, M), new t.DateTimeFormat(U, M).format(s3);
        } };
      }
    }
    {
      {
        let MaybeCloseImageBitmap2 = function(e2) {
          e2 && e2["close"] && e2["close"]();
        };
        MaybeCloseImageBitmap = MaybeCloseImageBitmap2;
        const e = self.C3, t = "video";
        e.Plugins.video = class extends e.SDKDOMPluginBase {
          constructor(e2) {
            super(e2, t), this._postImageBitmaps = false, this._supportedFormats = {}, this._lastStateSequenceNumber = -1, this._videoState = /* @__PURE__ */ new Map(), this._runtime.AddLoadPromise(this._runtime.PostComponentMessageToDOMAsync("video", "init", { "isInWorker": this._runtime.IsInWorker() }).then((e3) => {
              this._postImageBitmaps = e3["postImageBitmaps"], this._supportedFormats = e3["supportedFormats"];
            })), this.AddElementMessageHandler("playback-event", (e3, t2) => e3._OnPlaybackEvent(t2)), this._runtime.AddDOMComponentMessageHandler(t, "state", (e3) => this._OnUpdateState(e3));
          }
          Release() {
            super.Release();
          }
          IsPostImageBitmapsMode() {
            return this._postImageBitmaps;
          }
          IsFormatSupported(e2) {
            return !!this._supportedFormats[e2];
          }
          _OnUpdateState(e2) {
            const t2 = e2["sequenceNumber"];
            if (t2 <= this._lastStateSequenceNumber) for (const t3 of Object.values(e2["videoData"])) MaybeCloseImageBitmap2(t3["imageBitmap"]);
            else {
              this._lastStateSequenceNumber = t2;
              for (const e3 of this._videoState.values()) MaybeCloseImageBitmap2(e3["imageBitmap"]);
              this._videoState.clear();
              for (const [t3, s2] of Object.entries(e2["videoData"])) this._videoState.set(parseInt(t3, 10), s2);
            }
          }
          _DeleteVideoState(e2) {
            this._videoState.delete(e2);
          }
          GetVideoState(e2) {
            return this._videoState.get(e2) || null;
          }
        };
      }
      {
        const s2 = self.C3;
        s2.Plugins.video.Type = class extends s2.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const i2 = self.C3, a2 = i2.New(i2.Rect), r2 = i2.New(i2.Quad), n = "video", o2 = ["webm-vp8", "webm-vp9", "webm-av1", "mp4-h264", "mp4-h265", "mp4-av1"];
        i2.Plugins.video.Instance = class extends i2.SDKDOMInstanceBase {
          constructor(e, t) {
            super(e, n), this._primarySrc = "", this._primaryFormat = "mp4-h264", this._secondarySrc = "", this._secondaryFormat = "webm-vp9", this._autoplay = 2, this._playInBackground = false, this._videoWasPlayingOnSuspend = false, this._webGLTexture = null, this._currentTrigger = -1, this._isSettingSource = 0, this._isPlaying = false, this._isPaused = false, this._hasEnded = false, this._isLooping = false, this._isMuted = false, this._volume = 0, t && (this._primarySrc = t[0], this._primaryFormat = o2[t[1]], this._secondarySrc = t[2], this._secondaryFormat = o2[t[3]], this._autoplay = t[4], this._playInBackground = t[5], this.GetWorldInfo().SetVisible(t[6]));
            const s2 = this._runtime.Dispatcher();
            this._disposables = new i2.CompositeDisposable(i2.Disposable.From(s2, "renderercontextlost", () => this._OnRendererContextLost()), i2.Disposable.From(s2, "suspend", () => this._OnSuspend()), i2.Disposable.From(s2, "resume", () => this._OnResume())), this.CreateElement({ "src": this.GetVideoSource(), "autoplay": this._autoplay });
          }
          Release() {
            this.GetPlugin()._DeleteVideoState(this.GetElementId()), this._ReleaseTexture(), super.Release();
          }
          _MaybeCreateTexture(e, t, s2) {
            if (this._webGLTexture) {
              if (this._webGLTexture.GetWidth() === t || this._webGLTexture.GetHeight() === s2) return;
              this._ReleaseTexture();
            }
            this._webGLTexture = e.CreateDynamicTexture(t, s2, { sampling: this._runtime.GetSampling(), mipMap: false });
          }
          _ReleaseTexture() {
            this._webGLTexture && (this._runtime.GetRenderer().DeleteTexture(this._webGLTexture), this._webGLTexture = null);
          }
          GetElementState() {
            return {};
          }
          DbToLinearNoCap(e) {
            return Math.pow(10, e / 20);
          }
          DbToLinear(e) {
            const t = this.DbToLinearNoCap(e);
            return isFinite(t) ? Math.max(Math.min(t, 1), 0) : 0;
          }
          LinearToDbNoCap(e) {
            return Math.log(e) / Math.log(10) * 20;
          }
          LinearToDb(e) {
            return this.LinearToDbNoCap(Math.max(Math.min(e, 1), 0));
          }
          GetVideoSource() {
            let e = "";
            const t = this.GetPlugin();
            return t.IsFormatSupported(this._primaryFormat) && this._primarySrc ? e = this._primarySrc : t.IsFormatSupported(this._secondaryFormat) && this._secondarySrc && (e = this._secondarySrc), e && i2.IsRelativeURL(e) ? this._runtime.GetAssetManager().GetMediaFileUrl(e) : e;
          }
          _OnRendererContextLost() {
            this._webGLTexture = null;
          }
          async _OnPlaybackEvent(e) {
            const t = e["type"];
            5 === t ? this._SetIsPlaying(true) : 2 === t ? (this._SetIsPlaying(false), this._hasEnded = true, this._isPaused = false) : 6 === t && (this._SetIsPlaying(false), this._isPaused = true, this._hasEnded = false), this._currentTrigger = t, await this.TriggerAsync(i2.Plugins.video.Cnds.OnPlaybackEvent);
          }
          _SetIsPlaying(e) {
            this._isPlaying = !!e, this._isPlaying ? (this._StartTicking(), this._isPaused = false, this._hasEnded = false) : this._StopTicking();
          }
          _OnSuspend() {
            this._playInBackground || this._isPlaying && (this._videoWasPlayingOnSuspend = true, this.PostToDOMElement("pause"));
          }
          _OnResume() {
            this._playInBackground || this._videoWasPlayingOnSuspend && (this.PostToDOMElement("play"), this._videoWasPlayingOnSuspend = false);
          }
          Draw(e) {
            const t = this.GetWorldInfo();
            let s2 = 0, i3 = 0, n2 = null;
            const o3 = this.GetPlugin().IsPostImageBitmapsMode();
            if (o3) {
              const e2 = this.GetMyState();
              if (!e2) return;
              n2 = e2["imageBitmap"], e2["imageBitmap"] = null, s2 = e2["videoWidth"], i3 = e2["videoHeight"];
            } else {
              const e2 = self["C3Video_GetElement"](this.GetElementId());
              if (!e2) return;
              s2 = e2.videoWidth, i3 = e2.videoHeight, n2 = e2;
            }
            if (s2 <= 0 || i3 <= 0) return;
            this._MaybeCreateTexture(e, s2, i3), n2 && (e.UpdateTexture(n2, this._webGLTexture), o3 && n2["close"] && n2["close"]());
            const h = s2 / i3, u = t.GetWidth(), l2 = t.GetHeight();
            let d2 = 0, m = 0, _ = 0, p = 0;
            u / l2 > h ? (_ = l2 * h, p = l2, d2 = Math.max(Math.floor((u - _) / 2), 0)) : (_ = u, p = u / h, m = Math.max(Math.floor((l2 - p) / 2), 0)), e.SetTexture(this._webGLTexture), a2.setWH(t.GetX() + d2, t.GetY() + m, _, p), r2.setFromRect(a2), e.Quad(r2);
          }
          Tick() {
            this._runtime.UpdateRender();
          }
          GetMyState() {
            return this.GetPlugin().GetVideoState(this.GetElementId());
          }
        };
      }
      self.C3.Plugins.video.Cnds = { IsPlaying() {
        return this._isPlaying;
      }, IsPaused() {
        return this._isPaused;
      }, HasEnded() {
        return this._hasEnded;
      }, IsMuted() {
        return this._isMuted;
      }, OnPlaybackEvent(e) {
        return this._currentTrigger === e;
      } };
      {
        const h = self.C3, u = ["webm-vp8", "webm-vp9", "webm-av1", "mp4-h264", "mp4-h265", "mp4-av1"];
        h.Plugins.video.Acts = { SetSource(e, t) {
          this._primarySrc = e, this._primaryFormat = "webm-vp8", this._secondarySrc = t, this._secondaryFormat = "mp4-h264", this.PostToDOMElement("set-source", { "src": this.GetVideoSource() }), this._ReleaseTexture();
        }, SetSource2(e, t, s2, i2) {
          this._primarySrc = e, this._primaryFormat = u[t], this._secondarySrc = s2, this._secondaryFormat = u[i2], this.PostToDOMElement("set-source", { "src": this.GetVideoSource() }), this._ReleaseTexture();
        }, SetPlaybackTime(e) {
          this.PostToDOMElement("set-playback-time", { "time": e });
        }, SetPlaybackRate(e) {
          this.PostToDOMElement("set-playback-rate", { "rate": e });
        }, SetLooping(e) {
          e = 0 !== e, this._isLooping !== e && (this._isLooping = e, this.PostToDOMElement("set-looping", { "isLooping": e }));
        }, SetMuted(e) {
          e = 0 !== e, this._isMuted !== e && (this._isMuted = e, this.PostToDOMElement("set-muted", { "isMuted": e }));
        }, SetVolume(e) {
          this._volume !== e && (this._volume = e, this.PostToDOMElement("set-volume", { "volume": this.DbToLinear(e) }));
        }, Pause() {
          this.PostToDOMElement("pause");
        }, Play() {
          this._PostToDOMElementMaybeSync("play");
        } };
      }
      self.C3.Plugins.video.Exps = { PlaybackTime() {
        const e = this.GetMyState();
        return e ? e["currentTime"] : 0;
      }, PlaybackRate() {
        const e = this.GetMyState();
        return e ? e["playbackRate"] : 1;
      }, Duration() {
        const e = this.GetMyState();
        return e ? e["duration"] : 0;
      }, Volume() {
        return this._volume;
      }, VideoWidth() {
        const e = this.GetMyState();
        return e ? e["videoWidth"] : 0;
      }, VideoHeight() {
        const e = this.GetMyState();
        return e ? e["videoHeight"] : 0;
      } };
    }
    var MaybeCloseImageBitmap;
    {
      "use strict";
      {
        C3.Plugins.GameAnalytics = class GameAnalyticsPlugin extends C3.SDKPluginBase {
          constructor(opts) {
            super(opts);
          }
          Release() {
            super.Release();
          }
        };
      }
    }
    {
      "use strict";
      {
        C3.Plugins.GameAnalytics.Type = class GameAnalyticsType extends C3.SDKTypeBase {
          constructor(objectClass) {
            super(objectClass);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
    }
    {
      "use strict";
      {
        C3.Plugins.GameAnalytics.Instance = class GameAnalyticsInstance extends C3.SDKInstanceBase {
          constructor(inst, properties) {
            super(inst);
            this._build = "";
            this._customUserId = "";
            this._enableManualSessionHandling = false;
            this._enableInfoLog = false;
            this._enableVerboseLog = false;
            this._autoDetectAppVersion = false;
            this._gameKeyBrowser = "";
            this._secretKeyBrowser = "";
            this._gameKeyAndroid = "";
            this._secretKeyAndroid = "";
            this._gameKeyIOS = "";
            this._secretKeyIOS = "";
            this._customDimensions01 = [];
            this._customDimensions02 = [];
            this._customDimensions03 = [];
            this._resourceCurrencies = [];
            this._resourceItemTypes = [];
            if (properties) {
              this._build = properties[0];
              this._customUserId = properties[1];
              this._enableManualSessionHandling = properties[2];
              this._enableInfoLog = properties[3];
              this._enableVerboseLog = properties[4];
              this._autoDetectAppVersion = properties[5];
              this._gameKeyBrowser = properties[6];
              this._secretKeyBrowser = properties[7];
              this._gameKeyAndroid = properties[8];
              this._secretKeyAndroid = properties[9];
              this._gameKeyIOS = properties[10];
              this._secretKeyIOS = properties[11];
            }
          }
          Release() {
            super.Release();
          }
          SaveToJson() {
            return {
              // data to be saved for savegames
            };
          }
          LoadFromJson(o2) {
          }
        };
      }
    }
    {
      "use strict";
      {
        C3.Plugins.GameAnalytics.Cnds = {
          isRemoteConfigsReady(functionName) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["isRemoteConfigsReady"] == "function") {
              var callback = function(result2) {
                if (functionName && globalThis["c2_callFunction"]) {
                  globalThis["c2_callFunction"](functionName, [result2 ? 1 : 0]);
                }
              };
              globalThis["GameAnalytics"]["isRemoteConfigsReady"](callback);
              return false;
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              return globalThis["gameanalytics"]["GameAnalytics"]["isRemoteConfigsReady"]();
            } else {
              console.log("isRemoteConfigsReady: GameAnalytics object not found");
              return false;
            }
          }
        };
      }
    }
    {
      "use strict";
      {
        C3.Plugins.GameAnalytics.Acts = {
          addAvailableCustomDimension01(dimension) {
            this._customDimensions01.push(dimension);
          },
          addAvailableCustomDimension02(dimension) {
            this._customDimensions02.push(dimension);
          },
          addAvailableCustomDimension03(dimension) {
            this._customDimensions03.push(dimension);
          },
          addAvailableResourceCurrency(currency) {
            this._resourceCurrencies.push(currency);
          },
          addAvailableResourceItemType(itemType) {
            this._resourceItemTypes.push(itemType);
          },
          initialize() {
            var VERSION = "3.0.13";
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["initialize"] == "function") {
              var ga = globalThis["GameAnalytics"];
              if (this._enableInfoLog) {
                ga["setEnabledInfoLog"](true);
              }
              if (this._enableVerboseLog) {
                ga["setEnabledVerboseLog"](true);
              }
              if (this._enableManualSessionHandling) {
                ga["setEnabledManualSessionHandling"](true);
              }
              if (this._customDimensions01.length > 0) {
                ga["configureAvailableCustomDimensions01"](this._customDimensions01);
              }
              if (this._customDimensions02.length > 0) {
                ga["configureAvailableCustomDimensions02"](this._customDimensions02);
              }
              if (this._customDimensions03.length > 0) {
                ga["configureAvailableCustomDimensions03"](this._customDimensions03);
              }
              if (this._resourceCurrencies.length > 0) {
                ga["configureAvailableResourceCurrencies"](this._resourceCurrencies);
              }
              if (this._resourceItemTypes.length > 0) {
                ga["configureAvailableResourceItemTypes"](this._resourceItemTypes);
              }
              ga["configureBuild"](this._build);
              if (this._autoDetectAppVersion) {
                ga["configureAutoDetectAppVersion"](true);
              }
              var sdkVersion = "construct " + VERSION;
              var gameKey = globalThis["device"]["platform"] === "Android" ? this._gameKeyAndroid : this._gameKeyIOS;
              var secretKey = globalThis["device"]["platform"] === "Android" ? this._secretKeyAndroid : this._secretKeyIOS;
              ga["initialize"]({
                "gameKey": gameKey,
                "secretKey": secretKey,
                "sdkVersion": sdkVersion
              });
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              var ga = globalThis["gameanalytics"]["GameAnalytics"];
              if (this._enableInfoLog) {
                ga["setEnabledInfoLog"](true);
              }
              if (this._enableVerboseLog) {
                ga["setEnabledVerboseLog"](true);
              }
              if (this._enableManualSessionHandling) {
                ga["setEnabledManualSessionHandling"](true);
              }
              if (this._customDimensions01.length > 0) {
                ga["configureAvailableCustomDimensions01"](this._customDimensions01);
              }
              if (this._customDimensions02.length > 0) {
                ga["configureAvailableCustomDimensions02"](this._customDimensions02);
              }
              if (this._customDimensions03.length > 0) {
                ga["configureAvailableCustomDimensions03"](this._customDimensions03);
              }
              if (this._resourceCurrencies.length > 0) {
                ga["configureAvailableResourceCurrencies"](this._resourceCurrencies);
              }
              if (this._resourceItemTypes.length > 0) {
                ga["configureAvailableResourceItemTypes"](this._resourceItemTypes);
              }
              ga["configureBuild"](this._build);
              ga["configureSdkGameEngineVersion"]("construct " + VERSION);
              ga["initialize"](this._gameKeyBrowser, this._secretKeyBrowser);
            } else {
              console.log("initialize: GameAnalytics object not found");
              return;
            }
          },
          addBusinessEvent(currency, amount, itemType, itemId, cartType) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["addBusinessEvent"] == "function") {
              globalThis["GameAnalytics"]["addBusinessEvent"]({
                "currency": currency,
                "amount": amount,
                "itemType": itemType,
                "itemId": itemId,
                "cartType": cartType
              });
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["addBusinessEvent"](currency, amount, itemType, itemId, cartType);
            } else {
              console.log("addBusinessEvent: GameAnalytics object not found");
              return;
            }
          },
          addResourceEvent(flowType, currency, amount, itemType, itemId) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["addResourceEvent"] == "function") {
              globalThis["GameAnalytics"]["addResourceEvent"]({
                "flowType": flowType,
                "currency": currency,
                "amount": amount,
                "itemType": itemType,
                "itemId": itemId
              });
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["addResourceEvent"](flowType, currency, amount, itemType, itemId);
            } else {
              console.log("addResourceEvent: GameAnalytics object not found");
              return;
            }
          },
          addProgressionEvent(progressionStatus, progression01, progression02, progression03) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["addProgressionEvent"] == "function") {
              globalThis["GameAnalytics"]["addProgressionEvent"]({
                "progressionStatus": progressionStatus,
                "progression01": progression01,
                "progression02": progression02,
                "progression03": progression03
              });
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["addProgressionEvent"](progressionStatus, progression01, progression02, progression03);
            } else {
              console.log("addProgressionEvent: GameAnalytics object not found");
              return;
            }
          },
          addProgressionEventWithScore(progressionStatus, progression01, progression02, progression03, score) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["addProgressionEvent"] == "function") {
              globalThis["GameAnalytics"]["addProgressionEvent"]({
                "progressionStatus": progressionStatus,
                "progression01": progression01,
                "progression02": progression02,
                "progression03": progression03,
                "score": score
              });
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["addProgressionEvent"](progressionStatus, progression01, progression02, progression03, score);
            } else {
              console.log("addProgressionEventWithScore: GameAnalytics object not found");
              return;
            }
          },
          addDesignEvent(eventId) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["addDesignEvent"] == "function") {
              globalThis["GameAnalytics"]["addDesignEvent"]({
                "eventId": eventId
              });
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["addDesignEvent"](eventId);
            } else {
              console.log("addDesignEvent: GameAnalytics object not found");
              return;
            }
          },
          addDesignEventWithValue(eventId, value) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["addDesignEvent"] == "function") {
              globalThis["GameAnalytics"]["addDesignEvent"]({
                "eventId": eventId,
                "value": value
              });
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["addDesignEvent"](eventId, value);
            } else {
              console.log("addDesignEventWithValue: GameAnalytics object not found");
              return;
            }
          },
          addErrorEvent(severity, message) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["addErrorEvent"] == "function") {
              globalThis["GameAnalytics"]["addErrorEvent"]({
                "severity": severity,
                "message": message
              });
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["addErrorEvent"](severity, message);
            } else {
              console.log("addErrorEvent: GameAnalytics object not found");
              return;
            }
          },
          setEnabledEventSubmission(flag) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["setEnabledEventSubmission"] == "function") {
              globalThis["GameAnalytics"]["setEnabledEventSubmission"](flag ? true : false);
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["setEnabledEventSubmission"](flag ? true : false);
            } else {
              console.log("setEnabledEventSubmission: GameAnalytics object not found");
              return;
            }
          },
          setEnabledManualSessionHandling(flag) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["setEnabledManualSessionHandling"] == "function") {
              globalThis["GameAnalytics"]["setEnabledManualSessionHandling"](flag ? true : false);
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["setEnabledManualSessionHandling"](flag ? true : false);
            } else {
              console.log("setEnabledManualSessionHandling: GameAnalytics object not found");
              return;
            }
          },
          setCustomDimension01(dimension) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["setCustomDimension01"] == "function") {
              globalThis["GameAnalytics"]["setCustomDimension01"](dimension);
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["setCustomDimension01"](dimension);
            } else {
              console.log("setCustomDimension01: GameAnalytics object not found");
              return;
            }
          },
          setCustomDimension02(dimension) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["setCustomDimension02"] == "function") {
              globalThis["GameAnalytics"]["setCustomDimension02"](dimension);
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["setCustomDimension02"](dimension);
            } else {
              console.log("setCustomDimension02: GameAnalytics object not found");
              return;
            }
          },
          setCustomDimension03(dimension) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["setCustomDimension03"] == "function") {
              globalThis["GameAnalytics"]["setCustomDimension03"](dimension);
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["setCustomDimension03"](dimension);
            } else {
              console.log("setCustomDimension03: GameAnalytics object not found");
              return;
            }
          },
          startSession() {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["startSession"] == "function") {
              globalThis["GameAnalytics"]["startSession"]();
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["startSession"]();
            } else {
              console.log("startSession: GameAnalytics object not found");
              return;
            }
          },
          endSession() {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["endSession"] == "function") {
              globalThis["GameAnalytics"]["endSession"]();
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              globalThis["gameanalytics"]["GameAnalytics"]["endSession"]();
            } else {
              console.log("endSession: GameAnalytics object not found");
              return;
            }
          },
          configureBuild(buildNumber) {
            this._build = buildNumber;
          }
        };
      }
    }
    {
      "use strict";
      {
        C3.Plugins.GameAnalytics.Exps = {
          getRemoteConfigsValueAsString(key, defaultValue, functionName) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["getRemoteConfigsValueAsString"] == "function") {
              var callback = function(result2) {
                if (functionName && globalThis["c2_callFunction"]) {
                  globalThis["c2_callFunction"](functionName, [result2]);
                }
              };
              globalThis["GameAnalytics"]["getRemoteConfigsValueAsString"]({
                "key": key,
                "defaultValue": defaultValue
              }, callback);
              return "";
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              return globalThis["gameanalytics"]["GameAnalytics"]["getRemoteConfigsValueAsString"](key, defaultValue);
            } else {
              console.log("getRemoteConfigsValueAsString: GameAnalytics object not found");
              return "";
            }
          },
          getRemoteConfigsContentAsString(functionName) {
            if (typeof globalThis["GameAnalytics"] !== "undefined" && typeof globalThis["GameAnalytics"]["getRemoteConfigsContentAsString"] == "function") {
              var callback = function(result2) {
                if (functionName && globalThis["c2_callFunction"]) {
                  globalThis["c2_callFunction"](functionName, [result2]);
                }
              };
              globalThis["GameAnalytics"]["getRemoteConfigsContentAsString"](callback);
              return "";
            } else if (typeof globalThis["gameanalytics"] !== "undefined" && typeof globalThis["gameanalytics"]["GameAnalytics"] != "undefined") {
              return globalThis["gameanalytics"]["GameAnalytics"]["getRemoteConfigsContentAsString"]();
            } else {
              console.log("endSession: GameAnalytics object not found");
              return "";
            }
          }
        };
      }
    }
    {
      {
        const t = self.C3;
        t.Plugins.BinaryData = class extends t.SDKPluginBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.BinaryData.Type = class extends t.SDKTypeBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const t = self.C3, e = (self.C3X, self.IInstance), r2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        t.Plugins.BinaryData.Instance = class extends t.SDKInstanceBase {
          constructor(t2, e2) {
            super(t2), this._buffer = new ArrayBuffer(0), this._view = null, this._altView = null, this._littleEndian = 0 === e2[0], this._blobURL = "", this._dataChangedSinceBlobURL = false, this._setters = [[1, (t3, e3) => this._view.setInt8(t3, e3)], [1, (t3, e3) => this._view.setUint8(t3, e3)], [2, (t3, e3) => this._view.setInt16(t3, e3, this._littleEndian)], [2, (t3, e3) => this._view.setUint16(t3, e3, this._littleEndian)], [4, (t3, e3) => this._view.setInt32(t3, e3, this._littleEndian)], [4, (t3, e3) => this._view.setUint32(t3, e3, this._littleEndian)], [4, (t3, e3) => this._view.setFloat32(t3, e3, this._littleEndian)], [8, (t3, e3) => this._view.setFloat64(t3, e3, this._littleEndian)]], this._getters = [[1, (t3) => this._view.getInt8(t3)], [1, (t3) => this._view.getUint8(t3)], [2, (t3) => this._view.getInt16(t3, this._littleEndian)], [2, (t3) => this._view.getUint16(t3, this._littleEndian)], [4, (t3) => this._view.getInt32(t3, this._littleEndian)], [4, (t3) => this._view.getUint32(t3, this._littleEndian)], [4, (t3) => this._view.getFloat32(t3, this._littleEndian)], [8, (t3) => this._view.getFloat64(t3, this._littleEndian)]], this._UpdateViews();
          }
          _CheckValidIndex(t2, e2) {
            return t2 >= 0 && t2 + e2 <= this.ByteLength();
          }
          _ClampToLength(t2) {
            const e2 = this.ByteLength();
            return t2 < 0 ? 0 : t2 >= e2 ? e2 : t2;
          }
          _ClampToValidIndex(t2) {
            const e2 = this.ByteLength();
            return t2 < 0 ? 0 : t2 > e2 ? e2 : t2;
          }
          ByteLength() {
            return this._buffer.byteLength;
          }
          _UpdateViews() {
            const t2 = this._buffer;
            this._view = new DataView(t2), this._altView = new Uint8Array(t2), this._OnDataChanged();
          }
          _OnDataChanged() {
            this._blobURL && (this._dataChangedSinceBlobURL = true);
          }
          _RevokeBlobURL() {
            this._blobURL && (URL.revokeObjectURL(this._blobURL), this._blobURL = "");
          }
          _GetBlobURL() {
            if (this._dataChangedSinceBlobURL && (this._RevokeBlobURL(), this._dataChangedSinceBlobURL = false), !this._blobURL) {
              const t2 = new Blob([this._altView], { type: "" });
              this._blobURL = URL.createObjectURL(t2);
            }
            return this._blobURL;
          }
          _GetBinaryDataSdkInstance(t2) {
            if (!t2) return null;
            const e2 = t2.GetFirstPicked(this._inst);
            return e2 ? e2.GetSdkInstance() : null;
          }
          _Get(t2, e2) {
            const r3 = this._getters[t2][1], n2 = this._getters[t2][0];
            return this._CheckValidIndex(e2, n2) ? r3(e2) : 0;
          }
          _Set(t2, e2, r3) {
            const n2 = this._setters[t2][1], i2 = this._setters[t2][0];
            this._CheckValidIndex(e2, i2) && (n2(e2, r3), this._OnDataChanged());
          }
          _ResizeBuffer(t2, e2) {
            if (!(t2 instanceof ArrayBuffer)) throw new TypeError("Source must be an instance of ArrayBuffer");
            if (e2 <= t2.byteLength) return t2.slice(0, e2);
            const r3 = new Uint8Array(t2), n2 = new Uint8Array(new ArrayBuffer(e2));
            return n2.set(r3), n2.buffer;
          }
          SetArrayBufferCopy(e2) {
            if (t.WeakIsInstanceOf(e2, ArrayBuffer)) this._buffer = e2.slice(0);
            else {
              t.WeakRequireTypedArray(e2);
              const r3 = e2.buffer, n2 = e2.byteLength, i2 = e2.byteOffset;
              this._buffer = r3.slice(i2, i2 + n2);
            }
            this._UpdateViews();
          }
          SetArrayBufferTransfer(e2) {
            t.WeakRequireInstanceOf(e2, ArrayBuffer), this._buffer = e2, this._UpdateViews();
          }
          GetArrayBufferCopy() {
            return this._buffer.slice(0);
          }
          GetArrayBufferReadOnly() {
            return this._buffer;
          }
          TypedArrayToString(t2, e2) {
            return new TextDecoder(e2 || "utf-8").decode(t2);
          }
          StringToArrayBuffer(t2) {
            return new TextEncoder("utf-8").encode(t2).buffer;
          }
          Uint8ArrayToBase64String(t2) {
            const e2 = (e3) => e3 < n2 ? t2[e3] : (s2++, 0), n2 = t2.length, i2 = [];
            let s2 = 0, a2 = 0;
            for (; a2 < n2; ) {
              const t3 = (e2(a2++) << 16) + (e2(a2++) << 8) + e2(a2++);
              i2.push(r2[t3 >>> 18 & 63], r2[t3 >>> 12 & 63], r2[t3 >>> 6 & 63], r2[63 & t3]);
            }
            for (a2 = i2.length - s2; a2 < i2.length; ) i2[a2++] = "=";
            return i2.join("");
          }
          Base64StringToUint8Array(t2) {
            const e2 = t2.indexOf("="), r3 = t2.length, n2 = r3 >> 2 << 2, i2 = r3 - n2, s2 = e2 > -1 ? r3 - e2 : 0;
            if (s2 > 2) throw new Error("Invalid padding");
            let a2 = r3;
            n2 === e2 ? a2 = n2 - s2 : 0 === i2 && e2 > -1 && (a2 -= s2);
            const h = 3 * a2 >> 2, o2 = new Uint8Array(h);
            let l2 = 0, f2 = 0;
            const u = () => {
              if (l2 >= a2) return 0;
              const e3 = t2.charCodeAt(l2++);
              if (e3 > 64 && e3 < 91) return e3 - 65;
              if (e3 > 96 && e3 < 123) return e3 - 71;
              if (e3 > 47 && e3 < 58) return e3 + 4;
              if (43 === e3) return 62;
              if (47 === e3) return 63;
              if (61 === e3) return 0;
              throw new Error("Invalid character at column " + (l2 - 1));
            }, c2 = (t3) => f2 < h && (o2[f2++] = t3);
            for (; f2 < h; ) {
              const t3 = (u() << 18) + (u() << 12) + (u() << 6) + u();
              c2(t3 >>> 16 & 255), c2(t3 >>> 8 & 255), c2(255 & t3);
            }
            return o2;
          }
          GetScriptInterfaceClass() {
            return self.IBinaryDataInstance;
          }
        };
        const n = /* @__PURE__ */ new WeakMap();
        self.IBinaryDataInstance = class extends e {
          constructor() {
            super(), n.set(this, e._GetInitInst().GetSdkInstance());
          }
          setArrayBufferCopy(e2) {
            if (!(e2 instanceof ArrayBuffer || t.IsTypedArray(e2))) throw new TypeError("invalid parameter");
            n.get(this).SetArrayBufferCopy(e2);
          }
          setArrayBufferTransfer(t2) {
            if (!(t2 instanceof ArrayBuffer)) throw new TypeError("invalid parameter");
            n.get(this).SetArrayBufferTransfer(t2);
          }
          getArrayBufferCopy() {
            return n.get(this).GetArrayBufferCopy();
          }
          getArrayBufferReadOnly() {
            return n.get(this).GetArrayBufferReadOnly();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.BinaryData.Cnds = { CompareLength(e, r2) {
          return t.compare(this.ByteLength(), e, r2);
        }, CompareValue(e, r2, n, i2) {
          return t.compare(this._Get(e, r2), n, i2);
        }, OnCompressionFinished: () => true, OnCompressionFailed: () => true, OnDecompressionFinished: () => true, OnDecompressionFailed: () => true };
      }
      {
        const t = self.C3, e = ["deflate", "gzip"];
        t.Plugins.BinaryData.Acts = { SetEndian(t2) {
          this._littleEndian = 0 === t2;
        }, SetLength(t2) {
          this._buffer = this._ResizeBuffer(this._buffer, t2), this._UpdateViews();
        }, SetFromBase64(t2) {
          try {
            const e2 = this.Base64StringToUint8Array(t2);
            this.SetArrayBufferTransfer(e2.buffer);
          } catch (t3) {
            console.warn("[BinaryData] Invalid base64 string: ", t3);
          }
        }, SetFromBinaryData(t2) {
          const e2 = this._GetBinaryDataSdkInstance(t2);
          if (null === e2) return;
          const r2 = e2.GetArrayBufferCopy();
          this.SetArrayBufferTransfer(r2);
        }, SetFromText(t2) {
          const e2 = this.StringToArrayBuffer(t2.normalize());
          this.SetArrayBufferTransfer(e2);
        }, Fill(t2, e2, r2, n) {
          const i2 = this._setters[t2][1], s2 = this._setters[t2][0], a2 = this._ClampToLength(r2);
          let h = 0;
          if (h = -1 === n ? this.ByteLength() : this._ClampToLength(a2 + n), h <= a2) return;
          h = a2 + Math.floor((h - a2) / s2) * s2;
          for (let t3 = a2; t3 < h; t3 += s2) i2(t3, e2);
          this._OnDataChanged();
        }, Copy(t2, e2, r2, n) {
          const i2 = this._GetBinaryDataSdkInstance(t2);
          if (null === i2) return;
          let s2;
          if (n = this._ClampToValidIndex(n), e2 = i2._ClampToLength(e2), s2 = -1 === r2 ? i2.ByteLength() : i2._ClampToLength(e2 + r2), s2 <= e2) return;
          const a2 = this.ByteLength();
          if (n + s2 - e2 > a2) {
            if (s2 = e2 + (a2 - n), s2 <= e2) return;
          }
          if (i2 === this) this._altView.copyWithin(n, e2, s2);
          else {
            const t3 = i2.GetArrayBufferReadOnly(), r3 = new Uint8Array(t3, e2, s2 - e2);
            this._altView.set(r3, n);
          }
          this._OnDataChanged();
        }, SetValue(t2, e2, r2) {
          this._Set(t2, r2, e2);
        }, async Compress(r2) {
          const n = e[r2];
          try {
            const e2 = new CompressionStream(n), r3 = new Blob([this._buffer]).stream().pipeThrough(e2), i2 = await new Response(r3).arrayBuffer();
            this.SetArrayBufferTransfer(i2), await this.TriggerAsync(t.Plugins.BinaryData.Cnds.OnCompressionFinished);
          } catch (e2) {
            console.error(`[Binary data] Error compressing data as '${n}': `, e2), await this.TriggerAsync(t.Plugins.BinaryData.Cnds.OnCompressionFailed);
          }
        }, async Decompress(r2) {
          const n = e[r2];
          try {
            const e2 = new DecompressionStream(n), r3 = new Blob([this._buffer]).stream().pipeThrough(e2), i2 = await new Response(r3).arrayBuffer();
            this.SetArrayBufferTransfer(i2), await this.TriggerAsync(t.Plugins.BinaryData.Cnds.OnDecompressionFinished);
          } catch (e2) {
            console.error(`[Binary data] Error decompressing data as '${n}': `, e2), await this.TriggerAsync(t.Plugins.BinaryData.Cnds.OnDecompressionFailed);
          }
        } };
      }
      {
        const t = self.C3, e = { int8: 0, uint8: 1, int16: 2, uint16: 3, int32: 4, uint32: 5, float32: 6, float64: 7 };
        t.Plugins.BinaryData.Exps = { GetURL() {
          return this._GetBlobURL();
        }, GetBase64() {
          return this.Uint8ArrayToBase64String(this._altView);
        }, ByteLength() {
          return this.ByteLength();
        }, GetInt8(t2) {
          return this._Get(e.int8, t2);
        }, GetUint8(t2) {
          return this._Get(e.uint8, t2);
        }, GetInt16(t2) {
          return this._Get(e.int16, t2);
        }, GetUint16(t2) {
          return this._Get(e.uint16, t2);
        }, GetInt32(t2) {
          return this._Get(e.int32, t2);
        }, GetUint32(t2) {
          return this._Get(e.uint32, t2);
        }, GetFloat32(t2) {
          return this._Get(e.float32, t2);
        }, GetFloat64(t2) {
          return this._Get(e.float64, t2);
        }, GetText(t2, e2) {
          let r2 = "";
          if (this._CheckValidIndex(t2, e2)) {
            const n = this._altView.subarray(t2, t2 + e2);
            try {
              r2 = this.TypedArrayToString(n);
            } catch (t3) {
              console.warn("[Binary data] Failed to decode text: ", t3);
            }
          }
          return r2;
        }, GetAllText() {
          try {
            return this.TypedArrayToString(this._altView);
          } catch (t2) {
            return console.warn("[Binary data] Failed to decode text: ", t2), "";
          }
        } };
      }
    }
    {
      {
        const e = self.C3;
        e.Plugins.PlatformInfo = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.PlatformInfo.Type = class extends e.SDKTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3, t = "platform-info";
        e.Plugins.PlatformInfo.Instance = class extends e.SDKInstanceBase {
          constructor(e2, n) {
            super(e2, t), this._screenWidth = 0, this._screenHeight = 0, this._windowOuterWidth = 0, this._windowOuterHeight = 0, this._safeAreaInset = [0, 0, 0, 0], this._supportsWakeLock = false, this._isWakeLockActive = false, this.AddDOMMessageHandlers([["window-resize", (e3) => this._OnWindowResize(e3)], ["wake-lock-acquired", (e3) => this._OnWakeLockAcquired(e3)], ["wake-lock-error", (e3) => this._OnWakeLockError(e3)], ["wake-lock-released", (e3) => this._OnWakeLockReleased(e3)]]), navigator.connection && navigator.connection.addEventListener("change", () => this._OnNetworkChange()), this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state").then((e3) => {
              this._screenWidth = e3["screenWidth"], this._screenHeight = e3["screenHeight"], this._windowOuterWidth = e3["windowOuterWidth"], this._windowOuterHeight = e3["windowOuterHeight"], this._safeAreaInset = e3["safeAreaInset"], this._supportsWakeLock = e3["supportsWakeLock"];
            }));
          }
          Release() {
            super.Release();
          }
          _OnWindowResize(e2) {
            this._windowOuterWidth = e2["windowOuterWidth"], this._windowOuterHeight = e2["windowOuterHeight"], this._safeAreaInset = e2["safeAreaInset"];
          }
          async _OnNetworkChange() {
            await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnNetworkChange);
          }
          async _OnWakeLockAcquired() {
            this._isWakeLockActive = true, await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockAcquired);
          }
          async _OnWakeLockError() {
            this._isWakeLockActive = false, await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockError);
          }
          async _OnWakeLockReleased() {
            this._isWakeLockActive = false, await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockReleased);
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.PlatformInfo.Cnds = { IsOnMobile: () => e.Platform.IsMobile, IsOnWindows: () => "Windows" === e.Platform.OS, IsOnMacOS: () => "macOS" === e.Platform.OS, IsOnLinux: () => "Linux" === e.Platform.OS, IsOnChromeOS: () => "Chrome OS" === e.Platform.OS, IsOnAndroid: () => "Android" === e.Platform.OS, IsOniOS: () => "iOS" === e.Platform.OS, IsWebExport() {
          const e2 = this._runtime.GetExportType();
          return "html5" === e2 || "scirra-arcade" === e2 || "preview" === e2 || "instant-games" === e2;
        }, IsCordovaExport() {
          return this._runtime.IsCordova();
        }, IsNWjsExport() {
          return this._runtime.IsNWjs();
        }, IsWindowsUWPExport() {
          return "windows-uwp" === this._runtime.GetExportType();
        }, IsWindowsWebView2Export() {
          return this._runtime.IsWindowsWebView2();
        }, IsMacOSWKWebView2Export() {
          return "macos-wkwebview" === this._runtime.GetExportType();
        }, IsLinuxCEFExport() {
          return "linux-cef" === this._runtime.GetExportType();
        }, OnNetworkChange: () => true, OnWakeLockAcquired: () => true, OnWakeLockError: () => true, OnWakeLockReleased: () => true, IsWakeLockActive() {
          return this._isWakeLockActive;
        }, IsWakeLockSupported() {
          return this._supportsWakeLock;
        } };
      }
      self.C3.Plugins.PlatformInfo.Acts = { RequestWakeLock() {
        this._supportsWakeLock && this._PostToDOMMaybeSync("request-wake-lock");
      }, ReleaseWakeLock() {
        this._supportsWakeLock && (this._isWakeLockActive = false, this.PostToDOM("release-wake-lock"));
      } };
      self.C3.Plugins.PlatformInfo.Exps = { Renderer() {
        return this._runtime.GetCanvasManager().GetRendererString();
      }, RendererDetail() {
        return this._runtime.GetCanvasManager().GetRendererDetailString();
      }, DevicePixelRatio() {
        return this._runtime.GetDevicePixelRatio();
      }, ScreenWidth() {
        return this._screenWidth;
      }, ScreenHeight() {
        return this._screenHeight;
      }, WindowInnerWidth() {
        return this._runtime.GetCanvasManager().GetLastWidth();
      }, WindowInnerHeight() {
        return this._runtime.GetCanvasManager().GetLastHeight();
      }, WindowOuterWidth() {
        return this._windowOuterWidth;
      }, WindowOuterHeight() {
        return this._windowOuterHeight;
      }, CanvasCssWidth() {
        return this._runtime.GetCanvasManager().GetCssWidth();
      }, CanvasCssHeight() {
        return this._runtime.GetCanvasManager().GetCssHeight();
      }, CanvasDeviceWidth() {
        return this._runtime.GetCanvasManager().GetDeviceWidth();
      }, CanvasDeviceHeight() {
        return this._runtime.GetCanvasManager().GetDeviceHeight();
      }, Downlink: () => navigator.connection && navigator.connection["downlink"] || 0, DownlinkMax: () => navigator.connection && navigator.connection["downlinkMax"] || 0, ConnectionType: () => navigator.connection && navigator.connection["type"] || "unknown", ConnectionEffectiveType: () => navigator.connection && navigator.connection["effectiveType"] || "unknown", ConnectionRTT: () => navigator.connection && navigator.connection["rtt"] || 0, HardwareConcurrency: () => navigator.hardwareConcurrency || 0, DeviceMemory: () => navigator.deviceMemory || 0, SafeAreaInsetTop() {
        return this._safeAreaInset[0];
      }, SafeAreaInsetRight() {
        return this._safeAreaInset[1];
      }, SafeAreaInsetBottom() {
        return this._safeAreaInset[2];
      }, SafeAreaInsetLeft() {
        return this._safeAreaInset[3];
      }, FramesPerSecond() {
        return this._runtime.GetFramesPerSecond();
      }, TicksPerSecond() {
        return this._runtime.GetTicksPerSecond();
      } };
    }
    {
      {
        const t = self.C3;
        t.Plugins.Dictionary = class extends t.SDKPluginBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.Dictionary.Type = class extends t.SDKTypeBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const t = self.C3, e = (self.C3X, self.IInstance);
        t.Plugins.Dictionary.Instance = class extends t.SDKInstanceBase {
          constructor(t2, e2) {
            super(t2), this._data = /* @__PURE__ */ new Map(), this._curKey = "";
          }
          Release() {
            this._data.clear(), super.Release();
          }
          GetAsJsonString() {
            return JSON.stringify({ "c2dictionary": true, "data": t.MapToObject(this._data) });
          }
          GetDataMap() {
            return this._data;
          }
          SaveToJson() {
            return t.MapToObject(this._data);
          }
          LoadFromJson(e2) {
            t.ObjectToMap(e2, this._data);
          }
          GetDebuggerProperties() {
            const t2 = "plugins.dictionary";
            return [{ title: t2 + ".name", properties: [{ name: t2 + ".debugger.key-count", value: this._data.size }, ...[...this._data].map((t3) => ({ name: "$" + t3[0], value: t3[1], onedit: (e2) => this._data.set(t3[0], e2) }))] }];
          }
          GetScriptInterfaceClass() {
            return self.IDictionaryInstance;
          }
        };
        const a2 = /* @__PURE__ */ new WeakMap();
        self.IDictionaryInstance = class extends e {
          constructor() {
            super(), a2.set(this, e._GetInitInst().GetSdkInstance());
          }
          getDataMap() {
            return a2.get(this).GetDataMap();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.Dictionary.Cnds = { CompareValue(e, a2, s2) {
          const n = this._data.get(e);
          return void 0 !== n && t.compare(n, a2, s2);
        }, ForEachKey() {
          const t2 = this._runtime, e = t2.GetEventSheetManager(), a2 = t2.GetCurrentEvent(), s2 = a2.GetSolModifiers(), n = t2.GetEventStack(), r2 = n.GetCurrentStackFrame(), i2 = n.Push(a2);
          t2.SetDebuggingEnabled(false);
          for (const t3 of this._data.keys()) {
            this._curKey = t3, e.PushCopySol(s2);
            this.GetObjectClass().GetCurrentSol().PickOne(this.GetInstance()), a2.Retrigger(r2, i2), e.PopSol(s2);
          }
          return t2.SetDebuggingEnabled(true), this._curKey = "", n.Pop(), false;
        }, CompareCurrentValue(e, a2) {
          const s2 = this._data.get(this._curKey);
          return void 0 !== s2 && t.compare(s2, e, a2);
        }, HasKey(t2) {
          return this._data.has(t2);
        }, IsEmpty() {
          return 0 === this._data.size;
        } };
      }
      {
        const t = self.C3;
        t.Plugins.Dictionary.Acts = { AddKey(t2, e) {
          this._data.set(t2, e);
        }, SetKey(t2, e) {
          this._data.has(t2) && this._data.set(t2, e);
        }, DeleteKey(t2) {
          this._data.delete(t2);
        }, Clear() {
          this._data.clear();
        }, JSONLoad(e) {
          let a2 = null;
          try {
            a2 = JSON.parse(e);
          } catch (t2) {
            return void console.error("[Construct] Error parsing JSON: ", t2);
          }
          a2["c2dictionary"] ? t.ObjectToMap(a2["data"], this._data) : console.warn("[Dictionary] Attempted to load JSON that does not appear to be Construct dictionary data - no data loaded");
        }, JSONDownload(t2) {
          const e = URL.createObjectURL(new Blob([this.GetAsJsonString()], { type: "application/json" }));
          this._runtime.InvokeDownload(e, t2);
        } };
      }
      self.C3.Plugins.Dictionary.Exps = { Get(t) {
        const e = this._data.get(t);
        return void 0 === e ? 0 : e;
      }, GetDefault(t, e) {
        const a2 = this._data.get(t);
        return void 0 === a2 ? e : a2;
      }, KeyCount() {
        return this._data.size;
      }, CurrentKey() {
        return this._curKey;
      }, CurrentValue() {
        return this._data.get(this._curKey) ?? 0;
      }, AsJSON() {
        return this.GetAsJsonString();
      } };
    }
    {
      {
        const e = self.C3;
        e.Plugins.Keyboard = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        let GetKeyboardSdkInstance2 = function() {
          return t.GetSingleGlobalInstance().GetSdkInstance();
        };
        GetKeyboardSdkInstance = GetKeyboardSdkInstance2;
        const r2 = self.C3;
        self.C3X;
        r2.Plugins.Keyboard.Type = class extends r2.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
          GetScriptInterfaceClass() {
            return self.IKeyboardObjectType;
          }
        };
        let t = null;
        self.IKeyboardObjectType = class extends self.IObjectType {
          constructor(e) {
            super(e), t = e, e.GetRuntime()._GetCommonScriptInterfaces().keyboard = this;
          }
          isKeyDown(e) {
            const r3 = GetKeyboardSdkInstance2();
            if ("string" == typeof e) return r3.IsKeyDown(e);
            if ("number" == typeof e) return r3.IsKeyCodeDown(e);
            throw new TypeError("expected string or number");
          }
        };
      }
      {
        const s2 = self.C3, n = "keyboard";
        s2.Plugins.Keyboard.Instance = class extends s2.SDKInstanceBase {
          constructor(e, r2) {
            super(e, n), this._keysDownByString = /* @__PURE__ */ new Set(), this._keysDownByWhich = /* @__PURE__ */ new Set(), this._triggerWhich = 0, this._triggerString = "", this._triggerTypedKey = "", this._isKeyboardLockSupported = false;
            const t = this.GetRuntime().Dispatcher();
            this._disposables = new s2.CompositeDisposable(s2.Disposable.From(t, "keydown", (e2) => this._OnKeyDown(e2.data)), s2.Disposable.From(t, "keyup", (e2) => this._OnKeyUp(e2.data)), s2.Disposable.From(t, "window-blur", () => this._OnWindowOrKeyboardBlur()), s2.Disposable.From(t, "keyboard-blur", () => this._OnWindowOrKeyboardBlur())), this._runtime.AddLoadPromise(this._Init());
          }
          Release() {
            super.Release();
          }
          async _Init() {
            const e = await this.PostToDOMAsync("init");
            this._isKeyboardLockSupported = e["isKeyboardLockSupported"];
          }
          _OnKeyDown(e) {
            const r2 = e["which"], t = e["code"] || r2.toString(), n2 = e["key"];
            this._keysDownByString.has(t) || (this._keysDownByString.add(t), this._keysDownByWhich.add(r2), this._triggerString = t, this._triggerWhich = r2, this._triggerTypedKey = n2, this.Trigger(s2.Plugins.Keyboard.Cnds.OnAnyKey), this.Trigger(s2.Plugins.Keyboard.Cnds.OnKey), this.Trigger(s2.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed), this.Trigger(s2.Plugins.Keyboard.Cnds.OnKeyCode));
          }
          _OnKeyUp(e) {
            const r2 = e["which"], t = e["code"] || r2.toString(), n2 = e["key"];
            this._keysDownByString.delete(t), this._keysDownByWhich.delete(r2), this._triggerString = t, this._triggerWhich = r2, this._triggerTypedKey = n2, this.Trigger(s2.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(s2.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(s2.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased), this.Trigger(s2.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
          }
          _OnWindowOrKeyboardBlur() {
            for (const e of this._keysDownByWhich) this._keysDownByWhich.delete(e), this._triggerWhich = e, this.Trigger(s2.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(s2.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(s2.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
            this._keysDownByString.clear();
          }
          IsKeyDown(e) {
            return this._keysDownByString.has(e);
          }
          IsKeyCodeDown(e) {
            return this._keysDownByWhich.has(e);
          }
          SaveToJson() {
            return { "tk": this._triggerWhich, "tkk": this._triggerTypedKey };
          }
          LoadFromJson(e) {
            this._triggerWhich = e["tk"], e.hasOwnProperty("tkk") && (this._triggerTypedKey = e["tkk"]);
          }
          GetDebuggerProperties() {
            const e = "plugins.keyboard";
            return [{ title: e + ".name", properties: [{ name: e + ".debugger.last-key-code", value: this._triggerWhich }, { name: e + ".debugger.last-key-string", value: s2.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich) }, { name: e + ".debugger.last-typed-key", value: this._triggerTypedKey }] }];
          }
        };
      }
      {
        const i2 = self.C3, a2 = ["ShiftLeft", "ShiftRight", "ControlLeft", "ControlRight", "AltLeft", "AltRight", "MetaLeft", "MetaRight"];
        i2.Plugins.Keyboard.Cnds = { IsKeyDown(e) {
          return this._keysDownByWhich.has(e);
        }, OnKey(e) {
          return this._triggerWhich === e;
        }, OnAnyKey: () => true, OnAnyKeyReleased: () => true, OnKeyReleased(e) {
          return this._triggerWhich === e;
        }, IsKeyCodeDown(e) {
          return e = Math.floor(e), this._keysDownByWhich.has(e);
        }, OnKeyCode(e) {
          return this._triggerWhich === e;
        }, OnKeyCodeReleased(e) {
          return this._triggerWhich === e;
        }, OnLeftRightKeyPressed(e) {
          const r2 = a2[e];
          return this._triggerString === r2;
        }, OnLeftRightKeyReleased(e) {
          const r2 = a2[e];
          return this._triggerString === r2;
        }, IsLeftRightKeyDown(e) {
          const r2 = a2[e];
          return this._keysDownByString.has(r2);
        }, IsKeyboardLockSupported() {
          return this._isKeyboardLockSupported;
        }, OnKeyboardLocked: () => true, OnKeyboardLockError: () => true };
      }
      {
        const o2 = self.C3;
        o2.Plugins.Keyboard.Acts = { async LockKeyboard(e) {
          if (!this._isKeyboardLockSupported) return;
          let r2 = [];
          e && (r2 = e.split(","));
          (await this.PostToDOMAsync("lock-keyboard", { "keysArr": r2 }))["isOk"] ? this.Trigger(o2.Plugins.Keyboard.Cnds.OnKeyboardLocked) : this.Trigger(o2.Plugins.Keyboard.Cnds.OnKeyboardLockError);
        }, UnlockKeyboard() {
          this._isKeyboardLockSupported && this.PostToDOMAsync("unlock-keyboard");
        } };
      }
      {
        let StringFromCharCode2 = function(e) {
          switch (e = Math.floor(e)) {
            case 8:
              return "backspace";
            case 9:
              return "tab";
            case 13:
              return "enter";
            case 16:
              return "shift";
            case 17:
              return "control";
            case 18:
              return "alt";
            case 19:
              return "pause";
            case 20:
              return "capslock";
            case 27:
              return "esc";
            case 33:
              return "pageup";
            case 34:
              return "pagedown";
            case 35:
              return "end";
            case 36:
              return "home";
            case 37:
              return "\u2190";
            case 38:
              return "\u2191";
            case 39:
              return "\u2192";
            case 40:
              return "\u2193";
            case 45:
              return "insert";
            case 46:
              return "del";
            case 91:
              return "left window key";
            case 92:
              return "right window key";
            case 93:
              return "select";
            case 96:
              return "numpad 0";
            case 97:
              return "numpad 1";
            case 98:
              return "numpad 2";
            case 99:
              return "numpad 3";
            case 100:
              return "numpad 4";
            case 101:
              return "numpad 5";
            case 102:
              return "numpad 6";
            case 103:
              return "numpad 7";
            case 104:
              return "numpad 8";
            case 105:
              return "numpad 9";
            case 106:
              return "numpad *";
            case 107:
              return "numpad +";
            case 109:
              return "numpad -";
            case 110:
              return "numpad .";
            case 111:
              return "numpad /";
            case 112:
              return "F1";
            case 113:
              return "F2";
            case 114:
              return "F3";
            case 115:
              return "F4";
            case 116:
              return "F5";
            case 117:
              return "F6";
            case 118:
              return "F7";
            case 119:
              return "F8";
            case 120:
              return "F9";
            case 121:
              return "F10";
            case 122:
              return "F11";
            case 123:
              return "F12";
            case 144:
              return "numlock";
            case 145:
              return "scroll lock";
            case 186:
              return ";";
            case 187:
              return "=";
            case 188:
              return ",";
            case 189:
              return "-";
            case 190:
              return ".";
            case 191:
              return "/";
            case 192:
              return "'";
            case 219:
              return "[";
            case 220:
              return "\\";
            case 221:
              return "]";
            case 222:
              return "#";
            case 223:
              return "`";
            default:
              return String.fromCharCode(e);
          }
        };
        StringFromCharCode = StringFromCharCode2;
        self.C3.Plugins.Keyboard.Exps = { LastKeyCode() {
          return this._triggerWhich;
        }, StringFromKeyCode: (e) => StringFromCharCode2(e), TypedKey() {
          return this._triggerTypedKey;
        } };
      }
    }
    var GetKeyboardSdkInstance;
    var StringFromCharCode;
    {
      {
        const t = self.C3;
        t.Plugins.Sprite = class extends t.SDKPluginBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3, e = self.C3X, n = [];
        t.Plugins.Sprite.Type = class extends t.SDKTypeBase {
          constructor(t2) {
            super(t2), this._animations = t2.GetAnimations();
          }
          Release() {
            t.clearArray(this._animations), super.Release();
          }
          OnCreate() {
            for (const t2 of this._animations) t2.LoadAllAssets(this._runtime);
          }
          LoadTextures(t2) {
            const e2 = { sampling: this._runtime.GetSampling() };
            return Promise.all(this._animations.map((n2) => n2.LoadAllTextures(t2, e2)));
          }
          ReleaseTextures() {
            for (const t2 of this._animations) t2.ReleaseAllTextures();
          }
          OnDynamicTextureLoadComplete() {
            this._UpdateAllCurrentTexture();
          }
          _UpdateAllCurrentTexture() {
            for (const t2 of this._objectClass.instancesIncludingPendingCreate()) t2.GetSdkInstance()._UpdateCurrentTexture();
          }
          FinishCondition(e2) {
            t.Plugins.Sprite.FinishCollisionCondition(this, e2);
          }
          BeforeRunAction(t2) {
            n.push({ objectClass: null, createHierarchy: false, instances: [] });
          }
          _SpawnPickInstance(t2, e2, i3) {
            const r2 = n.at(-1);
            r2.objectClass = t2, r2.createHierarchy = i3, r2.instances.push(e2);
          }
          AfterRunAction(t2) {
            const e2 = n.pop(), i3 = e2.objectClass, r2 = e2.createHierarchy;
            if (!i3) return;
            const a2 = /* @__PURE__ */ new Map();
            for (const t3 of e2.instances) t3.CollectInstancesToPick(a2, i3, r2);
            for (const [t3, e3] of a2) t3.GetCurrentSol().SetSetPicked(e3);
          }
          _AddAnimation(t2) {
            const e2 = this.GetObjectClass().AddAnimation(t2), n2 = this.GetRuntime();
            return e2.GetFrameAt(0).GetImageInfo().LoadStaticTexture(n2.GetRenderer(), { sampling: n2.GetSampling() }).then(() => this._UpdateAllCurrentTexture()), e2;
          }
          _RemoveAnimation(t2) {
            for (const e2 of this._objectClass.instancesIncludingPendingCreate()) e2.GetSdkInstance()._OnAnimationRemoved(t2);
            this.GetObjectClass().RemoveAnimation(t2);
          }
          _AddAnimationFrame(e2, n2) {
            const i3 = this._objectClass.GetAnimationByName(e2);
            if (!i3) throw new Error(`cannot find animation name '${e2}'`);
            let r2 = i3.FrameTagOrIndexToIndex(n2);
            r2 < 0 && (r2 += i3.GetFrameCount() + 1);
            const a2 = t.AnimationFrameInfo.CreateDynamic(this.GetRuntime());
            i3.InsertFrameAt(a2, r2);
            const s2 = this.GetRuntime();
            a2.GetImageInfo().LoadStaticTexture(s2.GetRenderer(), { sampling: s2.GetSampling() }).then(() => this._UpdateAllCurrentTexture());
            for (const t2 of this._objectClass.instancesIncludingPendingCreate()) t2.GetSdkInstance()._OnAnimationFramesChanged();
            return a2;
          }
          _RemoveAnimationFrame(t2, e2) {
            const n2 = this._objectClass.GetAnimationByName(t2);
            if (!n2) throw new Error(`cannot find animation name '${t2}'`);
            if (1 === n2.GetFrameCount()) throw new Error(`cannot remove last frame from animation '${t2}'`);
            let i3 = n2.FrameTagOrIndexToIndex(e2);
            i3 < 0 && (i3 += n2.GetFrameCount()), n2.RemoveFrameAt(i3);
            for (const t3 of this._objectClass.instancesIncludingPendingCreate()) t3.GetSdkInstance()._OnAnimationFramesChanged();
          }
          GetScriptInterfaceClass() {
            return self.ISpriteObjectType;
          }
        };
        const i2 = /* @__PURE__ */ new WeakMap();
        self.ISpriteObjectType = class extends self.IObjectType {
          constructor(t2) {
            super(t2), i2.set(this, t2.GetSdkType());
          }
          getAnimation(t2) {
            e.RequireString(t2);
            const n2 = i2.get(this).GetObjectClass().GetAnimationByName(t2);
            return n2 ? n2.GetIAnimation() : null;
          }
          getAllAnimations() {
            return i2.get(this).GetObjectClass().GetAllAnimations().map((t2) => t2.GetIAnimation());
          }
          addAnimation(t2) {
            return e.RequireString(t2), i2.get(this)._AddAnimation(t2).GetIAnimation();
          }
          removeAnimation(t2) {
            e.RequireString(t2), i2.get(this)._RemoveAnimation(t2);
          }
          addAnimationFrame(t2, n2) {
            if (e.RequireString(t2), "number" != typeof n2 && "string" != typeof n2) throw new TypeError("invalid insert location");
            return i2.get(this)._AddAnimationFrame(t2, n2).GetIAnimationFrame();
          }
          removeAnimationFrame(t2, n2) {
            if (e.RequireString(t2), "number" != typeof n2 && "string" != typeof n2) throw new TypeError("invalid insert location");
            i2.get(this)._RemoveAnimationFrame(t2, n2);
          }
        };
      }
      {
        const t = self.C3, e = self.C3X, n = 0, i2 = 1, r2 = 2, a2 = 3, s2 = t.New(t.Rect), o2 = t.New(t.Quad), m = t.New(t.Vector2), h = 1, u = 2, c2 = 4;
        t.Plugins.Sprite.Instance = class extends t.SDKWorldInstanceBase {
          constructor(e2, s3) {
            super(e2);
            let o3 = true, m2 = "", c3 = 0, l3 = true;
            s3 && (o3 = !!s3[n], m2 = s3[i2], c3 = s3[r2], l3 = s3[a2]), this._currentAnimation = this._objectClass.GetAnimationByName(m2) || this._objectClass.GetAnimations()[0], this._currentFrameIndex = t.clamp(c3, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            const d3 = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = d3.GetTexture(), this._currentRcTex = d3.GetTexRect(), this._currentQuadTex = d3.GetTexQuad(), this.HandleRendererContextLoss(), e2.SetFlag(u, true), e2.SetFlag(h, this._currentAnimation.GetSpeed() >= 0), this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed()), this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo(), this._animationTimer = t.New(t.KahanSum), this._frameStartTime = 0, this._animationRepeats = 0, this._animTriggerName = "", this._changeAnimFrameIndex = -1, this._changeAnimationName = "", this._changeAnimationFrom = 0;
            const g = this.GetWorldInfo();
            this._bquadRef = g.GetBoundingQuad(), g.SetVisible(o3), g.SetCollisionEnabled(l3), g.SetOriginX(this._currentAnimationFrame.GetOriginX()), g.SetOriginY(this._currentAnimationFrame.GetOriginY()), g.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly()), g.SetBboxChanged(), 1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking();
          }
          Release() {
            this._currentAnimation = null, this._currentAnimationFrame = null, this._currentTexture = null, this._animationTimer = null, super.Release();
          }
          GetCurrentImageInfo() {
            return this._currentAnimationFrame.GetImageInfo();
          }
          IsOriginalSizeKnown() {
            return true;
          }
          OnRendererContextLost() {
            this._currentTexture = null;
          }
          OnRendererContextRestored() {
            this._UpdateCurrentTexture();
          }
          Draw(t2) {
            const e2 = this._currentTexture;
            if (null === e2) return;
            t2.SetTexture(e2);
            const n2 = this.GetWorldInfo();
            n2.HasMesh() ? this._DrawMesh(n2, t2) : this._DrawStandard(n2, t2);
          }
          _DrawStandard(t2, e2) {
            let n2 = this._bquadRef;
            this._runtime.IsPixelRoundingEnabled() && (n2 = t2.PixelRoundQuad(n2)), e2.Quad4(n2, this._currentQuadTex);
          }
          _DrawMesh(t2, e2) {
            const n2 = t2.GetTransformedMesh();
            if (t2.IsMeshChanged()) {
              t2.CalculateBbox(s2, o2, false);
              let e3 = o2;
              this._runtime.IsPixelRoundingEnabled() && (e3 = t2.PixelRoundQuad(e3)), n2.CalculateTransformedMesh(t2.GetSourceMesh(), e3, this._currentQuadTex), t2.SetMeshChanged(false);
            }
            n2.Draw(e2, t2.GetTotalZElevation());
          }
          GetAnimationTime() {
            return this._animationTimer.Get();
          }
          IsAnimationPlaying() {
            return this._inst.GetFlag(u);
          }
          SetAnimationPlaying(t2) {
            this._inst.SetFlag(u, t2);
          }
          IsPlayingForwards() {
            return this._inst.GetFlag(h);
          }
          SetPlayingForwards(t2) {
            this._inst.SetFlag(h, t2);
          }
          IsInAnimationTrigger() {
            return this._inst.GetFlag(c2);
          }
          SetInAnimationTrigger(t2) {
            this._inst.SetFlag(c2, t2);
          }
          Tick() {
            this._changeAnimationName && this._DoChangeAnimation(), this._changeAnimFrameIndex >= 0 && this._DoChangeAnimFrame();
            const e2 = this._currentAnimationSpeed;
            if (!this.IsAnimationPlaying() || 0 === e2) return void this._StopTicking();
            const n2 = this._runtime.GetDt(this._inst);
            this._animationTimer.Add(n2);
            const i3 = this.GetAnimationTime(), r3 = this._currentAnimationFrame, a3 = r3.GetDuration() / e2;
            if (i3 < this._frameStartTime + a3) return;
            const s3 = this._currentAnimation, o3 = this._currentAnimationRepeatTo, m2 = s3.GetFrameCount(), h2 = s3.GetRepeatCount(), u2 = s3.IsLooping(), c3 = s3.IsPingPong();
            this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--, this._frameStartTime += a3, this._currentFrameIndex >= m2 && (c3 ? (this.SetPlayingForwards(false), this._currentFrameIndex = m2 - 2) : u2 ? this._currentFrameIndex = o3 : (this._animationRepeats++, this._animationRepeats >= h2 ? this._FinishAnimation(false) : this._currentFrameIndex = o3)), this._currentFrameIndex < 0 && (c3 ? (this._currentFrameIndex = 1, this.SetPlayingForwards(true), u2 || (this._animationRepeats++, this._animationRepeats >= h2 && this._FinishAnimation(true))) : u2 ? this._currentFrameIndex = o3 : (this._animationRepeats++, this._animationRepeats >= h2 ? this._FinishAnimation(true) : this._currentFrameIndex = o3)), this._currentFrameIndex = t.clamp(this._currentFrameIndex, 0, m2 - 1);
            const l3 = s3.GetFrameAt(this._currentFrameIndex);
            i3 > this._frameStartTime + l3.GetDuration() / e2 && (this._frameStartTime = i3), this._OnFrameChanged(r3, l3);
          }
          _FinishAnimation(e2) {
            this._currentFrameIndex = e2 ? 0 : this._currentAnimation.GetFrameCount() - 1, this.SetAnimationPlaying(false), this._animTriggerName = this._currentAnimation.GetName(), this.SetInAnimationTrigger(true), this.DispatchScriptEvent("animationend", false, { animationName: this._animTriggerName }), this.Trigger(t.Plugins.Sprite.Cnds.OnAnyAnimFinished), this.Trigger(t.Plugins.Sprite.Cnds.OnAnimFinished), this.SetInAnimationTrigger(false), this._animationRepeats = 0;
          }
          _OnFrameChanged(e2, n2, i3) {
            if (e2 === n2) return;
            const r3 = this.GetWorldInfo(), a3 = e2.GetImageInfo(), s3 = n2.GetImageInfo(), o3 = a3.GetWidth(), m2 = a3.GetHeight(), h2 = s3.GetWidth(), u2 = s3.GetHeight();
            i3 && i3.onFrameChange ? i3.onFrameChange(r3, o3, m2, h2, u2) : (o3 !== h2 && r3.SetWidth(r3.GetWidth() * (h2 / o3)), m2 !== u2 && r3.SetHeight(r3.GetHeight() * (u2 / m2))), r3.SetOriginX(n2.GetOriginX()), r3.SetOriginY(n2.GetOriginY()), r3.SetSourceCollisionPoly(n2.GetCollisionPoly()), r3.SetBboxChanged(), this._currentAnimationFrame = n2, this._currentTexture = s3.GetTexture(), this._currentRcTex = s3.GetTexRect(), this._currentQuadTex = s3.GetTexQuad();
            const c3 = this.GetInstance().GetBehaviorInstances();
            for (let t2 = 0, i4 = c3.length; t2 < i4; ++t2) c3[t2].OnSpriteFrameChanged(e2, n2);
            this.DispatchScriptEvent("framechange", false, { animationName: this._currentAnimation.GetName(), animationFrame: this._currentFrameIndex }), this.Trigger(t.Plugins.Sprite.Cnds.OnFrameChanged), this._runtime.UpdateRender();
          }
          _StartAnim(t2) {
            this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime(), 1 === t2 && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame()), this._StartTicking();
          }
          _SetAnim(t2, e2, n2) {
            this._changeAnimationName = t2, this._changeAnimationFrom = e2, this._StartTicking(), !n2 && this.IsInAnimationTrigger() || this._DoChangeAnimation();
          }
          _GetCurrentAnimation() {
            return this._currentAnimation;
          }
          _GetCurrentAnimationName() {
            return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName();
          }
          _OnAnimationRemoved(e2) {
            t.equalsNoCase(e2, this._GetCurrentAnimationName()) && this._SetAnim(this._objectClass.GetFirstAnimation().GetName(), 1, true);
          }
          _SetAnimFrame(t2) {
            if ("string" == typeof t2) if (String(Number(t2)) === t2) t2 = Number(t2);
            else {
              const e2 = this._objectClass.GetAnimationByName(this._GetCurrentAnimationName());
              if (!e2) return;
              if (-1 === (t2 = e2.GetFrameIndexByTag(t2))) return;
            }
            isFinite(t2) && (this._changeAnimFrameIndex = t2, this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
          }
          _OnAnimationFramesChanged() {
            if (this._changeAnimationName || -1 !== this._changeAnimFrameIndex) return;
            const e2 = this._currentAnimationFrame, n2 = this._currentAnimation.GetFrameAt(t.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1));
            e2 !== n2 && this._OnFrameChanged(e2, n2), this._currentAnimation.GetFrameCount() > 1 && this._currentAnimationSpeed > 0 && this._StartTicking();
          }
          _GetAnimFrame() {
            return this._currentFrameIndex;
          }
          _GetAnimFrameTag() {
            return this._currentAnimationFrame.GetTag();
          }
          _SetAnimSpeed(t2) {
            this._currentAnimationSpeed = Math.abs(t2), this.SetPlayingForwards(t2 >= 0), this._currentAnimationSpeed > 0 && this._StartTicking();
          }
          _GetAnimSpeed() {
            return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed;
          }
          _SetAnimRepeatToFrame(e2) {
            "string" == typeof e2 && -1 === (e2 = this._currentAnimation.GetFrameIndexByTag(e2)) || (e2 = t.clamp(Math.floor(e2), 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationRepeatTo = e2);
          }
          _GetAnimRepeatToFrame() {
            return this._currentAnimationRepeatTo;
          }
          _DoChangeAnimation(e2) {
            const n2 = this._currentAnimationFrame, i3 = this._objectClass.GetAnimationByName(this._changeAnimationName);
            if (this._changeAnimationName = "", !i3) return;
            if (i3 === this._currentAnimation && this.IsAnimationPlaying()) return;
            this._currentAnimation = i3, this.SetPlayingForwards(i3.GetSpeed() >= 0), this._currentAnimationSpeed = Math.abs(i3.GetSpeed()), this._currentAnimationRepeatTo = i3.GetRepeatTo(), this._currentFrameIndex = t.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), 1 === this._changeAnimationFrom && (this._currentFrameIndex = 0), this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime();
            const r3 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            this._OnFrameChanged(n2, r3, e2);
          }
          _DoChangeAnimFrame(e2) {
            const n2 = this._currentAnimationFrame, i3 = this._currentFrameIndex;
            if (this._currentFrameIndex = t.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1), this._changeAnimFrameIndex = -1, !e2 && i3 === this._currentFrameIndex) return;
            const r3 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            this._OnFrameChanged(n2, r3), this._frameStartTime = this.GetAnimationTime();
          }
          _UpdateCurrentTexture() {
            const t2 = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = t2.GetTexture(), this._currentRcTex = t2.GetTexRect(), this._currentQuadTex = t2.GetTexQuad(), this.GetWorldInfo().SetMeshChanged(true);
          }
          GetTexture() {
            return this._currentTexture;
          }
          GetTexRect() {
            return this._currentRcTex;
          }
          GetTexQuad() {
            return this._currentQuadTex;
          }
          GetImagePointCount() {
            return this._currentAnimationFrame.GetImagePointCount();
          }
          GetImagePoint(t2) {
            const e2 = this._currentAnimationFrame, n2 = this.GetWorldInfo();
            let i3 = null;
            if ("string" == typeof t2) i3 = e2.GetImagePointByName(t2);
            else {
              if ("number" != typeof t2) throw new TypeError("expected string or number");
              i3 = e2.GetImagePointByIndex(t2 - 1);
            }
            let r3 = n2.GetTotalZElevation();
            if (!i3) return [n2.GetX(), n2.GetY(), r3];
            if (m.copy(i3.GetVec2()), n2.HasMesh()) {
              const [t3, e3, i4] = n2.GetSourceMesh().TransformPoint(m.getX(), m.getY());
              m.set(t3, e3), r3 += i4;
            }
            return m.offset(-e2.GetOriginX(), -e2.GetOriginY()), m.scale(n2.GetWidth(), n2.GetHeight()), m.rotate(n2.GetAngle()), m.offset(n2.GetX(), n2.GetY()), [m.getX(), m.getY(), r3];
          }
          GetCollisionPolyPointCount() {
            return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount();
          }
          GetCollisionPolyPoint(t2) {
            t2 = Math.floor(t2);
            const e2 = this.GetWorldInfo(), n2 = e2.GetTransformedCollisionPoly(), i3 = n2.pointCount();
            if (t2 === i3 && (t2 = 0), t2 < 0 || t2 >= i3) return [0, 0];
            const r3 = n2.pointsArr();
            return [r3[2 * t2 + 0] + e2.GetX(), r3[2 * t2 + 1] + e2.GetY()];
          }
          GetDebuggerProperties() {
            const e2 = t.Plugins.Sprite.Acts, n2 = "plugins.sprite.debugger.animation-properties";
            return [{ title: n2 + ".title", properties: [{ name: n2 + ".current-animation", value: this._currentAnimation.GetName(), onedit: (t2) => this.CallAction(e2.SetAnim, t2, 0) }, { name: n2 + ".current-frame", value: this._currentFrameIndex, onedit: (t2) => this.CallAction(e2.SetAnimFrame, t2) }, { name: n2 + ".is-playing", value: this.IsAnimationPlaying(), onedit: (t2) => t2 ? this.CallAction(e2.StartAnim, 0) : this.CallAction(e2.StopAnim) }, { name: n2 + ".speed", value: this._currentAnimationSpeed, onedit: (t2) => this.CallAction(e2.SetAnimSpeed, t2) }, { name: n2 + ".repeats", value: this._animationRepeats, onedit: (t2) => this._animationRepeats = t2 }] }];
          }
          SaveToJson() {
            const t2 = { "a": this._currentAnimation.GetSID() };
            0 !== this._frameStartTime && (t2["fs"] = this._frameStartTime);
            const e2 = this.GetAnimationTime();
            0 !== e2 && (t2["at"] = e2), 0 !== this._currentFrameIndex && (t2["f"] = this._currentFrameIndex), 0 !== this._currentAnimationSpeed && (t2["cas"] = this._currentAnimationSpeed), 1 !== this._animationRepeats && (t2["ar"] = this._animationRepeats), 0 !== this._currentAnimationRepeatTo && (t2["rt"] = this._currentAnimationRepeatTo), this.IsAnimationPlaying() || (t2["ap"] = this.IsAnimationPlaying()), this.IsPlayingForwards() || (t2["af"] = this.IsPlayingForwards());
            const n2 = this.GetWorldInfo();
            return n2.IsCollisionEnabled() && (t2["ce"] = n2.IsCollisionEnabled()), t2;
          }
          LoadFromJson(e2) {
            const n2 = this.GetObjectClass().GetAnimationBySID(e2["a"]);
            n2 && (this._currentAnimation = n2), this._frameStartTime = e2.hasOwnProperty("fs") ? e2["fs"] : 0, this._animationTimer.Set(e2.hasOwnProperty("at") ? e2["at"] : 0);
            const i3 = e2.hasOwnProperty("f") ? e2["f"] : 0;
            this._currentFrameIndex = t.clamp(i3, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationSpeed = e2.hasOwnProperty("cas") ? e2["cas"] : 0, this._animationRepeats = e2.hasOwnProperty("ar") ? e2["ar"] : 1;
            const r3 = e2.hasOwnProperty("rt") ? e2["rt"] : 0;
            this._currentAnimationRepeatTo = t.clamp(r3, 0, this._currentAnimation.GetFrameCount() - 1), this.SetAnimationPlaying(!e2.hasOwnProperty("ap") || !!e2["ap"]), this.SetPlayingForwards(!e2.hasOwnProperty("af") || !!e2["af"]);
            const a3 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            this._currentAnimationFrame = a3, this._UpdateCurrentTexture();
            const s3 = this.GetWorldInfo();
            s3.SetOriginX(a3.GetOriginX()), s3.SetOriginY(a3.GetOriginY()), s3.SetSourceCollisionPoly(a3.GetCollisionPoly()), s3.SetCollisionEnabled(!!e2["ce"]), this.IsAnimationPlaying() && this._StartTicking();
          }
          GetPropertyValueByIndex(e2) {
            const n2 = this.GetWorldInfo();
            switch (e2) {
              case a2:
                return n2.IsCollisionEnabled();
              case r2:
                return t.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1);
              case i2:
                return this._currentAnimation.GetName();
            }
          }
          SetPropertyValueByIndex(e2, n2, s3) {
            const o3 = this.GetWorldInfo();
            switch (e2) {
              case a2:
                o3.SetCollisionEnabled(!!n2);
                break;
              case r2: {
                this.SetAnimationPlaying(false);
                const e3 = this._currentAnimation.GetFrameCount() - 1, i3 = n2 = t.clamp(n2, 0, e3), r3 = this._currentAnimation.GetFrameAt(this._currentFrameIndex), a3 = this._currentAnimation.GetFrameAt(i3);
                this._OnFrameChanged(r3, a3, s3), this._currentFrameIndex = t.clamp(i3, 0, e3);
                break;
              }
              case i2:
                this._changeAnimationName = n2, this._DoChangeAnimation(s3);
                this._currentAnimation.GetFrameCount() > 1 && this._currentAnimation.GetSpeed() > 0 ? this._StartTicking() : this._StopTicking();
                break;
            }
          }
          GetScriptInterfaceClass() {
            return self.ISpriteInstance;
          }
        };
        const l2 = /* @__PURE__ */ new WeakMap(), d2 = /* @__PURE__ */ new Map([["current-frame", 0], ["beginning", 1]]);
        self.ISpriteInstance = class extends self.IWorldInstance {
          constructor() {
            super(), l2.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          getImagePointCount() {
            return l2.get(this).GetImagePointCount();
          }
          getImagePointX(t2) {
            return this.getImagePoint(t2)[0];
          }
          getImagePointY(t2) {
            return this.getImagePoint(t2)[1];
          }
          getImagePointZ(t2) {
            return this.getImagePoint(t2)[2];
          }
          getImagePoint(t2) {
            if ("string" != typeof t2 && "number" != typeof t2) throw new TypeError("expected string or number");
            return l2.get(this).GetImagePoint(t2);
          }
          getPolyPointCount() {
            return l2.get(this).GetCollisionPolyPointCount();
          }
          getPolyPointX(t2) {
            return e.RequireFiniteNumber(t2), l2.get(this).GetCollisionPolyPoint(t2)[0];
          }
          getPolyPointY(t2) {
            return e.RequireFiniteNumber(t2), l2.get(this).GetCollisionPolyPoint(t2)[1];
          }
          getPolyPoint(t2) {
            return e.RequireFiniteNumber(t2), l2.get(this).GetCollisionPolyPoint(t2);
          }
          stopAnimation() {
            l2.get(this).SetAnimationPlaying(false);
          }
          startAnimation(t2 = "current-frame") {
            e.RequireString(t2);
            const n2 = d2.get(t2);
            if (void 0 === n2) throw new Error("invalid mode");
            l2.get(this)._StartAnim(n2);
          }
          setAnimation(t2, n2 = "beginning") {
            e.RequireString(t2), e.RequireString(n2);
            const i3 = d2.get(n2);
            if (void 0 === i3) throw new Error("invalid mode");
            const r3 = l2.get(this);
            if (!r3.GetObjectClass().GetAnimationByName(t2)) throw new Error(`animation name "${t2}" does not exist`);
            r3._SetAnim(t2, i3);
          }
          getAnimation(t2) {
            e.RequireString(t2);
            const n2 = l2.get(this).GetObjectClass().GetAnimationByName(t2);
            return n2 ? n2.GetIAnimation() : null;
          }
          get animation() {
            return l2.get(this)._GetCurrentAnimation().GetIAnimation();
          }
          get animationName() {
            return l2.get(this)._GetCurrentAnimationName();
          }
          set animationFrame(t2) {
            e.RequireFiniteNumber(t2), l2.get(this)._SetAnimFrame(t2);
          }
          get animationFrame() {
            return l2.get(this)._GetAnimFrame();
          }
          set animationFrameTag(t2) {
            e.RequireString(t2), l2.get(this)._SetAnimFrame(t2);
          }
          get animationFrameTag() {
            return l2.get(this)._GetAnimFrameTag();
          }
          set animationSpeed(t2) {
            e.RequireFiniteNumber(t2), l2.get(this)._SetAnimSpeed(t2);
          }
          get animationSpeed() {
            return l2.get(this)._GetAnimSpeed();
          }
          set animationRepeatToFrame(t2) {
            e.RequireFiniteNumber(t2), l2.get(this)._SetAnimRepeatToFrame(t2);
          }
          get animationRepeatToFrame() {
            return l2.get(this)._GetAnimRepeatToFrame();
          }
          get imageWidth() {
            return l2.get(this).GetCurrentImageInfo().GetWidth();
          }
          get imageHeight() {
            return l2.get(this).GetCurrentImageInfo().GetHeight();
          }
          getImageSize() {
            const t2 = l2.get(this).GetCurrentImageInfo();
            return [t2.GetWidth(), t2.GetHeight()];
          }
          async replaceCurrentAnimationFrame(n2) {
            e.RequireInstanceOf(n2, Blob);
            const i3 = l2.get(this), r3 = i3.GetRuntime(), a3 = i3.GetCurrentImageInfo(), s3 = t.New(t.ImageInfo);
            if (s3.LoadDynamicBlobAsset(r3, n2), await s3.LoadStaticTexture(r3.GetRenderer(), { sampling: r3.GetSampling() }), i3.WasReleased()) return void s3.Release();
            a3.ReplaceWith(s3);
            const o3 = i3.GetSdkType();
            o3._UpdateAllCurrentTexture(), o3.GetObjectClass().Dispatcher().dispatchEvent(new t.Event("animationframeimagechange")), r3.UpdateRender();
          }
          setSolidCollisionFilter(t2, n2) {
            e.RequireString(n2), l2.get(this).GetWorldInfo().SetSolidCollisionFilter(!!t2, n2);
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.Sprite.Cnds = { IsAnimPlaying(e) {
          return t.equalsNoCase(this._GetCurrentAnimationName(), e);
        }, CompareFrame(e, n) {
          return t.compare(this._currentFrameIndex, e, n);
        }, CompareFrameTag(e, n) {
          if ("string" != typeof n) return false;
          const i2 = this._currentAnimationFrame.GetTag();
          return t.compare(i2.toLowerCase(), e, n.toLowerCase());
        }, CompareAnimSpeed(e, n) {
          return t.compare(this._GetAnimSpeed(), e, n);
        }, OnAnimFinished(e) {
          return t.equalsNoCase(this._animTriggerName, e);
        }, OnAnyAnimFinished: () => true, OnFrameChanged: () => true, IsMirrored() {
          return this.GetWorldInfo().GetWidth() < 0;
        }, IsFlipped() {
          return this.GetWorldInfo().GetHeight() < 0;
        }, OnURLLoaded: () => true, OnURLFailed: () => true, IsCollisionEnabled() {
          return this.GetWorldInfo().IsCollisionEnabled();
        } };
      }
      {
        const t = self.C3;
        t.Plugins.Sprite.Acts = { Spawn(t2, e, n, i2, r2) {
          if (!t2 || !e) return;
          const [a2, s2] = this.GetImagePoint(n), o2 = this._runtime.CreateInstance(t2, e, a2, s2, i2, r2);
          if (!o2) return;
          if (i2 && e.SortAndAddInstancesByZIndex(o2), t2.GetPlugin().IsRotatable()) {
            const t3 = o2.GetWorldInfo();
            t3.SetAngle(this.GetWorldInfo().GetAngle()), t3.SetBboxChanged();
          }
          const m = this._runtime.GetEventSheetManager();
          m.BlockFlushingInstances(true), o2._TriggerOnCreatedOnSelfAndRelated(), m.BlockFlushingInstances(false), t2 !== this._runtime.GetCurrentAction().GetObjectClass() && this._sdkType._SpawnPickInstance(t2, o2, i2);
        }, StopAnim() {
          this.SetAnimationPlaying(false);
        }, StartAnim(t2) {
          this._StartAnim(t2);
        }, SetAnim(t2, e) {
          this._SetAnim(t2, e);
        }, SetAnimFrame(t2) {
          this._SetAnimFrame(t2);
        }, SetAnimSpeed(t2) {
          this._SetAnimSpeed(t2);
        }, SetAnimRepeatToFrame(t2) {
          this._SetAnimRepeatToFrame(t2);
        }, AddRemoveAnimation(t2, e) {
          try {
            0 === t2 ? this.GetSdkType()._AddAnimation(e) : this.GetSdkType()._RemoveAnimation(e);
          } catch (e2) {
            console.error(`[Construct] Error ${0 === t2 ? "adding" : "removing"} animation: `, e2);
          }
        }, AddRemoveAnimationFrame(t2, e, n) {
          try {
            0 === t2 ? this.GetSdkType()._AddAnimationFrame(e, n) : this.GetSdkType()._RemoveAnimationFrame(e, n);
          } catch (e2) {
            console.error(`[Construct] Error ${0 === t2 ? "adding" : "removing"} animation frame: `, e2);
          }
        }, SetMirrored(t2) {
          const e = this.GetWorldInfo(), n = e.GetWidth(), i2 = Math.abs(n) * (0 === t2 ? -1 : 1);
          n !== i2 && (e.SetWidth(i2), e.SetBboxChanged());
        }, SetFlipped(t2) {
          const e = this.GetWorldInfo(), n = e.GetHeight(), i2 = Math.abs(n) * (0 === t2 ? -1 : 1);
          n !== i2 && (e.SetHeight(i2), e.SetBboxChanged());
        }, SetScale(t2) {
          const e = this._currentAnimationFrame.GetImageInfo(), n = this.GetWorldInfo(), i2 = n.GetWidth() < 0 ? -1 : 1, r2 = n.GetHeight() < 0 ? -1 : 1, a2 = e.GetWidth() * t2 * i2, s2 = e.GetHeight() * t2 * r2;
          n.GetWidth() === a2 && n.GetHeight() === s2 || (n.SetSize(a2, s2), n.SetBboxChanged());
        }, async LoadURL(e, n, i2) {
          const r2 = this._currentAnimationFrame.GetImageInfo(), a2 = this.GetWorldInfo(), s2 = this._runtime, o2 = this._sdkType;
          if (r2.GetURL() === e) return 0 === n && (a2.SetSize(r2.GetWidth(), r2.GetHeight()), a2.SetBboxChanged()), void this.Trigger(t.Plugins.Sprite.Cnds.OnURLLoaded);
          const m = t.New(t.ImageInfo);
          try {
            if (await m.LoadDynamicAsset(s2, e), !m.IsLoaded()) throw new Error("image failed to load");
            if (this.WasReleased()) return void m.Release();
            await m.LoadStaticTexture(s2.GetRenderer(), { sampling: s2.GetSampling() });
          } catch (e2) {
            return console.error("Load image from URL failed: ", e2), void (this.WasReleased() || this.Trigger(t.Plugins.Sprite.Cnds.OnURLFailed));
          }
          this.WasReleased() ? m.Release() : (r2.ReplaceWith(m), o2._UpdateAllCurrentTexture(), o2.GetObjectClass().Dispatcher().dispatchEvent(new t.Event("animationframeimagechange")), s2.UpdateRender(), 0 === n && (a2.SetSize(r2.GetWidth(), r2.GetHeight()), a2.SetBboxChanged()), await this.TriggerAsync(t.Plugins.Sprite.Cnds.OnURLLoaded));
        }, SetCollisions(t2) {
          this.GetWorldInfo().SetCollisionEnabled(t2);
        }, SetSolidCollisionFilter(t2, e) {
          this.GetWorldInfo().SetSolidCollisionFilter(0 === t2, e);
        }, SetEffect(t2) {
          this.GetWorldInfo().SetBlendMode(t2), this._runtime.UpdateRender();
        } };
      }
      self.C3.Plugins.Sprite.Exps = { AnimationFrame() {
        return this._GetAnimFrame();
      }, AnimationFrameTag() {
        return this._GetAnimFrameTag();
      }, AnimationFrameCount() {
        return this._currentAnimation.GetFrameCount();
      }, AnimationName() {
        return this._currentAnimation.GetName();
      }, AnimationSpeed() {
        return this._GetAnimSpeed();
      }, OriginalAnimationSpeed() {
        return this._currentAnimation.GetSpeed();
      }, ImagePointX(t) {
        return this.GetImagePoint(t)[0];
      }, ImagePointY(t) {
        return this.GetImagePoint(t)[1];
      }, ImagePointZ(t) {
        return this.GetImagePoint(t)[2];
      }, ImagePointCount() {
        return this.GetImagePointCount();
      }, ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth();
      }, ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight();
      }, PolyPointXAt(t) {
        return this.GetCollisionPolyPoint(t)[0];
      }, PolyPointYAt(t) {
        return this.GetCollisionPolyPoint(t)[1];
      }, PolyPointCount() {
        return this.GetCollisionPolyPointCount();
      } };
    }
    {
      {
        const e = self.C3;
        e.Plugins.Text = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.Text.Type = class extends e.SDKTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
          LoadTextures(e2) {
          }
          ReleaseTextures() {
          }
        };
      }
      {
        const e = self.C3, t = self.C3X, i2 = [0, 0, 0], s2 = 0, r2 = 1, n = 2, a2 = 3, o2 = 4, h = 5, l2 = 6, _ = 7, c2 = 8, d2 = 9, g = 10, u = 11, T = 12, S = 13, p = 15, x = ["left", "center", "right"], m = ["top", "center", "bottom"], G = ["ltr", "rtl"], f2 = ["word", "cjk", "character"], w = new e.Rect(), I = new e.Quad(), R = new e.Color(), y = e.New(e.Vector2), b = /* @__PURE__ */ new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["iconoffsety", null]]);
        e.Plugins.Text.Instance = class extends e.SDKWorldInstanceBase {
          constructor(t2, i3) {
            if (super(t2), this._text = "", this._enableBBcode = true, this._faceName = "Arial", this._ptSize = 12, this._lineHeightOffset = 0, this._isBold = false, this._isItalic = false, this._color = e.New(e.Color), this._horizontalAlign = 0, this._verticalAlign = 0, this._wrapMode = "word", this._textDirection = 0, this._resolutionMode = "auto", this._fixedScaleFactor = 1, this._iconObjectClass = null, this._htmlString = "", this._isHtmlStringUpToDate = false, this._readAloud = false, this._screenReaderText = null, this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText = e.New(e.Gfx.RendererText, this._runtime.GetRenderer(), { timeout: 5 }), this._rendererText.ontextureupdate = () => this._runtime.UpdateRender(), this._animationframeimagechange_handler = () => this._OnIconObjectClassImageChanged(), this._pendingUpdateIconSet = false, i3) {
              this._text = i3[s2], this._enableBBcode = !!i3[r2], this._faceName = i3[n], this._ptSize = i3[a2], this._lineHeightOffset = i3[o2], this._isBold = !!i3[h], this._isItalic = !!i3[l2], this._horizontalAlign = i3[c2], this._verticalAlign = i3[d2], this._wrapMode = f2[i3[g]], this._textDirection = i3[u], this._SetIconObjectClass(this._runtime.GetObjectClassBySID(i3[T]));
              const e2 = i3[_];
              this._color.setRgb(e2[0], e2[1], e2[2]), this.GetWorldInfo().SetVisible(i3[S]), this._readAloud = !!i3[p];
            }
            this._UpdateTextSettings(), this._UpdateScreenReaderText();
          }
          Release() {
            this._SetIconObjectClass(null), this._CancelTypewriter(), this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null), this._rendererText.Release(), this._rendererText = null, super.Release();
          }
          _UpdateTextSettings() {
            const e2 = this._rendererText;
            e2.SetText(this._text), e2.SetBBCodeEnabled(this._enableBBcode), this._rendererText.IsBBCodeEnabled() && this._iconObjectClass ? this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)) : this._rendererText.SetIconSet(null), e2.SetIconSmoothing("nearest" !== this._runtime.GetSampling()), e2.SetFontName(this._faceName), e2.SetLineHeight(this._lineHeightOffset), e2.SetBold(this._isBold), e2.SetItalic(this._isItalic), e2.SetColor(this._color), e2.SetHorizontalAlignment(x[this._horizontalAlign]), e2.SetVerticalAlignment(m[this._verticalAlign]), e2.SetWordWrapMode(this._wrapMode), e2.SetTextDirection(G[this._textDirection]);
          }
          _UpdateTextSize() {
            const e2 = this.GetWorldInfo();
            this._rendererText.SetFontSize(this._ptSize), this._rendererText.SetFontSizeScale(e2.GetSceneGraphScale());
            const t2 = e2.GetLayer();
            let i3;
            "auto" === this._resolutionMode ? i3 = t2.GetResolutionScaleFactorToZ(e2.GetTotalZElevation()) : "fixed" === this._resolutionMode && (i3 = this._fixedScaleFactor), e2.HasMesh() && i3 !== this._rendererText.GetZoom() && e2.SetMeshChanged(true), this._rendererText.SetSize(e2.GetWidth(), e2.GetHeight(), i3);
          }
          _SetIconObjectClass(t2) {
            t2 && (t2.IsFamily() || t2.GetPlugin().constructor !== e.Plugins.Sprite) || t2 !== this._iconObjectClass && (this._iconObjectClass && this._iconObjectClass.Dispatcher().removeEventListener("animationframeimagechange", this._animationframeimagechange_handler), this._iconObjectClass = t2, this._iconObjectClass && this._iconObjectClass.Dispatcher().addEventListener("animationframeimagechange", this._animationframeimagechange_handler), this._UpdateTextSettings(), this._isHtmlStringUpToDate = false, this._runtime.UpdateRender());
          }
          _OnIconObjectClassImageChanged() {
            this._runtime.DeleteTextIconSet(this._iconObjectClass), this._runtime.UpdateRender(), this._pendingUpdateIconSet = true;
          }
          _UpdateScreenReaderText() {
            if (this._readAloud) {
              let t2 = this._text;
              this._enableBBcode && (t2 = e.BBString.StripAnyTags(t2)), this._screenReaderText ? this._screenReaderText.SetText(t2) : this._screenReaderText = e.New(e.ScreenReaderText, this._runtime, t2);
            } else this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null);
          }
          Draw(e2) {
            const t2 = this.GetWorldInfo();
            this._UpdateTextSize(), this._pendingUpdateIconSet && (this._pendingUpdateIconSet = false, this._rendererText.IsBBCodeEnabled() && this._iconObjectClass && this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)));
            const i3 = this._rendererText.GetTexture();
            if (!i3) return;
            const s3 = t2.GetLayer();
            if (0 === t2.GetAngle() && 0 === s3.GetAngle() && 0 === t2.GetTotalZElevation() && !t2.HasMesh() && s3.RendersIn2DMode()) {
              const r3 = t2.GetBoundingQuad(), [n2, a3] = s3.LayerToDrawSurface(r3.getTlx(), r3.getTly()), [o3, h2] = s3.LayerToDrawSurface(r3.getBrx(), r3.getBry()), l3 = n2 - Math.round(n2), _2 = a3 - Math.round(a3);
              w.set(n2, a3, o3, h2), w.offset(-l3, -_2), I.setFromRect(w);
              const [c3, d3] = e2.GetRenderTargetSize(e2.GetRenderTarget());
              e2.IsWebGL() ? this._runtime.GetCanvasManager().SetDeviceTransform(e2, c3, d3) : (e2.SetNormalizedCoordsProgramVariant(true), I.divide(c3, d3)), e2.SetTexture(i3), e2.Quad3(I, this._rendererText.GetTexRect()), e2.IsWebGL() ? s3._SetTransform(e2) : e2.SetNormalizedCoordsProgramVariant(false);
            } else e2.SetTexture(i3), t2.HasMesh() ? this._DrawMesh(t2, e2) : this._DrawStandard(t2, e2);
          }
          _DrawStandard(e2, t2) {
            let i3 = e2.GetBoundingQuad();
            this._runtime.IsPixelRoundingEnabled() && (i3 = this._PixelRoundQuad(i3)), t2.Quad3(i3, this._rendererText.GetTexRect());
          }
          _DrawMesh(e2, t2) {
            const i3 = e2.GetTransformedMesh();
            if (e2.IsMeshChanged()) {
              e2.CalculateBbox(w, I, false);
              let t3 = I;
              this._runtime.IsPixelRoundingEnabled() && (t3 = this._PixelRoundQuad(t3)), i3.CalculateTransformedMesh(e2.GetSourceMesh(), t3, this._rendererText.GetTexRect()), e2.SetMeshChanged(false);
            }
            i3.Draw(t2, e2.GetTotalZElevation());
          }
          _PixelRoundQuad(e2) {
            const t2 = e2.getTlx() - Math.round(e2.getTlx()), i3 = e2.getTly() - Math.round(e2.getTly());
            return 0 === t2 && 0 === i3 ? e2 : (I.copy(e2), I.offset(-t2, -i3), I);
          }
          GetCurrentSurfaceSize() {
            const e2 = this._rendererText.GetTexture();
            return e2 ? [e2.GetWidth(), e2.GetHeight()] : [100, 100];
          }
          GetCurrentTexRect() {
            return this._rendererText.GetTexRect();
          }
          IsCurrentTexRotated() {
            return false;
          }
          SaveToJson() {
            const e2 = { "t": this._text, "c": this._color.toJSON(), "fn": this._faceName, "ps": this._ptSize };
            return this._enableBBcode && (e2["bbc"] = this._enableBBcode), 0 !== this._horizontalAlign && (e2["ha"] = this._horizontalAlign), 0 !== this._verticalAlign && (e2["va"] = this._verticalAlign), "word" !== this._wrapMode && (e2["wr"] = this._wrapMode), 0 !== this._lineHeightOffset && (e2["lho"] = this._lineHeightOffset), this._isBold && (e2["b"] = this._isBold), this._isItalic && (e2["i"] = this._isItalic), -1 !== this._typewriterEndTime && (e2["tw"] = { "st": this._typewriterStartTime, "en": this._typewriterEndTime, "l": this._typewriterLength }), this._iconObjectClass && (e2["ioc"] = this._iconObjectClass.GetSID()), "fixed" === this._resolutionMode && (e2["fs"] = this._fixedScaleFactor), e2;
          }
          LoadFromJson(e2) {
            if (this._CancelTypewriter(), this._text = e2["t"], this._color.setFromJSON(e2["c"]), this._faceName = e2["fn"], this._ptSize = e2["ps"], this._enableBBcode = !!e2.hasOwnProperty("bbc") && e2["bbc"], this._horizontalAlign = e2.hasOwnProperty("ha") ? e2["ha"] : 0, this._verticalAlign = e2.hasOwnProperty("va") ? e2["va"] : 0, e2.hasOwnProperty("wr")) {
              const t2 = e2["wr"];
              this._wrapMode = "boolean" == typeof t2 ? t2 ? "word" : "character" : t2;
            } else this._wrapMode = "word";
            if (this._lineHeightOffset = e2.hasOwnProperty("lho") ? e2["lho"] : 0, this._isBold = !!e2.hasOwnProperty("b") && e2["b"], this._isItalic = !!e2.hasOwnProperty("i") && e2["i"], e2.hasOwnProperty("tw")) {
              const t2 = e2["tw"];
              this._typewriterStartTime = t2["st"], this._typewriterEndTime = t2["en"], this._typewriterLength = t2["l"];
            }
            if (e2.hasOwnProperty("ioc")) {
              const t2 = this.GetRuntime().GetObjectClassBySID(e2["ioc"]);
              t2 && this._SetIconObjectClass(t2);
            } else this._SetIconObjectClass(null);
            e2.hasOwnProperty("fs") ? (this._resolutionMode = "fixed", this._fixedScaleFactor = e2["fs"]) : this._resolutionMode = "auto", this._UpdateTextSettings(), this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = false, -1 !== this._typewriterEndTime && this._StartTicking();
          }
          GetPropertyValueByIndex(e2) {
            switch (e2) {
              case s2:
                return this.GetText();
              case r2:
                return this._enableBBcode;
              case n:
                return this._GetFontFace();
              case a2:
                return this._GetFontSize();
              case o2:
                return this._GetLineHeight();
              case h:
                return this._IsBold();
              case l2:
                return this._IsItalic();
              case _:
                return i2[0] = this._color.getR(), i2[1] = this._color.getG(), i2[2] = this._color.getB(), i2;
              case c2:
                return this._GetHAlign();
              case d2:
                return this._GetVAlign();
              case g:
                return this._GetWrapMode();
              case p:
                return this._IsReadAloud();
            }
          }
          SetPropertyValueByIndex(e2, t2) {
            switch (e2) {
              case s2:
                this._SetText(t2);
                break;
              case r2:
                if (this._enableBBcode === !!t2) return;
                this._enableBBcode = !!t2, this._UpdateTextSettings();
                break;
              case n:
                this._SetFontFace(t2);
                break;
              case a2:
                this._SetFontSize(t2);
                break;
              case o2:
                this._SetLineHeight(t2);
                break;
              case h:
                this._SetBold(t2);
                break;
              case l2:
                this._SetItalic(t2);
                break;
              case _:
                const e3 = this._color, i3 = t2;
                if (e3.getR() === i3[0] && e3.getG() === i3[1] && e3.getB() === i3[2]) return;
                this._color.setRgb(i3[0], i3[1], i3[2]), this._UpdateTextSettings();
                break;
              case c2:
                this._SetHAlign(t2);
                break;
              case d2:
                this._SetVAlign(t2);
                break;
              case g:
                this._SetWrapMode(t2);
            }
          }
          SetPropertyColorOffsetValueByIndex(e2, t2, i3, s3) {
            if ((0 !== t2 || 0 !== i3 || 0 !== s3) && e2 === _) this._color.addRgb(t2, i3, s3), this._UpdateTextSettings();
          }
          _SetText(e2) {
            this._text !== e2 && (this._text = e2, this._rendererText.SetText(e2), this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = false, this._runtime.UpdateRender());
          }
          GetText() {
            return this._text;
          }
          _StartTypewriter(e2, t2) {
            this._UpdateTextSize(), this._SetText(e2), this._typewriterStartTime = this._runtime.GetWallTime(), this._typewriterEndTime = this._typewriterStartTime + t2 / this.GetInstance().GetActiveTimeScale(), this._typewriterLength = this._rendererText.GetLengthInGraphemes(), this._rendererText.SetDrawMaxCharacterCount(0), this._StartTicking();
          }
          _CancelTypewriter() {
            this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText.SetDrawMaxCharacterCount(-1), this._StopTicking();
          }
          _FinishTypewriter() {
            -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender());
          }
          _SetFontFace(e2) {
            this._faceName !== e2 && (this._faceName = e2, this._rendererText.SetFontName(e2), this._runtime.UpdateRender());
          }
          _GetFontFace() {
            return this._faceName;
          }
          _SetBold(e2) {
            e2 = !!e2, this._isBold !== e2 && (this._isBold = e2, this._rendererText.SetBold(e2), this._runtime.UpdateRender());
          }
          _IsBold() {
            return this._isBold;
          }
          _SetItalic(e2) {
            e2 = !!e2, this._isItalic !== e2 && (this._isItalic = e2, this._rendererText.SetItalic(e2), this._runtime.UpdateRender());
          }
          _IsItalic() {
            return this._isItalic;
          }
          _SetFontSize(e2) {
            this._ptSize !== e2 && (this._ptSize = e2, this._runtime.UpdateRender());
          }
          _GetFontSize() {
            return this._ptSize;
          }
          _SetFontColor(e2) {
            this._color.equalsIgnoringAlpha(e2) || (this._color.copyRgb(e2), this._rendererText.SetColor(this._color), this._runtime.UpdateRender());
          }
          _GetFontColor() {
            return this._color;
          }
          _SetLineHeight(e2) {
            this._lineHeightOffset !== e2 && (this._lineHeightOffset = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
          }
          _GetLineHeight() {
            return this._lineHeightOffset;
          }
          _SetHAlign(e2) {
            this._horizontalAlign !== e2 && (this._horizontalAlign = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
          }
          _GetHAlign() {
            return this._horizontalAlign;
          }
          _SetVAlign(e2) {
            this._verticalAlign !== e2 && (this._verticalAlign = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
          }
          _GetVAlign() {
            return this._verticalAlign;
          }
          _SetWrapModeByIndex(e2) {
            this._SetWrapMode(f2[e2]);
          }
          _SetWrapMode(e2) {
            this._wrapMode !== e2 && (this._wrapMode = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
          }
          _GetWrapMode() {
            return this._wrapMode;
          }
          _SetTextDirection(e2) {
            this._textDirection !== e2 && (this._textDirection = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
          }
          _GetTextDirection() {
            return this._textDirection;
          }
          _SetReadAloud(e2) {
            this._readAloud = !!e2, this._UpdateScreenReaderText();
          }
          _IsReadAloud() {
            return this._readAloud;
          }
          _SetResolutionMode(e2) {
            this._resolutionMode !== e2 && (this._resolutionMode = e2, this._runtime.UpdateRender());
          }
          _GetResolutionMode() {
            return this._resolutionMode;
          }
          _SetFixedScaleFactor(e2) {
            this._fixedScaleFactor !== e2 && (this._fixedScaleFactor = e2, "fixed" === this._resolutionMode && this._runtime.UpdateRender());
          }
          _GetFixedScaleFactor() {
            return this._fixedScaleFactor;
          }
          _GetTextWidth() {
            return this._UpdateTextSize(), this._rendererText.GetTextWidth();
          }
          _GetTextHeight() {
            return this._UpdateTextSize(), this._rendererText.GetTextHeight();
          }
          _GetTagAtPosition(e2, t2) {
            this._UpdateTextSize();
            const i3 = this.GetWorldInfo();
            y.set(e2 - i3.GetX(), t2 - i3.GetY()), y.rotate(-i3.GetAngle()), y.offset(i3.GetWidth() * i3.GetOriginX(), i3.GetHeight() * i3.GetOriginY()), y.divide(i3.GetWidth(), i3.GetHeight()), y.scale(this._rendererText.GetWidth(), this._rendererText.GetHeight());
            const s3 = this._rendererText.HitTestFragment(y.getX(), y.getY());
            if (s3) {
              const e3 = s3.GetStyleTag("tag");
              if (e3) return e3.param;
            }
            return "";
          }
          _HasTagAtPosition(t2, i3, s3) {
            const r3 = this._GetTagAtPosition(i3, s3);
            return r3 && e.equalsNoCase(t2, r3);
          }
          _GetTagPosition(e2, t2) {
            this._UpdateTextSize(), t2 = Math.floor(t2);
            const i3 = this._rendererText.FindFragmentWithTag(e2, t2);
            if (!i3) return null;
            const s3 = this.GetWorldInfo(), r3 = this._rendererText.GetDrawScale(), n2 = i3.GetPosX(), a3 = i3.GetPosY() - (i3.GetHeight() - i3.GetFontBoundingBoxDescent()) * r3, o3 = i3.GetWidth() * r3 / this._rendererText.GetWidth() * s3.GetWidth(), h2 = i3.GetHeight() * r3 / this._rendererText.GetHeight() * s3.GetHeight();
            return y.set(n2, a3), y.divide(this._rendererText.GetWidth(), this._rendererText.GetHeight()), y.scale(s3.GetWidth(), s3.GetHeight()), y.offset(-s3.GetWidth() * s3.GetOriginX(), -s3.GetHeight() * s3.GetOriginY()), y.rotate(s3.GetAngle()), y.offset(s3.GetX(), s3.GetY()), { x: y.getX(), y: y.getY(), width: o3, height: h2 };
          }
          _GetTagCount(e2) {
            return this._UpdateTextSize(), this._rendererText.CountFragmentsWithTag(e2);
          }
          _GetHTMLCloseTag(e2) {
            let t2 = b.get(e2);
            return null === t2 ? "" : (t2 || (t2 = "span"), `</${t2 || "span"}>`);
          }
          _GetHTMLOpenTag(e2, t2) {
            let i3 = b.get(e2);
            if (null === i3) return "";
            switch (i3 || (i3 = "span"), e2) {
              case "color":
                return `<${i3} style="color: ${t2}">`;
              case "font":
                return `<${i3} style="font-family: '${t2}'">`;
              case "opacity":
                return `<${i3} style="opacity: ${t2}%">`;
              case "size":
                return `<${i3} style="font-size: ${t2}pt">`;
              case "background":
                return `<${i3} style="background-color: ${t2}">`;
              case "hide":
                return `<${i3} style="visibility: hidden">`;
              case "class":
                return `<${i3} class="${t2}">`;
              case "tag":
                return `<${i3} data-tag="${t2}">`;
              default:
                return `<${i3}>`;
            }
          }
          async _UpdateHTMLString() {
            if (this._isHtmlStringUpToDate) return this._htmlString;
            const t2 = new e.BBString(this._text, { noEscape: true }).toFragmentList(), i3 = /* @__PURE__ */ new Map();
            let s3 = '<span class="c3-text"';
            const r3 = [];
            r3.push(`font-family: '${this._GetFontFace()}';`), this._IsBold() && r3.push("font-weight: bold;"), this._IsItalic() && r3.push("font-style: italic;"), "character" === this._GetWrapMode() && r3.push("word-break: break-all;"), s3 += ` style="${r3.join(" ")}">`;
            const n2 = this._iconObjectClass ? this.GetRuntime().GetTextIconSet(this._iconObjectClass) : null;
            if (this._iconObjectClass) {
              const s4 = e.New(e.PromiseThrottle), r4 = [], a4 = /* @__PURE__ */ new Map();
              for (const e2 of t2) if (e2.IsIcon()) {
                const t3 = e2.GetTextIcon(n2);
                if (t3) {
                  const e3 = t3.GetSource().GetImageInfo().GetImageAsset();
                  if (a4.has(e3)) continue;
                  a4.set(e3, null), r4.push(s4.Add(async () => {
                    const t4 = await e3.LoadToDrawable();
                    a4.set(e3, t4);
                  }));
                }
              }
              await Promise.all(r4);
              const o4 = [];
              for (const e2 of t2) if (e2.IsIcon()) {
                const t3 = e2.GetTextIcon(n2);
                if (t3) {
                  const e3 = t3.GetSource(), r5 = e3.GetImageInfo().GetImageAsset();
                  o4.push(s4.Add(async () => {
                    const s5 = await e3.GetImageInfo().ExtractImageToBlobURL(a4.get(r5));
                    i3.set(t3, s5);
                  }));
                }
              }
              await Promise.all(o4);
              for (const e2 of a4.values()) e2 instanceof ImageBitmap && e2["close"] && e2["close"]();
            }
            const a3 = /* @__PURE__ */ new Map();
            for (const r4 of t2) {
              const t3 = r4.GetStyleMap();
              let o4 = [...a3.keys()];
              o4.reverse();
              for (const e2 of o4) t3.has(e2) && t3.get(e2) === a3.get(e2) || (a3.delete(e2), s3 += this._GetHTMLCloseTag(e2));
              for (const [e2, i4] of t3) a3.has(e2) || (a3.set(e2, i4), s3 += this._GetHTMLOpenTag(e2, i4));
              if (r4.IsText() && (s3 += e.ReplaceAll(e.EscapeHTML(r4.GetCharacterArray().join("")), "\n", "<br>")), r4.IsIcon() && n2) {
                const e2 = r4.GetTextIcon(n2);
                if (e2) {
                  const n3 = i3.get(e2);
                  if (n3) {
                    const i4 = [];
                    let a4 = "0.2em";
                    const o5 = t3.get("iconoffsety");
                    if (o5) {
                      let e3 = o5.trim();
                      a4 = e3.endsWith("%") ? parseFloat(e3) / 100 + "em" : e3 + "px";
                    }
                    i4.push(`top: ${a4}`), "nearest" === this._runtime.GetSampling() && i4.push("image-rendering: pixelated"), s3 += `<img class="c3-text-icon" data-icon="${r4.GetIconParameter()}" width="${e2.GetWidth()}" height="${e2.GetHeight()}" style="${i4.join(";")}" src="${n3}">`;
                  }
                }
              }
            }
            const o3 = [...a3.keys()];
            o3.reverse();
            for (const e2 of o3) s3 += this._GetHTMLCloseTag(e2);
            return s3 += "</span>", this._htmlString = s3, this._isHtmlStringUpToDate = true, this._htmlString;
          }
          Tick() {
            const t2 = this._runtime.GetWallTime();
            if (t2 >= this._typewriterEndTime) this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender();
            else {
              let i3 = e.relerp(this._typewriterStartTime, this._typewriterEndTime, t2, 0, this._typewriterLength);
              i3 = Math.floor(i3), i3 !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(i3), this._runtime.UpdateRender());
            }
          }
          GetDebuggerProperties() {
            const e2 = "plugins.text";
            return [{ title: e2 + ".name", properties: [{ name: e2 + ".properties.text.name", value: this.GetText(), onedit: (e3) => this._SetText(e3) }, { name: e2 + ".properties.font.name", value: this._GetFontFace(), onedit: (e3) => this._SetFontFace(e3) }, { name: e2 + ".properties.size.name", value: this._GetFontSize(), onedit: (e3) => this._SetFontSize(e3) }, { name: e2 + ".properties.line-height.name", value: this._GetLineHeight(), onedit: (e3) => this._SetLineHeight(e3) }, { name: e2 + ".properties.bold.name", value: this._IsBold(), onedit: (e3) => this._SetBold(e3) }, { name: e2 + ".properties.italic.name", value: this._IsItalic(), onedit: (e3) => this._SetItalic(e3) }, { name: e2 + ".debugger.text-width", value: this._GetTextWidth() }, { name: e2 + ".debugger.text-height", value: this._GetTextHeight() }] }];
          }
          GetScriptInterfaceClass() {
            return self.ITextInstance;
          }
        };
        const C = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new Map([["left", 0], ["center", 1], ["right", 2]]), A = /* @__PURE__ */ new Map([["top", 0], ["center", 1], ["bottom", 2]]), M = ["ltr", "rtl"];
        /* @__PURE__ */ new Set(["auto", "fixed"]);
        self.ITextInstance = class extends self.IWorldInstance {
          constructor() {
            super(), C.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          get text() {
            return C.get(this).GetText();
          }
          set text(e2) {
            t.RequireString(e2);
            const i3 = C.get(this);
            i3._CancelTypewriter(), i3._SetText(e2);
          }
          typewriterText(e2, i3) {
            t.RequireString(e2), t.RequireFiniteNumber(i3);
            const s3 = C.get(this);
            s3._CancelTypewriter(), s3._StartTypewriter(e2, i3);
          }
          typewriterFinish() {
            C.get(this)._FinishTypewriter();
          }
          set fontFace(e2) {
            t.RequireString(e2), C.get(this)._SetFontFace(e2);
          }
          get fontFace() {
            return C.get(this)._GetFontFace();
          }
          set isBold(e2) {
            C.get(this)._SetBold(e2);
          }
          get isBold() {
            return C.get(this)._IsBold();
          }
          set isItalic(e2) {
            C.get(this)._SetItalic(e2);
          }
          get isItalic() {
            return C.get(this)._IsItalic();
          }
          set sizePt(e2) {
            t.RequireFiniteNumber(e2), C.get(this)._SetFontSize(e2);
          }
          get sizePt() {
            return C.get(this)._GetFontSize();
          }
          set fontColor(e2) {
            if (t.RequireArray(e2), e2.length < 3) throw new Error("expected 3 elements");
            R.setRgb(e2[0], e2[1], e2[2]), C.get(this)._SetFontColor(R);
          }
          get fontColor() {
            const e2 = C.get(this)._GetFontColor();
            return [e2.getR(), e2.getG(), e2.getB()];
          }
          set lineHeight(e2) {
            t.RequireFiniteNumber(e2), C.get(this)._SetLineHeight(e2);
          }
          get lineHeight() {
            return C.get(this)._GetLineHeight();
          }
          set horizontalAlign(e2) {
            t.RequireString(e2);
            const i3 = F.get(e2);
            if (void 0 === i3) throw new Error("invalid mode");
            C.get(this)._SetHAlign(i3);
          }
          get horizontalAlign() {
            return x[C.get(this)._GetHAlign()];
          }
          set verticalAlign(e2) {
            t.RequireString(e2);
            const i3 = A.get(e2);
            if (void 0 === i3) throw new Error("invalid mode");
            C.get(this)._SetVAlign(i3);
          }
          get verticalAlign() {
            return m[C.get(this)._GetVAlign()];
          }
          set wordWrapMode(e2) {
            if (!f2.includes(e2)) throw new Error("invalid mode");
            C.get(this)._SetWrapMode(e2);
          }
          get wordWrapMode() {
            return C.get(this)._GetWrapMode();
          }
          set textDirection(e2) {
            t.RequireString(e2);
            const i3 = M.indexOf(e2);
            if (-1 === i3) throw new Error("invalid text direction");
            C.get(this)._SetTextDirection(i3);
          }
          get textDirection() {
            return M[C.get(this)._GetTextDirection()];
          }
          set readAloud(e2) {
            C.get(this)._SetReadAloud(!!e2);
          }
          get readAloud() {
            return C.get(this)._IsReadAloud();
          }
          setFixedResolutionMode(e2) {
            t.RequireFiniteNumber(e2);
            const i3 = C.get(this);
            i3._SetResolutionMode("fixed"), i3._SetFixedScaleFactor(e2);
          }
          setAutoResolutionMode() {
            C.get(this)._SetResolutionMode("auto");
          }
          get textWidth() {
            return C.get(this)._GetTextWidth();
          }
          get textHeight() {
            return C.get(this)._GetTextHeight();
          }
          getTextSize() {
            const e2 = C.get(this);
            return [e2._GetTextWidth(), e2._GetTextHeight()];
          }
          hasTagAtPosition(e2, i3, s3) {
            return t.RequireString(e2), t.RequireFiniteNumber(i3), t.RequireFiniteNumber(s3), C.get(this)._HasTagAtPosition(e2, i3, s3);
          }
          getTagAtPosition(e2, i3) {
            return t.RequireFiniteNumber(e2), t.RequireFiniteNumber(i3), C.get(this)._GetTagAtPosition(e2, i3);
          }
          getTagPositionAndSize(e2, i3 = 0) {
            return t.RequireString(e2), t.RequireFiniteNumber(i3), C.get(this)._GetTagPosition(e2, i3);
          }
          getTagCount(e2) {
            return t.RequireString(e2), C.get(this)._GetTagCount(e2);
          }
          changeIconSet(e2) {
            const t2 = C.get(this), i3 = t2.GetRuntime()._UnwrapIObjectClass(e2);
            t2._SetIconObjectClass(i3);
          }
          getAsHtmlString() {
            return C.get(this)._UpdateHTMLString();
          }
        };
      }
      {
        const e = self.C3;
        e.Plugins.Text.Cnds = { CompareText(t, i2) {
          return i2 ? this._text === t : e.equalsNoCase(this._text, t);
        }, IsRunningTypewriterText() {
          return -1 !== this._typewriterEndTime;
        }, OnTypewriterTextFinished: () => true, HasTagAtPosition(e2, t, i2) {
          return this._HasTagAtPosition(e2, t, i2);
        } };
      }
      {
        const e = self.C3, t = e.New(e.Color);
        e.Plugins.Text.Acts = { SetText(e2) {
          this._CancelTypewriter(), "number" == typeof e2 && e2 < 1e9 && (e2 = Math.round(1e10 * e2) / 1e10), this._SetText(e2.toString());
        }, AppendText(e2) {
          this._CancelTypewriter(), "number" == typeof e2 && e2 < 1e9 && (e2 = Math.round(1e10 * e2) / 1e10), (e2 = e2.toString()) && this._SetText(this._text + e2);
        }, TypewriterText(e2, t2) {
          this._CancelTypewriter(), "number" == typeof e2 && e2 < 1e9 && (e2 = Math.round(1e10 * e2) / 1e10), this._StartTypewriter(e2.toString(), t2);
        }, SetFontFace(e2, t2) {
          let i2 = false, s2 = false;
          switch (t2) {
            case 1:
              i2 = true;
              break;
            case 2:
              s2 = true;
              break;
            case 3:
              i2 = true, s2 = true;
          }
          e2 === this._faceName && i2 === this._isBold && s2 === this._isItalic || (this._SetFontFace(e2), this._SetBold(i2), this._SetItalic(s2));
        }, SetFontSize(e2) {
          this._SetFontSize(e2);
        }, SetFontColor(e2) {
          t.setFromRgbValue(e2), t.clamp(), this._SetFontColor(t);
        }, SetWebFont(e2, t2) {
          console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect");
        }, SetEffect(e2) {
          this.GetWorldInfo().SetBlendMode(e2), this._runtime.UpdateRender();
        }, TypewriterFinish() {
          this._FinishTypewriter();
        }, SetLineHeight(e2) {
          this._SetLineHeight(e2);
        }, SetHAlign(e2) {
          this._SetHAlign(e2);
        }, SetVAlign(e2) {
          this._SetVAlign(e2);
        }, SetWrapping(e2) {
          this._SetWrapModeByIndex(e2);
        }, SetTextDirection(e2) {
          this._SetTextDirection(e2);
        }, ChangeIconSet(e2) {
          this._SetIconObjectClass(e2);
        }, UpdateHTML() {
          return this._UpdateHTMLString();
        }, SetReadAloud(e2) {
          this._SetReadAloud(e2);
        }, SetResolutionMode(e2, t2) {
          this._SetResolutionMode(["auto", "fixed"][e2]), this._SetFixedScaleFactor(t2);
        } };
      }
      {
        const e = self.C3;
        e.Plugins.Text.Exps = { Text() {
          return this._text;
        }, PlainText() {
          return this._enableBBcode ? e.BBString.StripAnyTags(this._text) : this._text;
        }, FaceName() {
          return this._faceName;
        }, FaceSize() {
          return this._ptSize;
        }, TextWidth() {
          return this._GetTextWidth();
        }, TextHeight() {
          return this._GetTextHeight();
        }, LineHeight() {
          return this._lineHeightOffset;
        }, TagAtPosition(e2, t) {
          return this._GetTagAtPosition(e2, t);
        }, TagCount(e2) {
          return this._GetTagCount(e2);
        }, TagX(e2, t) {
          const i2 = this._GetTagPosition(e2, t);
          return i2 ? i2.x : 0;
        }, TagY(e2, t) {
          const i2 = this._GetTagPosition(e2, t);
          return i2 ? i2.y : 0;
        }, TagWidth(e2, t) {
          const i2 = this._GetTagPosition(e2, t);
          return i2 ? i2.width : 0;
        }, TagHeight(e2, t) {
          const i2 = this._GetTagPosition(e2, t);
          return i2 ? i2.height : 0;
        }, AsHTML() {
          return this._htmlString;
        } };
      }
    }
    {
      {
        const t = self.C3, e = "text-input";
        t.Plugins.TextBox = class extends t.SDKDOMPluginBase {
          constructor(t2) {
            super(t2, e), this.AddElementMessageHandler("click", (t3, e2) => t3._OnClick(e2)), this.AddElementMessageHandler("dblclick", (t3, e2) => t3._OnDoubleClick(e2)), this.AddElementMessageHandler("change", (t3, e2) => t3._OnChange(e2));
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.TextBox.Type = class extends t.SDKTypeBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const t = self.C3, e = self.C3X, s2 = 0, i2 = 1, l2 = 2, n = 3, a2 = 4, h = 5, r2 = 6, _ = 7, o2 = 8, d2 = 9, c2 = 10, p = "text-input", x = ["text", "password", "email", "number", "tel", "url", "textarea", "search"];
        t.Plugins.TextBox.Instance = class extends t.SDKDOMInstanceBase {
          constructor(t2, e2) {
            super(t2, p), this._text = "", this._placeholder = "", this._title = "", this._isEnabled = true, this._isReadOnly = false, this._spellCheck = false, this._type = "text", this._autoFontSize = true, this._maxLength = -1, this._id = "", this._className = "", e2 && (this._text = e2[s2], this._placeholder = e2[i2], this._title = e2[l2], this.GetWorldInfo().SetVisible(e2[n]), this._isEnabled = e2[a2], this._isReadOnly = e2[h], this._spellCheck = e2[r2], this._type = x[e2[_]], this._autoFontSize = e2[o2], this._id = e2[d2], this._className = e2[c2]), this.CreateElement({ "type": this._type, "id": this._id, "className": this._className });
          }
          Release() {
            super.Release();
          }
          GetElementState() {
            return { "text": this._text, "placeholder": this._placeholder, "title": this._title, "isEnabled": this._isEnabled, "isReadOnly": this._isReadOnly, "spellCheck": this._spellCheck, "maxLength": this._maxLength };
          }
          async _OnClick(e2) {
            this.DispatchScriptEvent("click", true), await this.TriggerAsync(t.Plugins.TextBox.Cnds.OnClicked);
          }
          async _OnDoubleClick(e2) {
            this.DispatchScriptEvent("dblclick", true), await this.TriggerAsync(t.Plugins.TextBox.Cnds.OnDoubleClicked);
          }
          async _OnChange(e2) {
            this._text = e2["text"], this.DispatchScriptEvent("change", true), await this.TriggerAsync(t.Plugins.TextBox.Cnds.OnTextChanged);
          }
          _SetText(t2) {
            this._text !== t2 && (this._text = t2, this.UpdateElementState());
          }
          _GetText() {
            return this._text;
          }
          _SetPlaceholder(t2) {
            this._placeholder !== t2 && (this._placeholder = t2, this.UpdateElementState());
          }
          _GetPlaceholder() {
            return this._placeholder;
          }
          _SetTooltip(t2) {
            this._title !== t2 && (this._title = t2, this.UpdateElementState());
          }
          _GetTooltip() {
            return this._title;
          }
          _SetEnabled(t2) {
            t2 = !!t2, this._isEnabled !== t2 && (this._isEnabled = t2, this.UpdateElementState());
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          _SetReadOnly(t2) {
            t2 = !!t2, this._isReadOnly !== t2 && (this._isReadOnly = t2, this.UpdateElementState());
          }
          _IsReadOnly() {
            return this._isReadOnly;
          }
          _SetMaxLength(t2) {
            t2 = Math.max(+t2, -1), this._maxLength !== t2 && (this._maxLength = t2, this.UpdateElementState());
          }
          _GetMaxLength() {
            return this._maxLength;
          }
          _ScrollToBottom() {
            Promise.resolve().then(() => this.PostToDOMElement("scroll-to-bottom"));
          }
          Draw(t2) {
          }
          SaveToJson() {
            return { "t": this._text, "p": this._placeholder, "ti": this._title, "e": this._isEnabled, "r": this._isReadOnly, "sp": this._spellCheck, "ml": this._maxLength, "type": this._type, "id": this._id };
          }
          LoadFromJson(t2) {
            this._text = t2["t"], this._placeholder = t2["p"], this._title = t2["ti"], this._isEnabled = t2["e"], this._isReadOnly = t2["r"], this._spellCheck = t2["sp"], this._maxLength = t2.hasOwnProperty("ml") ? t2["ml"] : -1, this._type = t2["type"], this._id = t2["id"], this.UpdateElementState();
          }
          GetPropertyValueByIndex(t2) {
            switch (t2) {
              case s2:
                return this._text;
              case i2:
                return this._placeholder;
              case l2:
                return this._title;
              case a2:
                return this._isEnabled;
              case h:
                return this._isReadOnly;
              case r2:
                return this._spellCheck;
              case o2:
                return this._autoFontSize;
            }
          }
          SetPropertyValueByIndex(t2, e2) {
            switch (t2) {
              case s2:
                if (this._text === e2) return;
                this._text = e2, this.UpdateElementState();
                break;
              case i2:
                if (this._placeholder === e2) return;
                this._placeholder = e2, this.UpdateElementState();
                break;
              case l2:
                if (this._title === e2) return;
                this._title = e2, this.UpdateElementState();
                break;
              case a2:
                if (this._isEnabled === !!e2) return;
                this._isEnabled = !!e2, this.UpdateElementState();
                break;
              case h:
                if (this._isReadOnly === !!e2) return;
                this._isReadOnly = !!e2, this.UpdateElementState();
                break;
              case r2:
                if (this._spellCheck === !!e2) return;
                this._spellCheck = !!e2, this.UpdateElementState();
                break;
              case o2:
                this._autoFontSize = !!e2;
            }
          }
          GetDebuggerProperties() {
            const e2 = t.Plugins.TextBox.Acts, s3 = "plugins.textbox";
            return [{ title: s3 + ".name", properties: [{ name: s3 + ".properties.text.name", value: this._text, onedit: (t2) => this.CallAction(e2.SetText, t2) }, { name: s3 + ".properties.enabled.name", value: this._isEnabled, onedit: (t2) => this.CallAction(e2.SetEnabled, t2) }, { name: s3 + ".properties.read-only.name", value: this._isReadOnly, onedit: (t2) => this.CallAction(e2.SetReadOnly, t2) }] }];
          }
          GetScriptInterfaceClass() {
            return self.ITextInputInstance;
          }
        };
        const u = /* @__PURE__ */ new WeakMap();
        self.ITextInputInstance = class extends self.IDOMInstance {
          constructor() {
            super(), u.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          set text(t2) {
            e.RequireString(t2), u.get(this)._SetText(t2);
          }
          get text() {
            return u.get(this)._GetText();
          }
          set placeholder(t2) {
            e.RequireString(t2), u.get(this)._SetPlaceholder(t2);
          }
          get placeholder() {
            return u.get(this)._GetPlaceholder();
          }
          set tooltip(t2) {
            e.RequireString(t2), u.get(this)._SetTooltip(t2);
          }
          get tooltip() {
            return u.get(this)._GetTooltip();
          }
          set isEnabled(t2) {
            u.get(this)._SetEnabled(t2);
          }
          get isEnabled() {
            return u.get(this)._IsEnabled();
          }
          set isReadOnly(t2) {
            u.get(this)._SetReadOnly(t2);
          }
          get isReadOnly() {
            return u.get(this)._IsReadOnly();
          }
          set maxLength(t2) {
            e.RequireFiniteNumber(t2), u.get(this)._SetMaxLength(t2);
          }
          get maxLength() {
            return u.get(this)._GetMaxLength();
          }
          scrollToBottom() {
            u.get(this)._ScrollToBottom();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.TextBox.Cnds = { CompareText(e, s2) {
          return 0 === s2 ? t.equalsNoCase(this._text, e) : this._text === e;
        }, OnTextChanged: () => true, OnClicked: () => true, OnDoubleClicked: () => true };
      }
      self.C3.Plugins.TextBox.Acts = { SetText(t) {
        this._SetText(t.toString());
      }, AppendText(t) {
        "" !== t && this._SetText(this._GetText() + t);
      }, SetPlaceholder(t) {
        this._SetPlaceholder(t);
      }, SetTooltip(t) {
        this._SetTooltip(t);
      }, SetReadOnly(t) {
        this._SetReadOnly(0 === t);
      }, ScrollToBottom() {
        this._ScrollToBottom();
      }, SetMaxLength(t) {
        this._SetMaxLength(t);
      } };
      self.C3.Plugins.TextBox.Exps = { Text() {
        return this._GetText();
      }, MaxLength() {
        return this._GetMaxLength();
      } };
    }
    {
      {
        const e = self.C3;
        e.Plugins.TiledBg = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        let WrapModeToStr2 = function(e) {
          switch (e) {
            case 0:
              return "clamp-to-edge";
            case 1:
              return "repeat";
            case 2:
              return "mirror-repeat";
          }
          return "repeat";
        };
        WrapModeToStr = WrapModeToStr2;
        const t = self.C3;
        t.Plugins.TiledBg.Type = class extends t.SDKTypeBase {
          constructor(e, t2) {
            super(e), this._wrapX = "repeat", this._wrapY = "repeat", t2 && (this._wrapX = WrapModeToStr2(t2[0]), this._wrapY = WrapModeToStr2(t2[1]));
          }
          Release() {
            super.Release();
          }
          OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime);
          }
          LoadTextures(e) {
            return this.GetImageInfo().LoadStaticTexture(e, { sampling: this._runtime.GetSampling(), wrapX: this._wrapX, wrapY: this._wrapY });
          }
          ReleaseTextures() {
            this.GetImageInfo().ReleaseTexture();
          }
          GetWrapModeX() {
            return this._wrapX;
          }
          GetWrapModeY() {
            return this._wrapY;
          }
        };
      }
      {
        const i2 = self.C3, a2 = self.C3X, n = 0, s2 = 4, l2 = 5, r2 = 6, g = 7, m = 8, d2 = 9, h = 10, o2 = 11, _ = 12, u = 13, R = 14, f2 = i2.New(i2.Rect), S = i2.New(i2.Quad), I = i2.New(i2.Rect), c2 = i2.New(i2.Quad);
        i2.Plugins.TiledBg.Instance = class extends i2.SDKWorldInstanceBase {
          constructor(e, t) {
            super(e), this._imageOffsetX = 0, this._imageOffsetY = 0, this._imageScaleX = 1, this._imageScaleY = 1, this._imageAngle = 0, this._enableTileRandomization = false, this._tileXRandom = 0, this._tileYRandom = 0, this._tileAngleRandom = 0, this._tileBlendMarginX = 0, this._tileBlendMarginY = 0, this._ownImageInfo = null, t && (this.GetWorldInfo().SetVisible(!!t[n]), this._imageOffsetX = t[s2], this._imageOffsetY = t[l2], this._imageScaleX = t[r2], this._imageScaleY = t[g], this._imageAngle = i2.toRadians(t[m]), this._enableTileRandomization = !!t[d2], this._tileXRandom = t[h], this._tileYRandom = t[o2], this._tileAngleRandom = t[_], this._tileBlendMarginX = t[u], this._tileBlendMarginY = t[R]);
          }
          Release() {
            this._ReleaseOwnImage(), super.Release();
          }
          _ReleaseOwnImage() {
            this._ownImageInfo && (this._ownImageInfo.Release(), this._ownImageInfo = null);
          }
          CalculateTextureCoordsFor3DFace(e, t, i3) {
            const a3 = this.GetCurrentImageInfo(), n2 = a3.GetWidth(), s3 = a3.GetHeight(), l3 = this._imageOffsetX / n2, r3 = this._imageOffsetY / s3, g2 = this._imageAngle;
            I.set(0, 0, e / (n2 * this._imageScaleX), t / (s3 * this._imageScaleY)), I.offset(-l3, -r3), 0 === g2 ? i3.setFromRect(I) : i3.setFromRotatedRect(I, -g2);
          }
          SetTilingShaderProgram(e, t = true) {
            if (this._enableTileRandomization) {
              const t2 = this.GetCurrentImageInfo();
              e.SetTileRandomizationMode(), e.SetTileRandomizationInfo(t2.GetWidth() * this._imageScaleX, t2.GetHeight() * this._imageScaleY, this._tileXRandom, this._tileYRandom, this._tileAngleRandom, this._tileBlendMarginX, this._tileBlendMarginY);
            } else t && e.SetTextureFillMode();
          }
          Draw(e) {
            const t = this.GetCurrentImageInfo(), i3 = t.GetTexture();
            if (null === i3) return;
            this.SetTilingShaderProgram(e), e.SetTexture(i3);
            const a3 = t.GetWidth(), n2 = t.GetHeight();
            let s3 = this._imageOffsetX / a3, l3 = this._imageOffsetY / n2;
            0 !== this._imageAngle || this._enableTileRandomization || ("repeat" === this.GetSdkType().GetWrapModeX() && (s3 %= 1), "repeat" === this.GetSdkType().GetWrapModeY() && (l3 %= 1));
            const r3 = this.GetWorldInfo();
            I.set(0, 0, r3.GetWidth() / (a3 * this._imageScaleX), r3.GetHeight() / (n2 * this._imageScaleY)), I.offset(-s3, -l3), r3.HasMesh() ? this._DrawMesh(r3, e) : this._DrawStandard(r3, e);
          }
          _DrawStandard(e, t) {
            let i3 = e.GetBoundingQuad();
            this._runtime.IsPixelRoundingEnabled() && (i3 = e.PixelRoundQuad(i3)), 0 === this._imageAngle ? t.Quad3(i3, I) : (c2.setFromRotatedRect(I, -this._imageAngle), t.Quad4(i3, c2));
          }
          _DrawMesh(e, t) {
            const i3 = e.GetTransformedMesh();
            if (e.IsMeshChanged()) {
              e.CalculateBbox(f2, S, false);
              let t2 = S;
              this._runtime.IsPixelRoundingEnabled() && (t2 = e.PixelRoundQuad(t2));
              let a3 = I;
              0 !== this._imageAngle && (c2.setFromRotatedRect(I, -this._imageAngle), a3 = c2), i3.CalculateTransformedMesh(e.GetSourceMesh(), t2, a3), e.SetMeshChanged(false);
            }
            i3.Draw(t, e.GetTotalZElevation());
          }
          GetCurrentImageInfo() {
            return this._ownImageInfo || this._objectClass.GetImageInfo();
          }
          IsOriginalSizeKnown() {
            return true;
          }
          GetTexture() {
            return this.GetCurrentImageInfo().GetTexture();
          }
          _SetMeshChanged() {
            this.GetWorldInfo().SetMeshChanged(true);
          }
          _SetImageOffsetX(e) {
            this._imageOffsetX !== e && (this._imageOffsetX = e, this._runtime.UpdateRender(), this._SetMeshChanged());
          }
          _GetImageOffsetX() {
            return this._imageOffsetX;
          }
          _SetImageOffsetY(e) {
            this._imageOffsetY !== e && (this._imageOffsetY = e, this._runtime.UpdateRender(), this._SetMeshChanged());
          }
          _GetImageOffsetY() {
            return this._imageOffsetY;
          }
          _SetImageScaleX(e) {
            this._imageScaleX !== e && (this._imageScaleX = e, this._runtime.UpdateRender(), this._SetMeshChanged());
          }
          _GetImageScaleX() {
            return this._imageScaleX;
          }
          _SetImageScaleY(e) {
            this._imageScaleY !== e && (this._imageScaleY = e, this._runtime.UpdateRender(), this._SetMeshChanged());
          }
          _GetImageScaleY() {
            return this._imageScaleY;
          }
          _SetImageAngle(e) {
            this._imageAngle !== e && (this._imageAngle = e, this._runtime.UpdateRender(), this._SetMeshChanged());
          }
          _GetImageAngle() {
            return this._imageAngle;
          }
          _SetTileRandomizationEnabled(e) {
            e = !!e, this._enableTileRandomization !== e && (this._enableTileRandomization = e, this._runtime.UpdateRender());
          }
          _IsTileRandomizationEnabled() {
            return this._enableTileRandomization;
          }
          _SetTileXRandom(e) {
            this._tileXRandom !== e && (this._tileXRandom = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());
          }
          _GetTileXRandom() {
            return this._tileXRandom;
          }
          _SetTileYRandom(e) {
            this._tileYRandom !== e && (this._tileYRandom = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());
          }
          _GetTileYRandom() {
            return this._tileYRandom;
          }
          _SetTileAngleRandom(e) {
            this._tileAngleRandom !== e && (this._tileAngleRandom = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());
          }
          _GetTileAngleRandom() {
            return this._tileAngleRandom;
          }
          _SetTileBlendMarginX(e) {
            this._tileBlendMarginX !== e && (this._tileBlendMarginX = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());
          }
          _GetTileBlendMarginX() {
            return this._tileBlendMarginX;
          }
          _SetTileBlendMarginY(e) {
            this._tileBlendMarginY !== e && (this._tileBlendMarginY = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());
          }
          _GetTileBlendMarginY() {
            return this._tileBlendMarginY;
          }
          SaveToJson() {
            const e = {};
            return 0 !== this._imageOffsetX && (e["iox"] = this._imageOffsetX), 0 !== this._imageOffsetY && (e["ioy"] = this._imageOffsetY), 1 !== this._imageScaleX && (e["isx"] = this._imageScaleX), 1 !== this._imageScaleY && (e["isy"] = this._imageScaleY), 0 !== this._imageAngle && (e["ia"] = this._imageAngle), this._enableTileRandomization && (e["tr"] = true), 1 !== this._tileXRandom && (e["trx"] = this._tileXRandom), 1 !== this._tileYRandom && (e["try"] = this._tileYRandom), 1 !== this._tileAngleRandom && (e["tra"] = this._tileAngleRandom), 0.1 !== this._tileBlendMarginX && (e["trbmx"] = this._tileBlendMarginX), 0.1 !== this._tileBlendMarginY && (e["trbmy"] = this._tileBlendMarginY), e;
          }
          LoadFromJson(e) {
            this._imageOffsetX = e["iox"] || 0, this._imageOffsetY = e["ioy"] || 0, this._imageScaleX = e.hasOwnProperty("isx") ? e["isx"] : 1, this._imageScaleY = e.hasOwnProperty("isy") ? e["isy"] : 1, this._imageAngle = e["ia"] || 0, this._enableTileRandomization = !!e["tr"], this._tileXRandom = e.hasOwnProperty("trx") ? e["trx"] : 1, this._tileYRandom = e.hasOwnProperty("try") ? e["try"] : 1, this._tileAngleRandom = e.hasOwnProperty("tra") ? e["tra"] : 1, this._tileBlendMarginX = e.hasOwnProperty("trbmx") ? e["trbmx"] : 0.1, this._tileBlendMarginY = e.hasOwnProperty("trbmy") ? e["trbmy"] : 0.1;
          }
          GetDebuggerProperties() {
            const e = "plugins.tiledbg.properties";
            return [{ title: e + ".image-transform.name", properties: [{ name: e + ".image-offset-x.name", value: this._GetImageOffsetX(), onedit: (e2) => this._SetImageOffsetX(e2) }, { name: e + ".image-offset-y.name", value: this._GetImageOffsetY(), onedit: (e2) => this._SetImageOffsetY(e2) }, { name: e + ".image-scale-x.name", value: 100 * this._GetImageScaleX(), onedit: (e2) => this._SetImageScaleX(e2 / 100) }, { name: e + ".image-scale-y.name", value: 100 * this._GetImageScaleY(), onedit: (e2) => this._SetImageScaleY(e2 / 100) }, { name: e + ".image-angle.name", value: i2.toDegrees(this._GetImageAngle()), onedit: (e2) => this._SetImageAngle(i2.toRadians(e2)) }] }, { title: e + ".tile-randomization.name", properties: [{ name: e + ".enable-tile-randomization.name", value: this._IsTileRandomizationEnabled(), onedit: (e2) => this._SetTileRandomizationEnabled(e2) }, { name: e + ".x-random.name", value: 100 * this._GetTileXRandom(), onedit: (e2) => this._SetTileXRandom(e2 / 100) }, { name: e + ".y-random.name", value: 100 * this._GetTileYRandom(), onedit: (e2) => this._SetTileYRandom(e2 / 100) }, { name: e + ".angle-random.name", value: 100 * this._GetTileAngleRandom(), onedit: (e2) => this._SetTileAngleRandom(e2 / 100) }, { name: e + ".blend-margin-x.name", value: 100 * this._GetTileBlendMarginX(), onedit: (e2) => this._SetTileBlendMarginX(e2 / 100) }, { name: e + ".blend-margin-y.name", value: 100 * this._GetTileBlendMarginY(), onedit: (e2) => this._SetTileBlendMarginY(e2 / 100) }] }];
          }
          GetPropertyValueByIndex(e) {
            switch (e) {
              case s2:
                return this._GetImageOffsetX();
              case l2:
                return this._GetImageOffsetY();
              case r2:
                return this._GetImageScaleX();
              case g:
                return this._GetImageScaleY();
              case m:
                return this._GetImageAngle();
              case d2:
                return this._IsTileRandomizationEnabled();
              case h:
                return this._GetTileXRandom();
              case o2:
                return this._GetTileYRandom();
              case _:
                return this._GetTileAngleRandom();
              case u:
                return this._GetTileBlendMarginX();
              case R:
                return this._GetTileBlendMarginY();
            }
          }
          SetPropertyValueByIndex(e, t) {
            switch (e) {
              case s2:
                this._SetImageOffsetX(t);
                break;
              case l2:
                this._SetImageOffsetY(t);
                break;
              case r2:
                this._SetImageScaleX(t);
                break;
              case g:
                this._SetImageScaleY(t);
                break;
              case m:
                this._SetImageAngle(t);
                break;
              case d2:
                this._SetTileRandomizationEnabled(!!t);
                break;
              case h:
                this._SetTileXRandom(t);
                break;
              case o2:
                this._SetTileYRandom(t);
                break;
              case _:
                this._SetTileAngleRandom(t);
                break;
              case u:
                this._SetTileBlendMarginX(t);
                break;
              case R:
                this._SetTileBlendMarginY(t);
            }
          }
          GetScriptInterfaceClass() {
            return self.ITiledBackgroundInstance;
          }
        };
        const T = /* @__PURE__ */ new WeakMap();
        self.ITiledBackgroundInstance = class extends self.IWorldInstance {
          constructor() {
            super(), T.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          set imageOffsetX(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetImageOffsetX(e);
          }
          get imageOffsetX() {
            return T.get(this)._GetImageOffsetX();
          }
          set imageOffsetY(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetImageOffsetY(e);
          }
          get imageOffsetY() {
            return T.get(this)._GetImageOffsetY();
          }
          setImageOffset(e, t) {
            a2.RequireFiniteNumber(e), a2.RequireFiniteNumber(t);
            const i3 = T.get(this);
            i3._SetImageOffsetX(e), i3._SetImageOffsetY(t);
          }
          getImageOffset() {
            const e = T.get(this);
            return [e._GetImageOffsetX(), e._GetImageOffsetY()];
          }
          set imageScaleX(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetImageScaleX(e);
          }
          get imageScaleX() {
            return T.get(this)._GetImageScaleX();
          }
          set imageScaleY(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetImageScaleY(e);
          }
          get imageScaleY() {
            return T.get(this)._GetImageScaleY();
          }
          setImageScale(e, t) {
            a2.RequireFiniteNumber(e), a2.RequireFiniteNumber(t);
            const i3 = T.get(this);
            i3._SetImageScaleX(e), i3._SetImageScaleY(t);
          }
          getImageScale() {
            const e = T.get(this);
            return [e._GetImageScaleX(), e._GetImageScaleY()];
          }
          set imageAngle(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetImageAngle(e);
          }
          get imageAngle() {
            return T.get(this)._GetImageAngle();
          }
          set imageAngleDegrees(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetImageAngle(i2.toRadians(e));
          }
          get imageAngleDegrees() {
            return i2.toDegrees(T.get(this)._GetImageAngle());
          }
          get imageWidth() {
            return T.get(this).GetCurrentImageInfo().GetWidth();
          }
          get imageHeight() {
            return T.get(this).GetCurrentImageInfo().GetHeight();
          }
          getImageSize() {
            const e = T.get(this).GetCurrentImageInfo();
            return [e.GetWidth(), e.GetHeight()];
          }
          set enableTileRandomization(e) {
            T.get(this)._SetTileRandomizationEnabled(!!e);
          }
          get enableTileRandomization() {
            return T.get(this)._IsTileRandomizationEnabled();
          }
          set tileXRandom(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetTileXRandom(e);
          }
          get tileXRandom() {
            return T.get(this)._GetTileXRandom();
          }
          set tileYRandom(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetTileYRandom(e);
          }
          get tileYRandom() {
            return T.get(this)._GetTileYRandom();
          }
          setTileRandom(e, t) {
            a2.RequireFiniteNumber(e), a2.RequireFiniteNumber(t);
            const i3 = T.get(this);
            i3._SetTileXRandom(e), i3._SetTileYRandom(t);
          }
          getTileRandom() {
            const e = T.get(this);
            return [e._GetTileXRandom(), e._GetTileYRandom()];
          }
          set tileAngleRandom(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetTileAngleRandom(e);
          }
          get tileAngleRandom() {
            return T.get(this)._GetTileAngleRandom();
          }
          set tileBlendMarginX(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetTileBlendMarginX(e);
          }
          get tileBlendMarginX() {
            return T.get(this)._GetTileBlendMarginX();
          }
          set tileBlendMarginY(e) {
            a2.RequireFiniteNumber(e), T.get(this)._SetTileBlendMarginY(e);
          }
          get tileBlendMarginY() {
            return T.get(this)._GetTileBlendMarginY();
          }
          setTileBlendMargin(e, t) {
            a2.RequireFiniteNumber(e), a2.RequireFiniteNumber(t);
            const i3 = T.get(this);
            i3._SetTileBlendMarginX(e), i3._SetTileBlendMarginY(t);
          }
          getTileBlendMargin() {
            const e = T.get(this);
            return [e._GetTileBlendMarginX(), e._GetTileBlendMarginY()];
          }
          async replaceImage(e) {
            a2.RequireInstanceOf(e, Blob);
            const t = T.get(this), n2 = t.GetRuntime(), s3 = i2.New(i2.ImageInfo);
            s3.LoadDynamicBlobAsset(n2, e), await s3.LoadStaticTexture(n2.GetRenderer(), { sampling: n2.GetSampling(), wrapX: t.GetSdkType().GetWrapModeX(), wrapY: t.GetSdkType().GetWrapModeY() }), t.WasReleased() ? s3.Release() : (t._ReleaseOwnImage(), t._ownImageInfo = s3, n2.UpdateRender());
          }
        };
      }
      self.C3.Plugins.TiledBg.Cnds = { OnURLLoaded: () => true, OnURLFailed: () => true, IsTileRandomizationEnabled() {
        return this._IsTileRandomizationEnabled();
      } };
      {
        const G = self.C3;
        G.Plugins.TiledBg.Acts = { SetImageOffsetX(e) {
          this._SetImageOffsetX(e);
        }, SetImageOffsetY(e) {
          this._SetImageOffsetY(e);
        }, SetImageScaleX(e) {
          this._SetImageScaleX(e / 100);
        }, SetImageScaleY(e) {
          this._SetImageScaleY(e / 100);
        }, SetImageAngle(e) {
          this._SetImageAngle(G.toRadians(e));
        }, SetTileRandomizationEnabled(e) {
          this._SetTileRandomizationEnabled(e);
        }, SetTilePosRandom(e, t) {
          this._SetTileXRandom(e / 100), this._SetTileYRandom(t / 100);
        }, SetTileAngleRandom(e) {
          this._SetTileAngleRandom(e / 100);
        }, SetTileBlendMargin(e, t) {
          this._SetTileBlendMarginX(e / 100), this._SetTileBlendMarginY(t / 100);
        }, SetEffect(e) {
          this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender();
        }, async LoadURL(e, t) {
          if (this._ownImageInfo && this._ownImageInfo.GetURL() === e) return;
          const i2 = this._runtime, a2 = G.New(G.ImageInfo);
          try {
            if (await a2.LoadDynamicAsset(i2, e, true), !a2.IsLoaded()) throw new Error("image failed to load");
            if (this.WasReleased()) return a2.Release(), null;
            if (!await a2.LoadStaticTexture(i2.GetRenderer(), { sampling: i2.GetSampling(), wrapX: this.GetSdkType().GetWrapModeX(), wrapY: this.GetSdkType().GetWrapModeY() })) return;
          } catch (e2) {
            return console.error("Load image from URL failed: ", e2), void (this.WasReleased() || this.Trigger(G.Plugins.TiledBg.Cnds.OnURLFailed));
          }
          this.WasReleased() ? a2.Release() : (this._ReleaseOwnImage(), this._ownImageInfo = a2, i2.UpdateRender(), await this.TriggerAsync(G.Plugins.TiledBg.Cnds.OnURLLoaded));
        } };
      }
      {
        const X = self.C3;
        X.Plugins.TiledBg.Exps = { ImageWidth() {
          return this.GetCurrentImageInfo().GetWidth();
        }, ImageHeight() {
          return this.GetCurrentImageInfo().GetHeight();
        }, ImageOffsetX() {
          return this._imageOffsetX;
        }, ImageOffsetY() {
          return this._imageOffsetY;
        }, ImageScaleX() {
          return 100 * this._imageScaleX;
        }, ImageScaleY() {
          return 100 * this._imageScaleY;
        }, ImageAngle() {
          return X.toDegrees(this._imageAngle);
        }, TileXRandom() {
          return 100 * this._GetTileXRandom();
        }, TileYRandom() {
          return 100 * this._GetTileYRandom();
        }, TileAngleRandom() {
          return 100 * this._GetTileAngleRandom();
        }, TileBlendMarginX() {
          return 100 * this._GetTileBlendMarginX();
        }, TileBlendMarginY() {
          return 100 * this._GetTileBlendMarginY();
        } };
      }
    }
    var WrapModeToStr;
    {
      {
        const e = self.C3;
        e.Plugins.Particles = class extends e.SDKPluginBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.Particles.Type = class extends t.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime);
          }
          LoadTextures(e) {
            return this.GetImageInfo().LoadStaticTexture(e, { sampling: this._runtime.GetSampling() });
          }
          ReleaseTextures() {
            this.GetImageInfo().ReleaseTexture();
          }
        };
      }
      {
        let GetParticleEngine2 = function(e) {
          return w.get(e).GetParticleEngine();
        };
        GetParticleEngine = GetParticleEngine2;
        const i2 = self.C3, n = self.C3X, a2 = 0, r2 = 1, s2 = 2, o2 = 3, c2 = 4, l2 = 5, S = 6, d2 = 7, p = 8, G = 9, m = 10, u = 11, h = 12, g = 13, R = 14, I = 15, y = 16, _ = 17, E = 18, P = 19, f2 = 20, b = 0, C = 1, O = i2.New(i2.Rect);
        i2.Plugins.Particles.Instance = class extends i2.SDKWorldInstanceBase {
          constructor(e, t) {
            super(e), this._isFirstTick = true;
            const n2 = i2.New(self.ParticleEngine);
            this._particleEngine = n2, n2.ononeshotfinish = () => this._OnOneShotFinish(), this._spawnObjectClass = null, this._particleUpdateCallback = (e2, t2, i3, n3, a3, r3) => this._OnParticleUpdate(e2, t2, i3, n3, a3, r3), this._particleDestroyCallback = (e2) => this._OnParticleDestroy(e2), this._hasAnyDefaultParticle = true;
            let b2 = true;
            t && (n2.SetRate(t[a2]), n2.SetSprayCone(i2.toRadians(t[r2])), n2.SetSprayType(t[s2] ? "one-shot" : "continuous-spray"), this._SetParticleObjectClass(this._runtime.GetObjectClassBySID(t[o2])), b2 = t[c2], n2.SetInitSpeed(t[l2]), n2.SetInitSize(t[S]), n2.SetInitOpacity(t[d2] / 100), n2.SetGrowRate(t[p]), n2.SetInitXRandom(t[G]), n2.SetInitYRandom(t[m]), n2.SetInitSpeedRandom(t[u]), n2.SetInitSizeRandom(t[h]), n2.SetGrowRandom(t[g]), n2.SetAcceleration(t[R]), n2.SetGravity(t[I]), n2.SetLifeAngleRandom(t[y]), n2.SetLifeSpeedRandom(t[_]), n2.SetLifeOpacityRandom(t[E]), n2.SetDestroyModeIndex(t[P]), n2.SetTimeout(t[f2])), this._UpdateEngineParameters(), this._spawnObjectClass && (this._hasAnyDefaultParticle = false), "one-shot" === n2.GetSprayType() ? n2.CreateOneShotSpray() : n2.SetSpraying(true);
            const C2 = this.GetWorldInfo();
            C2.SetVisible(b2), C2.SetBboxChangeEventEnabled(true), this._inst.Dispatcher().addEventListener("bboxchange", () => {
              C2.OverwriteBoundingBox(this._particleEngine.GetBoundingBox());
            }), this.GetRuntime().GetRenderer().IsWebGPU() && C2.SetUsePointsShaderProgram(), this._afterLoad = (e2) => this._OnAfterLoad(e2), this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad), this._StartTicking();
          }
          Release() {
            this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad), this._afterLoad = null, this._particleEngine.Release(), this._particleEngine = null, this._particleUpdateCallback = null, this._particleDestroyCallback = null, super.Release();
          }
          GetParticleEngine() {
            return this._particleEngine;
          }
          _SetRate(e) {
            this._particleEngine.SetRate(e), "one-shot" === this._particleEngine.GetSprayType() && this._isFirstTick && this._particleEngine.SetParticleCount(e);
          }
          _SetParticleObjectClass(e) {
            e === this.GetObjectClass() && (e = null), e !== this._spawnObjectClass && (this._spawnObjectClass = e, this._particleEngine.onparticlecreate = e ? (e2) => this._OnParticleCreate(e2) : null, this._spawnObjectClass || (this._hasAnyDefaultParticle = true));
          }
          _UpdateEngineParameters() {
            const e = this._particleEngine, t = this.GetWorldInfo();
            e.SetMasterOpacity(t.GetOpacity()), e.SetPixelRounding(this._runtime.IsPixelRoundingEnabled()), e.SetSpawnX(t.GetX()), e.SetSpawnY(t.GetY()), e.SetSpawnAngle(t.GetAngle()), e.SetInitSizeScale(Math.abs(t.GetSceneGraphScale()));
          }
          _OnOneShotFinish() {
            this._runtime.DestroyInstance(this._inst);
          }
          Draw(e) {
            if (!this._hasAnyDefaultParticle) return;
            const t = this._objectClass.GetImageInfo(), i3 = t.GetTexture();
            if (!i3) return;
            const n2 = this.GetWorldInfo(), a3 = n2.GetLayer(), r3 = O;
            this._runtime.GetCanvasManager().IsPastingToDrawingCanvas() ? r3.set(-1 / 0, -1 / 0, 1 / 0, 1 / 0) : a3.Has3DCamera() ? a3.CalculateViewport3D(n2.GetTotalZElevation(), r3) : a3.GetViewportForZ(n2.GetTotalZElevation(), r3), e.SetTexture(i3);
            const s3 = a3.Get2DScaleFactorToZ(n2.GetTotalZElevation());
            this._particleEngine.SetParticleScale(a3.GetRenderScale() * s3), this._particleEngine.Draw(e, t.GetTexQuad(), r3, a3.Has3DCamera());
          }
          SaveToJson() {
            const e = this._particleEngine;
            return { "r": e.GetRate(), "sc": e.GetSprayCone(), "st": e.GetSprayType(), "isp": e.GetInitSpeed(), "isz": e.GetInitSize(), "io": e.GetInitOpacity(), "gr": e.GetGrowRate(), "xr": e.GetInitXRandom(), "yr": e.GetInitYRandom(), "spr": e.GetInitSpeedRandom(), "szr": e.GetInitSizeRandom(), "grnd": e.GetGrowRandom(), "acc": e.GetAcceleration(), "g": e.GetGravity(), "lar": e.GetLifeAngleRandom(), "lsr": e.GetLifeSpeedRandom(), "lor": e.GetLifeOpacityRandom(), "dm": e.GetDestroyModeIndex(), "to": e.GetTimeout(), "s": e.IsSpraying(), "pcc": e._GetCreateCounter(), "ft": this._isFirstTick, "soc": this._spawnObjectClass ? this._spawnObjectClass.GetSID() : null, "p": e.GetParticles().map((e2) => e2.toJSON()) };
          }
          LoadFromJson(e, t) {
            const i3 = this._particleEngine;
            if (i3.SetRate(e["r"]), i3.SetSprayCone(e["sc"]), i3.SetSprayType(e["st"]), i3.SetInitSpeed(e["isp"]), i3.SetInitSize(e["isz"]), i3.SetInitOpacity(e["io"]), i3.SetGrowRate(e["gr"]), i3.SetInitXRandom(e["xr"]), i3.SetInitYRandom(e["yr"]), i3.SetInitSpeedRandom(e["spr"]), i3.SetInitSizeRandom(e["szr"]), i3.SetGrowRandom(e["grnd"]), i3.SetAcceleration(e["acc"]), i3.SetGravity(e["g"]), i3.SetLifeAngleRandom(e["lar"]), i3.SetLifeSpeedRandom(e["lsr"]), i3.SetLifeOpacityRandom(e["lor"]), i3.SetDestroyModeIndex(e["dm"]), i3.SetTimeout(e["to"]), i3.SetSpraying(e["s"]), i3._SetCreateCounter(e["pcc"]), this._isFirstTick = e["ft"], e.hasOwnProperty("soc")) {
              const t2 = this.GetRuntime().GetObjectClassBySID(e["soc"]);
              t2 && this._SetParticleObjectClass(t2);
            }
            const n2 = e["p"];
            i3.SetParticleCount(n2.length, false);
            const a3 = i3.GetParticles();
            for (let e2 = 0, t2 = a3.length; e2 < t2; ++e2) a3[e2].setFromJSON(n2[e2]);
            "state" === t && this._spawnObjectClass && (i3.UpdateAllParticlesUserData(), i3.ApplyParticleDataToUserData(this));
          }
          _OnAfterLoad() {
            const e = this._particleEngine;
            e.UpdateAllParticlesUserData(), e.ApplyParticleDataToUserData(this);
            const t = e.GetParticles();
            for (let e2 = 0, i3 = t.length; e2 < i3; ++e2) {
              const i4 = t[e2], n2 = i4.GetUserData();
              if (!n2) continue;
              const a3 = n2.GetWorldInfo();
              if (!a3) continue;
              const r3 = a3.GetInstance();
              if (!r3) continue;
              const s3 = i4.GetUserDataUID(), o3 = r3.GetUID();
              if (("number" != typeof s3 || "number" != typeof o3 || s3 !== o3) && "number" == typeof s3) {
                const e3 = this.GetRuntime(), t2 = e3.GetInstanceByUID(s3);
                t2 && e3.DestroyInstance(t2);
              }
            }
          }
          Tick() {
            const e = this._runtime.GetDt(this._inst);
            this._UpdateEngineParameters(), this._isFirstTick && "one-shot" === this._particleEngine.GetSprayType() && this._particleEngine.ReInitAllParticles(), this._particleEngine.Tick(e), this._particleEngine.IsSpraying() && this._runtime.UpdateRender(), this.GetWorldInfo().SetBboxChanged(), this._isFirstTick = false;
          }
          _FastForward(e) {
            const t = 1 / 60;
            for (this._isFirstTick && "one-shot" === this._particleEngine.GetSprayType() && this._particleEngine.ReInitAllParticles(); e > 0; ) this._particleEngine.Tick(t), e -= t;
            this._particleEngine.IsSpraying() && this._runtime.UpdateRender(), this.GetWorldInfo().SetBboxChanged(), this._isFirstTick = false;
          }
          _OnParticleCreate(e, t) {
            let i3;
            "number" == typeof t && (i3 = this._runtime.GetInstanceByUID(t)), i3 && i3.GetObjectClass() !== this._spawnObjectClass && (i3 = null), i3 || (i3 = this._runtime.CreateInstance(this._spawnObjectClass, this.GetWorldInfo().GetLayer(), e.GetX(), e.GetY()));
            const n2 = i3.GetWorldInfo();
            return n2.SetSize(e.GetSize(), e.GetSize()), n2.SetAngle(e.GetAngle()), n2.SetOpacity(e.GetOpacity()), n2.SetUnpremultipliedColor(this.GetWorldInfo().GetUnpremultipliedColor()), n2.SetBboxChanged(), n2.ZOrderMoveAdjacentToInstance(this.GetInstance(), true), i3._TriggerOnCreated(), e.SetUpdateCallback(this._particleUpdateCallback), e.SetDestroyCallback(this._particleDestroyCallback), i3;
          }
          _OnParticleUpdate(e, t, i3, n2, a3, r3) {
            if (e.IsDestroyed()) return;
            const s3 = e.GetWorldInfo();
            s3.OffsetXY(t, i3), s3.SetSize(s3.GetWidth() + n2, s3.GetHeight() + n2), s3.SetAngle(s3.GetAngle() + a3), s3.SetOpacity(s3.GetOpacity() + r3), s3.SetBboxChanged();
          }
          _OnParticleDestroy(e) {
            e.IsDestroyed() || this._runtime.DestroyInstance(e);
          }
          GetPropertyValueByIndex(e) {
            const t = this._particleEngine;
            switch (e) {
              case a2:
                return t.GetRate();
              case r2:
                return i2.toDegrees(t.GetSprayCone());
              case s2:
                return "one-shot" === t.GetSprayType() ? C : b;
              case l2:
                return t.GetInitSpeed();
              case S:
                return t.GetInitSize();
              case d2:
                return 100 * t.GetInitOpacity();
              case p:
                return t.GetGrowRate();
              case G:
                return t.GetInitXRandom();
              case m:
                return t.GetInitYRandom();
              case u:
                return t.GetInitSpeedRandom();
              case h:
                return t.GetInitSizeRandom();
              case g:
                return t.GetGrowRandom();
              case R:
                return t.GetAcceleration();
              case I:
                return t.GetGravity();
              case y:
                return t.GetLifeAngleRandom();
              case _:
                return t.GetLifeSpeedRandom();
              case E:
                return t.GetLifeOpacityRandom();
              case P:
                return t.GetDestroyModeIndex();
              case f2:
                return t.GetTimeout();
            }
          }
          SetPropertyValueByIndex(e, t) {
            const n2 = this._particleEngine;
            switch (e) {
              case a2:
                n2.SetRate(t);
                break;
              case r2:
                n2.SetSprayCone(i2.toRadians(t));
                break;
              case s2:
                n2.SetSprayType(t ? "one-shot" : "continuous-spray");
                break;
              case l2:
                n2.SetInitSpeed(t);
                break;
              case S:
                n2.SetInitSize(t);
                break;
              case d2:
                n2.SetInitOpacity(t / 100);
                break;
              case p:
                n2.SetGrowRate(t);
                break;
              case G:
                n2.SetInitXRandom(t);
                break;
              case m:
                n2.SetInitYRandom(t);
                break;
              case u:
                n2.SetInitSpeedRandom(t);
                break;
              case h:
                n2.SetInitSizeRandom(t);
                break;
              case g:
                n2.SetGrowRandom(t);
                break;
              case R:
                n2.SetAcceleration(t);
                break;
              case I:
                n2.SetGravity(t);
                break;
              case y:
                n2.SetLifeAngleRandom(t);
                break;
              case _:
                n2.SetLifeSpeedRandom(t);
                break;
              case E:
                n2.SetLifeOpacityRandom(t);
                break;
              case P:
                n2.SetDestroyModeIndex(t);
                break;
              case f2:
                n2.SetTimeout(t);
            }
          }
          GetDebuggerProperties() {
            const e = "plugins.particles", t = e + ".properties", n2 = e + ".debugger", a3 = this._particleEngine;
            return [{ title: e + ".name", properties: [{ name: n2 + ".particle-count", value: a3.GetParticleCount() }, { name: t + ".type.name", value: [t + ".type.items." + a3.GetSprayType()] }, { name: n2 + ".is-spraying", value: a3.IsSpraying(), onedit: (e2) => a3.SetSpraying(e2) }, { name: t + ".rate.name", value: a3.GetRate(), onedit: (e2) => a3.SetRate(e2) }, { name: t + ".spray-cone.name", value: i2.toDegrees(a3.GetSprayCone()), onedit: (e2) => a3.SetSprayCone(i2.toRadians(e2)) }, { name: t + ".speed.name", value: a3.GetInitSpeed(), onedit: (e2) => a3.SetInitSpeed(e2) }, { name: t + ".size.name", value: a3.GetInitSize(), onedit: (e2) => a3.SetInitSize(e2) }, { name: t + ".opacity.name", value: a3.GetInitOpacity(), onedit: (e2) => a3.SetInitOpacity(e2) }, { name: t + ".grow-rate.name", value: a3.GetGrowRate(), onedit: (e2) => a3.SetGrowRate(e2) }, { name: t + ".x-randomiser.name", value: a3.GetInitXRandom(), onedit: (e2) => a3.SetInitXRandom(e2) }, { name: t + ".y-randomiser.name", value: a3.GetInitYRandom(), onedit: (e2) => a3.SetInitYRandom(e2) }, { name: t + ".initial-speed-randomiser.name", value: a3.GetInitSpeedRandom(), onedit: (e2) => a3.SetInitSpeedRandom(e2) }, { name: t + ".size-randomiser.name", value: a3.GetInitSizeRandom(), onedit: (e2) => a3.SetInitSizeRandom(e2) }, { name: t + ".grow-rate-randomiser.name", value: a3.GetGrowRandom(), onedit: (e2) => a3.SetGrowRandom(e2) }, { name: t + ".acceleration.name", value: a3.GetAcceleration(), onedit: (e2) => a3.SetAcceleration(e2) }, { name: t + ".gravity.name", value: a3.GetGravity(), onedit: (e2) => a3.SetGravity(e2) }, { name: t + ".angle-randomiser.name", value: a3.GetLifeAngleRandom(), onedit: (e2) => a3.SetLifeAngleRandom(e2) }, { name: t + ".life-speed-randomiser.name", value: a3.GetLifeSpeedRandom(), onedit: (e2) => a3.SetLifeSpeedRandom(e2) }, { name: t + ".opacity-randomiser.name", value: a3.GetLifeOpacityRandom(), onedit: (e2) => a3.SetLifeOpacityRandom(e2) }, { name: t + ".timeout.name", value: a3.GetTimeout(), onedit: (e2) => a3.SetTimeout(e2) }] }];
          }
          GetScriptInterfaceClass() {
            return self.IParticlesInstance;
          }
        };
        const w = /* @__PURE__ */ new WeakMap();
        self.IParticlesInstance = class extends self.IWorldInstance {
          constructor() {
            super(), w.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          set isSpraying(e) {
            GetParticleEngine2(this).SetSpraying(!!e);
          }
          get isSpraying() {
            return GetParticleEngine2(this).IsSpraying();
          }
          set rate(e) {
            n.RequireFiniteNumber(e), w.get(this)._SetRate(e);
          }
          get rate() {
            return GetParticleEngine2(this).GetRate();
          }
          set sprayCone(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetSprayCone(e);
          }
          get sprayCone() {
            return GetParticleEngine2(this).GetSprayCone();
          }
          set initSpeed(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetInitSpeed(e);
          }
          get initSpeed() {
            return GetParticleEngine2(this).GetInitSpeed();
          }
          set initSize(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetInitSize(e);
          }
          get initSize() {
            return GetParticleEngine2(this).GetInitSize();
          }
          set initOpacity(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetInitOpacity(e);
          }
          get initOpacity() {
            return GetParticleEngine2(this).GetInitOpacity();
          }
          set initXRandom(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetInitXRandom(e);
          }
          get initXRandom() {
            return GetParticleEngine2(this).GetInitXRandom();
          }
          set initYRandom(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetInitYRandom(e);
          }
          get initYRandom() {
            return GetParticleEngine2(this).GetInitYRandom();
          }
          set initSpeedRandom(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetInitSpeedRandom(e);
          }
          get initSpeedRandom() {
            return GetParticleEngine2(this).GetInitSpeedRandom();
          }
          set initSizeRandom(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetInitSizeRandom(e);
          }
          get initSizeRandom() {
            return GetParticleEngine2(this).GetInitSizeRandom();
          }
          set initGrowRate(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetGrowRate(e);
          }
          get initGrowRate() {
            return GetParticleEngine2(this).GetGrowRate();
          }
          set initGrowRandom(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetGrowRandom(e);
          }
          get initGrowRandom() {
            return GetParticleEngine2(this).GetGrowRandom();
          }
          set acceleration(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetAcceleration(e);
          }
          get acceleration() {
            return GetParticleEngine2(this).GetAcceleration();
          }
          set gravity(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetGravity(e);
          }
          get gravity() {
            return GetParticleEngine2(this).GetGravity();
          }
          set lifeAngleRandom(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetLifeAngleRandom(e);
          }
          get lifeAngleRandom() {
            return GetParticleEngine2(this).GetLifeAngleRandom();
          }
          set lifeSpeedRandom(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetLifeSpeedRandom(e);
          }
          get lifeSpeedRandom() {
            return GetParticleEngine2(this).GetLifeSpeedRandom();
          }
          set lifeOpacityRandom(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetLifeOpacityRandom(e);
          }
          get lifeOpacityRandom() {
            return GetParticleEngine2(this).GetLifeOpacityRandom();
          }
          set timeout(e) {
            n.RequireFiniteNumber(e), GetParticleEngine2(this).SetTimeout(e);
          }
          get timeout() {
            return GetParticleEngine2(this).GetTimeout();
          }
          fastForward(e) {
            n.RequireFiniteNumber(e), w.get(this)._FastForward(e);
          }
          setParticleObjectClass(e) {
            const t = w.get(this);
            e ? t._SetParticleObjectClass(t.GetRuntime()._UnwrapIObjectClass(e)) : t._SetParticleObjectClass(null);
          }
        };
      }
      self.C3.Plugins.Particles.Cnds = { IsSpraying() {
        return this._particleEngine.IsSpraying();
      } };
      {
        const T = self.C3;
        T.Plugins.Particles.Acts = { SetSpraying(e) {
          this._particleEngine.SetSpraying(0 !== e);
        }, SetRate(e) {
          this._SetRate(e);
        }, SetParticleObject(e) {
          this._SetParticleObjectClass(e);
        }, UnsetParticleObject() {
          this._SetParticleObjectClass(null);
        }, SetSprayCone(e) {
          this._particleEngine.SetSprayCone(T.toRadians(e));
        }, SetInitSpeed(e) {
          this._particleEngine.SetInitSpeed(e);
        }, SetInitSize(e) {
          this._particleEngine.SetInitSize(e);
        }, SetInitOpacity(e) {
          this._particleEngine.SetInitOpacity(e / 100);
        }, SetGrowRate(e) {
          this._particleEngine.SetGrowRate(e);
        }, SetXRandomiser(e) {
          this._particleEngine.SetInitXRandom(e);
        }, SetYRandomiser(e) {
          this._particleEngine.SetInitYRandom(e);
        }, SetSpeedRandomiser(e) {
          this._particleEngine.SetInitSpeedRandom(e);
        }, SetSizeRandomiser(e) {
          this._particleEngine.SetInitSizeRandom(e);
        }, SetGrowRateRandomiser(e) {
          this._particleEngine.SetGrowRandom(e);
        }, SetParticleAcc(e) {
          this._particleEngine.SetAcceleration(e);
        }, SetGravity(e) {
          this._particleEngine.SetGravity(e);
        }, SetAngleRandomiser(e) {
          this._particleEngine.SetLifeAngleRandom(e);
        }, SetLifeSpeedRandomiser(e) {
          this._particleEngine.SetLifeSpeedRandom(e);
        }, SetOpacityRandomiser(e) {
          this._particleEngine.SetLifeOpacityRandom(e);
        }, SetTimeout(e) {
          this._particleEngine.SetTimeout(e);
        }, FastForward(e) {
          this._FastForward(e);
        }, SetEffect(e) {
          this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender();
        } };
      }
      {
        const D = self.C3;
        D.Plugins.Particles.Exps = { ParticleCount() {
          return this._particleEngine.GetParticleCount();
        }, Rate() {
          return this._particleEngine.GetRate();
        }, SprayCone() {
          return D.toDegrees(this._particleEngine.GetSprayCone());
        }, InitSpeed() {
          return this._particleEngine.GetInitSpeed();
        }, InitSize() {
          return this._particleEngine.GetInitSize();
        }, InitOpacity() {
          return 100 * this._particleEngine.GetInitOpacity();
        }, InitGrowRate() {
          return this._particleEngine.GetGrowRate();
        }, XRandom() {
          return this._particleEngine.GetInitXRandom();
        }, YRandom() {
          return this._particleEngine.GetInitYRandom();
        }, InitSizeRandom() {
          return this._particleEngine.GetInitSizeRandom();
        }, InitSpeedRandom() {
          return this._particleEngine.GetInitSpeedRandom();
        }, InitGrowRandom() {
          return this._particleEngine.GetGrowRandom();
        }, ParticleAcceleration() {
          return this._particleEngine.GetAcceleration();
        }, Gravity() {
          return this._particleEngine.GetGravity();
        }, ParticleAngleRandom() {
          return this._particleEngine.GetLifeAngleRandom();
        }, ParticleSpeedRandom() {
          return this._particleEngine.GetLifeSpeedRandom();
        }, ParticleOpacityRandom() {
          return this._particleEngine.GetLifeOpacityRandom();
        }, Timeout() {
          return this._particleEngine.GetTimeout();
        } };
      }
    }
    var GetParticleEngine;
    {
      const C33 = self.C3, inactiveParticles = [], MAX_RECYCLE_PARTICLES = 1e3, VALID_SPRAY_TYPES = /* @__PURE__ */ new Set(["continuous-spray", "one-shot"]), DESTROY_MODES = ["fade-to-invisible", "timeout-expired", "particle-stopped"], tempRect = C33.New(C33.Rect);
      self.ParticleEngine = class {
        constructor() {
          this._rate = 0, this._sprayCone = 0, this._sprayType = "continuous-spray", this._isSpraying = false, this._masterOpacity = 0, this._isPixelRounding = false, this._spawnX = 0, this._spawnY = 0, this._spawnAngle = 0, this._initSpeed = 0, this._initSize = 0, this._initSizeScale = 1, this._initOpacity = 0, this._growRate = 0, this._xRandom = 0, this._yRandom = 0, this._initSpeedRandom = 0, this._initSizeRandom = 0, this._growRandom = 0, this._acceleration = 0, this._gravity = 0, this._lifeAngleRandom = 0, this._lifeSpeedRandom = 0, this._lifeOpacityRandom = 0, this._destroyMode = 0, this._timeout = 0, this._createCounter = 0, this._particleScale = 1, this.ononeshotfinish = null, this.onparticlecreate = null, this._particles = [], this._boundingBox = new C33.Rect(), this._color = new C33.Color(), this._devicePixelRatio = globalThis.devicePixelRatio || 1;
        }
        Release() {
          this.Cancel(), C33.clearArray(this._particles), this._particles = null, this.ononeshotfinish = null, this.onparticlecreate = null, this._boundingBox = null, this._color = null;
        }
        Cancel() {
          const t = this._particles;
          for (let e = 0, i2 = t.length; e < i2; ++e) t[e].Destroy();
          C33.appendArray(inactiveParticles, t), C33.clearArray(t), inactiveParticles.length > 1e3 && C33.truncateArray(inactiveParticles, 1e3), this._isSpraying = false;
        }
        CreateOneShotSpray() {
          for (let t = 0, e = this._rate; t < e; ++t) this._CreateParticle();
          this._particles.length && (this._isSpraying = true);
        }
        _CreateParticle(t = true) {
          let e = null;
          return inactiveParticles.length ? (e = inactiveParticles.pop(), e.SetEngine(this)) : e = C33.New(self.Particle, this), this._particles.push(e), t ? e.Init(this.onparticlecreate) : e.Init(), e;
        }
        ReInitAllParticles() {
          const t = this._particles, e = this.onparticlecreate;
          for (let i2 = 0, n = t.length; i2 < n; ++i2) t[i2].Init(e);
        }
        UpdateAllParticlesUserData() {
          const t = this._particles, e = this.onparticlecreate;
          for (let i2 = 0, n = t.length; i2 < n; ++i2) t[i2].UpdateUserData(e);
        }
        ApplyParticleDataToUserData(t) {
          const e = this._particles;
          for (let i2 = 0, n = e.length; i2 < n; ++i2) {
            const n2 = e[i2], s2 = n2.GetUserData();
            if (s2) {
              const e2 = s2.GetWorldInfo();
              e2.SetX(n2.GetX()), e2.SetY(n2.GetY()), e2.SetSize(n2.GetSize(), n2.GetSize()), e2.SetOpacity(n2.GetOpacity()), e2.SetAngle(n2.GetAngle()), e2.SetUnpremultipliedColor(t.GetWorldInfo().GetUnpremultipliedColor()), e2.SetBboxChanged();
            }
          }
        }
        SetParticleCount(t, e = true) {
          const i2 = this._particles;
          if (t < i2.length) {
            const e2 = i2.length - t;
            for (let t2 = 0; t2 < e2; ++t2) {
              const t3 = i2.pop();
              t3.Destroy(), inactiveParticles.push(t3);
            }
            inactiveParticles.length > 1e3 && C33.truncateArray(inactiveParticles, 1e3);
          } else if (t > i2.length) {
            const n = t - i2.length;
            for (let t2 = 0; t2 < n; ++t2) this._CreateParticle(e);
          }
        }
        GetParticles() {
          return this._particles;
        }
        GetParticleCount() {
          return this._particles.length;
        }
        Tick(t) {
          this._SpawnContinuous(t), this._TickParticles(t), this._MaybeFinishOneShot();
        }
        _SpawnContinuous(t) {
          if ("continuous-spray" === this._sprayType && this._isSpraying) {
            this._createCounter += t * this._rate;
            const e = Math.floor(this._createCounter);
            this._createCounter -= e;
            for (let t2 = 0; t2 < e; ++t2) this._CreateParticle();
          }
        }
        _SetCreateCounter(t) {
          this._createCounter = t;
        }
        _GetCreateCounter() {
          return this._createCounter;
        }
        _TickParticles(t) {
          const e = this._boundingBox;
          e.set(this._spawnX, this._spawnY, this._spawnX, this._spawnY);
          const i2 = this._particles;
          let n = 0;
          for (let s2 = 0, r2 = i2.length; s2 < r2; ++s2) {
            const r3 = i2[s2];
            i2[n] = r3, r3.Tick(t), r3.IsActive() ? (++n, e.expandToContain(r3.GetBoundingBox())) : (r3.Destroy(), inactiveParticles.push(r3));
          }
          C33.truncateArray(i2, n), inactiveParticles.length > 1e3 && C33.truncateArray(inactiveParticles, 1e3);
        }
        _MaybeFinishOneShot() {
          "one-shot" === this._sprayType && 0 === this._particles.length && this._isSpraying && (this.ononeshotfinish && this.ononeshotfinish(), this._isSpraying = false);
        }
        Draw(t, e, i2, n) {
          this._devicePixelRatio = globalThis.devicePixelRatio || 1, tempRect.set(e.getTlx(), e.getTly(), e.getBrx(), e.getBry()), t.StartRenderingPoints(tempRect), this._color.copy(t.GetColor());
          const s2 = this._particles;
          for (let r2 = 0, a2 = s2.length; r2 < a2; ++r2) {
            const a3 = s2[r2];
            i2.intersectsRect(a3.GetBoundingBox()) && a3.Draw(t, e, n);
          }
          t.FinishRenderingPoints();
        }
        GetColor() {
          return this._color;
        }
        SetRate(t) {
          this._rate = +t;
        }
        GetRate() {
          return this._rate;
        }
        SetSprayCone(t) {
          this._sprayCone = +t;
        }
        GetSprayCone() {
          return this._sprayCone;
        }
        SetSprayType(t) {
          if (!VALID_SPRAY_TYPES.has(t)) throw new Error("invalid spray type");
          this._sprayType = t;
        }
        GetSprayType() {
          return this._sprayType;
        }
        SetSpraying(t) {
          this._isSpraying = !!t;
        }
        IsSpraying() {
          return this._isSpraying;
        }
        SetMasterOpacity(t) {
          this._masterOpacity = +t;
        }
        GetMasterOpacity() {
          return this._masterOpacity;
        }
        SetPixelRounding(t) {
          this._isPixelRounding = !!t;
        }
        IsPixelRounding() {
          return this._isPixelRounding;
        }
        SetSpawnX(t) {
          this._spawnX = +t;
        }
        GetSpawnX() {
          return this._spawnX;
        }
        SetSpawnY(t) {
          this._spawnY = +t;
        }
        GetSpawnY() {
          return this._spawnY;
        }
        SetSpawnAngle(t) {
          this._spawnAngle = +t;
        }
        GetInitAngle() {
          return this._spawnAngle;
        }
        SetInitSpeed(t) {
          this._initSpeed = +t;
        }
        GetInitSpeed() {
          return this._initSpeed;
        }
        SetInitSize(t) {
          this._initSize = +t;
        }
        GetInitSize() {
          return this._initSize;
        }
        SetInitSizeScale(t) {
          this._initSizeScale = +t;
        }
        GetInitSizeScale() {
          return this._initSizeScale;
        }
        SetInitOpacity(t) {
          this._initOpacity = +t;
        }
        GetInitOpacity() {
          return this._initOpacity;
        }
        SetGrowRate(t) {
          this._growRate = +t;
        }
        GetGrowRate() {
          return this._growRate;
        }
        SetInitXRandom(t) {
          this._xRandom = +t;
        }
        GetInitXRandom() {
          return this._xRandom;
        }
        SetInitYRandom(t) {
          this._yRandom = +t;
        }
        GetInitYRandom() {
          return this._yRandom;
        }
        SetInitSpeedRandom(t) {
          this._initSpeedRandom = +t;
        }
        GetInitSpeedRandom() {
          return this._initSpeedRandom;
        }
        SetInitSizeRandom(t) {
          this._initSizeRandom = +t;
        }
        GetInitSizeRandom() {
          return this._initSizeRandom;
        }
        SetGrowRandom(t) {
          this._growRandom = +t;
        }
        GetGrowRandom() {
          return this._growRandom;
        }
        SetAcceleration(t) {
          this._acceleration = +t;
        }
        GetAcceleration() {
          return this._acceleration;
        }
        SetGravity(t) {
          this._gravity = +t;
        }
        GetGravity() {
          return this._gravity;
        }
        SetLifeAngleRandom(t) {
          this._lifeAngleRandom = +t;
        }
        GetLifeAngleRandom() {
          return this._lifeAngleRandom;
        }
        SetLifeSpeedRandom(t) {
          this._lifeSpeedRandom = +t;
        }
        GetLifeSpeedRandom() {
          return this._lifeSpeedRandom;
        }
        SetLifeOpacityRandom(t) {
          this._lifeOpacityRandom = +t;
        }
        GetLifeOpacityRandom() {
          return this._lifeOpacityRandom;
        }
        SetDestroyMode(t) {
          let e = DESTROY_MODES.indexOf(t);
          if (-1 === e) throw new Error("invalid destroy mode");
          this._destroyMode = e;
        }
        SetDestroyModeIndex(t) {
          this.SetDestroyMode(DESTROY_MODES[t]);
        }
        GetDestroyMode() {
          return DESTROY_MODES[this._destroyMode];
        }
        GetDestroyModeIndex() {
          return this._destroyMode;
        }
        SetTimeout(t) {
          this._timeout = +t;
        }
        GetTimeout() {
          return this._timeout;
        }
        SetParticleScale(t) {
          this._particleScale = +t;
        }
        GetParticleScale() {
          return this._particleScale;
        }
        GetBoundingBox() {
          return this._boundingBox;
        }
        GetDevicePixelRatio() {
          return this._devicePixelRatio;
        }
      };
    }
    {
      let randomOffset2 = function(t) {
        return Math.random() * t - t / 2;
      };
      randomOffset = randomOffset2;
      const C33 = self.C3, ParticleEngine = self.ParticleEngine;
      const tmpQuad = new C33.Quad(), tmpColor = new C33.Color();
      let didChangeColor = false;
      self.Particle = class {
        constructor(t) {
          this._engine = t, this._isActive = false, this._x = 0, this._y = 0, this._speed = 0, this._angle = 0, this._opacity = 1, this._lastOpacity = 0, this._grow = 0, this._size = 0, this._halfSize = 0, this._gs = 0, this._age = 0, this._bbox = new C33.Rect(), this._userData = null, this._userDataUid = NaN, this._updateCallback = null, this._destroyCallback = null;
        }
        SetEngine(t) {
          this._engine = t;
        }
        Init(t) {
          const e = this._engine;
          this._isActive = true, this._x = e.GetSpawnX() + randomOffset2(e.GetInitXRandom()), this._y = e.GetSpawnY() + randomOffset2(e.GetInitYRandom()), this._speed = e.GetInitSpeed() + randomOffset2(e.GetInitSpeedRandom()), this._angle = e.GetInitAngle() + randomOffset2(e.GetSprayCone()), this._opacity = e.GetInitOpacity(), this._lastOpacity = this._opacity, this._size = (e.GetInitSize() + randomOffset2(e.GetInitSizeRandom())) * e.GetInitSizeScale(), this._halfSize = this._size / 2, this._grow = e.GetGrowRate() + randomOffset2(e.GetGrowRandom()), this._gs = 0, this._age = 0, this._UpdateBoundingBox(), t ? this._userData || (this._userData = t(this)) : (this._userData = null, this._updateCallback = null, this._destroyCallback = null);
        }
        UpdateUserData(t) {
          t ? this._userData && !this._userData.IsDestroyed() || (this._userData = t(this, this._userDataUid)) : (this._userData = null, this._updateCallback = null, this._destroyCallback = null);
        }
        SetUpdateCallback(t) {
          this._updateCallback = t;
        }
        SetDestroyCallback(t) {
          this._destroyCallback = t;
        }
        Destroy() {
          const t = this._destroyCallback;
          t && t(this._userData), this._userData = null, this._updateCallback = null, this._destroyCallback = null;
        }
        toJSON() {
          let t;
          return this._userData && this._userData.GetWorldInfo() && (t = this._userData.GetWorldInfo().GetInstance().GetUID()), [this._x, this._y, this._speed, this._angle, this._opacity, this._grow, this._size, this._gs, this._age, t];
        }
        setFromJSON(t) {
          this._x = t[0], this._y = t[1], this._speed = t[2], this._angle = t[3], this._opacity = t[4], this._lastOpacity = this._opacity, this._grow = t[5], this._size = t[6], this._gs = t[7], this._age = t[8], this._userDataUid = t[9], this._halfSize = this._size / 2, this._UpdateBoundingBox();
        }
        Tick(t) {
          const e = this._engine, i2 = this._speed * t, s2 = this._angle, a2 = Math.cos(s2) * i2, h = Math.sin(s2) * i2 + this._gs * t;
          this._x += a2, this._y += h;
          const n = this._grow * t;
          this._size += n, this._halfSize = this._size / 2, this._speed += e.GetAcceleration() * t, this._gs += e.GetGravity() * t, this._age += t, this._UpdateBoundingBox();
          const _ = e.GetLifeAngleRandom(), o2 = e.GetLifeSpeedRandom(), l2 = e.GetLifeOpacityRandom();
          let r2 = 0;
          0 !== _ && (r2 = randomOffset2(_ * t), this._angle += r2), 0 !== o2 && (this._speed += randomOffset2(o2 * t)), 0 !== l2 && (this._opacity = C33.clamp(this._opacity + randomOffset2(l2 * t), 0, 1));
          const d2 = this._size >= 1 && (2 === e.GetDestroyModeIndex() ? this._speed > 0 : this._age < e.GetTimeout()), c2 = this._updateCallback;
          if (c2 && d2) {
            let t2 = e.GetMasterOpacity() * this._opacity;
            0 === e.GetDestroyModeIndex() && (t2 *= 1 - this._age / e.GetTimeout());
            const i3 = t2 - this._lastOpacity;
            this._lastOpacity = t2, c2(this._userData, a2, h, n, r2, i3);
          }
          this._isActive = d2;
        }
        IsActive() {
          return this._isActive;
        }
        GetBoundingBox() {
          return this._bbox;
        }
        _UpdateBoundingBox() {
          const t = this._x, e = this._y, i2 = this._halfSize;
          this._bbox.set(t - i2, e - i2, t + i2, e + i2);
        }
        Draw(t, e, i2) {
          if (this._userData) return;
          const s2 = this._engine;
          let a2 = s2.GetMasterOpacity() * this._opacity;
          if (0 === s2.GetDestroyModeIndex() && (a2 *= 1 - this._age / s2.GetTimeout()), a2 <= 0) return;
          const h = this._size, n = h * s2.GetParticleScale() * s2.GetDevicePixelRatio();
          if (n < 1) return;
          let _ = this._x, o2 = this._y;
          s2.IsPixelRounding() && (_ = _ + 0.5 | 0, o2 = o2 + 0.5 | 0), t.IsWebGPU() ? t.Point(_, o2, h, a2) : i2 || n > t.GetMaxPointSize() || n < t.GetMinPointSize() ? (tmpColor.copy(s2.GetColor()), tmpColor.multiplyAlpha(a2), t.SetColor(tmpColor), didChangeColor = true, tmpQuad.setFromRect(this._bbox), t.Quad4(tmpQuad, e)) : (didChangeColor && (t.SetColor(s2.GetColor()), didChangeColor = false), t.Point(_, o2, n, a2));
        }
        GetUserData() {
          return this._userData;
        }
        GetUserDataUID() {
          return this._userDataUid;
        }
        GetX() {
          return this._x;
        }
        GetY() {
          return this._y;
        }
        GetSize() {
          return this._size;
        }
        GetAngle() {
          return this._angle;
        }
        GetOpacity() {
          return this._opacity;
        }
      };
    }
    var randomOffset;
    {
      {
        const t = self.C3, e = "html-element";
        t.Plugins.HTMLElement = class extends t.SDKDOMPluginBase {
          constructor(t2) {
            super(t2, e), this.AddElementMessageHandler("initial-content", (t3, e2) => t3._OnInitialContent(e2)), this.AddElementMessageHandler("click", (t3, e2) => t3._OnClick(e2)), this.AddElementMessageHandler("animationend", (t3, e2) => t3._OnAnimationEnd(e2));
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.HTMLElement.Type = class extends t.SDKTypeBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const t = self.C3, e = self.C3X, n = 0, s2 = 1, i2 = 2, r2 = 3, a2 = 4, o2 = 5, l2 = 6, h = 7, c2 = 9, C = 10, g = 11, m = 12, _ = 13, d2 = 14, u = 15, S = "html-element";
        t.Plugins.HTMLElement.Instance = class extends t.SDKDOMInstanceBase {
          constructor(e2, p2) {
            super(e2, S), this._tag = "div", this._htmlContent = "", this._textContent = "", this._id = "", this._className = "", this._targetId = "", this._targetClass = "", this._cssAnimationName = "";
            let I2 = "";
            this._initialType = "html";
            let y2 = false, T2 = 0, E2 = false, f3 = t.New(t.Color), M = false, w = t.New(t.Color);
            this._autoFontSize = true, this._autoFontSizeOffset = 0;
            let O = false, x = "";
            if (p2) {
              this._tag = p2[n] || "div", I2 = p2[s2];
              const e3 = p2[i2];
              1 === e3 ? I2 = t.New(t.BBString, I2, { convertLineBreaks: true }).toHTML() : 2 === e3 && (this._initialType = "text"), this.GetWorldInfo().SetVisible(p2[r2]), this._id = p2[a2], this._className = p2[o2], y2 = p2[l2], T2 = p2[h], E2 = p2[c2], f3.setFromJSON(p2[C]), M = p2[g], w.setFromJSON(p2[m]), this._autoFontSize = p2[_], O = p2[d2], x = p2[u];
            }
            "html" === this._initialType ? this._htmlContent = I2 : this._textContent = I2, this.CreateElement({ "tag": this._tag, "str": I2, "type": this._initialType, "id": this._id, "className": this._className, "allow-context-menu": y2, "stop-input-events-mode": T2, "css-color": E2 ? f3.getCssRgb() : "", "css-background-color": M ? w.getCssRgb() : "", "allow-text-selection": O, "style-attribute": x });
          }
          Release() {
            super.Release();
          }
          _GetStringContent(e2, n2) {
            let s3 = "html";
            return "bbcode" === n2 ? e2 = t.New(t.BBString, e2, { convertLineBreaks: true }).toHTML() : "text" === n2 && (s3 = "text"), { contentType: s3, str: e2 };
          }
          async _SetContent(t2, e2 = "html", n2 = "", s3 = false) {
            const { contentType: i3, str: r3 } = this._GetStringContent(t2, e2);
            if (!n2) {
              if ("html" === i3) {
                if ("html" === this._initialType && this._htmlContent === r3) return;
                this._htmlContent = r3;
              } else if ("text" === i3) {
                if ("text" === this._initialType && this._textContent === r3) return;
                this._textContent = r3;
              }
            }
            await this._SendHTMLUpdateMessage("set-content", { "str": r3, "type": i3, "selector": n2, "is-all": s3 });
          }
          async _InsertContent(t2, e2 = "html", n2 = true, s3 = "", i3 = false) {
            if (!t2) return;
            const { contentType: r3, str: a3 } = this._GetStringContent(t2, e2);
            await this._SendHTMLUpdateMessage("insert-content", { "str": a3, "type": r3, "at-end": n2, "selector": s3, "is-all": i3 });
          }
          async _RemoveContent(t2, e2 = false, n2 = false) {
            await this._SendHTMLUpdateMessage("remove-content", { "selector": t2, "is-clear": e2, "is-all": n2 });
          }
          async _SetContentClass(t2, e2, n2, s3 = false) {
            await this._SendHTMLUpdateMessage("set-content-class", { "mode": t2, "class-array": e2, "selector": n2, "is-all": s3 });
          }
          async _SetContentAttribute(t2, e2, n2, s3, i3 = false) {
            await this._SendHTMLUpdateMessage("set-content-attribute", { "mode": t2, "attribute": e2, "value": n2, "selector": s3, "is-all": i3 });
          }
          async _SetContentCSSStyle(e2, n2, s3, i3 = false) {
            await this._SendHTMLUpdateMessage("set-content-css-style", { "prop": t.CSSToCamelCase(e2), "value": n2, "selector": s3, "is-all": i3 });
          }
          async _SendHTMLUpdateMessage(t2, e2) {
            const n2 = await this.PostToDOMElementAsync(t2, e2);
            n2["isOk"] && (this._htmlContent = n2["html"], this._textContent = n2["text"]);
          }
          async _PositionObjectAtElement(t2, e2) {
            const n2 = await this.PostToDOMElementAsync("get-element-box", { "selector": e2 });
            if (!n2["isOk"]) return;
            const s3 = this._runtime.GetCanvasManager(), i3 = n2["left"] - s3.GetCanvasClientX(), r3 = n2["top"] - s3.GetCanvasClientY(), a3 = n2["right"] - s3.GetCanvasClientX(), o3 = n2["bottom"] - s3.GetCanvasClientY();
            for (const e3 of t2) {
              const t3 = e3.GetWorldInfo();
              if (!t3) continue;
              const n3 = t3.GetLayer(), [s4, l3] = n3.CanvasCssToLayer(i3, r3, t3.GetZElevation()), [h2, c3] = n3.CanvasCssToLayer(a3, o3, t3.GetZElevation());
              if (!(isFinite(s4) && isFinite(l3) && isFinite(h2) && isFinite(c3))) continue;
              const C2 = h2 - s4, g2 = c3 - l3, m2 = s4 + t3.GetOriginX() * C2, _2 = l3 + t3.GetOriginY() * g2;
              t3.GetX() === m2 && t3.GetY() === _2 && t3.GetWidth() === C2 && t3.GetHeight() === g2 || (t3.SetXY(m2, _2), t3.SetSize(C2, g2), t3.SetBboxChanged());
            }
          }
          async _CreateSpriteImgElement(t2, e2, n2, s3, i3) {
            const r3 = t2.GetWorldInfo(), a3 = t2.GetCurrentImageInfo();
            if (!r3 || !a3) return;
            const o3 = await a3.ExtractImageToBlobURL(), l3 = await this.PostToDOMElementAsync("insert-img-element", { "blobUrl": o3, "width": a3.GetWidth(), "height": a3.GetHeight(), "selector": e2, "insertAt": n2, "id": s3, "class": i3 });
            l3["isOk"] && (this._htmlContent = l3["html"], this._textContent = l3["text"]);
          }
          async _SetElementScrollPosition(t2, e2, n2) {
            await this.PostToDOMElementAsync("set-scroll-position", { "selector": t2, "direction": e2, "position": n2 });
          }
          GetElementState() {
            return { "html": this._htmlContent };
          }
          _OnInitialContent(t2) {
            this._htmlContent = t2["html"], this._textContent = t2["text"];
          }
          _GetHTMLContent() {
            return this._htmlContent;
          }
          _GetTextContent() {
            return this._textContent;
          }
          async _OnClick(e2) {
            const n2 = e2["chain"];
            for (const e3 of n2) this._targetId = e3["targetId"], this._targetClass = e3["targetClass"], this.DispatchScriptEvent("click", true, { "targetId": this._targetId, "targetClass": this._targetClass }), this._targetId && await this.TriggerAsync(t.Plugins.HTMLElement.Cnds.OnClickedID), this._targetClass && await this.TriggerAsync(t.Plugins.HTMLElement.Cnds.OnClickedClass);
            if (n2.length > 0) {
              const t2 = n2[0];
              this._targetId = t2["targetId"], this._targetClass = t2["targetClass"];
            } else this._targetId = "", this._targetClass = "";
            await this.TriggerAsync(t.Plugins.HTMLElement.Cnds.OnClicked), this._targetId = "", this._targetClass = "";
          }
          async _OnAnimationEnd(e2) {
            this._targetId = e2["targetId"], this._targetClass = e2["targetClass"], this._cssAnimationName = e2["animationName"], this.DispatchScriptEvent("animationend", true, { "targetId": this._targetId, "targetClass": this._targetClass, "animationName": this._cssAnimationName }), await this.TriggerAsync(t.Plugins.HTMLElement.Cnds.OnCSSAnimationEnded), this._targetId = "", this._targetClass = "", this._cssAnimationName = "";
          }
          Draw(t2) {
          }
          SaveToJson() {
            return { "t": this._tag, "h": this._htmlContent, "id": this._id, "c": this._className };
          }
          LoadFromJson(t2) {
            this._tag = t2["t"], this._htmlContent = t2["h"], this._id = t2["id"], this._className = t2["c"], this.UpdateElementState();
          }
          GetPropertyValueByIndex(t2) {
          }
          SetPropertyValueByIndex(t2, e2) {
          }
          GetDebuggerProperties() {
            return [];
          }
          GetScriptInterfaceClass() {
            return self.IHTMLElementInstance;
          }
        };
        const p = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new Set(["html", "bbcode", "text"]), y = /* @__PURE__ */ new Set(["add", "toggle", "remove"]), T = /* @__PURE__ */ new Set(["set", "remove"]), E = ["start", "end", "replace"], f2 = /* @__PURE__ */ new Set(["left", "top"]);
        self.IHTMLElementInstance = class extends self.IDOMInstance {
          constructor() {
            super(), p.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          setContent(t2, n2 = "html", s3 = "", i3 = false) {
            if (e.RequireString(t2), !I.has(n2)) throw new Error("invalid type");
            return e.RequireString(s3), p.get(this)._SetContent(t2, n2, s3, !!i3);
          }
          insertContent(t2, n2 = "html", s3 = true, i3 = "", r3 = false) {
            if (e.RequireString(t2), !I.has(n2)) throw new Error("invalid type");
            return e.RequireString(i3), p.get(this)._InsertContent(t2, n2, !!s3, i3, !!r3);
          }
          setContentClass(t2, n2, s3, i3 = false) {
            if (!y.has(t2)) throw new Error("invalid mode");
            return "string" == typeof n2 && (n2 = n2.split(" ")), e.RequireArray(n2), e.RequireString(s3), p.get(this)._SetContentClass(t2, n2, s3, !!i3);
          }
          setContentAttribute(t2, n2, s3, i3, r3 = false) {
            if (!T.has(t2)) throw new Error("invalid type");
            return e.RequireString(n2), s3 = s3.toString(), e.RequireString(i3), p.get(this)._SetContentAttribute(t2, n2, s3, i3, !!r3);
          }
          setContentCssStyle(t2, n2, s3, i3) {
            return e.RequireString(t2), n2 = n2.toString(), e.RequireString(s3), p.get(this)._SetContentCSSStyle(t2, n2, s3, !!i3);
          }
          positionInstanceAtElement(t2, n2) {
            e.RequireInstanceOf(t2, self.IWorldInstance), e.RequireString(n2);
            const s3 = p.get(this).GetRuntime()._UnwrapIWorldInstance(t2);
            return p.get(this)._PositionObjectAtElement([s3], n2);
          }
          createSpriteImgElement(t2, n2, s3, i3, r3) {
            e.RequireInstanceOf(t2, self.ISpriteInstance), e.RequireString(n2), e.RequireOptionalString(i3), e.RequireOptionalString(r3);
            const a3 = E.indexOf(s3);
            if (a3 < 0) throw new Error("invalid insert position");
            const o3 = p.get(this).GetRuntime()._UnwrapIWorldInstance(t2);
            return p.get(this)._CreateSpriteImgElement(o3, n2, a3, i3, r3);
          }
          setScrollPosition(t2, n2, s3) {
            if (e.RequireString("selector"), !f2.has(n2)) throw new Error("invalid direction");
            return e.RequireNumber(s3), p.get(this)._SetElementScrollPosition(t2, n2, s3);
          }
          get htmlContent() {
            return p.get(this)._GetHTMLContent();
          }
          set htmlContent(t2) {
            p.get(this)._SetContent(t2, "html", "", false);
          }
          get textContent() {
            return p.get(this)._GetTextContent();
          }
          set textContent(t2) {
            p.get(this)._SetContent(t2, "text", "", false);
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.HTMLElement.Cnds = { OnClicked: () => true, OnClickedID(e) {
          return t.equalsNoCase(this._targetId, e);
        }, OnClickedClass(t2) {
          const e = this._targetClass.toLowerCase().split(" ");
          return t2.toLowerCase().split(" ").every((t3) => e.includes(t3));
        }, OnCSSAnimationEnded(e) {
          return t.equalsNoCase(this._cssAnimationName, e);
        } };
      }
      {
        const t = self.C3, e = ["html", "bbcode", "text"], n = ["add", "toggle", "remove"], s2 = ["set", "remove"];
        t.Plugins.HTMLElement.Acts = { SetContent(t2, n2, s3, i2) {
          return this._SetContent(n2, e[t2], s3, 0 !== i2);
        }, InsertContent(t2, n2, s3, i2, r2) {
          return this._InsertContent(n2, e[t2], 0 !== s3, i2, 0 !== r2);
        }, RemoveContent(t2, e2, n2) {
          return this._RemoveContent(e2, 0 !== t2, 0 !== n2);
        }, SetContentClass(t2, e2, s3, i2) {
          return this._SetContentClass(n[t2], e2.split(" "), s3, 0 !== i2);
        }, SetContentAttribute(t2, e2, n2, i2, r2) {
          return this._SetContentAttribute(s2[t2], e2, n2.toString(), i2, 0 !== r2);
        }, SetContentCSSStyle(t2, e2, n2, s3) {
          return this._SetContentCSSStyle(t2, e2, n2, 0 !== s3);
        }, PositionObjectAtElement(t2, e2) {
          if (t2) return this._PositionObjectAtElement(t2.GetCurrentSol().GetInstances(), e2);
        }, CreateSpriteImgElement(t2, e2, n2, s3, i2) {
          if (!t2) return;
          const r2 = t2.GetFirstPicked();
          return r2 ? this._CreateSpriteImgElement(r2, e2, n2, s3, i2) : void 0;
        }, SetScrollPosition(t2, e2, n2) {
          return this._SetElementScrollPosition(t2, ["left", "top"][e2], n2);
        } };
      }
      {
        const t = self.C3;
        t.Plugins.HTMLElement.Exps = { HTMLContent() {
          return this._htmlContent;
        }, TextContent() {
          return this._textContent;
        }, TargetID() {
          return this._targetId;
        }, TargetClass() {
          return this._targetClass;
        }, EscapeHTML: (e) => t.EscapeHTML(e.toString()) };
      }
    }
    {
      {
        const t = self.C3;
        t.Plugins.NinePatch = class extends t.SDKPluginBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Plugins.NinePatch.Type = class extends t.SDKTypeBase {
          constructor(t2) {
            super(t2), this._textureSet = null, this._drawable = null;
          }
          Release() {
            this.ReleaseTextures(), super.Release();
          }
          OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime);
          }
          async LoadTextures(t2) {
            const e = this.GetImageInfo();
            this._drawable = await e.ExtractImageToCanvas();
          }
          CreatePatch(t2, e, s2, i2) {
            !this._textureSet && this._drawable && (this._textureSet = new self.NinePatchTextureSet(this), this._textureSet.CreateTextures(this._drawable, t2, e, s2, i2));
          }
          ReleaseTextures() {
            this._textureSet && (this._textureSet.Release(), this._textureSet = null);
          }
          GetTextureSet() {
            return this._textureSet;
          }
        };
      }
      {
        const t = self.C3, e = 0, s2 = 1, i2 = 2, a2 = 3, h = 4, r2 = 5, l2 = 6, n = 8, _ = t.New(t.Rect), c2 = t.New(t.Rect), u = t.New(t.Quad);
        t.Plugins.NinePatch.Instance = class extends t.SDKWorldInstanceBase {
          constructor(t2, _2) {
            super(t2), this._leftMargin = 16, this._rightMargin = 16, this._topMargin = 16, this._bottomMargin = 16, this._edges = 1, this._fill = 1, this._isSeamless = true, this._callback3d = null, _2 && (this._leftMargin = _2[e], this._rightMargin = _2[s2], this._topMargin = _2[i2], this._bottomMargin = _2[a2], this._edges = _2[h], this._fill = _2[r2], this._isSeamless = !!_2[n], this.GetWorldInfo().SetVisible(!!_2[l2])), this._sdkType.CreatePatch(this._leftMargin, this._rightMargin, this._topMargin, this._bottomMargin);
          }
          Release() {
            super.Release();
          }
          _Set3DCallback(t2) {
            this._callback3d = t2;
          }
          Draw(t2) {
            const e2 = this.GetWorldInfo(), s3 = e2.GetBoundingQuad();
            this._Draw(t2, s3.getTlx(), s3.getTly(), e2.GetWidth(), e2.GetHeight());
          }
          _Draw(t2, e2, s3, i3, a3) {
            let h2 = this._sdkType.GetTextureSet();
            if (!h2 && (this._sdkType.CreatePatch(this._leftMargin, this._rightMargin, this._topMargin, this._bottomMargin), h2 = this._sdkType.GetTextureSet(), !h2)) return;
            const r3 = h2.GetImageWidth(), l3 = h2.GetImageHeight(), n2 = Math.min(this._leftMargin, r3), _2 = Math.min(this._rightMargin, r3), c3 = Math.min(this._topMargin, l3), u2 = Math.min(this._bottomMargin, l3), o2 = r3 - _2, g = l3 - u2, d2 = this._isSeamless ? 1 : 0, T = this._edges, x = this._fill;
            if (n2 > 0 && c3 > 0 && this._DrawPatch(t2, h2.GetTexture(), 0, 0, n2 + d2, c3 + d2, e2, s3, n2 + d2, c3 + d2), _2 > 0 && c3 > 0 && this._DrawPatch(t2, h2.GetTexture(), o2 - d2, 0, _2 + d2, c3 + d2, e2 + i3 - _2 - d2, s3, _2 + d2, c3 + d2), _2 > 0 && u2 > 0 && this._DrawPatch(t2, h2.GetTexture(), o2 - d2, g - d2, _2 + d2, u2 + d2, e2 + i3 - _2 - d2, s3 + a3 - u2 - d2, _2 + d2, u2 + d2), n2 > 0 && u2 > 0 && this._DrawPatch(t2, h2.GetTexture(), 0, g - d2, n2 + d2, u2 + d2, e2, s3 + a3 - u2 - d2, n2 + d2, u2 + d2), 0 === T) {
              const r4 = 2 === x ? 0 : d2;
              n2 > 0 && g > c3 && this._TilePatch(t2, h2.GetLeftTexture(), e2, s3 + c3, n2 + r4, a3 - c3 - u2, 0, 0), _2 > 0 && g > c3 && this._TilePatch(t2, h2.GetRightTexture(), e2 + i3 - _2 - r4, s3 + c3, _2 + r4, a3 - c3 - u2, r4, 0), c3 > 0 && o2 > n2 && this._TilePatch(t2, h2.GetTopTexture(), e2 + n2, s3, i3 - n2 - _2, c3 + r4, 0, 0), u2 > 0 && o2 > n2 && this._TilePatch(t2, h2.GetBottomTexture(), e2 + n2, s3 + a3 - u2 - r4, i3 - n2 - _2, u2 + r4, 0, r4);
            } else 1 === T && (n2 > 0 && g > c3 && this._DrawPatch(t2, h2.GetTexture(), 0, c3, n2, g - c3, e2, s3 + c3, n2, a3 - c3 - u2), _2 > 0 && g > c3 && this._DrawPatch(t2, h2.GetTexture(), o2, c3, _2, g - c3, e2 + i3 - _2, s3 + c3, _2, a3 - c3 - u2), c3 > 0 && o2 > n2 && this._DrawPatch(t2, h2.GetTexture(), n2, 0, o2 - n2, c3, e2 + n2, s3, i3 - n2 - _2, c3), u2 > 0 && o2 > n2 && this._DrawPatch(t2, h2.GetTexture(), n2, g, o2 - n2, u2, e2 + n2, s3 + a3 - u2, i3 - n2 - _2, u2));
            g > c3 && o2 > n2 && (0 === x ? this._TilePatch(t2, h2.GetFillTexture(), e2 + n2, s3 + c3, i3 - n2 - _2, a3 - c3 - u2, 0, 0) : 1 === x && this._DrawPatch(t2, h2.GetTexture(), n2, c3, o2 - n2, g - c3, e2 + n2, s3 + c3, i3 - n2 - _2, a3 - c3 - u2));
          }
          _DrawPatch(t2, e2, s3, i3, a3, h2, r3, l3, n2, o2) {
            const g = e2.GetWidth(), d2 = e2.GetHeight();
            if (t2.SetTexture(e2), _.set(r3, l3, r3 + n2, l3 + o2), c2.set(s3 / g, i3 / d2, (s3 + a3) / g, (i3 + h2) / d2), null === this._callback3d) {
              const e3 = this.GetWorldInfo(), s4 = e3.GetBoundingQuad(), i4 = s4.getTlx(), a4 = s4.getTly();
              _.offset(-i4, -a4), u.setFromRotatedRect(_, e3.GetAngle()), u.offset(i4, a4), t2.Quad3(u, c2);
            } else this._callback3d(_, c2);
          }
          _TilePatch(t2, e2, s3, i3, a3, h2, r3, l3) {
            const n2 = e2.GetWidth(), o2 = e2.GetHeight();
            if (t2.SetTexture(e2), _.set(s3, i3, s3 + a3, i3 + h2), c2.set(-r3 / n2, -l3 / o2, (a3 - r3) / n2, (h2 - l3) / o2), null === this._callback3d) {
              const e3 = this.GetWorldInfo(), s4 = e3.GetBoundingQuad(), i4 = s4.getTlx(), a4 = s4.getTly();
              _.offset(-i4, -a4), u.setFromRotatedRect(_, e3.GetAngle()), u.offset(i4, a4), t2.Quad3(u, c2);
            } else this._callback3d(_, c2);
          }
          GetCurrentImageInfo() {
            this._objectClass.GetImageInfo();
          }
          GetPropertyValueByIndex(t2) {
          }
          SetPropertyValueByIndex(t2, e2) {
          }
        };
      }
      self.C3.Plugins.NinePatch.Cnds = {};
      self.C3.Plugins.NinePatch.Acts = { SetEffect(t) {
        this.GetWorldInfo().SetBlendMode(t), this._runtime.UpdateRender();
      } };
      self.C3.Plugins.NinePatch.Exps = {};
    }
    {
      let CloneDrawable2 = function(e) {
        const t = C33.CreateCanvas(e.width, e.height);
        return t.getContext("2d").drawImage(e, 0, 0), t;
      };
      CloneDrawable = CloneDrawable2;
      const C33 = self.C3;
      self.NinePatchTextureSet = class {
        constructor(e) {
          this._sdkType = e, this._runtime = this._sdkType.GetRuntime(), this._texture = null, this._fillTexture = null, this._leftTexture = null, this._rightTexture = null, this._topTexture = null, this._bottomTexture = null, this._imageWidth = 0, this._imageHeight = 0, this._renderer = this._runtime.GetRenderer(), this._isLoading = false, this._wasReleased = false;
        }
        Release() {
          this._renderer.IsContextLost() || (this._renderer.DeleteTexture(this._texture), this._renderer.DeleteTexture(this._fillTexture), this._renderer.DeleteTexture(this._leftTexture), this._renderer.DeleteTexture(this._rightTexture), this._renderer.DeleteTexture(this._topTexture), this._renderer.DeleteTexture(this._bottomTexture)), this._texture = null, this._fillTexture = null, this._leftTexture = null, this._rightTexture = null, this._topTexture = null, this._bottomTexture = null, this._sdkType = null, this._renderer = null, this._wasReleased = true;
        }
        WasReleased() {
          return this._wasReleased;
        }
        CreateTextures(e, t, r2, i2, s2) {
          this._SliceImage(e, t, r2, i2, s2);
        }
        HasCreatedTextures() {
          return !!this._texture;
        }
        _SliceImage(e, t, r2, i2, s2) {
          if (this._wasReleased) return;
          const a2 = e.width, h = e.height;
          this._imageWidth = a2, this._imageHeight = h, t = Math.min(Math.floor(t), a2), r2 = Math.min(Math.floor(r2), a2), i2 = Math.min(Math.floor(i2), h);
          const l2 = a2 - r2, u = h - (s2 = Math.min(Math.floor(s2), h)), n = this._runtime.GetSampling(), _ = this._runtime.GetCanvasManager().GetTextureAnisotropy();
          this._texture = this._renderer.CreateStaticTexture(CloneDrawable2(e), { sampling: n, anisotropy: _ }), l2 > t && u > i2 && (this._fillTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable2(e), t, i2, l2, u), { wrapX: "repeat", wrapY: "repeat", sampling: n, anisotropy: _ })), t > 0 && u > i2 && (this._leftTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable2(e), 0, i2, t, u), { wrapY: "repeat", sampling: n, anisotropy: _ })), r2 > 0 && u > i2 && (this._rightTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable2(e), l2, i2, a2, u), { wrapY: "repeat", sampling: n, anisotropy: _ })), i2 > 0 && l2 > t && (this._topTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable2(e), t, 0, l2, i2), { wrapX: "repeat", sampling: n, anisotropy: _ })), s2 > 0 && l2 > t && (this._bottomTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable2(e), t, u, l2, h), { wrapX: "repeat", sampling: n, anisotropy: _ }));
        }
        _SliceSubImage(e, t, r2, i2, s2) {
          const a2 = i2 - t, h = s2 - r2, l2 = C33.CreateCanvas(a2, h);
          return l2.getContext("2d").drawImage(e, t, r2, a2, h, 0, 0, a2, h), l2;
        }
        GetImageWidth() {
          return this._imageWidth;
        }
        GetImageHeight() {
          return this._imageHeight;
        }
        GetTexture() {
          return this._texture;
        }
        GetFillTexture() {
          return this._fillTexture;
        }
        GetLeftTexture() {
          return this._leftTexture;
        }
        GetRightTexture() {
          return this._rightTexture;
        }
        GetTopTexture() {
          return this._topTexture;
        }
        GetBottomTexture() {
          return this._bottomTexture;
        }
      };
    }
    var CloneDrawable;
    {
      {
        const e = self.C3;
        e.Behaviors.Timer = class extends e.SDKBehaviorBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.Timer.Type = class extends e.SDKBehaviorTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3, t = self.C3X, r2 = self.IBehaviorInstance;
        e.Behaviors.Timer.SingleTimer = class {
          constructor(t2, r3, i3, s2) {
            this._current = e.New(e.KahanSum), this._current.Set(t2 || 0), this._total = e.New(e.KahanSum), this._total.Set(r3 || 0), this._duration = i3 || 0, this._isRegular = !!s2, this._isPaused = false;
          }
          GetCurrentTime() {
            return this._current.Get();
          }
          GetTotalTime() {
            return this._total.Get();
          }
          GetDuration() {
            return this._duration;
          }
          SetPaused(e2) {
            this._isPaused = !!e2;
          }
          IsPaused() {
            return this._isPaused;
          }
          Add(e2) {
            this._current.Add(e2), this._total.Add(e2);
          }
          HasFinished() {
            return this._current.Get() >= this._duration;
          }
          Update() {
            if (this.HasFinished()) {
              if (!this._isRegular) return true;
              this._current.Subtract(this._duration);
            }
            return false;
          }
          SaveToJson() {
            return { "c": this._current.Get(), "t": this._total.Get(), "d": this._duration, "r": this._isRegular, "p": this._isPaused };
          }
          LoadFromJson(e2) {
            this._current.Set(e2["c"]), this._total.Set(e2["t"]), this._duration = e2["d"], this._isRegular = !!e2["r"], this._isPaused = !!e2["p"];
          }
        }, e.Behaviors.Timer.Instance = class extends e.SDKBehaviorInstanceBase {
          constructor(e2, t2) {
            super(e2), this._timers = /* @__PURE__ */ new Map();
          }
          Release() {
            this._timers.clear(), super.Release();
          }
          _StartTimer(t2, r3, i3) {
            const s2 = new e.Behaviors.Timer.SingleTimer(0, 0, t2, i3);
            this._timers.set(r3.toLowerCase(), s2), this._UpdateTickState();
          }
          _StopTimer(e2) {
            this._timers.delete(e2.toLowerCase()), this._UpdateTickState();
          }
          _StopAllTimers() {
            this._timers.clear(), this._UpdateTickState();
          }
          _IsTimerRunning(e2) {
            return this._timers.has(e2.toLowerCase());
          }
          _GetTimerCurrentTime(e2) {
            const t2 = this._timers.get(e2.toLowerCase());
            return t2 ? t2.GetCurrentTime() : 0;
          }
          _GetTimerNormalizedProgress(e2) {
            const t2 = this._timers.get(e2.toLowerCase());
            return t2 ? t2.GetCurrentTime() / t2.GetDuration() : 0;
          }
          _GetTimerTotalTime(e2) {
            const t2 = this._timers.get(e2.toLowerCase());
            return t2 ? t2.GetTotalTime() : 0;
          }
          _GetTimerDuration(e2) {
            const t2 = this._timers.get(e2.toLowerCase());
            return t2 ? t2.GetDuration() : 0;
          }
          _HasTimerFinished(e2) {
            const t2 = this._timers.get(e2.toLowerCase());
            return !!t2 && t2.HasFinished();
          }
          _SetTimerPaused(e2, t2) {
            const r3 = this._timers.get(e2.toLowerCase());
            r3 && r3.SetPaused(t2);
          }
          _IsTimerPaused(e2) {
            const t2 = this._timers.get(e2.toLowerCase());
            return !!t2 && t2.IsPaused();
          }
          _SetAllTimersPaused(e2) {
            for (const t2 of this._timers.values()) t2.SetPaused(e2);
          }
          _UpdateTickState() {
            this._timers.size > 0 ? (this._StartTicking(), this._StartTicking2()) : (this._StopTicking(), this._StopTicking2());
          }
          SaveToJson() {
            const e2 = {};
            for (const [t2, r3] of this._timers.entries()) e2[t2] = r3.SaveToJson();
            return e2;
          }
          LoadFromJson(t2) {
            this._timers.clear();
            for (const [r3, i3] of Object.entries(t2)) {
              const t3 = new e.Behaviors.Timer.SingleTimer();
              t3.LoadFromJson(i3), this._timers.set(r3, t3);
            }
            this._UpdateTickState();
          }
          Tick() {
            const e2 = this._runtime.GetDt(this._inst);
            for (const [t2, r3] of this._timers) r3.IsPaused() || (r3.Add(e2), r3.HasFinished() && this.DispatchScriptEvent("timer", false, { tag: t2 }));
          }
          Tick2() {
            for (const [e2, t2] of this._timers.entries()) {
              t2.Update() && this._timers.delete(e2);
            }
          }
          GetDebuggerProperties() {
            return [{ title: "behaviors.timer.debugger.timers", properties: [...this._timers.entries()].map((e2) => ({ name: "$" + e2[0], value: `${Math.round(10 * e2[1].GetCurrentTime()) / 10} / ${Math.round(10 * e2[1].GetDuration()) / 10}` })) }];
          }
          GetScriptInterfaceClass() {
            return self.ITimerBehaviorInstance;
          }
        };
        const i2 = ["once", "regular"];
        self.ITimerBehaviorInstance = class extends r2 {
          #e;
          constructor() {
            super(), this.#e = r2._GetInitInst().GetSdkInstance();
          }
          startTimer(e2, r3, s2 = "once") {
            t.RequireFiniteNumber(e2), t.RequireString(r3);
            const a2 = i2.indexOf(s2);
            if (-1 === a2) throw new Error("invalid type");
            this.#e._StartTimer(e2, r3, 1 === a2);
          }
          setTimerPaused(e2, r3) {
            t.RequireString(e2), this.#e._SetTimerPaused(e2, !!r3);
          }
          setAllTimersPaused(e2) {
            this.#e._SetAllTimersPaused(!!e2);
          }
          stopTimer(e2) {
            t.RequireString(e2), this.#e._StopTimer(e2);
          }
          stopAllTimers() {
            this.#e._StopAllTimers();
          }
          isTimerRunning(e2) {
            return t.RequireString(e2), this.#e._IsTimerRunning(e2);
          }
          isTimerPaused(e2) {
            return t.RequireString(e2), this.#e._IsTimerPaused(e2);
          }
          getCurrentTime(e2) {
            return t.RequireString(e2), this.#e._GetTimerCurrentTime(e2);
          }
          getNormalizedProgress(e2) {
            return t.RequireString(e2), this.#e._GetTimerNormalizedProgress(e2);
          }
          getTotalTime(e2) {
            return t.RequireString(e2), this.#e._GetTimerTotalTime(e2);
          }
          getDuration(e2) {
            return t.RequireString(e2), this.#e._GetTimerDuration(e2);
          }
          hasFinished(e2) {
            return t.RequireString(e2), this.#e._HasTimerFinished(e2);
          }
        };
      }
      self.C3.Behaviors.Timer.Cnds = { OnTimer(e) {
        return this._HasTimerFinished(e);
      }, IsTimerRunning(e) {
        return this._IsTimerRunning(e);
      }, IsTimerPaused(e) {
        return this._IsTimerPaused(e);
      } };
      self.C3.Behaviors.Timer.Acts = { StartTimer(e, t, r2) {
        this._StartTimer(e, r2, 1 === t);
      }, StopTimer(e) {
        this._StopTimer(e);
      }, StopAllTimers() {
        this._StopAllTimers();
      }, PauseResumeTimer(e, t) {
        this._SetTimerPaused(e, 0 === t);
      }, PauseResumeAllTimers(e) {
        this._SetAllTimersPaused(0 === e);
      } };
      self.C3.Behaviors.Timer.Exps = { CurrentTime(e) {
        return this._GetTimerCurrentTime(e);
      }, NormalizedProgress(e) {
        return this._GetTimerNormalizedProgress(e);
      }, TotalTime(e) {
        return this._GetTimerTotalTime(e);
      }, Duration(e) {
        return this._GetTimerDuration(e);
      } };
    }
    {
      {
        const t = self.C3;
        t.Behaviors.Bullet = class extends t.SDKBehaviorBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Behaviors.Bullet.Type = class extends t.SDKBehaviorTypeBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const t = self.C3, e = self.C3X, s2 = self.IBehaviorInstance, i2 = 0, n = 1, h = 2, a2 = 3, _ = 4, l2 = 5, o2 = 6;
        t.Behaviors.Bullet.Instance = class extends t.SDKBehaviorInstanceBase {
          constructor(t2, e2) {
            super(t2);
            const s3 = this.GetWorldInfo();
            this._speed = 0, this._acc = 0, this._g = 0, this._bounceOffSolid = false, this._setAngle = false, this._isStepping = false, this._isEnabled = true, this._dx = 0, this._dy = 0, this._lastX = s3.GetX(), this._lastY = s3.GetY(), this._lastKnownAngle = s3.GetAngle(), this._travelled = 0, this._stepSize = Math.min(Math.abs(s3.GetWidth()), Math.abs(s3.GetHeight()) / 2), this._stopStepping = false, e2 && (this._speed = e2[i2], this._acc = e2[n], this._g = e2[h], this._bounceOffSolid = !!e2[a2], this._setAngle = !!e2[_], this._isStepping = !!e2[l2], this._isEnabled = !!e2[o2]);
            const r3 = s3.GetAngle();
            this._dx = Math.cos(r3) * this._speed, this._dy = Math.sin(r3) * this._speed, this._isEnabled && (this._StartTicking(), this._bounceOffSolid && this._StartPostTicking());
          }
          Release() {
            super.Release();
          }
          SaveToJson() {
            const t2 = { "dx": this._dx, "dy": this._dy, "lx": this._lastX, "ly": this._lastY, "lka": this._lastKnownAngle, "t": this._travelled };
            return 0 !== this._acc && (t2["acc"] = this._acc), 0 !== this._g && (t2["g"] = this._g), this._isStepping && (t2["st"] = this._isStepping), this._isEnabled || (t2["e"] = this._isEnabled), this._bounceOffSolid && (t2["bos"] = this._bounceOffSolid), this._setAngle && (t2["sa"] = this._setAngle), t2;
          }
          LoadFromJson(t2) {
            this._dx = t2["dx"], this._dy = t2["dy"], this._lastX = t2["lx"], this._lastY = t2["ly"], this._lastKnownAngle = t2["lka"], this._travelled = t2["t"], this._acc = t2.hasOwnProperty("acc") ? t2["acc"] : 0, this._g = t2.hasOwnProperty("g") ? t2["g"] : 0, this._isStepping = !!t2.hasOwnProperty("st") && t2["st"], this._bounceOffSolid = !!t2.hasOwnProperty("bos") && t2["bos"], this._setAngle = !!t2.hasOwnProperty("sa") && t2["sa"], this._SetEnabled(!t2.hasOwnProperty("e") || t2["e"]);
          }
          Tick() {
            if (!this._isEnabled) return;
            const e2 = this._runtime.GetDt(this._inst), s3 = this._inst.GetWorldInfo();
            if (s3.GetAngle() !== this._lastKnownAngle) {
              const e3 = s3.GetAngle();
              if (this._setAngle) {
                const s4 = t.distanceTo(0, 0, this._dx, this._dy);
                this._dx = Math.cos(e3) * s4, this._dy = Math.sin(e3) * s4;
              }
              this._lastKnownAngle = e3;
            }
            let i3 = 0, n2 = 0;
            if (0 !== this._acc) {
              let h2 = t.distanceTo(0, 0, this._dx, this._dy), a3 = 0;
              a3 = 0 === this._dx && 0 === this._dy ? s3.GetAngle() : t.angleTo(0, 0, this._dx, this._dy), h2 += this._acc * e2, i3 = Math.cos(a3) * this._acc, n2 = Math.sin(a3) * this._acc, h2 < 0 && (h2 = 0, i3 = 0, n2 = 0), this._dx = Math.cos(a3) * h2, this._dy = Math.sin(a3) * h2;
            }
            if (0 !== this._g && (this._dy += this._g * e2, n2 += this._g), this._lastX = s3.GetX(), this._lastY = s3.GetY(), 0 !== this._dx || 0 !== this._dy) {
              const h2 = this._dx * e2 + 0.5 * i3 * e2 * e2, a3 = this._dy * e2 + 0.5 * n2 * e2 * e2, _2 = t.distanceTo(0, 0, h2, a3);
              if (this._MoveBy(h2, a3, _2), this._travelled += _2, this._setAngle && (0 !== h2 || 0 !== a3)) {
                const e3 = t.angleTo(0, 0, h2, a3);
                s3.SetAngle(e3), this._lastKnownAngle = s3.GetAngle();
              }
              s3.SetBboxChanged();
            }
          }
          _MoveBy(e2, s3, i3) {
            const n2 = this.GetWorldInfo();
            if (!this._isStepping || i3 <= this._stepSize) return n2.OffsetXY(e2, s3), n2.SetBboxChanged(), void (this._isStepping && this.Trigger(t.Behaviors.Bullet.Cnds.OnStep));
            this._stopStepping = false;
            const h2 = n2.GetX(), a3 = n2.GetY(), _2 = h2 + e2, l3 = a3 + s3, o3 = t.angleTo(0, 0, e2, s3), r3 = Math.cos(o3) * this._stepSize, d2 = Math.sin(o3) * this._stepSize, c2 = Math.floor(i3 / this._stepSize);
            for (let e3 = 1; e3 <= c2; ++e3) if (n2.SetXY(h2 + r3 * e3, a3 + d2 * e3), n2.SetBboxChanged(), this.Trigger(t.Behaviors.Bullet.Cnds.OnStep), this._inst.IsDestroyed() || this._stopStepping) return;
            n2.SetXY(_2, l3), n2.SetBboxChanged(), this.Trigger(t.Behaviors.Bullet.Cnds.OnStep);
          }
          PostTick() {
            if (!this._isEnabled || !this._bounceOffSolid || 0 === this._dx && 0 === this._dy) return;
            const e2 = this._runtime.GetDt(this._inst), s3 = this._inst.GetWorldInfo(), i3 = this._runtime.GetCollisionEngine(), n2 = i3.TestOverlapSolid(this._inst);
            if (n2) {
              i3.RegisterCollision(this._inst, n2);
              const h2 = t.distanceTo(0, 0, this._dx, this._dy), a3 = i3.CalculateBounceAngle(this._inst, this._lastX, this._lastY);
              this._dx = Math.cos(a3) * h2, this._dy = Math.sin(a3) * h2, s3.OffsetXY(this._dx * e2, this._dy * e2), s3.SetBboxChanged(), this._setAngle && (s3.SetAngle(a3), this._lastKnownAngle = s3.GetAngle(), s3.SetBboxChanged()), i3.PushOutSolid(this._inst, this._dx / h2, this._dy / h2, Math.max(2.5 * h2 * e2, 30)) || i3.PushOutSolidNearest(this._inst, 100);
            }
          }
          GetPropertyValueByIndex(t2) {
            switch (t2) {
              case i2:
                return this._GetSpeed();
              case n:
                return this._GetAcceleration();
              case h:
                return this._GetGravity();
              case _:
                return this._setAngle;
              case l2:
                return this._isStepping;
              case o2:
                return this._IsEnabled();
            }
          }
          SetPropertyValueByIndex(t2, e2) {
            switch (t2) {
              case i2:
                this._SetSpeed(e2);
                break;
              case n:
                this._acc = e2;
                break;
              case h:
                this._g = e2;
                break;
              case _:
                this._setAngle = !!e2;
                break;
              case l2:
                this._isStepping = !!e2;
                break;
              case o2:
                this._SetEnabled(!!e2);
            }
          }
          _SetSpeed(e2) {
            const s3 = t.angleTo(0, 0, this._dx, this._dy);
            this._dx = Math.cos(s3) * e2, this._dy = Math.sin(s3) * e2;
          }
          _GetSpeed() {
            return t.roundToDp(t.distanceTo(0, 0, this._dx, this._dy), 6);
          }
          _SetAcceleration(t2) {
            this._acc = t2;
          }
          _GetAcceleration() {
            return this._acc;
          }
          _SetGravity(t2) {
            this._g = t2;
          }
          _GetGravity() {
            return this._g;
          }
          _SetAngleOfMotion(e2) {
            const s3 = t.distanceTo(0, 0, this._dx, this._dy);
            this._dx = Math.cos(e2) * s3, this._dy = Math.sin(e2) * s3;
          }
          _GetAngleOfMotion() {
            return t.angleTo(0, 0, this._dx, this._dy);
          }
          _SetBounceOffSolids(t2) {
            t2 = !!t2, this._bounceOffSolid !== t2 && (this._bounceOffSolid = t2, this._isEnabled && (this._bounceOffSolid ? this._StartPostTicking() : this._StopPostTicking()));
          }
          _IsBounceOffSolids() {
            return this._bounceOffSolid;
          }
          _SetDistanceTravelled(t2) {
            this._travelled = t2;
          }
          _GetDistanceTravelled() {
            return this._travelled;
          }
          _SetEnabled(t2) {
            this._isEnabled = !!t2, this._isEnabled ? (this._StartTicking(), this._bounceOffSolid && this._StartPostTicking()) : (this._StopTicking(), this._StopPostTicking());
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          GetDebuggerProperties() {
            const e2 = "behaviors.bullet";
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e2 + ".debugger.vector-x", value: this._dx, onedit: (t2) => this._dx = t2 }, { name: e2 + ".debugger.vector-y", value: this._dy, onedit: (t2) => this._dy = t2 }, { name: e2 + ".properties.speed.name", value: this._GetSpeed(), onedit: (t2) => this._SetSpeed(t2) }, { name: e2 + ".debugger.angle-of-motion", value: t.toDegrees(this._GetAngleOfMotion()) }, { name: e2 + ".properties.gravity.name", value: this._GetGravity(), onedit: (t2) => this._SetGravity(t2) }, { name: e2 + ".properties.acceleration.name", value: this._GetAcceleration(), onedit: (t2) => this._SetAcceleration(t2) }, { name: e2 + ".debugger.distance-travelled", value: this._GetDistanceTravelled() }, { name: e2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (t2) => this._SetEnabled(t2) }] }];
          }
          GetScriptInterfaceClass() {
            return self.IBulletBehaviorInstance;
          }
        };
        const r2 = /* @__PURE__ */ new WeakMap();
        self.IBulletBehaviorInstance = class extends s2 {
          constructor() {
            super(), r2.set(this, s2._GetInitInst().GetSdkInstance());
          }
          get speed() {
            return r2.get(this)._GetSpeed();
          }
          set speed(t2) {
            e.RequireFiniteNumber(t2), r2.get(this)._SetSpeed(t2);
          }
          get acceleration() {
            return r2.get(this)._GetAcceleration();
          }
          set acceleration(t2) {
            e.RequireFiniteNumber(t2), r2.get(this)._SetAcceleration(t2);
          }
          get gravity() {
            return r2.get(this)._GetGravity();
          }
          set gravity(t2) {
            e.RequireFiniteNumber(t2), r2.get(this)._SetGravity(t2);
          }
          get angleOfMotion() {
            return r2.get(this)._GetAngleOfMotion();
          }
          set angleOfMotion(t2) {
            e.RequireFiniteNumber(t2), r2.get(this)._SetAngleOfMotion(t2);
          }
          get bounceOffSolids() {
            return r2.get(this)._IsBounceOffSolids();
          }
          set bounceOffSolids(t2) {
            r2.get(this)._SetBounceOffSolids(!!t2);
          }
          get distanceTravelled() {
            return r2.get(this)._GetDistanceTravelled();
          }
          set distanceTravelled(t2) {
            e.RequireFiniteNumber(t2), r2.get(this)._SetDistanceTravelled(t2);
          }
          get isEnabled() {
            return r2.get(this)._IsEnabled();
          }
          set isEnabled(t2) {
            r2.get(this)._SetEnabled(t2);
          }
        };
      }
      {
        const t = self.C3;
        t.Behaviors.Bullet.Cnds = { CompareSpeed(e, s2) {
          const i2 = Math.hypot(this._dx, this._dy);
          return t.compare(i2, e, s2);
        }, CompareTravelled(e, s2) {
          return t.compare(this._GetDistanceTravelled(), e, s2);
        }, OnStep: () => true, IsEnabled() {
          return this._IsEnabled();
        } };
      }
      {
        const t = self.C3;
        t.Behaviors.Bullet.Acts = { SetSpeed(t2) {
          this._SetSpeed(t2);
        }, SetAcceleration(t2) {
          this._SetAcceleration(t2);
        }, SetGravity(t2) {
          this._SetGravity(t2);
        }, SetAngleOfMotion(e) {
          this._SetAngleOfMotion(t.toRadians(e));
        }, Bounce(e) {
          if (!e) return;
          const s2 = e.GetFirstPicked(this._inst);
          if (!s2) return;
          const i2 = this._inst.GetWorldInfo(), n = this._runtime.GetCollisionEngine(), h = this._runtime.GetDt(this._inst), a2 = t.distanceTo(0, 0, this._dx, this._dy), _ = n.CalculateBounceAngle(this._inst, this._lastX, this._lastY, s2);
          this._dx = Math.cos(_) * a2, this._dy = Math.sin(_) * a2, i2.OffsetXY(this._dx * h, this._dy * h), i2.SetBboxChanged(), this._setAngle && (i2.SetAngle(_), this._lastKnownAngle = i2.GetAngle(), i2.SetBboxChanged()), 0 !== a2 && (this._bounceOffSolid ? n.PushOutSolid(this._inst, this._dx / a2, this._dy / a2, Math.max(2.5 * a2 * h, 30)) || n.PushOutSolidNearest(this._inst, 100) : n.PushOut(this._inst, this._dx / a2, this._dy / a2, Math.max(2.5 * a2 * h, 30), s2));
        }, SetBounceOffSolids(t2) {
          this._SetBounceOffSolids(t2);
        }, SetDistanceTravelled(t2) {
          this._SetDistanceTravelled(t2);
        }, SetEnabled(t2) {
          this._SetEnabled(t2);
        }, StopStepping() {
          this._stopStepping = true;
        } };
      }
      {
        const t = self.C3;
        t.Behaviors.Bullet.Exps = { Speed() {
          return this._GetSpeed();
        }, Acceleration() {
          return this._GetAcceleration();
        }, AngleOfMotion() {
          return t.toDegrees(this._GetAngleOfMotion());
        }, DistanceTravelled() {
          return this._GetDistanceTravelled();
        }, Gravity() {
          return this._GetGravity();
        } };
      }
    }
    {
      {
        const e = self.C3;
        e.Behaviors.destroy = class extends e.SDKBehaviorBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.destroy.Type = class extends e.SDKBehaviorTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.destroy.Instance = class extends e.SDKBehaviorInstanceBase {
          constructor(e2, s2) {
            super(e2), this._StartTicking();
          }
          Release() {
            super.Release();
          }
          Tick() {
            const e2 = this._inst.GetWorldInfo(), s2 = e2.GetBoundingBox(), t = e2.GetLayout();
            (s2.getRight() < 0 || s2.getBottom() < 0 || s2.getLeft() > t.GetWidth() || s2.getTop() > t.GetHeight()) && this._runtime.DestroyInstance(this._inst);
          }
        };
      }
      self.C3.Behaviors.destroy.Cnds = {};
      self.C3.Behaviors.destroy.Acts = {};
      self.C3.Behaviors.destroy.Exps = {};
    }
    {
      {
        const e = self.C3;
        e.Behaviors.Tween = class extends e.SDKBehaviorBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.Tween.Type = class extends e.SDKBehaviorTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3, s2 = e.Behaviors.Tween, t = 0;
        s2.Instance = class extends e.SDKBehaviorInstanceBase {
          constructor(e2, s3) {
            super(e2), this._allowMultiple = false, this._enabled = true, s3 && (this._allowMultiple = false, this._enabled = !!s3[t]), this._activeTweens = /* @__PURE__ */ new Map(), this._disabledTweens = [], this._waitingForReleaseTweens = /* @__PURE__ */ new Map(), this._finishingTween = null, this._activeTweensJson = null, this._disabledTweensJson = null, this._waitingForReleaseTweensJson = null, this._finishingTweenName = "", this._triggerTweens = [], this._afterLoad = (e3) => this._OnAfterLoad(), this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad);
          }
          Release() {
            this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad), this._afterLoad = null, this._finishingTween && (this.ReleaseAndCompleteTween(this._finishingTween), this._finishingTween = null), this.ReleaseAndCompleteTweens(), this._tweens = null, this.ClearDisabledList(), this._disabledTweens = null, this._ReleaseWaitingTweens(), this._waitingForReleaseTweens = null, this._triggerTweens = null, super.Release();
          }
          PushTriggerTween(e2) {
            this._triggerTweens.push(e2);
          }
          PopTriggerTween() {
            this._triggerTweens.pop();
          }
          GetTriggerTween() {
            return this._triggerTweens[this._triggerTweens.length - 1];
          }
          SetEnabled(e2) {
            this._enabled = !!e2, e2 ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();
            for (const s3 of this.AllTweens()) e2 ? this.IsInDisabledList(s3) && s3.Resume() : ((s3.IsPlaying() || s3.IsScheduled()) && this.AddToDisabledList(s3), s3.Stop());
            e2 && this.ClearDisabledList();
          }
          IsEnabled() {
            return this._enabled;
          }
          AddToDisabledList(e2) {
            this._disabledTweens.push(e2);
          }
          IsInDisabledList(e2) {
            return this._disabledTweens.includes(e2);
          }
          ClearDisabledList() {
            e.clearArray(this._disabledTweens);
          }
          GetFinishingTween() {
            return this._finishingTween;
          }
          IsInstanceValid() {
            const e2 = this.GetObjectInstance();
            return !!e2 && !e2.IsDestroyed();
          }
          GetTween(e2, s3, t2 = false) {
            const n = s3 ? this.PropertyTweens(s3, t2) : this.AllTweens(t2);
            if (n && n.length) {
              for (const s4 of n) if (s4.HasTags(e2)) return s4;
            }
          }
          CheckTweensWithTags(e2, s3) {
            for (const t2 of this._activeTweens.values()) for (const n of t2) if (!n.IsReleased() && n.HasTags(e2) && s3(n)) return true;
            for (const t2 of this._waitingForReleaseTweens.values()) for (const n of t2) if (!n.IsReleased() && n.HasTags(e2) && s3(n)) return true;
            return false;
          }
          CheckTweens(e2) {
            for (const s3 of this._activeTweens.values()) for (const t2 of s3) if (!t2.IsReleased() && e2(t2)) return true;
            for (const s3 of this._waitingForReleaseTweens.values()) for (const t2 of s3) if (!t2.IsReleased() && e2(t2)) return true;
            return false;
          }
          GetTweenIncludingWaitingForRelease(e2, s3) {
            return this.GetTween(e2, s3, true);
          }
          *GetTweens(e2, s3, t2 = false) {
            const n = s3 ? this.PropertyTweens(s3, t2) : this.AllTweens(t2);
            if (n && n.length) for (const s4 of n) s4.HasTags(e2) && (yield s4);
          }
          *GetTweensIncludingWaitingForRelease(e2, s3) {
            yield* this.GetTweens(e2, s3, true);
          }
          PropertyTweens(e2, s3) {
            if (s3) {
              let s4 = this._activeTweens.get(e2), t2 = this._waitingForReleaseTweens.get(e2);
              return s4 || (s4 = []), t2 || (t2 = []), s4.concat(t2).filter((e3) => e3).filter((e3) => !e3.IsReleased());
            }
            {
              let s4 = this._activeTweens.get(e2);
              return s4 || (s4 = []), s4.filter((e3) => e3).filter((e3) => !e3.IsReleased());
            }
          }
          AllTweens(e2) {
            if (e2) {
              const e3 = [...this._activeTweens.values()].flat(), s3 = [...this._waitingForReleaseTweens.values()].flat();
              return e3.concat(s3).filter((e4) => e4).filter((e4) => !e4.IsReleased());
            }
            return [...this._activeTweens.values()].flat().filter((e3) => e3).filter((e3) => !e3.IsReleased());
          }
          AllTweensIncludingWaitingForRelease() {
            return this.AllTweens(true);
          }
          SaveToJson(e2 = "full") {
            return { "s": false, "e": !!this._enabled, "at": this._SaveActiveTweensToJson(), "dt": this._SaveDisabledTweensToJson(), "wt": this._SaveWaitingForReleaseTweensToJson(), "ft": this._SaveFinishingTweenToJson() };
          }
          LoadFromJson(e2, s3 = "full") {
            e2 && (this._activeTweensJson = e2["at"], this._disabledTweensJson = e2["dt"], this._waitingForReleaseTweensJson = e2["wt"], this._finishingTweenName = e2["ft"], this._allowMultiple = false, this._enabled = !!e2["e"], "state" === s3 && this._OnAfterLoad());
          }
          _OnAfterLoad() {
            const s3 = this.GetRuntime().GetTimelineManager();
            if (this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, s3), this._disabledTweensJson) {
              e.clearArray(this._disabledTweens);
              for (const e2 of this._disabledTweensJson) this._PopulateTweenArray(this._disabledTweens, e2, s3);
            }
            this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, s3), this._finishingTween = this._GetTween(this._finishingTweenName, s3), this._enabled ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();
          }
          _PopulateTweenMap(s3, t2, n) {
            if (s3) for (const i2 in s3) {
              let a2 = t2.get(i2);
              a2 ? e.clearArray(a2) : a2 = [];
              const r2 = s3[i2];
              for (const s4 of r2) {
                if (this._PopulateTweenArray(a2, s4["name"], n)) this._LoadTweenFromJson(s4["name"], s4, n);
                else {
                  const t3 = e.TweenState.Build({ runtime: this.GetRuntime(), json: s4 });
                  e.TweenState.SetInstanceUID(t3, this.GetObjectInstance().GetUID()), t3.AddCompletedCallback((e2) => this._FinishTriggers(e2)), t3.SetBehaviorInstance(this), n.AddScheduledTimeline(t3), this._PopulateTweenArray(a2, t3, n);
                }
              }
              t2.set(i2, a2);
            }
          }
          _GetTween(e2, s3) {
            return s3.GetScheduledOrPlayingTimelineByName(e2);
          }
          _PopulateTweenArray(e2, s3, t2) {
            if ("string" != typeof s3) return !!e2.push(s3);
            {
              const n = this._GetTween(s3, t2);
              if (n) return !!e2.push(n);
            }
            return false;
          }
          _LoadTweenFromJson(s3, t2, n) {
            if ("string" == typeof s3) {
              const i2 = this._GetTween(s3, n);
              i2 && (i2._LoadFromJson(t2), e.TweenState.SetInstanceUID(i2, this.GetObjectInstance().GetUID()), e.TweenState.SetBehaviorInstance(i2, this));
            } else s3._LoadFromJson(t2), e.TweenState.SetInstanceUID(s3, this.GetObjectInstance().GetUID()), e.TweenState.SetBehaviorInstance(s3, this);
          }
          _SaveActiveTweensToJson() {
            const e2 = {};
            for (const [s3, t2] of this._activeTweens) e2[s3] = t2.filter((e3) => !e3.IsReleased()).map((e3) => e3._SaveToJson());
            return e2;
          }
          _SaveDisabledTweensToJson() {
            return this._disabledTweens.filter((e2) => !e2.IsReleased()).map((e2) => e2.GetName());
          }
          _SaveWaitingForReleaseTweensToJson() {
            const e2 = {};
            for (const [s3, t2] of this._waitingForReleaseTweens) e2[s3] = t2.map((e3) => e3._SaveToJson());
            return e2;
          }
          _SaveFinishingTweenToJson() {
            return this._finishingTween ? this._finishingTween.GetName() : "";
          }
          Tick2() {
            this._ReleaseWaitingTweens();
          }
          CreateTween(t2) {
            const n = s2.Config.GetPropertyTracksConfig(t2.property, t2.startValue, t2.endValue, t2.ease, t2.resultMode, this.GetObjectInstance()), i2 = s2.Maps.GetPropertyFromIndex(t2.property);
            s2.Maps.IsValueId(i2) || this.ReleaseTweens(t2.property);
            const a2 = e.TweenState.Build({ runtime: this.GetRuntime(), id: i2, tags: t2.tags, time: t2.time, instance: this.GetObjectInstance(), releaseOnComplete: !!t2.releaseOnComplete, loop: !!t2.loop, pingPong: !!t2.pingPong, repeatCount: t2.repeatCount, initialValueMode: t2.initialValueMode, propertyTracksConfig: n });
            return a2.AddCompletedCallback((e2) => this._FinishTriggers(e2)), a2.SetBehaviorInstance(this), this._AddTween(a2, t2.property), a2;
          }
          _MaybeRemoveFromActiveTweenMap(e2) {
            const s3 = e2.GetId();
            if (this._activeTweens.has(s3)) {
              const t2 = this._activeTweens.get(s3);
              if (t2) {
                const s4 = t2.indexOf(e2);
                -1 !== s4 && t2.splice(s4, 1);
              }
            }
          }
          ReleaseTween(e2, s3 = false) {
            this._MaybeRemoveFromActiveTweenMap(e2), e2.IsReleased() || this._IsInWaitingList(e2) || (e2.Stop(s3), this._AddToWaitingList(e2));
          }
          ReleaseTweens(t2, n = false) {
            if (e.IsFiniteNumber(t2)) {
              const i2 = s2.Maps.GetPropertyFromIndex(t2);
              if (!this._activeTweens.has(i2)) return;
              const a2 = this._activeTweens.get(i2), r2 = this.GetFinishingTween();
              for (const e2 of a2) e2 !== r2 && (e2.IsReleased() || this._IsInWaitingList(e2) || (e2.Stop(n), e2.Release()));
              e.clearArray(a2);
            } else {
              const s3 = this.GetFinishingTween();
              for (const e2 of this.AllTweens()) e2 !== s3 && (e2.IsReleased() || this._IsInWaitingList(e2) || (e2.Stop(n), e2.Release()));
              for (const s4 of this._activeTweens.keys()) e.clearArray(this._activeTweens.get(s4)), this._activeTweens.delete(s4);
              this._activeTweens.clear();
            }
          }
          ReleaseAndCompleteTween(e2) {
            this.ReleaseTween(e2, true);
          }
          ReleaseAndCompleteTweens() {
            this.ReleaseTweens(NaN, true);
          }
          GetPropertyValueByIndex(e2) {
            if (e2 === t) return this._enabled;
          }
          SetPropertyValueByIndex(e2, s3) {
            if (e2 === t) this._enabled = !!s3;
          }
          _GetBehaviorType(e2) {
            const s3 = e2.GetInstance().GetBehaviorInstances();
            for (const e3 of s3) {
              const s4 = e3.GetBehaviorType();
              if (s4.GetInstanceSdkCtor() === this.constructor) return s4;
            }
          }
          Trigger(e2, s3, t2, n) {
            return this._runtime ? super.Trigger(e2) : s3.Trigger(e2, t2, n);
          }
          _FinishTriggers(e2) {
            let t2, n;
            if (this._finishingTween = e2, s2.Cnds.SetFinishingTween(e2), this.GetRuntime()) t2 = this._inst, n = this._runtime, this.Trigger(s2.Cnds.OnTweensFinished), this.Trigger(s2.Cnds.OnAnyTweensFinished), this.ReleaseTween(e2);
            else {
              if (t2 = e2.GetInstance(), !t2) return;
              if (t2 && t2.IsDestroyed()) return;
              n = t2.GetRuntime();
              const i2 = this._GetBehaviorType(e2);
              this.Trigger(s2.Cnds.OnTweensFinished, n, t2, i2), this.Trigger(s2.Cnds.OnAnyTweensFinished, n, t2, i2), e2.Stop();
            }
            this._finishingTween = null, s2.Cnds.SetFinishingTween(null), e2.GetDestroyInstanceOnComplete() && n.DestroyInstance(t2);
          }
          _AddTween(e2, t2) {
            const n = s2.Maps.GetPropertyFromIndex(t2);
            this._activeTweens.has(n) || this._activeTweens.set(n, []);
            this._activeTweens.get(n).push(e2);
          }
          _AddToWaitingList(e2) {
            const s3 = e2.GetId();
            this._waitingForReleaseTweens.has(s3) || this._waitingForReleaseTweens.set(s3, []), this._waitingForReleaseTweens.get(s3).push(e2), this.IsTicking2() || this._StartTicking2();
          }
          _IsInWaitingList(e2) {
            const s3 = e2.GetId();
            return !!this._waitingForReleaseTweens.has(s3) && this._waitingForReleaseTweens.get(s3).includes(e2);
          }
          _ReleaseWaitingTweens() {
            if (this._waitingForReleaseTweens.size) {
              for (const s3 of this._waitingForReleaseTweens.values()) {
                for (const e2 of s3) e2.IsReleased() || e2.Release();
                e.clearArray(s3);
              }
              this._waitingForReleaseTweens.clear(), this.IsTicking2() && this._StopTicking2();
            }
          }
          GetDebuggerProperties() {
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: "behaviors.tween.properties.enabled.name", value: this.IsEnabled(), onedit: (e2) => this.SetEnabled(e2) }] }];
          }
          GetScriptInterfaceClass() {
            return self.ITweenBehaviorInstance;
          }
        };
      }
      {
        const e = self.C3;
        let s2 = null;
        e.Behaviors.Tween.Cnds = { OnAnyTweenLoop: () => true, OnTweensLoop(e2) {
          const s3 = this.GetTriggerTween();
          return !!s3 && s3.HasTags(e2);
        }, OnAnyTweenPingPong(e2) {
          const s3 = this.GetTriggerTween();
          return !!s3 && (s3.GetPingPongState() === e2 || 2 === e2);
        }, OnTweensPingPong(e2, s3) {
          const t = this.GetTriggerTween();
          return !!t && ((t.GetPingPongState() === s3 || 2 === s3) && t.HasTags(e2));
        }, SetFinishingTween(e2) {
          s2 = e2;
        }, OnTweensFinished: (e2) => s2.HasTags(e2), OnAnyTweensFinished: () => true, IsPlaying(s3) {
          return this.CheckTweensWithTags(s3, e.TweenState.IsPlaying);
        }, IsAnyPlaying() {
          return this.CheckTweens(e.TweenState.IsPlaying);
        }, IsPaused(s3) {
          return this.CheckTweensWithTags(s3, e.TweenState.IsPaused);
        }, IsAnyPaused() {
          return this.CheckTweens(e.TweenState.IsPaused);
        }, IsPingPong(s3, t) {
          return 0 === t ? this.CheckTweensWithTags(s3, e.TweenState.IsPing) : 1 === t && this.CheckTweensWithTags(s3, e.TweenState.IsPong);
        }, IsAnyPingPong(s3) {
          return 0 === s3 ? this.CheckTweens(e.TweenState.IsPing) : 1 === s3 && this.CheckTweens(e.TweenState.IsPong);
        } };
      }
      {
        const e = self.C3, s2 = self.Ease, t = e.Behaviors.Tween;
        t.Acts = { SetEnabled(e2) {
          this.SetEnabled(!!e2);
        }, async TweenOneProperty(...e2) {
          if (!this.IsEnabled() || !this.IsInstanceValid()) return;
          const s3 = this.CreateTween(t.TweenArguments.OneProperty(this, ...e2));
          s3.Play() && await s3.GetPlayPromise();
        }, async TweenTwoProperties(...e2) {
          if (!this.IsEnabled() || !this.IsInstanceValid()) return;
          const s3 = this.CreateTween(t.TweenArguments.TwoProperties(this, ...e2));
          s3.Play() && await s3.GetPlayPromise();
        }, async TweenValue(...e2) {
          if (!this.IsEnabled() || !this.IsInstanceValid()) return;
          const s3 = this.CreateTween(t.TweenArguments.ValueProperty(this, ...e2));
          s3.Play() && await s3.GetPlayPromise();
        }, PauseTweens(e2) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s3 of this.GetTweens(e2)) s3.Stop();
        }, PauseAllTweens() {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const e2 of this.AllTweens()) e2.Stop();
        }, ResumeTweens(e2) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s3 of this.GetTweens(e2)) s3.Resume();
        }, ResumeAllTweens() {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const e2 of this.AllTweens()) e2.Resume();
        }, StopTweens(e2) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s3 of this.GetTweens(e2)) this.ReleaseTween(s3);
        }, StopAllTweens() {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const e2 of this.AllTweens()) this.ReleaseTween(e2);
        }, SetOnePropertyTweensEndValue(s3, t2, n) {
          if (!this.IsEnabled() || !this.IsInstanceValid()) return;
          const i2 = e.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(t2);
          for (const e2 of this.GetTweens(s3)) e2.BeforeSetEndValues([i2]), e2.SetEndValue(n, i2);
        }, SetTwoPropertiesTweensEndValue(s3, t2, n, i2) {
          if (!this.IsEnabled() || !this.IsInstanceValid()) return;
          const a2 = e.Behaviors.Tween.Maps.GetRealProperties(t2);
          for (const e2 of this.GetTweens(s3)) e2.BeforeSetEndValues(a2), e2.SetEndValue(n, a2[0]), e2.SetEndValue(i2, a2[1]);
        }, SetValuePropertyTweensStartValue(e2, s3) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2, "value")) t2.SetStartValue(s3, "value");
        }, SetValuePropertyTweensEndValue(e2, s3) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2, "value")) t2.BeforeSetEndValues(["value"]), t2.SetEndValue(s3, "value");
        }, SetTweensEase(e2, t2) {
          if (!this.IsEnabled() || !this.IsInstanceValid()) return;
          const n = s2.GetEaseFromIndex(t2);
          for (const s3 of this.GetTweens(e2)) s3.SetEase(n);
        }, SetAllTweensEase(e2) {
          if (!this.IsEnabled() || !this.IsInstanceValid()) return;
          const t2 = s2.GetEaseFromIndex(e2);
          for (const e3 of this.AllTweens()) e3.SetEase(t2);
        }, SetTweensTime(e2, s3) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2)) t2.SetTime(s3);
        }, SetAllTweensTime(e2) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s3 of this.AllTweens()) s3.SetTime(e2);
        }, SetTweensPlaybackRate(e2, s3) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2)) t2.SetPlaybackRate(s3);
        }, SetAllTweensPlaybackRate(e2) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s3 of this.AllTweens()) s3.SetPlaybackRate(e2);
        }, SetTweensDestroyOnComplete(e2, s3) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2)) t2.SetDestroyInstanceOnComplete(!!s3);
        }, SetAllTweensDestroyOnComplete(e2) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s3 of this.AllTweens()) s3.SetDestroyInstanceOnComplete(!!e2);
        } };
      }
      self.C3.Behaviors.Tween.Exps = { Time(e) {
        const s2 = this.GetTweenIncludingWaitingForRelease(e);
        return s2 ? s2.GetTime() : 0;
      }, Progress(e) {
        const s2 = this.GetTweenIncludingWaitingForRelease(e);
        return s2 ? s2.GetTime() / s2.GetTotalTime() : 0;
      }, PlaybackRate(e) {
        const s2 = this.GetTweenIncludingWaitingForRelease(e);
        return s2 ? s2.GetPlaybackRate() : 0;
      }, Value(e) {
        const s2 = this.GetTweenIncludingWaitingForRelease(e, "value");
        return s2 ? s2.GetPropertyTrack("value").GetSourceAdapterValue() : 0;
      }, Tags() {
        let e = this.GetFinishingTween();
        return e ? e.GetStringTags() : (e = this.GetTriggerTween(), e ? e.GetStringTags() : "");
      } };
    }
    {
      const C33 = self.C3, Ease = self.Ease, PAIR_PROPERTIES = ["position", "size", "scale"], SINGLE_PROPERTIES = ["offsetX", "offsetY", "offsetWidth", "offsetHeight", "offsetAngle", "offsetOpacity", "offsetColor", "offsetZElevation", "offsetScaleX", "offsetScaleY"], VALUE_PROPERTIES = ["value"], PROPERTY_INDEX_TO_NAME = [].concat(PAIR_PROPERTIES).concat(SINGLE_PROPERTIES).concat(VALUE_PROPERTIES), PROPERTY_PAIR_TO_REAL_PROPERTIES = { "position": ["offsetX", "offsetY"], "size": ["offsetWidth", "offsetHeight"], "scale": ["offsetScaleX", "offsetScaleY"] }, ALL_REAL_PROPERTIES = Object.assign({}, PROPERTY_INDEX_TO_NAME.reduce((e, t) => Object.assign({}, e, { [t]: [t] }), {}), PROPERTY_PAIR_TO_REAL_PROPERTIES);
      C33.Behaviors.Tween.Maps = class {
        constructor() {
        }
        static GetEases() {
          return [...Ease.GetRuntimeEaseNames()];
        }
        static GetEaseFromIndex(e) {
          return [...Ease.GetRuntimeEaseNames()][e];
        }
        static GetPropertyFromIndex(e) {
          return PROPERTY_INDEX_TO_NAME[e];
        }
        static GetPropertyIndexFromName(e) {
          return PROPERTY_INDEX_TO_NAME.indexOf(e);
        }
        static GetPairPropertyFromIndex(e) {
          return PAIR_PROPERTIES[e];
        }
        static GetSinglePropertyFromIndex(e) {
          return SINGLE_PROPERTIES[e];
        }
        static GetValuePropertyFromIndex(e) {
          return VALUE_PROPERTIES[e];
        }
        static GetPairProperties(e) {
          return PROPERTY_PAIR_TO_REAL_PROPERTIES[e];
        }
        static GetRealProperties(e) {
          return C33.IsString(e) ? ALL_REAL_PROPERTIES[e] : ALL_REAL_PROPERTIES[PROPERTY_INDEX_TO_NAME[e]];
        }
        static IsPairId(e) {
          return !!PROPERTY_PAIR_TO_REAL_PROPERTIES[e];
        }
        static IsColorId(e) {
          return "offsetColor" === e;
        }
        static IsAngleId(e) {
          return "offsetAngle" === e;
        }
        static IsOpacityId(e) {
          return "offsetOpacity" === e;
        }
        static IsValueId(e) {
          return "value" === e;
        }
      };
    }
    {
      const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween, TWEEN_CONFIGURATIONS = /* @__PURE__ */ new Map();
      NAMESPACE.Config = class {
        constructor() {
        }
        static GetPropertyTracksConfig(e, t, r2, o2, a2, s2) {
          0 === TWEEN_CONFIGURATIONS.size && this._CreateConfigObjects();
          const n = NAMESPACE.PropertyTypes.Pick(e);
          let i2 = TWEEN_CONFIGURATIONS.get(n);
          return C33.IsFiniteNumber(e) && (e = NAMESPACE.Maps.GetPropertyFromIndex(e)), this._GetConfig(i2, e, t, r2, o2, a2, s2);
        }
        static TransformValue(e, t) {
          return C33.Behaviors.Tween.GetPropertyTracksConfig(e).valueGetter(t);
        }
        static _CreateConfigObjects() {
          const e = NAMESPACE.PropertyTypes, t = NAMESPACE.ValueGetters;
          this._AddConfigObject(e.PAIR, this._GetPairConfig, t._GetPropertyValue), this._AddConfigObject(e.COLOR, this._GetColorConfig, t._GetColorPropertyValue), this._AddConfigObject(e.ANGLE, this._GetAngleConfig, t._GetPropertyAngleValue), this._AddConfigObject(e.VALUE, this._GetValueConfig, t._GetPropertyValue), this._AddConfigObject(e.OTHER, this._GetCommonConfig, t._GetPropertyValue);
        }
        static _AddConfigObject(e, t, r2) {
          TWEEN_CONFIGURATIONS.set(e, this._CreateConfigObject(e, t, r2));
        }
        static _CreateConfigObject(e, t, r2) {
          return { name: e, configFunc: t, valueGetter: r2 };
        }
        static _GetConfig(e, t, r2, o2, a2, s2, n) {
          return e.configFunc(t, e.valueGetter(r2), e.valueGetter(o2), a2, s2, n);
        }
        static _GetPairConfig(e, t, r2, o2, a2, s2) {
          return NAMESPACE.Maps.GetPairProperties(e).map((e2, s3) => ({ sourceId: "world-instance", property: e2, type: "float", valueType: "numeric", startValue: t[s3], endValue: r2[s3], ease: NAMESPACE.Maps.GetEaseFromIndex(o2), resultMode: a2 }));
        }
        static _GetColorConfig(e, t, r2, o2, a2, s2) {
          return C33.Plugins.Text && s2.GetPlugin() instanceof C33.Plugins.Text ? { sourceId: "plugin", sourceArgs: [7], property: "color", type: "color", valueType: "color", startValue: t, endValue: r2, ease: NAMESPACE.Maps.GetEaseFromIndex(o2), resultMode: a2 } : { sourceId: "world-instance", property: e, type: "color", valueType: "color", startValue: t, endValue: r2, ease: NAMESPACE.Maps.GetEaseFromIndex(o2), resultMode: a2 };
        }
        static _GetAngleConfig(e, t, r2, o2, a2, s2) {
          return { sourceId: "world-instance", property: e, type: "angle", valueType: "angle", startValue: t, endValue: r2, ease: NAMESPACE.Maps.GetEaseFromIndex(o2), resultMode: a2 };
        }
        static _GetCommonConfig(e, t, r2, o2, a2, s2) {
          return { sourceId: "world-instance", property: e, type: "float", valueType: "numeric", startValue: t, endValue: r2, ease: NAMESPACE.Maps.GetEaseFromIndex(o2), resultMode: a2 };
        }
        static _GetValueConfig(e, t, r2, o2, a2, s2) {
          return { sourceId: "value", property: e, type: "float", valueType: "numeric", startValue: t, endValue: r2, ease: NAMESPACE.Maps.GetEaseFromIndex(o2), resultMode: a2 };
        }
      };
    }
    {
      const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween, COMMON_FIXED_ARGS = { resultMode: "absolute" }, COMMON_VARIABLE_ARGS = Object.assign({}, COMMON_FIXED_ARGS, { tags: "", property: "", time: 0, ease: 0, releaseOnComplete: 0, loop: false, pingPong: false, repeatCount: 1 }), ONE_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: "current-state", startValue: 0, endValue: 0 }), TWO_PROPERTIES_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: "current-state", startValue: [0, 0], endValue: [0, 0] }), COLOR_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: "current-state", startValue: [0, 0, 0], endValue: [0, 0, 0] }), VALUE_PROPERTY_ARGS = Object.assign({}, ONE_PROPERTY_ARGS, { initialValueMode: "start-value" }), X = 0, Y = 1, R = 0, G = 1, B = 2;
      NAMESPACE.TweenArguments = class {
        constructor() {
        }
        static _SetCommonProperties(e, t, R2, r2, P, a2, E, O) {
          e.tags = t, e.time = R2, e.ease = r2, e.releaseOnComplete = P, e.loop = a2, e.pingPong = E, e.repeatCount = O;
        }
        static OneProperty(e, t, R2, r2, P, a2, E, O, A, _) {
          const o2 = "string" == typeof R2 ? R2 : NAMESPACE.Maps.GetSinglePropertyFromIndex(R2), s2 = NAMESPACE.Maps.IsColorId(o2) ? COLOR_PROPERTY_ARGS : ONE_PROPERTY_ARGS;
          return this._SetCommonProperties(s2, t, P, a2, E, O, A, _), NAMESPACE.Maps.IsColorId(o2) ? (COLOR_PROPERTY_ARGS.endValue[0] = C33.GetRValue(r2), COLOR_PROPERTY_ARGS.endValue[1] = C33.GetGValue(r2), COLOR_PROPERTY_ARGS.endValue[2] = C33.GetBValue(r2), COLOR_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(o2)) : NAMESPACE.Maps.IsOpacityId(o2) ? ONE_PROPERTY_ARGS.endValue = r2 / 100 : ONE_PROPERTY_ARGS.endValue = r2, s2.property = NAMESPACE.Maps.GetPropertyIndexFromName(o2), s2;
        }
        static TwoProperties(e, t, R2, r2, P, a2, E, O, A, _, o2) {
          this._SetCommonProperties(TWO_PROPERTIES_ARGS, t, a2, E, O, A, _, o2);
          const s2 = "string" == typeof R2 ? R2 : NAMESPACE.Maps.GetPairPropertyFromIndex(R2);
          return TWO_PROPERTIES_ARGS.endValue[0] = r2, TWO_PROPERTIES_ARGS.endValue[1] = P, TWO_PROPERTIES_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(s2), TWO_PROPERTIES_ARGS;
        }
        static ValueProperty(e, t, R2, r2, P, a2, E, O, A, _) {
          return this._SetCommonProperties(VALUE_PROPERTY_ARGS, t, P, a2, E, O, A, _), VALUE_PROPERTY_ARGS.startValue = R2, VALUE_PROPERTY_ARGS.endValue = r2, VALUE_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName("value"), VALUE_PROPERTY_ARGS;
        }
      };
    }
    {
      const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween, TYPE_CHECK_OBJECTS = [];
      NAMESPACE.PropertyTypes = class {
        constructor() {
        }
        static Pick(t) {
          if (0 === TYPE_CHECK_OBJECTS.length) {
            const t2 = TYPE_CHECK_OBJECTS;
            t2.push({ checkFunc: NAMESPACE.Maps.IsPairId, result: this.PAIR }), t2.push({ checkFunc: NAMESPACE.Maps.IsColorId, result: this.COLOR }), t2.push({ checkFunc: NAMESPACE.Maps.IsAngleId, result: this.ANGLE }), t2.push({ checkFunc: NAMESPACE.Maps.IsValueId, result: this.VALUE }), t2.push({ checkFunc: () => true, result: this.OTHER });
          }
          C33.IsFiniteNumber(t) && (t = C33.Behaviors.Tween.Maps.GetPropertyFromIndex(t));
          for (const e of TYPE_CHECK_OBJECTS) if (e.checkFunc(t)) return e.result;
        }
        static get PAIR() {
          return "pair";
        }
        static get COLOR() {
          return "color";
        }
        static get ANGLE() {
          return "angle";
        }
        static get VALUE() {
          return "value";
        }
        static get OTHER() {
          return "other";
        }
      };
    }
    {
      const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween;
      NAMESPACE.ValueGetters = class {
        constructor() {
        }
        static _GetPropertyAngleValue(e) {
          const t = C33.toRadians(parseFloat(e));
          return C33.clampAngle(t);
        }
        static _GetColorPropertyValue(e) {
          return e.slice(0);
        }
        static _GetPropertyValue(e) {
          return e;
        }
      };
    }
    {
      let getIndexForEase2 = function(e) {
        C3X.RequireString(e);
        const t = Ease.ToInternal(e);
        let n;
        if (n = t ? Ease.GetIndexForEase(t, null) : Ease.GetIndexForEase(e, null), -1 === n) throw new Error(`invalid ease name '${e}'`);
        return n;
      }, ValidateTags2 = function(e, t = false) {
        if (!(t && null == e || "string" == typeof e || Array.isArray(e))) throw new Error("invalid tags");
      };
      getIndexForEase = getIndexForEase2, ValidateTags = ValidateTags2;
      const C33 = self.C3, C3X = self.C3X, IBehaviorInstance = self.IBehaviorInstance, Ease = self.Ease, NAMESPACE = C33.Behaviors.Tween, map = /* @__PURE__ */ new WeakMap(), TWEEN_PROPERTIES = /* @__PURE__ */ new Map([["x", { name: "offsetX", type: "one" }], ["y", { name: "offsetY", type: "one" }], ["width", { name: "offsetWidth", type: "one" }], ["height", { name: "offsetHeight", type: "one" }], ["angle", { name: "offsetAngle", type: "one" }], ["opacity", { name: "offsetOpacity", type: "one" }], ["color", { name: "offsetColor", type: "color" }], ["z-elevation", { name: "offsetZElevation", type: "one" }], ["x-scale", { name: "offsetScaleX", type: "one" }], ["y-scale", { name: "offsetScaleY", type: "one" }], ["position", { name: "position", type: "two" }], ["size", { name: "size", type: "two" }], ["scale", { name: "scale", type: "two" }], ["value", { name: "value", type: "value" }]]);
      const TWEEN_OPTS = { tags: "", destroyOnComplete: false, loop: false, pingPong: false, repeatCount: 1, startValue: 0 }, I_TWEEN_OPTS = { easeToIndexFunc: getIndexForEase2 };
      self.ITweenBehaviorInstance = class extends IBehaviorInstance {
        constructor() {
          super(), map.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance());
        }
        startTween(e, t, n, a2, o2) {
          const s2 = map.get(this);
          if (!s2.IsEnabled() || !s2.IsInstanceValid()) return null;
          const r2 = TWEEN_PROPERTIES.get(e);
          if (!r2) throw new Error("invalid tween property");
          "one" === r2.type || "value" === r2.type ? C3X.RequireNumber(t) : (C3X.RequireArray(t), "two" === r2.type ? (C3X.RequireNumber(t[0]), C3X.RequireNumber(t[1])) : "color" === r2.type && (C3X.RequireNumber(t[0]), C3X.RequireNumber(t[1]), C3X.RequireNumber(t[2]))), "angle" === e ? t = C33.toDegrees(t) : "opacity" === e ? t *= 100 : "color" === e && (t = C33.PackRGBEx(t[0], t[1], t[2]));
          const i2 = getIndexForEase2(a2);
          let l2;
          if (C3X.RequireFiniteNumber(n), o2 = Object.assign({}, TWEEN_OPTS, o2), "value" === r2.type && C3X.RequireNumber(o2.startValue), ValidateTags2(o2.tags, true), "one" === r2.type || "color" === r2.type ? l2 = s2.CreateTween(NAMESPACE.TweenArguments.OneProperty(s2, o2.tags, r2.name, t, n, i2, !!o2.destroyOnComplete, !!o2.loop, !!o2.pingPong, o2.repeatCount)) : "two" === r2.type ? l2 = s2.CreateTween(NAMESPACE.TweenArguments.TwoProperties(s2, o2.tags, r2.name, t[0], t[1], n, i2, !!o2.destroyOnComplete, !!o2.loop, !!o2.pingPong, o2.repeatCount)) : "value" === r2.type && (l2 = s2.CreateTween(NAMESPACE.TweenArguments.ValueProperty(s2, o2.tags, o2.startValue, t, n, i2, !!o2.destroyOnComplete, !!o2.loop, !!o2.pingPong, o2.repeatCount))), l2.SetBehaviorInstance(s2.GetBehaviorInstance().GetSdkInstance()), !l2.Play()) throw new Error("failed to start tween");
          return l2.GetITweenState(s2, I_TWEEN_OPTS);
        }
        *allTweens() {
          const e = map.get(this);
          for (const t of e.AllTweens()) yield t.GetITweenState(e, I_TWEEN_OPTS);
        }
        *tweensByTags(e) {
          ValidateTags2(e);
          const t = map.get(this);
          for (const n of t.GetTweens(e)) yield n.GetITweenState(t, I_TWEEN_OPTS);
        }
        get isEnabled() {
          return map.get(this).IsEnabled();
        }
        set isEnabled(e) {
          map.get(this).SetEnabled(e);
        }
      };
    }
    var getIndexForEase;
    var ValidateTags;
    {
      {
        const t = self.C3;
        t.Behaviors.Fade = class extends t.SDKBehaviorBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Behaviors.Fade.Type = class extends t.SDKBehaviorTypeBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const t = self.C3, e = self.C3X, i2 = self.IBehaviorInstance, s2 = 0, a2 = 1, h = 2, r2 = 3, n = 4;
        t.Behaviors.Fade.Instance = class extends t.SDKBehaviorInstanceBase {
          constructor(e2, i3) {
            super(e2), this._fadeInTime = 0, this._waitTime = 0, this._fadeOutTime = 0, this._destroy = true, this._activeAtStart = true, this._setMaxOpacity = false, this._stage = 0, this._stageTime = t.New(t.KahanSum), this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1, i3 && (this._fadeInTime = i3[s2], this._waitTime = i3[a2], this._fadeOutTime = i3[h], this._destroy = !!i3[r2], this._activeAtStart = !!i3[n], this._stage = this._activeAtStart ? 0 : 3), this._activeAtStart && (0 === this._fadeInTime ? (this._stage = 1, 0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0), this._runtime.UpdateRender())), this._StartTicking();
          }
          Release() {
            super.Release();
          }
          SaveToJson() {
            return { "fit": this._fadeInTime, "wt": this._waitTime, "fot": this._fadeOutTime, "d": this._destroy, "s": this._stage, "st": this._stageTime.Get(), "mo": this._maxOpacity };
          }
          LoadFromJson(t2) {
            this._fadeInTime = t2["fit"], this._waitTime = t2["wt"], this._fadeOutTime = t2["fot"], this._destroy = t2["d"], this._stage = t2["s"], this._stageTime.Set(t2["st"]), this._maxOpacity = t2["mo"], 3 === this._stage ? this._StopTicking() : this._StartTicking();
          }
          Tick() {
            const e2 = this._runtime.GetDt(this._inst);
            this._stageTime.Add(e2);
            const i3 = this._inst.GetWorldInfo();
            0 === this._stage && (i3.SetOpacity(this._stageTime.Get() / this._fadeInTime * this._maxOpacity), this._runtime.UpdateRender(), i3.GetOpacity() >= this._maxOpacity && (i3.SetOpacity(this._maxOpacity), this._stage = 1, this._stageTime.Reset(), this.DispatchScriptEvent("fadeinend"), this.Trigger(t.Behaviors.Fade.Cnds.OnFadeInEnd))), 1 === this._stage && this._stageTime.Get() >= this._waitTime && (this._stage = 2, this._stageTime.Reset(), this.DispatchScriptEvent("waitend"), this.Trigger(t.Behaviors.Fade.Cnds.OnWaitEnd)), 2 === this._stage && (0 !== this._fadeOutTime ? (i3.SetOpacity(this._maxOpacity - this._stageTime.Get() / this._fadeOutTime * this._maxOpacity), this._runtime.UpdateRender(), i3.GetOpacity() <= 0 && (this._stage = 3, this._stageTime.Reset(), this.DispatchScriptEvent("fadeoutend"), this.Trigger(t.Behaviors.Fade.Cnds.OnFadeOutEnd), this._destroy && this._runtime.DestroyInstance(this._inst))) : (this._stage = 3, this._stageTime.Reset())), 3 === this._stage && this._StopTicking();
          }
          _StartFade() {
            this._activeAtStart || this._setMaxOpacity || (this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1, this._setMaxOpacity = true), 3 === this._stage && this.Start();
          }
          _RestartFade() {
            this.Start();
          }
          Start() {
            this._stage = 0, this._stageTime.Reset(), 0 === this._fadeInTime ? (this._stage = 1, 0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0), this._runtime.UpdateRender()), this._StartTicking();
          }
          _SetFadeInTime(t2) {
            this._fadeInTime = Math.max(t2, 0);
          }
          _GetFadeInTime() {
            return this._fadeInTime;
          }
          _SetWaitTime(t2) {
            this._waitTime = Math.max(t2, 0);
          }
          _GetWaitTime() {
            return this._waitTime;
          }
          _SetFadeOutTime(t2) {
            this._fadeOutTime = Math.max(t2, 0);
          }
          _GetFadeOutTime() {
            return this._fadeOutTime;
          }
          GetPropertyValueByIndex(t2) {
            switch (t2) {
              case s2:
                return this._GetFadeInTime();
              case a2:
                return this._GetWaitTime();
              case h:
                return this._GetFadeOutTime();
              case r2:
                return this._destroy;
            }
          }
          SetPropertyValueByIndex(t2, e2) {
            switch (t2) {
              case s2:
                this._SetFadeInTime(e2);
                break;
              case a2:
                this._SetWaitTime(e2);
                break;
              case h:
                this._SetFadeOutTime(e2);
                break;
              case r2:
                this._destroy = !!e2;
            }
          }
          GetDebuggerProperties() {
            const t2 = "behaviors.fade";
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t2 + ".properties.fade-in-time.name", value: this._GetFadeInTime(), onedit: (t3) => this._SetFadeInTime(t3) }, { name: t2 + ".properties.wait-time.name", value: this._GetWaitTime(), onedit: (t3) => this._SetWaitTime(t3) }, { name: t2 + ".properties.fade-out-time.name", value: this._GetFadeOutTime(), onedit: (t3) => this._SetFadeOutTime(t3) }, { name: t2 + ".debugger.stage", value: [t2 + ".debugger." + ["fade-in", "wait", "fade-out", "done"][this._stage]] }] }];
          }
          GetScriptInterfaceClass() {
            return self.IFadeBehaviorInstance;
          }
        };
        const _ = /* @__PURE__ */ new WeakMap();
        self.IFadeBehaviorInstance = class extends i2 {
          constructor() {
            super(), _.set(this, i2._GetInitInst().GetSdkInstance());
          }
          startFade() {
            _.get(this)._StartFade();
          }
          restartFade() {
            _.get(this)._RestartFade();
          }
          set fadeInTime(t2) {
            e.RequireFiniteNumber(t2), _.get(this)._SetFadeInTime(t2);
          }
          get fadeInTime() {
            return _.get(this)._GetFadeInTime();
          }
          set waitTime(t2) {
            e.RequireFiniteNumber(t2), _.get(this)._SetWaitTime(t2);
          }
          get waitTime() {
            return _.get(this)._GetWaitTime();
          }
          set fadeOutTime(t2) {
            e.RequireFiniteNumber(t2), _.get(this)._SetFadeOutTime(t2);
          }
          get fadeOutTime() {
            return _.get(this)._GetFadeOutTime();
          }
        };
      }
      self.C3.Behaviors.Fade.Cnds = { OnFadeOutEnd: () => true, OnFadeInEnd: () => true, OnWaitEnd: () => true };
      self.C3.Behaviors.Fade.Acts = { StartFade() {
        this._StartFade();
      }, RestartFade() {
        this._RestartFade();
      }, SetFadeInTime(t) {
        this._SetFadeInTime(t);
      }, SetWaitTime(t) {
        this._SetWaitTime(t);
      }, SetFadeOutTime(t) {
        this._SetFadeOutTime(t);
      } };
      self.C3.Behaviors.Fade.Exps = { FadeInTime() {
        return this._GetFadeInTime();
      }, WaitTime() {
        return this._GetWaitTime();
      }, FadeOutTime() {
        return this._GetFadeOutTime();
      } };
    }
    {
      {
        const e = self.C3;
        e.Behaviors.MoveTo = class extends e.SDKBehaviorBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.MoveTo.Type = class extends e.SDKBehaviorTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3, t = self.C3X, i2 = self.IBehaviorInstance, s2 = 0, n = 1, a2 = 2, o2 = 3, r2 = 4, h = 5, _ = 6;
        e.Behaviors.MoveTo.Instance = class extends e.SDKBehaviorInstanceBase {
          constructor(t2, i3) {
            super(t2), this._maxSpeed = 200, this._acc = 600, this._dec = 600, this._rotateSpeed = 0, this._setAngle = true, this._stopOnSolids = false, this._isEnabled = true, this._speed = 0, this._movingAngle = this.GetWorldInfo().GetAngle(), this._waypoints = [], i3 && (this._maxSpeed = i3[s2], this._acc = i3[n], this._dec = i3[a2], this._rotateSpeed = e.toRadians(i3[o2]), this._setAngle = i3[r2], this._stopOnSolids = i3[h], this._isEnabled = i3[_]), this._timelineInfo = null, this._lastTargetX = NaN, this._lastTargetY = NaN, this._lastTargetAngle = NaN, this._tRange = [0, 0], this._timelineInfoProjectionRange = { tRange: this._tRange };
          }
          Release() {
            this._timelineInfo && (this._timelineInfo.Release(), this._timelineInfo = null), this._lastTargetX = NaN, this._lastTargetY = NaN, this._lastTargetAngle = NaN, this._tRange = null, this._timelineInfoProjectionRange = null, super.Release();
          }
          SaveToJson() {
            return { "ms": this._maxSpeed, "acc": this._acc, "dec": this._dec, "rs": this._rotateSpeed, "sa": this._setAngle, "sos": this._stopOnSolids, "s": this._speed, "ma": this._movingAngle, "wp": this._waypoints.map((e2) => ({ "x": e2.x, "y": e2.y })), "e": this._isEnabled };
          }
          LoadFromJson(e2) {
            this._maxSpeed = e2["ms"], this._acc = e2["acc"], this._dec = e2["dec"], this._rotateSpeed = e2["rs"], this._setAngle = e2["sa"], this._stopOnSolids = e2["sos"], this._speed = e2["s"], this._movingAngle = e2["ma"], this._waypoints = e2["wp"].map((e3) => ({ x: e3["x"], y: e3["y"] })), this._SetEnabled(e2["e"]), this._isEnabled && this._waypoints.length > 0 && this._StartTicking();
          }
          _AddWaypoint(t2, i3, s3, n2) {
            s3 && e.clearArray(this._waypoints), this._waypoints.push({ x: t2, y: i3, opts: n2 }), this._isEnabled && this._StartTicking();
          }
          _GetWaypointCount() {
            return this._waypoints.length;
          }
          _GetWaypointXAt(e2) {
            return (e2 = Math.floor(e2)) < 0 || e2 >= this._waypoints.length ? 0 : this._waypoints[e2].x;
          }
          _GetWaypointYAt(e2) {
            return (e2 = Math.floor(e2)) < 0 || e2 >= this._waypoints.length ? 0 : this._waypoints[e2].y;
          }
          _IsMoving() {
            return this._waypoints.length > 0;
          }
          _Stop() {
            e.clearArray(this._waypoints), this._speed = 0, this._StopTicking();
          }
          _GetTargetX() {
            return this._waypoints.length > 0 ? this._waypoints[0].x : 0;
          }
          _GetTargetY() {
            return this._waypoints.length > 0 ? this._waypoints[0].y : 0;
          }
          _GetTargetIsBezier() {
            if (this._waypoints.length > 0) {
              const e2 = this._waypoints[0];
              if (e2.opts) return e2.opts.isBezier;
            }
            return false;
          }
          _GetTargetIsBezierFirst() {
            if (this._waypoints.length > 0) {
              const e2 = this._waypoints[0];
              if (e2.opts) return e2.opts.isBezier && e2.opts.isFirst;
            }
            return false;
          }
          _GetTargetBezierAngle() {
            if (this._waypoints.length > 0) {
              const e2 = this._waypoints[0];
              if (e2.opts) return e2.opts.bezierAngle;
            }
            return NaN;
          }
          _SetSpeed(e2) {
            this._IsMoving() && (this._speed = Math.min(e2, this._maxSpeed));
          }
          _GetSpeed() {
            return this._speed;
          }
          _SetMaxSpeed(e2) {
            this._maxSpeed = Math.max(e2, 0), this._SetSpeed(this._speed);
          }
          _GetMaxSpeed() {
            return this._maxSpeed;
          }
          _IsRotationEnabled() {
            return 0 !== this._rotateSpeed;
          }
          Tick() {
            if (!this._isEnabled || !this._IsMoving()) return;
            const t2 = this._runtime.GetDt(this._inst), i3 = this._inst.GetWorldInfo(), s3 = i3.GetX(), n2 = i3.GetY(), a3 = i3.GetAngle();
            let o3 = this._speed, r3 = this._maxSpeed;
            const h2 = this._acc, _2 = this._dec, l3 = this._GetTargetX(), g = this._GetTargetY(), d2 = e.angleTo(s3, n2, l3, g);
            let p = false;
            if (_2 > 0 && 1 === this._waypoints.length) {
              const t3 = 0.5 * o3 * o3 / _2 * 1.0001;
              if (p = e.distanceSquared(s3, n2, l3, g) <= t3 * t3, p) {
                const t4 = e.distanceTo(s3, n2, l3, g);
                o3 = Math.sqrt(2 * _2 * t4), r3 = o3, this._speed = o3;
              }
            }
            if (this._IsRotationEnabled()) {
              const t3 = e.angleDiff(this._movingAngle, d2);
              if (t3 > Number.EPSILON) {
                const s4 = t3 / this._rotateSpeed, n3 = e.distanceTo(i3.GetX(), i3.GetY(), l3, g) / (2 * Math.sin(t3)) * t3;
                r3 = Math.min(r3, e.clamp(n3 / s4, 0, this._maxSpeed));
              }
            }
            let c2 = p ? -_2 : h2;
            const S = Math.min(o3 * t2 + 0.5 * c2 * t2 * t2, r3 * t2);
            if (p) {
              if (_2 > 0 && (this._speed = Math.max(this._speed - _2 * t2, 0), 0 === this._speed)) return void this._OnArrived(i3, l3, g);
            } else this._speed = 0 === h2 ? r3 : Math.min(this._speed + h2 * t2, r3);
            if (e.distanceSquared(i3.GetX(), i3.GetY(), l3, g) <= S * S) this._OnArrived(i3, l3, g);
            else {
              if (this._IsRotationEnabled() ? this._movingAngle = e.angleRotate(this._movingAngle, d2, this._rotateSpeed * t2) : this._movingAngle = d2, i3.OffsetXY(Math.cos(this._movingAngle) * S, Math.sin(this._movingAngle) * S), this._setAngle) {
                const t3 = this._GetTargetIsBezier(), s4 = this._GetTargetIsBezierFirst();
                if (t3 && !s4) {
                  const t4 = e.distanceTo(this._lastTargetX, this._lastTargetY, i3.GetX(), i3.GetY()) / e.distanceTo(this._lastTargetX, this._lastTargetY, l3, g);
                  i3.SetAngle(e.angleLerp(this._lastTargetAngle, this._GetTargetBezierAngle(), t4));
                } else i3.SetAngle(this._movingAngle), this._lastTargetX = NaN, this._lastTargetY = NaN, this._lastTargetAngle = NaN;
              }
              i3.SetBboxChanged(), this._CheckSolidCollision(s3, n2, a3);
            }
          }
          _OnArrived(t2, i3, s3) {
            t2.SetXY(i3, s3);
            const n2 = this._waypoints[0];
            n2.opts && n2.opts.isBezier ? (this._lastTargetX = n2.x, this._lastTargetY = n2.y, this._lastTargetAngle = n2.opts.bezierAngle, this._setAngle && t2.SetAngle(this._lastTargetAngle)) : (this._lastTargetX = NaN, this._lastTargetY = NaN, this._lastTargetAngle = NaN), t2.SetBboxChanged(), this._waypoints.shift(), 0 === this._waypoints.length && (this._timelineInfo && (this._timelineInfo.Release(), this._timelineInfo = null, this._lastTargetX = NaN, this._lastTargetY = NaN, this._lastTargetAngle = NaN), this._speed = 0, this._StopTicking()), this.DispatchScriptEvent("arrived"), this.Trigger(e.Behaviors.MoveTo.Cnds.OnArrived);
          }
          _CheckSolidCollision(t2, i3, s3) {
            const n2 = this._runtime.GetCollisionEngine();
            if (this._stopOnSolids && n2.TestOverlapSolid(this._inst)) {
              this._Stop();
              const a3 = this._inst.GetWorldInfo(), o3 = a3.GetX(), r3 = a3.GetY(), h2 = e.angleTo(o3, r3, t2, i3), _2 = e.distanceTo(o3, r3, t2, i3);
              n2.PushOutSolid(this._inst, Math.cos(h2), Math.sin(h2), Math.max(_2, 1)) || (a3.SetXY(t2, i3), a3.SetAngle(s3), a3.SetBboxChanged()), this.DispatchScriptEvent("hitsolid"), this.Trigger(e.Behaviors.MoveTo.Cnds.OnHitSolid);
            }
          }
          _IsSetAngle() {
            return this._setAngle;
          }
          _SetSetAngle(e2) {
            this._setAngle = !!e2;
          }
          _SetAngleOfMotion(e2) {
            if (this._movingAngle = e2, this._isEnabled && this._setAngle && !this._IsMoving()) {
              const e3 = this.GetWorldInfo();
              e3.SetAngle(this._movingAngle), e3.SetBboxChanged();
            }
          }
          _GetAngleOfMotion() {
            return this._movingAngle;
          }
          _SetAcceleration(e2) {
            this._acc = Math.max(e2, 0);
          }
          _GetAcceleration() {
            return this._acc;
          }
          _SetDeceleration(e2) {
            this._dec = Math.max(e2, 0);
          }
          _GetDeceleration() {
            return this._dec;
          }
          _SetRotateSpeed(e2) {
            this._rotateSpeed = Math.max(e2, 0);
          }
          _GetRotateSpeed() {
            return this._rotateSpeed;
          }
          _SetStopOnSolids(e2) {
            this._stopOnSolids = !!e2;
          }
          _IsStopOnSolids() {
            return this._stopOnSolids;
          }
          _SetEnabled(e2) {
            e2 = !!e2, this._isEnabled !== e2 && (this._isEnabled = e2, this._isEnabled && this._IsMoving() ? this._StartTicking() : this._StopTicking());
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          GetPropertyValueByIndex(t2) {
            switch (t2) {
              case s2:
                return this._GetMaxSpeed();
              case n:
                return this._GetAcceleration();
              case a2:
                return this._GetDeceleration();
              case o2:
                return e.toDegrees(this._GetRotateSpeed());
              case r2:
                return this._IsSetAngle();
              case h:
                return this._IsStopOnSolids();
              case _:
                return this._IsEnabled();
            }
          }
          SetPropertyValueByIndex(t2, i3) {
            switch (t2) {
              case s2:
                this._SetMaxSpeed(i3);
                break;
              case n:
                this._SetAcceleration(i3);
                break;
              case a2:
                this._SetDeceleration(i3);
                break;
              case o2:
                this._SetRotateSpeed(e.toRadians(i3));
                break;
              case r2:
                this._SetSetAngle(i3);
                break;
              case h:
                this._SetStopOnSolids(i3);
                break;
              case _:
                this._SetEnabled(i3);
            }
          }
          GetDebuggerProperties() {
            const t2 = "behaviors.moveto";
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t2 + ".debugger.speed", value: this._GetSpeed(), onedit: (e2) => this._SetSpeed(e2) }, { name: t2 + ".debugger.angle-of-motion", value: e.toDegrees(this._GetAngleOfMotion()), onedit: (t3) => this._movingAngle = e.toRadians(t3) }, { name: t2 + ".debugger.target-x", value: this._GetTargetX() }, { name: t2 + ".debugger.target-y", value: this._GetTargetY() }, { name: t2 + ".debugger.waypoint-count", value: this._GetWaypointCount() }, { name: t2 + ".properties.max-speed.name", value: this._GetMaxSpeed(), onedit: (e2) => this._SetMaxSpeed(e2) }, { name: t2 + ".properties.acceleration.name", value: this._GetAcceleration(), onedit: (e2) => this._SetAcceleration(e2) }, { name: t2 + ".properties.deceleration.name", value: this._GetDeceleration(), onedit: (e2) => this._SetDeceleration(e2) }, { name: t2 + ".properties.rotate-speed.name", value: e.toDegrees(this._GetRotateSpeed()), onedit: (t3) => this._SetRotateSpeed(e.toRadians(t3)) }, { name: t2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }] }];
          }
          GetScriptInterfaceClass() {
            return self.IMoveToBehaviorInstance;
          }
        };
        const l2 = /* @__PURE__ */ new WeakMap();
        self.IMoveToBehaviorInstance = class extends i2 {
          constructor() {
            super(), l2.set(this, i2._GetInitInst().GetSdkInstance());
          }
          moveToPosition(e2, i3, s3 = true) {
            t.RequireFiniteNumber(e2), t.RequireFiniteNumber(i3), l2.get(this)._AddWaypoint(e2, i3, !!s3);
          }
          getTargetX() {
            return l2.get(this)._GetTargetX();
          }
          getTargetY() {
            return l2.get(this)._GetTargetY();
          }
          getTargetPosition() {
            const e2 = l2.get(this);
            return [e2._GetTargetX(), e2._GetTargetY()];
          }
          getWaypointCount() {
            return l2.get(this)._GetWaypointCount();
          }
          getWaypointX(e2) {
            return t.RequireFiniteNumber(e2), l2.get(this)._GetWaypointXAt(e2);
          }
          getWaypointY(e2) {
            return t.RequireFiniteNumber(e2), l2.get(this)._GetWaypointYAt(e2);
          }
          getWaypoint(e2) {
            t.RequireFiniteNumber(e2);
            const i3 = l2.get(this);
            return [i3._GetWaypointXAt(e2), i3._GetWaypointYAt(e2)];
          }
          stop() {
            l2.get(this)._Stop();
          }
          get isMoving() {
            return l2.get(this)._IsMoving();
          }
          get speed() {
            return l2.get(this)._GetSpeed();
          }
          set speed(e2) {
            t.RequireFiniteNumber(e2), l2.get(this)._SetSpeed(e2);
          }
          get maxSpeed() {
            return l2.get(this)._GetMaxSpeed();
          }
          set maxSpeed(e2) {
            t.RequireFiniteNumber(e2), l2.get(this)._SetMaxSpeed(e2);
          }
          get acceleration() {
            return l2.get(this)._GetAcceleration();
          }
          set acceleration(e2) {
            t.RequireFiniteNumber(e2), l2.get(this)._SetAcceleration(e2);
          }
          get deceleration() {
            return l2.get(this)._GetDeceleration();
          }
          set deceleration(e2) {
            t.RequireFiniteNumber(e2), l2.get(this)._SetDeceleration(e2);
          }
          get angleOfMotion() {
            return l2.get(this)._GetAngleOfMotion();
          }
          set angleOfMotion(e2) {
            t.RequireFiniteNumber(e2), l2.get(this)._SetAngleOfMotion(e2);
          }
          get rotateSpeed() {
            return l2.get(this)._GetRotateSpeed();
          }
          set rotateSpeed(e2) {
            t.RequireFiniteNumber(e2), l2.get(this)._SetRotateSpeed(e2);
          }
          get isStopOnSolids() {
            return l2.get(this)._IsStopOnSolids();
          }
          set isStopOnSolids(e2) {
            l2.get(this)._SetStopOnSolids(e2);
          }
          get isEnabled() {
            return l2.get(this)._IsEnabled();
          }
          set isEnabled(e2) {
            l2.get(this)._SetEnabled(e2);
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.MoveTo.Cnds = { IsMoving() {
          return this._IsMoving();
        }, CompareSpeed(t, i2) {
          return e.compare(this._GetSpeed(), t, i2);
        }, IsEnabled() {
          return this._IsEnabled();
        }, OnArrived: () => true, OnHitSolid: () => true };
      }
      {
        const e = self.C3, t = 25;
        e.Behaviors.MoveTo.Acts = { MoveToPosition(e2, t2, i2) {
          this._AddWaypoint(e2, t2, 0 === i2);
        }, MoveToObject(e2, t2, i2) {
          if (!e2) return;
          const s2 = e2.GetPairedInstance(this._inst);
          if (!s2 || !s2.GetWorldInfo()) return;
          const [n, a2] = s2.GetImagePoint(t2);
          this._AddWaypoint(n, a2, 0 === i2);
        }, MoveAlongPathfindingPath(t2) {
          const i2 = this._inst.GetBehaviorSdkInstanceFromCtor(e.Behaviors.Pathfinding);
          if (!i2) return;
          const s2 = i2._GetPath();
          if (0 !== s2.length) for (let e2 = 0, i3 = s2.length; e2 < i3; ++e2) {
            const i4 = s2[e2];
            this._AddWaypoint(i4.x, i4.y, 0 === e2 && 0 === t2);
          }
        }, MoveAlongTimeline(i2, s2, n) {
          const a2 = e.New(e.TimelineInfo, i2, s2);
          if (!a2.WasInitialized()) return void a2.Release();
          a2.SetOrigin(this._inst.GetWorldInfo());
          let o2 = true;
          for (const i3 of a2.segments()) switch (i3.GetType()) {
            case "line": {
              const e2 = i3.GetX(), t2 = i3.GetY();
              this._AddWaypoint(e2, t2, o2 && 0 === n), o2 = false;
              break;
            }
            case "cubic-bezier":
              for (let s3 = 0; s3 <= i3.GetStepCount(); s3++) {
                const a3 = s3 * i3.GetStepIncrement(), r2 = i3.Map(a3), h = r2[0], _ = r2[1], l2 = this._GetWaypointXAt(this._GetWaypointCount() - 1), g = this._GetWaypointYAt(this._GetWaypointCount() - 1);
                !o2 && e.IsFiniteNumber(l2) && e.IsFiniteNumber(g) && e.distanceSquared(l2, g, h, _) < t || (this._AddWaypoint(h, _, o2 && 0 === n, { isBezier: true, isFirst: o2, bezierAngle: Math.atan2(_ - g, h - l2) }), o2 = false);
              }
          }
          this._timelineInfo = a2;
        }, MoveAlongTimelineByName(t2, i2, s2) {
          const n = this._runtime.GetTimelineManager().GetTimelineByName(t2);
          n && e.Behaviors.MoveTo.Acts.MoveAlongTimeline.call(this, n, i2, s2);
        }, Stop() {
          this._Stop();
        }, SetMovingAngle(t2) {
          this._SetAngleOfMotion(e.toRadians(t2));
        }, SetSpeed(e2) {
          this._SetSpeed(e2);
        }, SetMaxSpeed(e2) {
          this._SetMaxSpeed(e2);
        }, SetAcceleration(e2) {
          this._SetAcceleration(e2);
        }, SetDeceleration(e2) {
          this._SetDeceleration(e2);
        }, SetRotateSpeed(t2) {
          this._SetRotateSpeed(e.toRadians(t2));
        }, SetStopOnSolids(e2) {
          this._SetStopOnSolids(e2);
        }, SetEnabled(e2) {
          this._SetEnabled(e2);
        } };
      }
      {
        const e = self.C3;
        e.Behaviors.MoveTo.Exps = { Speed() {
          return this._GetSpeed();
        }, MaxSpeed() {
          return this._GetMaxSpeed();
        }, Acceleration() {
          return this._GetAcceleration();
        }, Deceleration() {
          return this._GetDeceleration();
        }, MovingAngle() {
          return e.toDegrees(this._GetAngleOfMotion());
        }, RotateSpeed() {
          return e.toDegrees(this._GetRotateSpeed());
        }, TargetX() {
          return this._GetTargetX();
        }, TargetY() {
          return this._GetTargetY();
        }, WaypointCount() {
          return this._GetWaypointCount();
        }, WaypointXAt(e2) {
          return this._GetWaypointXAt(e2);
        }, WaypointYAt(e2) {
          return this._GetWaypointYAt(e2);
        } };
      }
    }
    {
      {
        const e = self.C3;
        e.Behaviors.Flash = class extends e.SDKBehaviorBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.Flash.Type = class extends e.SDKBehaviorTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3, t = self.C3X, s2 = self.IBehaviorInstance;
        e.Behaviors.Flash.Instance = class extends e.SDKBehaviorInstanceBase {
          constructor(e2, t2) {
            super(e2), this._onTime = 0, this._offTime = 0, this._stage = 0, this._stageTimeLeft = 0, this._timeLeft = 0, this._StartTicking();
          }
          Release() {
            super.Release();
          }
          _Flash(e2, t2, s3) {
            this._onTime = e2, this._offTime = t2, this._stage = 1, this._stageTimeLeft = t2, this._timeLeft = s3, this._inst.GetWorldInfo().SetVisible(false), this._runtime.UpdateRender();
          }
          _StopFlashing() {
            this._timeLeft = 0, this._inst.GetWorldInfo().SetVisible(true), this._runtime.UpdateRender();
          }
          _IsFlashing() {
            return this._timeLeft > 0;
          }
          SaveToJson() {
            return { "on": this._onTime, "off": this._offTime, "s": this._stage, "stl": this._stageTimeLeft, "tl": this._timeLeft };
          }
          LoadFromJson(e2) {
            this._onTime = e2["on"], this._offTime = e2["off"], this._stage = e2["s"], this._stageTimeLeft = e2["stl"], this._timeLeft = null === e2["tl"] ? 1 / 0 : e2["tl"];
          }
          Tick() {
            if (this._timeLeft <= 0) return;
            const t2 = this._runtime.GetDt(this._inst);
            if (this._timeLeft -= t2, this._timeLeft <= 0) return this._timeLeft = 0, this._inst.GetWorldInfo().SetVisible(true), this._runtime.UpdateRender(), this.DispatchScriptEvent("flashend"), this.DebugTrigger(e.Behaviors.Flash.Cnds.OnFlashEnded);
            this._stageTimeLeft -= t2, this._stageTimeLeft <= 0 && (0 === this._stage ? (this._inst.GetWorldInfo().SetVisible(false), this._stage = 1, this._stageTimeLeft += this._offTime) : (this._inst.GetWorldInfo().SetVisible(true), this._stage = 0, this._stageTimeLeft += this._onTime), this._runtime.UpdateRender());
          }
          GetDebuggerProperties() {
            const e2 = "behaviors.flash.debugger";
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e2 + ".on-time", value: this._onTime, onedit: (e3) => this._onTime = e3 }, { name: e2 + ".off-time", value: this._offTime, onedit: (e3) => this._offTime = e3 }, { name: e2 + ".is-flashing", value: this._timeLeft > 0 }, { name: e2 + ".time-left", value: this._timeLeft }] }];
          }
          GetScriptInterfaceClass() {
            return self.IFlashBehaviorInstance;
          }
        };
        const i2 = /* @__PURE__ */ new WeakMap();
        self.IFlashBehaviorInstance = class extends s2 {
          constructor() {
            super(), i2.set(this, s2._GetInitInst().GetSdkInstance());
          }
          flash(e2, s3, h) {
            t.RequireFiniteNumber(e2), t.RequireFiniteNumber(s3), t.RequireFiniteNumber(h), i2.get(this)._Flash(e2, s3, h);
          }
          stop() {
            i2.get(this)._StopFlashing();
          }
          get isFlashing() {
            return i2.get(this)._IsFlashing();
          }
        };
      }
      self.C3.Behaviors.Flash.Cnds = { IsFlashing() {
        return this._IsFlashing();
      }, OnFlashEnded: () => true };
      self.C3.Behaviors.Flash.Acts = { Flash(e, t, s2) {
        this._Flash(e, t, s2);
      }, StopFlashing() {
        this._StopFlashing();
      } };
      self.C3.Behaviors.Flash.Exps = {};
    }
    {
      {
        const e = self.C3;
        e.Behaviors.Sin = class extends e.SDKBehaviorBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.Sin.Type = class extends e.SDKBehaviorTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3, t = self.C3X, i2 = self.IBehaviorInstance, s2 = 0, a2 = 1, n = 2, h = 3, _ = 4, r2 = 5, o2 = 6, l2 = 7, u = 8, d2 = 0, m = 1, g = 2, v = 3, c2 = 4, p = 5, G = 6, b = 7, S = 8, V = 9, w = 0, P = 1, M = 2, I = 3, f2 = 4, k = 2 * Math.PI, W = Math.PI / 2, E = 3 * Math.PI / 2, R = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];
        e.Behaviors.Sin.Instance = class extends e.SDKBehaviorInstanceBase {
          constructor(t2, i3) {
            super(t2), this._i = 0, this._movement = 0, this._wave = 0, this._period = 0, this._mag = 0, this._isEnabled = true, this._basePeriod = 0, this._basePeriodOffset = 0, this._baseMag = 0, this._periodRandom = 0, this._periodOffsetRandom = 0, this._magnitudeRandom = 0, this._initialValue = 0, this._initialValue2 = 0, this._lastKnownValue = 0, this._lastKnownValue2 = 0, this._ratio = 0, i3 && (this._movement = R[i3[s2]], this._wave = i3[a2], this._periodRandom = this._runtime.Random() * i3[h], this._basePeriod = i3[n], this._period = i3[n], this._period += this._periodRandom, this._basePeriodOffset = i3[_], 0 !== this._period && (this._periodOffsetRandom = this._runtime.Random() * i3[r2], this._i = i3[_] / this._period * k, this._i += this._periodOffsetRandom / this._period * k), this._magnitudeRandom = this._runtime.Random() * i3[l2], this._baseMag = i3[o2], this._mag = i3[o2], this._mag += this._magnitudeRandom, this._isEnabled = !!i3[u]), this._movement === p && (this._mag = e.toRadians(this._mag)), this.Init(), this._isEnabled && this._StartTicking();
          }
          Release() {
            super.Release();
          }
          SaveToJson() {
            return { "i": this._i, "e": this._isEnabled, "mv": this._movement, "w": this._wave, "p": this._period, "mag": this._mag, "iv": this._initialValue, "iv2": this._initialValue2, "r": this._ratio, "lkv": this._lastKnownValue, "lkv2": this._lastKnownValue2 };
          }
          LoadFromJson(e2) {
            this._i = e2["i"], this._SetEnabled(e2["e"]), this._movement = e2["mv"], this._wave = e2["w"], this._period = e2["p"], this._mag = e2["mag"], this._initialValue = e2["iv"], this._initialValue2 = e2["iv2"], this._ratio = e2["r"], this._lastKnownValue = e2["lkv"], this._lastKnownValue2 = e2["lkv2"];
          }
          Init() {
            const e2 = this._inst.GetWorldInfo();
            switch (this._movement) {
              case d2:
                this._initialValue = e2.GetX();
                break;
              case m:
                this._initialValue = e2.GetY();
                break;
              case g:
                this._initialValue = e2.GetWidth(), this._ratio = e2.GetHeight() / e2.GetWidth();
                break;
              case v:
                this._initialValue = e2.GetWidth();
                break;
              case c2:
                this._initialValue = e2.GetHeight();
                break;
              case p:
                this._initialValue = e2.GetAngle();
                break;
              case G:
                this._initialValue = e2.GetOpacity();
                break;
              case b:
                this._initialValue = 0;
                break;
              case S:
                this._initialValue = e2.GetX(), this._initialValue2 = e2.GetY();
                break;
              case V:
                this._initialValue = e2.GetZElevation();
            }
            this._lastKnownValue = this._initialValue, this._lastKnownValue2 = this._initialValue2;
          }
          WaveFunc(e2) {
            switch (e2 %= k, this._wave) {
              case w:
                return Math.sin(e2);
              case P:
                return e2 <= W ? e2 / W : e2 <= E ? 1 - 2 * (e2 - W) / Math.PI : (e2 - E) / W - 1;
              case M:
                return 2 * e2 / k - 1;
              case I:
                return -2 * e2 / k + 1;
              case f2:
                return e2 < Math.PI ? -1 : 1;
            }
            return 0;
          }
          Tick() {
            const e2 = this._runtime.GetDt(this._inst);
            this._isEnabled && 0 !== e2 && (0 === this._period ? this._i = 0 : this._i = (this._i + e2 / this._period * k) % k, this._UpdateFromPhase());
          }
          _UpdateFromPhase() {
            const t2 = this._inst.GetWorldInfo();
            switch (this._movement) {
              case d2:
                t2.GetX() !== this._lastKnownValue && (this._initialValue += t2.GetX() - this._lastKnownValue), t2.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t2.GetX();
                break;
              case m:
                t2.GetY() !== this._lastKnownValue && (this._initialValue += t2.GetY() - this._lastKnownValue), t2.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t2.GetY();
                break;
              case g:
                t2.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag), t2.SetHeight(t2.GetWidth() * this._ratio);
                break;
              case v:
                t2.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
                break;
              case c2:
                t2.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
                break;
              case p:
                t2.GetAngle() !== this._lastKnownValue && (this._initialValue = e.clampAngle(this._initialValue + (t2.GetAngle() - this._lastKnownValue))), t2.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t2.GetAngle();
                break;
              case G:
                t2.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);
                break;
              case S:
                t2.GetX() !== this._lastKnownValue && (this._initialValue += t2.GetX() - this._lastKnownValue), t2.GetY() !== this._lastKnownValue2 && (this._initialValue2 += t2.GetY() - this._lastKnownValue2), t2.SetX(this._initialValue + Math.cos(t2.GetAngle()) * this.WaveFunc(this._i) * this._mag), t2.SetY(this._initialValue2 + Math.sin(t2.GetAngle()) * this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t2.GetX(), this._lastKnownValue2 = t2.GetY();
                break;
              case V:
                t2.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag);
            }
            t2.SetBboxChanged();
          }
          _OnSpriteFrameChanged(e2, t2) {
          }
          _SetPeriod(e2) {
            this._period = e2;
          }
          _GetPeriod() {
            return this._period;
          }
          _SetMagnitude(e2) {
            this._mag = e2;
          }
          _SetMagnitude_ConvertAngle(t2) {
            5 === this._movement && (t2 = e.toRadians(t2)), this._SetMagnitude(t2);
          }
          _GetMagnitude() {
            return this._mag;
          }
          _GetMagnitude_ConvertAngle() {
            let t2 = this._GetMagnitude();
            return 5 === this._movement && (t2 = e.toDegrees(t2)), t2;
          }
          _SetMovement(t2) {
            5 === this._movement && 5 !== t2 && (this._mag = e.toDegrees(this._mag)), this._movement = t2, this.Init();
          }
          _GetMovement() {
            return this._movement;
          }
          _SetWave(e2) {
            this._wave = e2;
          }
          _GetWave() {
            return this._wave;
          }
          _SetPhase(t2) {
            this._i = e.clamp(t2, 0, 2 * Math.PI), this._UpdateFromPhase();
          }
          _GetPhase() {
            return this._i;
          }
          _SetEnabled(e2) {
            this._isEnabled = !!e2, this._isEnabled ? this._StartTicking() : this._StopTicking();
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          GetPropertyValueByIndex(e2) {
            switch (e2) {
              case s2:
                return this._movement;
              case a2:
                return this._wave;
              case n:
                return this._basePeriod;
              case o2:
                return this._baseMag;
              case u:
                return this._isEnabled;
            }
          }
          SetPropertyValueByIndex(t2, i3) {
            switch (t2) {
              case s2:
                this._movement = R[i3], this.Init();
                break;
              case a2:
                this._wave = i3;
                break;
              case n:
                this._basePeriod = i3, this._period = this._basePeriod + this._periodRandom, this._isEnabled || (0 !== this._period ? (this._i = this._basePeriodOffset / this._period * k, this._i += this._periodOffsetRandom / this._period * k) : this._i = 0);
                break;
              case o2:
                this._baseMag = i3, this._mag = this._baseMag + this._magnitudeRandom, this._movement === p && (this._mag = e.toRadians(this._mag));
                break;
              case u:
                this._isEnabled = !!i3;
            }
          }
          GetDebuggerProperties() {
            const e2 = "behaviors.sin";
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e3) => this._SetEnabled(e3) }, { name: e2 + ".properties.period.name", value: this._GetPeriod(), onedit: (e3) => this._SetPeriod(e3) }, { name: e2 + ".properties.magnitude.name", value: this._GetMagnitude_ConvertAngle(), onedit: (e3) => this._SetMagnitude_ConvertAngle(e3) }, { name: e2 + ".debugger.value", value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle() }] }];
          }
          GetScriptInterfaceClass() {
            return self.ISineBehaviorInstance;
          }
        };
        const C = /* @__PURE__ */ new WeakMap(), K = ["horizontal", "vertical", "size", "width", "height", "angle", "opacity", "value-only", "forwards-backwards", "z-elevation"], F = ["sine", "triangle", "sawtooth", "reverse-sawtooth", "square"];
        self.ISineBehaviorInstance = class extends i2 {
          constructor() {
            super(), C.set(this, i2._GetInitInst().GetSdkInstance());
          }
          set period(e2) {
            t.RequireFiniteNumber(e2), C.get(this)._SetPeriod(e2);
          }
          get period() {
            return C.get(this)._GetPeriod();
          }
          set magnitude(e2) {
            t.RequireFiniteNumber(e2), C.get(this)._SetMagnitude(e2);
          }
          get magnitude() {
            return C.get(this)._GetMagnitude();
          }
          set phase(e2) {
            C.get(this)._SetPhase(e2);
          }
          get phase() {
            return C.get(this)._GetPhase();
          }
          set movement(e2) {
            t.RequireString(e2);
            const i3 = K.indexOf(e2);
            if (-1 === i3) throw new Error("invalid movement");
            C.get(this)._SetMovement(i3);
          }
          get movement() {
            return K[C.get(this)._GetMovement()];
          }
          set wave(e2) {
            t.RequireString(e2);
            const i3 = F.indexOf(e2);
            if (-1 === i3) throw new Error("invalid wave");
            C.get(this)._SetWave(i3);
          }
          get wave() {
            return F[C.get(this)._GetWave()];
          }
          get value() {
            const e2 = C.get(this);
            return e2.WaveFunc(e2._GetPhase()) * e2._GetMagnitude();
          }
          updateInitialState() {
            C.get(this).Init();
          }
          set isEnabled(e2) {
            C.get(this)._SetEnabled(!!e2);
          }
          get isEnabled() {
            return C.get(this)._IsEnabled();
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.Sin.Cnds = { IsEnabled() {
          return this._IsEnabled();
        }, CompareMovement(e2) {
          return this._GetMovement() === e2;
        }, ComparePeriod(t, i2) {
          return e.compare(this._GetPeriod(), t, i2);
        }, CompareMagnitude(t, i2) {
          return e.compare(this._GetMagnitude_ConvertAngle(), t, i2);
        }, CompareWave(e2) {
          return this._GetWave() === e2;
        } };
      }
      self.C3.Behaviors.Sin.Acts = { SetEnabled(e) {
        this._SetEnabled(0 !== e);
      }, SetPeriod(e) {
        this._SetPeriod(e);
      }, SetMagnitude(e) {
        this._SetMagnitude_ConvertAngle(e);
      }, SetMovement(e) {
        this._SetMovement(e);
      }, SetWave(e) {
        this._wave = e;
      }, SetPhase(e) {
        const t = 2 * Math.PI;
        this._SetPhase(e * t % t);
      }, UpdateInitialState() {
        this.Init();
      } };
      self.C3.Behaviors.Sin.Exps = { CyclePosition() {
        return this._GetPhase() / (2 * Math.PI);
      }, Period() {
        return this._GetPeriod();
      }, Magnitude() {
        return this._GetMagnitude_ConvertAngle();
      }, Value() {
        return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle();
      } };
    }
    {
      {
        const t = self.C3;
        t.Behaviors.Pin = class extends t.SDKBehaviorBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const t = self.C3;
        t.Behaviors.Pin.Type = class extends t.SDKBehaviorTypeBase {
          constructor(t2) {
            super(t2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const t = self.C3;
        t.Behaviors.Pin.Instance = class extends t.SDKBehaviorInstanceBase {
          constructor(s2, e) {
            super(s2), this._pinInst = null, this._pinUid = -1, this._mode = "", this._propSet = /* @__PURE__ */ new Set(), this._pinDist = 0, this._pinAngle = 0, this._pinImagePoint = 0, this._dx = 0, this._dy = 0, this._dWidth = 0, this._dHeight = 0, this._dAngle = 0, this._dz = 0, this._lastKnownAngle = 0, this._destroy = false, e && (this._destroy = e[0]);
            const i2 = this._runtime.Dispatcher();
            this._disposables = new t.CompositeDisposable(t.Disposable.From(i2, "instancedestroy", (t2) => this._OnInstanceDestroyed(t2.instance)), t.Disposable.From(i2, "afterload", (t2) => this._OnAfterLoad()));
          }
          Release() {
            this._pinInst = null, super.Release();
          }
          _SetPinInst(t2) {
            t2 ? (this._pinInst = t2, this._StartTicking2()) : (this._pinInst = null, this._StopTicking2());
          }
          _Pin(s2, e, i2) {
            if (!s2) return;
            const h = s2.GetFirstPicked(this._inst);
            if (!h) return;
            this._mode = e, this._SetPinInst(h);
            const n = this._inst.GetWorldInfo(), a2 = h.GetWorldInfo();
            if ("properties" === this._mode) {
              const s3 = this._propSet;
              s3.clear();
              for (const t2 of i2) s3.add(t2);
              this._dx = n.GetX() - a2.GetX(), this._dy = n.GetY() - a2.GetY(), this._dAngle = n.GetAngle() - a2.GetAngle(), this._lastKnownAngle = n.GetAngle(), this._dz = n.GetZElevation() - a2.GetZElevation(), s3.has("x") && s3.has("y") && (this._pinAngle = t.angleTo(a2.GetX(), a2.GetY(), n.GetX(), n.GetY()) - a2.GetAngle(), this._pinDist = t.distanceTo(a2.GetX(), a2.GetY(), n.GetX(), n.GetY())), s3.has("width-abs") ? this._dWidth = n.GetWidth() - a2.GetWidth() : s3.has("width-scale") && (this._dWidth = n.GetWidth() / a2.GetWidth()), s3.has("height-abs") ? this._dHeight = n.GetHeight() - a2.GetHeight() : s3.has("height-scale") && (this._dHeight = n.GetHeight() / a2.GetHeight());
            } else this._pinDist = t.distanceTo(a2.GetX(), a2.GetY(), n.GetX(), n.GetY());
          }
          SaveToJson() {
            const t2 = this._propSet, s2 = this._mode, e = { "uid": this._pinInst && !this._pinInst.IsDestroyed() ? this._pinInst.GetUID() : -1, "m": s2, "d": this._destroy };
            return "rope" === s2 || "bar" === s2 ? e["pd"] = this._pinDist : "properties" === s2 && (e["ps"] = [...this._propSet], t2.has("imagepoint") ? e["ip"] = this._pinImagePoint : t2.has("x") && t2.has("y") ? (e["pa"] = this._pinAngle, e["pd"] = this._pinDist) : (t2.has("x") && (e["dx"] = this._dx), t2.has("y") && (e["dy"] = this._dy)), t2.has("angle") && (e["da"] = this._dAngle, e["lka"] = this._lastKnownAngle), (t2.has("width-abs") || t2.has("width-scale")) && (e["dw"] = this._dWidth), (t2.has("height-abs") || t2.has("height-scale")) && (e["dh"] = this._dHeight), t2.has("z") && (e["dz"] = this._dz)), e;
          }
          LoadFromJson(t2) {
            const s2 = t2["m"], e = this._propSet;
            if (e.clear(), this._pinUid = t2["uid"], "number" != typeof s2) {
              if (this._mode = s2, t2.hasOwnProperty("d") && (this._destroy = !!t2["d"]), "rope" === s2 || "bar" === s2) this._pinDist = t2["pd"];
              else if ("properties" === s2) {
                for (const s3 of t2["ps"]) e.add(s3);
                e.has("imagepoint") ? this._pinImagePoint = t2["ip"] : e.has("x") && e.has("y") ? (this._pinAngle = t2["pa"], this._pinDist = t2["pd"]) : (e.has("x") && (this._dx = t2["dx"]), e.has("y") && (this._dy = t2["dy"])), e.has("angle") && (this._dAngle = t2["da"], this._lastKnownAngle = t2["lka"] || 0), (e.has("width-abs") || e.has("width-scale")) && (this._dWidth = t2["dw"]), (e.has("height-abs") || e.has("height-scale")) && (this._dHeight = t2["dh"]), e.has("z") && (this._dz = t2["dz"]);
              }
            } else this._LoadFromJson_Legacy(t2);
          }
          _LoadFromJson_Legacy(t2) {
            const s2 = this._propSet, e = t2["msa"], i2 = t2["tsa"], h = t2["pa"], n = t2["pd"];
            switch (t2["m"]) {
              case 0:
                this._mode = "properties", s2.add("x").add("y").add("angle"), this._pinAngle = h, this._pinDist = n, this._dAngle = e - i2, this._lastKnownAngle = t2["lka"];
                break;
              case 1:
                this._mode = "properties", s2.add("x").add("y"), this._pinAngle = h, this._pinDist = n;
                break;
              case 2:
                this._mode = "properties", s2.add("angle"), this._dAngle = e - i2, this._lastKnownAngle = t2["lka"];
                break;
              case 3:
                this._mode = "rope", this._pinDist = t2["pd"];
                break;
              case 4:
                this._mode = "bar", this._pinDist = t2["pd"];
            }
          }
          _OnAfterLoad() {
            -1 === this._pinUid ? this._SetPinInst(null) : (this._SetPinInst(this._runtime.GetInstanceByUID(this._pinUid)), this._pinUid = -1);
          }
          _OnInstanceDestroyed(t2) {
            this._pinInst === t2 && (this._SetPinInst(null), this._destroy && this._runtime.DestroyInstance(this._inst));
          }
          Tick2() {
            const s2 = this._pinInst;
            if (!s2 || s2.IsDestroyed()) return;
            const e = s2.GetWorldInfo(), i2 = this._inst.GetWorldInfo(), h = this._mode;
            let n = false;
            if ("rope" === h || "bar" === h) {
              const s3 = t.distanceTo(i2.GetX(), i2.GetY(), e.GetX(), e.GetY());
              if (s3 > this._pinDist || "bar" === h && s3 < this._pinDist) {
                const s4 = t.angleTo(e.GetX(), e.GetY(), i2.GetX(), i2.GetY());
                i2.SetXY(e.GetX() + Math.cos(s4) * this._pinDist, e.GetY() + Math.sin(s4) * this._pinDist), n = true;
              }
            } else {
              const h2 = this._propSet;
              let a2 = 0;
              if (h2.has("imagepoint")) {
                const [t2, e2] = s2.GetImagePoint(this._pinImagePoint);
                i2.EqualsXY(t2, e2) || (i2.SetXY(t2, e2), n = true);
              } else if (h2.has("x") && h2.has("y")) {
                const t2 = e.GetX() + Math.cos(e.GetAngle() + this._pinAngle) * this._pinDist, s3 = e.GetY() + Math.sin(e.GetAngle() + this._pinAngle) * this._pinDist;
                i2.EqualsXY(t2, s3) || (i2.SetXY(t2, s3), n = true);
              } else a2 = e.GetX() + this._dx, h2.has("x") && a2 !== i2.GetX() && (i2.SetX(a2), n = true), a2 = e.GetY() + this._dy, h2.has("y") && a2 !== i2.GetY() && (i2.SetY(a2), n = true);
              h2.has("angle") && (this._lastKnownAngle !== i2.GetAngle() && (this._dAngle = t.clampAngle(this._dAngle + (i2.GetAngle() - this._lastKnownAngle))), a2 = t.clampAngle(e.GetAngle() + this._dAngle), a2 !== i2.GetAngle() && (i2.SetAngle(a2), n = true), this._lastKnownAngle = i2.GetAngle()), h2.has("width-abs") && (a2 = e.GetWidth() + this._dWidth, a2 !== i2.GetWidth() && (i2.SetWidth(a2), n = true)), h2.has("width-scale") && (a2 = e.GetWidth() * this._dWidth, a2 !== i2.GetWidth() && (i2.SetWidth(a2), n = true)), h2.has("height-abs") && (a2 = e.GetHeight() + this._dHeight, a2 !== i2.GetHeight() && (i2.SetHeight(a2), n = true)), h2.has("height-scale") && (a2 = e.GetHeight() * this._dHeight, a2 !== i2.GetHeight() && (i2.SetHeight(a2), n = true)), h2.has("z") && (a2 = e.GetZElevation() + this._dz, a2 !== i2.GetZElevation() && (i2.SetZElevation(a2), this._runtime.UpdateRender()));
            }
            n && i2.SetBboxChanged();
          }
          GetDebuggerProperties() {
            const t2 = "behaviors.pin.debugger";
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t2 + ".is-pinned", value: !!this._pinInst }, { name: t2 + ".pinned-uid", value: this._pinInst ? this._pinInst.GetUID() : 0 }] }];
          }
        };
      }
      self.C3.Behaviors.Pin.Cnds = { IsPinned() {
        return !!this._pinInst;
      }, WillDestroy() {
        return this._destroy;
      } };
      self.C3.Behaviors.Pin.Acts = { PinByDistance(t, s2) {
        this._Pin(t, 0 === s2 ? "rope" : "bar");
      }, PinByProperties(t, s2, e, i2, h, n, a2) {
        const o2 = [];
        s2 && o2.push("x"), e && o2.push("y"), i2 && o2.push("angle"), a2 && o2.push("z"), 1 === h ? o2.push("width-abs") : 2 === h && o2.push("width-scale"), 1 === n ? o2.push("height-abs") : 2 === n && o2.push("height-scale"), 0 !== o2.length && this._Pin(t, "properties", o2);
      }, PinByImagePoint(t, s2, e, i2, h, n) {
        const a2 = ["imagepoint"];
        e && a2.push("angle"), n && a2.push("z"), 1 === i2 ? a2.push("width-abs") : 2 === i2 && a2.push("width-scale"), 1 === h ? a2.push("height-abs") : 2 === h && a2.push("height-scale"), this._pinImagePoint = s2, this._Pin(t, "properties", a2);
      }, SetPinDistance(t) {
        "rope" !== this._mode && "bar" !== this._mode || (this._pinDist = Math.max(t, 0));
      }, SetDestroy(t) {
        this._destroy = t;
      }, Unpin() {
        this._SetPinInst(null), this._mode = "", this._propSet.clear(), this._pinImagePoint = "";
      }, Pin(t, s2) {
        switch (s2) {
          case 0:
            this._Pin(t, "properties", ["x", "y", "angle"]);
            break;
          case 1:
            this._Pin(t, "properties", ["x", "y"]);
            break;
          case 2:
            this._Pin(t, "properties", ["angle"]);
            break;
          case 3:
            this._Pin(t, "rope");
            break;
          case 4:
            this._Pin(t, "bar");
        }
      } };
      self.C3.Behaviors.Pin.Exps = { PinnedUID() {
        return this._pinInst ? this._pinInst.GetUID() : -1;
      } };
    }
    {
      {
        const e = self.C3;
        e.Behaviors.DragnDrop = class extends e.SDKBehaviorBase {
          constructor(t) {
            super(t);
            const s2 = this._runtime.Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(s2, "pointerdown", (e2) => this._OnPointerDown(e2.data)), e.Disposable.From(s2, "pointermove", (e2) => this._OnPointerMove(e2.data)), e.Disposable.From(s2, "pointerup", (e2) => this._OnPointerUp(e2.data, false)), e.Disposable.From(s2, "pointercancel", (e2) => this._OnPointerUp(e2.data, true)));
          }
          Release() {
            this._disposables.Release(), this._disposables = null, super.Release();
          }
          _OnPointerDown(e2) {
            "mouse" === e2["pointerType"] && 0 !== e2["button"] || this._OnInputDown(e2["pointerId"].toString(), e2["pageX"] - this._runtime.GetCanvasClientX(), e2["pageY"] - this._runtime.GetCanvasClientY());
          }
          _OnPointerMove(e2) {
            1 & e2["lastButtons"] && !(1 & e2["buttons"]) ? this._OnInputUp(e2["pointerId"].toString()) : this._OnInputMove(e2["pointerId"].toString(), e2["pageX"] - this._runtime.GetCanvasClientX(), e2["pageY"] - this._runtime.GetCanvasClientY());
          }
          _OnPointerUp(e2, t) {
            "mouse" === e2["pointerType"] && 0 !== e2["button"] || this._OnInputUp(e2["pointerId"].toString());
          }
          async _OnInputDown(t, s2, n) {
            const a2 = this.GetInstances();
            let r2 = null, i2 = null, o2 = 0, h = 0;
            for (const t2 of a2) {
              const a3 = t2.GetBehaviorSdkInstanceFromCtor(e.Behaviors.DragnDrop);
              if (!a3.IsEnabled() || a3.IsDragging() || t2.IsDestroyed()) continue;
              const g = t2.GetWorldInfo(), l2 = g.GetLayer(), [p, d2] = l2.CanvasCssToLayer(s2, n, g.GetTotalZElevation());
              if (!l2.IsSelfAndParentsInteractive() || !g.ContainsPoint(p, d2)) continue;
              if (!r2) {
                r2 = t2, i2 = a3, o2 = p, h = d2;
                continue;
              }
              const c2 = r2.GetWorldInfo();
              (l2.GetIndex() > c2.GetLayer().GetIndex() || l2.GetIndex() === c2.GetLayer().GetIndex() && g.GetZIndex() > c2.GetZIndex()) && (r2 = t2, i2 = a3, o2 = p, h = d2);
            }
            r2 && await i2._OnDown(t, o2, h);
          }
          _OnInputMove(t, s2, n) {
            const a2 = this.GetInstances();
            for (const r2 of a2) {
              const a3 = r2.GetBehaviorSdkInstanceFromCtor(e.Behaviors.DragnDrop);
              if (!a3.IsEnabled() || !a3.IsDragging() || a3.IsDragging() && a3.GetDragSource() !== t) continue;
              const i2 = r2.GetWorldInfo(), o2 = i2.GetLayer(), [h, g] = o2.CanvasCssToLayer(s2, n, i2.GetTotalZElevation());
              a3._OnMove(h, g);
            }
          }
          async _OnInputUp(t) {
            const s2 = this.GetInstances();
            for (const n of s2) {
              const s3 = n.GetBehaviorSdkInstanceFromCtor(e.Behaviors.DragnDrop);
              s3.IsDragging() && s3.GetDragSource() === t && await s3._OnUp();
            }
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.DragnDrop.Type = class extends e.SDKBehaviorTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3, t = (self.C3X, self.IBehaviorInstance), s2 = 0, n = 1;
        e.Behaviors.DragnDrop.Instance = class extends e.SDKBehaviorInstanceBase {
          constructor(e2, t2) {
            super(e2), this._isDragging = false, this._dx = 0, this._dy = 0, this._dragSource = "<none>", this._axes = 0, this._isEnabled = true, t2 && (this._axes = t2[s2], this._isEnabled = t2[n]);
          }
          Release() {
            super.Release();
          }
          SaveToJson() {
            return { "a": this._axes, "e": this._isEnabled };
          }
          LoadFromJson(e2) {
            this._axes = e2["a"], this._isEnabled = e2["e"], this._isDragging = false;
          }
          _SetEnabled(e2) {
            this._isEnabled = !!e2, this._isEnabled || (this._isDragging = false);
          }
          IsEnabled() {
            return this._isEnabled;
          }
          _SetAxes(e2) {
            this._axes = e2;
          }
          _GetAxes() {
            return this._axes;
          }
          _Drop() {
            this._isDragging && this._OnUp();
          }
          IsDragging() {
            return this._isDragging;
          }
          GetDragSource() {
            return this._dragSource;
          }
          async _OnDown(t2, s3, n2) {
            const a3 = this.GetWorldInfo();
            this._dx = s3 - a3.GetX(), this._dy = n2 - a3.GetY(), this._isDragging = true, this._dragSource = t2, this.DispatchScriptEvent("dragstart"), await this.TriggerAsync(e.Behaviors.DragnDrop.Cnds.OnDragStart);
          }
          _OnMove(e2, t2) {
            const s3 = this.GetWorldInfo(), n2 = e2 - this._dx, a3 = t2 - this._dy;
            0 === this._axes ? s3.GetX() === n2 && s3.GetY() === a3 || (s3.SetXY(n2, a3), s3.SetBboxChanged()) : 1 === this._axes ? s3.GetX() !== n2 && (s3.SetX(n2), s3.SetBboxChanged()) : 2 === this._axes && s3.GetY() !== a3 && (s3.SetY(a3), s3.SetBboxChanged());
          }
          async _OnUp() {
            this._isDragging = false, this.DispatchScriptEvent("drop"), await this.TriggerAsync(e.Behaviors.DragnDrop.Cnds.OnDrop);
          }
          GetPropertyValueByIndex(e2) {
            switch (e2) {
              case s2:
                return this._GetAxes();
              case n:
                return this.IsEnabled();
            }
          }
          SetPropertyValueByIndex(e2, t2) {
            switch (e2) {
              case s2:
                this._SetAxes(t2);
                break;
              case n:
                this._SetEnabled(!!t2);
            }
          }
          GetDebuggerProperties() {
            const e2 = "behaviors.dragndrop", t2 = e2 + ".properties.axes";
            let s3 = "";
            return 0 === this._axes ? s3 = t2 + ".items.both" : 1 === this._axes ? s3 = t2 + ".items.horizontal-only" : 2 === this._axes && (s3 = t2 + ".items.vertical-only"), [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e2 + ".debugger.is-dragging", value: this.IsDragging() }, { name: t2 + ".name", value: [s3] }, { name: e2 + ".properties.enabled.name", value: this.IsEnabled(), onedit: (e3) => this._SetEnabled(e3) }] }];
          }
          GetScriptInterfaceClass() {
            return self.IDragDropBehaviorInstance;
          }
        };
        const a2 = /* @__PURE__ */ new WeakMap(), r2 = ["both", "horizontal", "vertical"];
        self.IDragDropBehaviorInstance = class extends t {
          constructor() {
            super(), a2.set(this, t._GetInitInst().GetSdkInstance());
          }
          set axes(e2) {
            const t2 = r2.indexOf(e2);
            if (-1 === t2) throw new Error("invalid axes");
            a2.get(this)._SetAxes(t2);
          }
          get axes() {
            return r2[a2.get(this)._GetAxes()];
          }
          drop() {
            a2.get(this)._Drop();
          }
          get isDragging() {
            return a2.get(this).IsDragging();
          }
          get isEnabled() {
            return a2.get(this).IsEnabled();
          }
          set isEnabled(e2) {
            a2.get(this)._SetEnabled(e2);
          }
        };
      }
      self.C3.Behaviors.DragnDrop.Cnds = { IsDragging() {
        return this.IsDragging();
      }, OnDragStart: () => true, OnDrop: () => true, IsEnabled() {
        return this.IsEnabled();
      } };
      self.C3.Behaviors.DragnDrop.Acts = { SetEnabled(e) {
        this._SetEnabled(!!e);
      }, SetAxes(e) {
        this._SetAxes(e);
      }, Drop() {
        this._Drop();
      } };
      self.C3.Behaviors.DragnDrop.Exps = {};
    }
    {
      {
        let SetObjectTypeCollisionsEnabled2 = function(t2, e2, i3) {
          const s3 = t2.GetSavedDataMap(), n2 = e2.GetSavedDataMap();
          if (i3) {
            const i4 = s3.get(a2);
            i4 && i4.delete(e2.GetSID());
            const o3 = n2.get(a2);
            o3 && o3.delete(t2.GetSID());
          } else {
            let i4 = s3.get(a2);
            i4 || (i4 = /* @__PURE__ */ new Set(), s3.set(a2, i4));
            let o3 = n2.get(a2);
            o3 || (o3 = /* @__PURE__ */ new Set(), n2.set(a2, o3)), i4.add(e2.GetSID()), o3.add(t2.GetSID());
          }
        };
        SetObjectTypeCollisionsEnabled = SetObjectTypeCollisionsEnabled2;
        const t = self.C3, e = self.C3X;
        let i2 = null, s2 = null, n = [], o2 = null, r2 = null;
        const a2 = "Physics_DisabledCollisions";
        t.Behaviors.Physics = class extends t.SDKBehaviorBase {
          constructor(t2) {
            super(t2), r2 = this, this._world = null, this._worldG = 10, this._worldScale = 0.02, this._worldManifold = null, this._lastUpdateTick = -1, this._steppingMode = 1, this._velocityIterations = 8, this._positionIterations = 3, this._allCollisionsEnabled = true, this._runtime.AddLoadPromise(this._LoadBox2DWasm());
          }
          GetScriptInterfaceClass() {
            return self.IPhysicsBehavior;
          }
          async _LoadBox2DWasm() {
            const t2 = await this._runtime.GetAssetManager().GetProjectFileUrl("box2d.wasm");
            await new Promise((e2) => {
              self["Box2DWasmModule"]({ "wasmBinaryFile": t2 }).then((t3) => {
                o2 = t3, this._InitBox2DWorld(), e2();
              });
            });
          }
          _InitBox2DWorld() {
            const e2 = this._runtime.GetCollisionEngine();
            i2 = t.Behaviors.Physics.GetVec2(0, 0), s2 = t.Behaviors.Physics.GetVec2(0, 0), this._world = new o2["b2World"](t.Behaviors.Physics.GetTempVec2A(0, this._worldG), true);
            const n2 = new o2["JSContactListener"]();
            n2["BeginContact"] = (i3) => {
              const s3 = o2["wrapPointer"](i3, o2["b2Contact"]), n3 = t.Behaviors.Physics.Instance.LookupBehInstFromBody(s3["GetFixtureA"]()["GetBody"]()), r4 = t.Behaviors.Physics.Instance.LookupBehInstFromBody(s3["GetFixtureB"]()["GetBody"]());
              e2.RegisterCollision(n3.GetObjectInstance(), r4.GetObjectInstance());
            }, n2["EndContact"] = () => {
            }, n2["PreSolve"] = () => {
            }, n2["PostSolve"] = () => {
            }, this._world["SetContactListener"](n2);
            const r3 = new o2["JSContactFilter"]();
            r3["ShouldCollide"] = (e3, i3) => {
              if (this._allCollisionsEnabled) return true;
              const s3 = o2["wrapPointer"](e3, o2["b2Fixture"]), n3 = o2["wrapPointer"](i3, o2["b2Fixture"]), r4 = t.Behaviors.Physics.Instance.LookupBehInstFromBody(s3["GetBody"]()), l3 = t.Behaviors.Physics.Instance.LookupBehInstFromBody(n3["GetBody"]()), h = r4.GetObjectInstance().GetObjectClass(), _ = l3.GetObjectInstance().GetObjectClass(), c2 = h.GetSID(), d2 = _.GetSID(), u = h.GetSavedDataMap().get(a2);
              if (u && u.has(d2)) return false;
              const y = _.GetSavedDataMap().get(a2);
              return !y || !y.has(c2);
            }, this._world["SetContactFilter"](r3), this._worldManifold = new o2["b2WorldManifold"]();
          }
          Release() {
            super.Release();
          }
          GetBox2D() {
            return o2;
          }
          GetWorld() {
            return this._world;
          }
          GetWorldScale() {
            return this._worldScale;
          }
          GetSteppingMode() {
            return this._steppingMode;
          }
          SetSteppingMode(t2) {
            this._steppingMode = t2;
          }
          SetLastUpdateTick(t2) {
            this._lastUpdateTick = t2;
          }
          GetLastUpdateTick() {
            return this._lastUpdateTick;
          }
          SetVelocityIterations(t2) {
            this._velocityIterations = Math.max(t2, 1);
          }
          GetVelocityIterations() {
            return this._velocityIterations;
          }
          SetPositionIterations(t2) {
            this._positionIterations = Math.max(t2, 1);
          }
          GetPositionIterations() {
            return this._positionIterations;
          }
          SetIterations(t2, e2) {
            this.SetVelocityIterations(t2), this.SetPositionIterations(e2);
          }
          GetGravity() {
            return this._worldG;
          }
          SetGravity(e2) {
            e2 !== this._worldG && (this._world["SetGravity"](t.Behaviors.Physics.GetTempVec2A(0, e2)), this._worldG = e2, this._WakeUpAllPhysicsBodies());
          }
          _WakeUpAllPhysicsBodies() {
            for (const e2 of this.GetInstances()) {
              const i3 = t.Behaviors.Physics.Instance.LookupBehInstFromInst(e2);
              if (!i3) continue;
              const s3 = i3.GetBody();
              s3 && s3["SetAwake"](true);
            }
          }
          DisableShouldCollideFastPath() {
            this._allCollisionsEnabled = false;
          }
          SetCollisionsEnabled(t2, e2, i3) {
            if (i3 = !!i3, t2 && e2) {
              if (e2.IsFamily()) for (const s3 of e2.GetFamilyMembers()) SetObjectTypeCollisionsEnabled2(t2, s3, i3);
              else SetObjectTypeCollisionsEnabled2(t2, e2, i3);
              this.DisableShouldCollideFastPath();
            }
          }
          GetWorldManifold() {
            return this._worldManifold;
          }
          static GetPhysicsCollisionKey() {
            return a2;
          }
          static GetVec2(t2, e2) {
            if (n.length) {
              const i3 = n.pop();
              return i3["set_x"](t2), i3["set_y"](e2), i3;
            }
            return new (0, o2["b2Vec2"])(t2, e2);
          }
          static FreeVec2(t2) {
            n.push(t2);
          }
          static GetTempVec2A(t2, e2) {
            return i2["set_x"](t2), i2["set_y"](e2), i2;
          }
          static GetTempVec2B(t2, e2) {
            return s2["set_x"](t2), s2["set_y"](e2), s2;
          }
          static CreatePolygonShape(t2) {
            const e2 = new (0, o2["b2PolygonShape"])(), i3 = o2["_malloc"](8 * t2.length);
            let s3 = 0;
            for (let e3 = 0; e3 < t2.length; ++e3) o2["HEAPF32"][i3 + s3 >> 2] = t2[e3]["get_x"](), o2["HEAPF32"][i3 + (s3 + 4) >> 2] = t2[e3]["get_y"](), s3 += 8;
            const n2 = o2["wrapPointer"](i3, o2["b2Vec2"]);
            return e2["Set"](n2, t2.length), o2["_free"](i3), e2;
          }
        };
        const l2 = ["fixed", "variable"];
        self.IPhysicsBehavior = class extends self.IBehavior {
          constructor() {
            super();
          }
          set worldGravity(t2) {
            e.RequireFiniteNumber(t2), r2.SetGravity(t2);
          }
          get worldGravity() {
            return r2.GetGravity();
          }
          set steppingMode(t2) {
            const e2 = l2.indexOf(t2);
            if (e2 < 0) throw new Error("invalid stepping mode");
            r2.SetSteppingMode(l2[e2]);
          }
          get steppingMode() {
            return l2[r2.GetSteppingMode()];
          }
          set velocityIterations(t2) {
            e.RequireFiniteNumber(t2), r2.SetVelocityIterations(t2);
          }
          get velocityIterations() {
            return r2.GetVelocityIterations();
          }
          set positionIterations(t2) {
            e.RequireFiniteNumber(t2), r2.SetPositionIterations(t2);
          }
          get positionIterations() {
            return r2.GetPositionIterations();
          }
          setCollisionsEnabled(t2, e2, i3) {
            const s3 = r2.GetRuntime(), n2 = s3._UnwrapIObjectClass(t2), o3 = s3._UnwrapIObjectClass(e2);
            i3 = !!i3, r2.SetCollisionsEnabled(n2, o3, i3);
          }
        };
      }
      {
        const h = self.C3;
        h.Behaviors.Physics.Type = class extends h.SDKBehaviorTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        let UnwrapIWorldInstance2 = function(t, e) {
          return T.get(t).GetRuntime()._UnwrapIWorldInstance(e);
        };
        UnwrapIWorldInstance = UnwrapIWorldInstance2;
        const _ = self.C3, c2 = self.C3X, d2 = self.IBehaviorInstance, u = (self.assert, 0), y = 1, p = 2, g = 3, m = 4, b = 5, G = 6, I = 7, S = 8, f2 = 9, C = /* @__PURE__ */ new WeakMap(), A = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap(), v = -2147483648, B = 1073741824, w = 536870912, F = 3758096384, P = _.Behaviors.Physics.GetTempVec2A, M = _.Behaviors.Physics.GetTempVec2B, R = _.New(_.Rect), E = _.New(_.Quad);
        _.Behaviors.Physics.Instance = class extends _.SDKBehaviorInstanceBase {
          constructor(t, e) {
            super(t);
            const i2 = this.GetBehavior(), s2 = this.GetWorldInfo();
            this._box2d = i2.GetBox2D(), this._world = i2.GetWorld(), this._worldScale = i2.GetWorldScale(), this._isImmovable = false, this._collisionMask = 0, this._actualCollisionMask = 0, this._preventRotation = false, this._density = 1, this._friction = 0.5, this._restitution = 0.2, this._linearDamping = 0, this._angularDamping = 0.01, this._isBullet = false, this._isEnabled = true, this._body = null, this._fixtures = [], this._myJoints = [], this._myCreatedJoints = [], this._joiningMe = /* @__PURE__ */ new Set(), this._lastKnownX = s2.GetX(), this._lastKnownY = s2.GetY(), this._lastKnownAngle = s2.GetAngle(), this._lastWidth = 0, this._lastHeight = 0, this._lastTickOverride = false, e && (this._isImmovable = !!e[u], this._collisionMask = e[y], this._preventRotation = !!e[p], this._density = e[g], this._friction = e[m], this._restitution = e[b], this._linearDamping = e[G], this._angularDamping = e[I], this._isBullet = !!e[S], this._isEnabled = !!e[f2]);
            const n = this._runtime.Dispatcher();
            this._disposables = new _.CompositeDisposable(_.Disposable.From(n, "instancedestroy", (t2) => this._OnInstanceDestroyed(t2.instance)), _.Disposable.From(n, "beforeload", () => this._OnBeforeLoad()), _.Disposable.From(n, "afterload", () => this._OnAfterLoad())), A.set(this._inst, this), this._isEnabled && this._StartTicking();
          }
          PostCreate() {
            this._CreateBody();
          }
          Release() {
            this._DestroyMyJoints(), _.clearArray(this._myCreatedJoints), this._joiningMe.clear(), this._body && (this._DestroyFixtures(), this._world["DestroyBody"](this._body), this._body = null), super.Release();
          }
          _CreateFixture(t) {
            if (!this._body) return;
            const e = this._body["CreateFixture"](t);
            return this._fixtures.push(e), e;
          }
          _DestroyFixtures() {
            if (this._body) {
              for (const t of this._fixtures) this._body["DestroyFixture"](t);
              _.clearArray(this._fixtures);
            }
          }
          _GetBoundingQuadExcludingMesh() {
            const t = this.GetWorldInfo();
            return t.HasMesh() ? (t.CalculateBbox(R, E, false), E) : t.GetBoundingQuad();
          }
          _Destroy(t) {
            this._box2d["destroy"](t);
          }
          _CreateBody() {
            if (!this._isEnabled) return;
            const t = this._box2d["b2FixtureDef"], e = this._box2d["b2BodyDef"], i2 = this.GetWorldInfo(), s2 = i2.HasOwnCollisionPoly();
            if (this._actualCollisionMask = this._collisionMask, s2 || this._inst.HasTilemap() || 0 !== this._actualCollisionMask || (this._actualCollisionMask = 1), !this._body) {
              const t2 = new e();
              t2["set_type"](this._isImmovable ? 0 : 2);
              let s3 = i2.GetX() * this._worldScale, n2 = i2.GetY() * this._worldScale;
              if (2 === this._actualCollisionMask) {
                const t3 = this._GetBoundingQuadExcludingMesh();
                s3 = t3.midX() * this._worldScale, n2 = t3.midY() * this._worldScale;
              }
              t2["set_position"](M(s3, n2)), t2["set_angle"](i2.GetAngle()), t2["set_fixedRotation"](this._preventRotation), t2["set_linearDamping"](this._linearDamping), t2["set_angularDamping"](this._angularDamping), t2["set_bullet"](this._isBullet), this._body = this._world["CreateBody"](t2), this._Destroy(t2), C.set(this._body, this);
            }
            this._DestroyFixtures();
            const n = new t();
            n["set_density"](this._density), n["set_friction"](this._friction), n["set_restitution"](this._restitution);
            const o2 = Math.max(Math.abs(i2.GetWidth()), 1), r2 = Math.max(Math.abs(i2.GetHeight()), 1);
            0 === this._actualCollisionMask ? this._inst.HasTilemap() ? this._CreateTilemapFixtures(n) : this._CreatePolygonFixture(n, o2, r2) : 1 === this._actualCollisionMask ? this._CreateBoundingBoxFixture(n, i2, o2, r2) : this._CreateCircleFixture(n, o2, r2), this._lastWidth = i2.GetWidth(), this._lastHeight = i2.GetHeight(), i2.SetPhysicsBodyChanged(false), this._Destroy(n);
          }
          _CreateBoundingBoxFixture(t, e, i2, s2) {
            const n = new (0, this._box2d["b2PolygonShape"])(), o2 = i2 * this._worldScale, r2 = s2 * this._worldScale;
            let a2 = e.GetOriginX(), l2 = e.GetOriginY();
            e.GetWidth() < 0 && (a2 = 1 - a2), e.GetHeight() < 0 && (l2 = 1 - l2);
            const h = (0.5 - a2) * o2, c3 = (0.5 - l2) * r2, d3 = _.Behaviors.Physics.GetVec2(h, c3);
            n["SetAsBox"](o2 / 2, r2 / 2, d3, 0), t["set_shape"](n), this._CreateFixture(t), this._Destroy(n), _.Behaviors.Physics.FreeVec2(d3);
          }
          _CreateCircleFixture(t, e, i2) {
            const s2 = new (0, this._box2d["b2CircleShape"])();
            s2["set_m_radius"](Math.min(e, i2) * this._worldScale * 0.5), t["set_shape"](s2), this._CreateFixture(t), this._Destroy(s2);
          }
          _CreatePolygonFixture(t, e, i2) {
            const s2 = this.GetWorldInfo(), n = s2.GetWidth() < 0, o2 = s2.GetHeight() < 0, r2 = this._worldScale, a2 = s2.GetCustomTransformedCollisionPoly(n ? -e : e, o2 ? -i2 : i2, 0).pointsArr(), l2 = a2.length / 2, h = [];
            for (let t2 = 0; t2 < l2; ++t2) h.push(_.Behaviors.Physics.GetVec2(a2[2 * t2], a2[2 * t2 + 1]));
            n !== o2 && h.reverse();
            const c3 = _.Behaviors.Physics.Separator.Separate(h, e * i2);
            for (const t2 of h) _.Behaviors.Physics.FreeVec2(t2);
            if (c3.length) for (const e2 of c3) {
              for (const t2 of e2) t2["set_x"](t2["get_x"]() * r2), t2["set_y"](t2["get_y"]() * r2);
              const i3 = _.Behaviors.Physics.CreatePolygonShape(e2);
              t["set_shape"](i3), this._CreateFixture(t), this._Destroy(i3);
              for (const t2 of e2) _.Behaviors.Physics.FreeVec2(t2);
            }
            else this._CreateBoundingBoxFixture(t, s2, e, i2);
          }
          _CreateTilemapFixtures(t) {
            const e = this._worldScale, i2 = _.Behaviors.Physics.GetVec2, s2 = _.Behaviors.Physics.FreeVec2, n = [];
            this._inst.GetSdkInstance().GetAllCollisionRects(n);
            const o2 = [];
            for (let r2 = 0, a2 = n.length; r2 < a2; ++r2) {
              const a3 = n[r2], l2 = a3.GetRect(), h = a3.GetPoly();
              if (h) {
                let n2 = D.get(h);
                if (!n2) {
                  const t2 = h.pointsArr(), e2 = h.pointCount();
                  for (let s3 = 0; s3 < e2; ++s3) o2.push(i2(t2[2 * s3], t2[2 * s3 + 1]));
                  const r3 = a3.GetTileId() & F;
                  (r3 === v || r3 === B || r3 === w || r3 & v && r3 & B && r3 & w) && o2.reverse(), n2 = _.Behaviors.Physics.Separator.Separate(o2, l2.width() * l2.height()), D.set(h, n2);
                  for (const t3 of o2) s2(t3);
                  _.clearArray(o2);
                }
                for (let r3 = 0, a4 = n2.length; r3 < a4; ++r3) {
                  const a5 = n2[r3];
                  for (let t2 = 0, s3 = a5.length; t2 < s3; ++t2) o2.push(i2((l2.getLeft() + a5[t2]["get_x"]()) * e, (l2.getTop() + a5[t2]["get_y"]()) * e));
                  const h2 = _.Behaviors.Physics.CreatePolygonShape(o2);
                  t["set_shape"](h2), this._CreateFixture(t), this._Destroy(h2);
                  for (const t2 of o2) s2(t2);
                  _.clearArray(o2);
                }
              } else {
                o2.push(i2(l2.getLeft() * e, l2.getTop() * e)), o2.push(i2(l2.getRight() * e, l2.getTop() * e)), o2.push(i2(l2.getRight() * e, l2.getBottom() * e)), o2.push(i2(l2.getLeft() * e, l2.getBottom() * e));
                const s3 = _.Behaviors.Physics.CreatePolygonShape(o2);
                t["set_shape"](s3), this._CreateFixture(t), this._Destroy(s3);
              }
              for (const t2 of o2) s2(t2);
              _.clearArray(o2);
            }
          }
          _DestroyBody() {
            this._body && (this._DestroyMyJoints(), C.delete(this._body), this._DestroyFixtures(), this._world["DestroyBody"](this._body), this._body = null);
          }
          _DestroyMyJoints() {
            for (const t of this._myJoints) this._world["DestroyJoint"](t);
            _.clearArray(this._myJoints);
          }
          _RecreateMyJoints() {
            for (const t of this._myCreatedJoints) switch (t.type) {
              case 0:
                this._DoCreateDistanceJoint(...t.params);
                break;
              case 1:
                this._DoCreateRevoluteJoint(...t.params);
                break;
              case 2:
                this._DoCreateLimitedRevoluteJoint(...t.params);
                break;
              case 3:
                this._DoCreatePrismaticJoint(...t.params);
            }
          }
          _GetInstImagePoint(t) {
            const e = this.GetWorldInfo();
            if (-1 === t) return [e.GetX(), e.GetY()];
            if (0 === t && this._body) {
              const t2 = this._body["GetWorldCenter"]();
              return [t2["get_x"]() / this._worldScale, t2["get_y"]() / this._worldScale];
            }
            return this._inst.GetImagePoint(t);
          }
          _CreateDistanceJoint(t, e, i2, s2, n) {
            if (!this._isEnabled || !e || e === this._inst) return;
            const o2 = _.Behaviors.Physics.Instance.LookupBehInstFromInst(e);
            o2 && o2._IsEnabled() && (this._myCreatedJoints.push({ type: 0, params: [t, e.GetUID(), i2, s2, n] }), this._DoCreateDistanceJoint(t, e.GetUID(), i2, s2, n));
          }
          _DoCreateDistanceJoint(t, e, i2, s2, n) {
            if (!this._isEnabled) return;
            const o2 = this._runtime.GetInstanceByUID(e);
            if (!o2 || o2 === this._inst) return;
            const r2 = _.Behaviors.Physics.Instance.LookupBehInstFromInst(o2);
            if (!r2 || !r2._IsEnabled()) return;
            r2._joiningMe.add(this._inst), this._UpdateBodyToMatchInstance(false), r2._UpdateBodyToMatchInstance(false);
            const [a2, l2] = this._GetInstImagePoint(t), [h, c3] = o2.GetImagePoint(i2), d3 = a2 - h, u2 = l2 - c3, y2 = this._box2d["b2DistanceJointDef"], p2 = this._worldScale, g2 = new y2();
            g2["Initialize"](this._body, r2.GetBody(), P(a2 * p2, l2 * p2), M(h * p2, c3 * p2)), g2["set_length"](Math.hypot(d3, u2) * p2), g2["set_dampingRatio"](s2), g2["set_frequencyHz"](n), this._myJoints.push(this._world["CreateJoint"](g2)), this._Destroy(g2);
          }
          _CreateRevoluteJoint(t, e) {
            if (!this._isEnabled || !e || e === this._inst) return;
            const i2 = _.Behaviors.Physics.Instance.LookupBehInstFromInst(e);
            i2 && i2._IsEnabled() && (this._myCreatedJoints.push({ type: 1, params: [t, e.GetUID()] }), this._DoCreateRevoluteJoint(t, e.GetUID()));
          }
          _DoCreateRevoluteJoint(t, e) {
            if (!this._isEnabled) return;
            const i2 = this._runtime.GetInstanceByUID(e);
            if (!i2 || i2 === this._inst) return;
            const s2 = _.Behaviors.Physics.Instance.LookupBehInstFromInst(i2);
            if (!s2 || !s2._IsEnabled()) return;
            s2._joiningMe.add(this._inst), this._UpdateBodyToMatchInstance(false), s2._UpdateBodyToMatchInstance(false);
            const [n, o2] = this._GetInstImagePoint(t), r2 = this._box2d["b2RevoluteJointDef"], a2 = this._worldScale, l2 = new r2();
            l2["Initialize"](this._body, s2.GetBody(), P(n * a2, o2 * a2)), this._myJoints.push(this._world["CreateJoint"](l2)), this._Destroy(l2);
          }
          _CreateLimitedRevoluteJoint(t, e, i2, s2) {
            if (!this._isEnabled || !e || e === this._inst) return;
            const n = _.Behaviors.Physics.Instance.LookupBehInstFromInst(e);
            n && n._IsEnabled() && (i2 = _.toDegrees(i2), s2 = _.toDegrees(s2), this._myCreatedJoints.push({ type: 2, params: [t, e.GetUID(), i2, s2] }), this._DoCreateLimitedRevoluteJoint(t, e.GetUID(), i2, s2));
          }
          _DoCreateLimitedRevoluteJoint(t, e, i2, s2) {
            if (!this._isEnabled) return;
            const n = this._runtime.GetInstanceByUID(e);
            if (!n || n === this._inst) return;
            const o2 = _.Behaviors.Physics.Instance.LookupBehInstFromInst(n);
            if (!o2 || !o2._IsEnabled()) return;
            o2._joiningMe.add(this._inst), this._UpdateBodyToMatchInstance(false), o2._UpdateBodyToMatchInstance(false);
            const [r2, a2] = this._GetInstImagePoint(t), l2 = this._box2d["b2RevoluteJointDef"], h = this._worldScale, c3 = new l2();
            c3["Initialize"](this._body, o2.GetBody(), P(r2 * h, a2 * h)), c3["set_enableLimit"](true), c3["set_lowerAngle"](_.toRadians(i2)), c3["set_upperAngle"](_.toRadians(s2)), this._myJoints.push(this._world["CreateJoint"](c3)), this._Destroy(c3);
          }
          _CreatePrismaticJoint(t, e, i2, s2, n, o2, r2, a2, l2) {
            if (!this._isEnabled || !e || e === this._inst) return;
            const h = _.Behaviors.Physics.Instance.LookupBehInstFromInst(e);
            h && h._IsEnabled() && (i2 = _.toDegrees(i2), a2 = _.toDegrees(a2), this._myCreatedJoints.push({ type: 3, params: [t, e.GetUID(), i2, s2, n, o2, r2, a2, l2] }), this._DoCreatePrismaticJoint(t, e.GetUID(), i2, s2, n, o2, r2, a2, l2));
          }
          _DoCreatePrismaticJoint(t, e, i2, s2, n, o2, r2, a2, l2) {
            if (!this._isEnabled) return;
            const h = this._runtime.GetInstanceByUID(e);
            if (!h || h === this._inst) return;
            const c3 = _.Behaviors.Physics.Instance.LookupBehInstFromInst(h);
            if (!c3 || !c3._IsEnabled()) return;
            c3._joiningMe.add(this._inst), this._UpdateBodyToMatchInstance(false), c3._UpdateBodyToMatchInstance(false);
            const [d3, u2] = this._GetInstImagePoint(t);
            i2 = _.toRadians(i2);
            const y2 = Math.cos(i2), p2 = Math.sin(i2), g2 = this._box2d["b2PrismaticJointDef"], m2 = this._worldScale, b2 = new g2();
            b2["Initialize"](this._body, c3.GetBody(), P(d3 * m2, u2 * m2), M(y2, p2)), b2["set_enableLimit"](!!s2), b2["set_lowerTranslation"](n * m2), b2["set_upperTranslation"](o2 * m2), b2["set_enableMotor"](!!r2), b2["set_motorSpeed"](_.toRadians(a2)), b2["set_maxMotorForce"](l2), this._myJoints.push(this._world["CreateJoint"](b2)), this._Destroy(b2);
          }
          _RemoveJoints() {
            this._isEnabled && (this._DestroyMyJoints(), _.clearArray(this._myCreatedJoints), this._joiningMe.clear());
          }
          _RemoveOtherInstanceJointsToMe() {
            for (const t of this._joiningMe) {
              const e = _.Behaviors.Physics.Instance.LookupBehInstFromInst(t);
              if (!e || !e._IsEnabled()) return;
              e._DestroyJointsForInstance(this._inst);
            }
            this._joiningMe.clear();
          }
          _OnInstanceDestroyed(t) {
            this._DestroyJointsForInstance(t);
          }
          _DestroyJointsForInstance(t) {
            const e = t.GetUID();
            let i2 = 0;
            for (let t2 = 0, s2 = this._myCreatedJoints.length; t2 < s2; ++t2) this._myCreatedJoints[i2] = this._myCreatedJoints[t2], i2 < this._myJoints.length && (this._myJoints[i2] = this._myJoints[t2]), this._myCreatedJoints[t2].params[1] === e ? t2 < this._myJoints.length && this._world["DestroyJoint"](this._myJoints[t2]) : ++i2;
            _.truncateArray(this._myCreatedJoints, i2), i2 < this._myJoints.length && _.truncateArray(this._myJoints, i2), this._joiningMe.delete(t);
          }
          GetBody() {
            return this._body;
          }
          static LookupBehInstFromBody(t) {
            return C.get(t) || null;
          }
          static LookupBehInstFromInst(t) {
            return A.get(t) || null;
          }
          SaveToJson() {
            const t = { "e": this._isEnabled, "im": this._isImmovable, "pr": this._preventRotation, "d": this._density, "fr": this._friction, "re": this._restitution, "ld": this._linearDamping, "ad": this._angularDamping, "b": this._isBullet, "mcj": this._myCreatedJoints };
            if (this._isEnabled) {
              const e = this._body["GetLinearVelocity"]();
              t["vx"] = e["get_x"](), t["vy"] = e["get_y"](), t["om"] = this._body["GetAngularVelocity"]();
            }
            return t;
          }
          _OnBeforeLoad() {
            this._DestroyMyJoints(), _.clearArray(this._myCreatedJoints), this._joiningMe.clear();
          }
          LoadFromJson(t) {
            this._DestroyBody(), this._isEnabled = t["e"], t.hasOwnProperty("im") && (this._isImmovable = !!t["im"]), this._preventRotation = t["pr"], this._density = t["d"], this._friction = t["fr"], this._restitution = t["re"], this._linearDamping = t["ld"], this._angularDamping = t["ad"], this._isBullet = t["b"], this._myCreatedJoints = t["mcj"];
            const e = this.GetWorldInfo();
            this._lastKnownX = e.GetX(), this._lastKnownY = e.GetY(), this._lastKnownAngle = e.GetAngle(), this._lastWidth = e.GetWidth(), this._lastHeight = e.GetHeight(), this._isEnabled && (this._CreateBody(), this._body["SetLinearVelocity"](P(t["vx"], t["vy"])), this._body["SetAngularVelocity"](t["om"]), 0 === t["vx"] && 0 === t["vy"] && 0 === t["om"] || this._body["SetAwake"](true), this._myCreatedJoints = t["mcj"]), this._isEnabled ? this._StartTicking() : this._StopTicking();
          }
          _OnAfterLoad() {
            this._isEnabled && this._RecreateMyJoints();
          }
          Tick() {
            if (!this._isEnabled) return;
            const t = this._runtime, e = this.GetBehavior();
            let i2 = 0;
            0 === e.GetSteppingMode() ? i2 = t.GetTimeScale() / 60 : (i2 = t.GetDt(this._inst), i2 > 1 / 30 && (i2 = 1 / 30));
            const s2 = t.GetTickCountNoSave();
            s2 > e.GetLastUpdateTick() && t.GetTimeScale() > 0 && (0 !== i2 && this._world["Step"](i2, e.GetVelocityIterations(), e.GetPositionIterations()), this._world["ClearForces"](), e.SetLastUpdateTick(s2)), this._UpdateBodyToMatchInstance(true);
          }
          _UpdateBodyToMatchInstance(t) {
            const e = this._inst.GetWorldInfo(), i2 = this._worldScale;
            (e.GetWidth() !== this._lastWidth || e.GetHeight() !== this._lastHeight || e.IsPhysicsBodyChanged()) && this._CreateBody();
            const s2 = this._body, n = e.GetX(), o2 = e.GetY(), r2 = n - this._lastKnownX, a2 = o2 - this._lastKnownY, l2 = Math.abs(r2) > 1e-3 || Math.abs(a2) > 1e-3, h = e.GetAngle() !== this._lastKnownAngle;
            let _2 = n, c3 = o2;
            if (2 === this._actualCollisionMask) {
              const t2 = this._GetBoundingQuadExcludingMesh();
              _2 = t2.midX(), c3 = t2.midY();
            }
            l2 ? (h ? s2["SetTransform"](P(_2 * i2, c3 * i2), e.GetAngle()) : s2["SetTransform"](P(_2 * i2, c3 * i2), s2["GetAngle"]()), t && (s2["SetLinearVelocity"](P(r2, a2)), this._lastTickOverride = true), s2["SetAwake"](true)) : t && this._lastTickOverride && (this._lastTickOverride = false, s2["SetLinearVelocity"](P(0, 0)), s2["SetTransform"](P(_2 * i2, c3 * i2), s2["GetAngle"]())), !l2 && h && (s2["SetTransform"](s2["GetPosition"](), e.GetAngle()), s2["SetAwake"](true));
            const d3 = s2["GetPosition"](), u2 = d3["get_x"]() / i2, y2 = d3["get_y"]() / i2, p2 = s2["GetAngle"]();
            if ((u2 !== e.GetX() || y2 !== e.GetY() || p2 !== e.GetAngle()) && (e.SetXY(u2, y2), e.SetAngle(p2), e.SetBboxChanged(), 2 === this._actualCollisionMask)) {
              const t2 = this._GetBoundingQuadExcludingMesh(), i3 = t2.midX() - e.GetX(), s3 = t2.midY() - e.GetY();
              0 === i3 && 0 === s3 || (e.OffsetXY(-i3, -s3), e.SetBboxChanged());
            }
            this._lastKnownX = e.GetX(), this._lastKnownY = e.GetY(), this._lastKnownAngle = e.GetAngle();
          }
          GetPropertyValueByIndex(t) {
            switch (t) {
              case p:
                return this._IsPreventRotate();
              case g:
                return this._GetDensity();
              case m:
                return this._GetFriction();
              case b:
                return this._GetElasticity();
              case G:
                return this._GetLinearDamping();
              case I:
                return this._GetAngularDamping();
              case S:
                return this._IsBullet();
              case f2:
                return this._IsEnabled();
            }
          }
          SetPropertyValueByIndex(t, e) {
            switch (t) {
              case p:
                this._SetPreventRotate(e);
                break;
              case g:
                this._SetDensity(e);
                break;
              case m:
                this._SetFriction(e);
                break;
              case b:
                this._SetElasticity(e);
                break;
              case G:
                this._SetLinearDamping(e);
                break;
              case I:
                this._SetAngularDamping(e);
                break;
              case S:
                this._SetBullet(e);
                break;
              case f2:
                this._SetEnabled(e);
            }
          }
          _SetEnabled(t) {
            t = !!t, this._isEnabled && !t ? (this._RemoveOtherInstanceJointsToMe(), this._DestroyBody(), this._isEnabled = false, this._StopTicking()) : !this._isEnabled && t && (this._isEnabled = true, this._CreateBody(), this._StartTicking());
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          GetDebuggerProperties() {
            const t = "behaviors.physics", e = [{ name: t + ".properties.enabled.name", value: this._IsEnabled(), onedit: (t2) => this._SetEnabled(t2) }, { name: t + ".properties.immovable.name", value: this._IsImmovable(), onedit: (t2) => this._SetImmovable(t2) }, { name: t + ".properties.density.name", value: this._GetDensity(), onedit: (t2) => this._SetDensity(t2) }, { name: t + ".properties.friction.name", value: this._GetFriction(), onedit: (t2) => this._SetFriction(t2) }, { name: t + ".properties.elasticity.name", value: this._GetElasticity(), onedit: (t2) => this._SetElasticity(t2) }, { name: t + ".properties.linear-damping.name", value: this._GetLinearDamping(), onedit: (t2) => this._SetLinearDamping(t2) }, { name: t + ".properties.angular-damping.name", value: this._GetAngularDamping(), onedit: (t2) => this._SetAngularDamping(t2) }];
            return this._isEnabled && (e.push({ name: t + ".debugger.is-sleeping", value: !this._IsAwake() }), e.push({ name: t + ".debugger.velocity-x", value: this._GetVelocityX(), onedit: (t2) => this._SetVelocity(t2, this._GetVelocityY()) }), e.push({ name: t + ".debugger.velocity-y", value: this._GetVelocityY(), onedit: (t2) => this._SetVelocity(this._GetVelocityX(), t2) }), e.push({ name: t + ".debugger.angular-velocity", value: _.toDegrees(this._GetAngularVelocity()), onedit: (t2) => this._SetAngularVelocity(_.toRadians(t2)) }), e.push({ name: t + ".debugger.mass", value: this._GetMass() })), [{ title: "$" + this.GetBehaviorType().GetName(), properties: e }];
          }
          _ApplyForce(t, e, i2) {
            const [s2, n] = this._GetInstImagePoint(i2);
            this._DoApplyForce(t, e, s2, n);
          }
          _ApplyForceToward(t, e, i2, s2) {
            const [n, o2] = this._GetInstImagePoint(s2), r2 = _.angleTo(n, o2, e, i2);
            this._DoApplyForce(Math.cos(r2) * t, Math.sin(r2) * t, n, o2);
          }
          _ApplyForceAtAngle(t, e, i2) {
            const [s2, n] = this._GetInstImagePoint(i2);
            this._DoApplyForce(Math.cos(e) * t, Math.sin(e) * t, s2, n);
          }
          _DoApplyForce(t, e, i2, s2) {
            if (!this._isEnabled) return;
            const n = this._worldScale;
            this._body["ApplyForce"](P(t, e), M(i2 * n, s2 * n), true);
          }
          _ApplyImpulse(t, e, i2) {
            const [s2, n] = this._GetInstImagePoint(i2);
            this._DoApplyImpulse(t, e, s2, n);
          }
          _ApplyImpulseToward(t, e, i2, s2) {
            const [n, o2] = this._GetInstImagePoint(s2), r2 = _.angleTo(n, o2, e, i2);
            this._DoApplyImpulse(Math.cos(r2) * t, Math.sin(r2) * t, n, o2);
          }
          _ApplyImpulseAtAngle(t, e, i2) {
            const [s2, n] = this._GetInstImagePoint(i2);
            this._DoApplyImpulse(Math.cos(e) * t, Math.sin(e) * t, s2, n);
          }
          _DoApplyImpulse(t, e, i2, s2) {
            if (!this._isEnabled) return;
            const n = this._worldScale;
            this._body["ApplyLinearImpulse"](P(t, e), M(i2 * n, s2 * n), true);
            const o2 = this.GetWorldInfo();
            this._lastKnownX = o2.GetX(), this._lastKnownY = o2.GetY(), this._lastTickOverride = false;
          }
          _ApplyTorque(t) {
            this._isEnabled && this._body["ApplyTorque"](t, true);
          }
          _ApplyTorqueToAngle(t, e) {
            const i2 = _.angleClockwise(this.GetWorldInfo().GetAngle(), e) ? -1 : 1;
            this._ApplyTorque(t * i2);
          }
          _ApplyTorqueToPosition(t, e, i2) {
            const s2 = this.GetWorldInfo(), n = _.angleTo(s2.GetX(), s2.GetY(), e, i2), o2 = _.angleClockwise(s2.GetAngle(), n) ? -1 : 1;
            this._ApplyTorque(t * o2);
          }
          _SetAngularVelocity(t) {
            this._isEnabled && (this._body["SetAngularVelocity"](t), this._body["SetAwake"](true));
          }
          _GetAngularVelocity() {
            return this._isEnabled ? this._body["GetAngularVelocity"]() : 0;
          }
          _SetVelocity(t, e) {
            if (!this._isEnabled) return;
            const i2 = this._worldScale;
            this._body["SetLinearVelocity"](P(t * i2, e * i2)), this._body["SetAwake"](true);
            const s2 = this.GetWorldInfo();
            this._lastKnownX = s2.GetX(), this._lastKnownY = s2.GetY(), this._lastTickOverride = false;
          }
          _GetVelocity() {
            if (!this._isEnabled) return [0, 0];
            const t = this._worldScale, e = this._body["GetLinearVelocity"]();
            return [e["get_x"]() / t, e["get_y"]() / t];
          }
          _GetVelocityX() {
            return this._isEnabled ? this._body["GetLinearVelocity"]()["get_x"]() / this._worldScale : 0;
          }
          _GetVelocityY() {
            return this._isEnabled ? this._body["GetLinearVelocity"]()["get_y"]() / this._worldScale : 0;
          }
          _Teleport(t, e) {
            if (!this._isEnabled) return;
            const i2 = this._worldScale;
            this._body["SetTransform"](P(t * i2, e * i2), this._body["GetAngle"]());
            const s2 = this.GetWorldInfo();
            s2.SetXY(t, e), s2.SetBboxChanged(), this._lastKnownX = s2.GetX(), this._lastKnownY = s2.GetY();
          }
          _SetDensity(t) {
            if (this._isEnabled && this._density !== t) {
              this._density = t;
              for (const e of this._fixtures) e["SetDensity"](t);
              this._body["ResetMassData"]();
            }
          }
          _GetDensity() {
            return this._isEnabled ? this._density : 0;
          }
          _SetFriction(t) {
            if (this._isEnabled && this._friction !== t) {
              this._friction = t;
              for (const e of this._fixtures) e["SetFriction"](t);
              if (this._body) for (let t2 = this._body["GetContactList"](); this._box2d["getPointer"](t2); t2 = t2["get_next"]()) {
                const e = t2["get_contact"]();
                e && e["ResetFriction"]();
              }
            }
          }
          _GetFriction() {
            return this._isEnabled ? this._friction : 0;
          }
          _SetElasticity(t) {
            if (this._isEnabled && this._restitution !== t) {
              this._restitution = t;
              for (const e of this._fixtures) e["SetRestitution"](t);
            }
          }
          _GetElasticity() {
            return this._isEnabled ? this._restitution : 0;
          }
          _SetLinearDamping(t) {
            this._isEnabled && this._linearDamping !== t && (this._linearDamping = t, this._body["SetLinearDamping"](t));
          }
          _GetLinearDamping() {
            return this._isEnabled ? this._linearDamping : 0;
          }
          _SetAngularDamping(t) {
            this._isEnabled && this._angularDamping !== t && (this._angularDamping = t, this._body["SetAngularDamping"](t));
          }
          _GetAngularDamping() {
            return this._isEnabled ? this._angularDamping : 0;
          }
          _SetImmovable(t) {
            this._isEnabled && (t = !!t, this._isImmovable !== t && (this._isImmovable = t, this._body["SetType"](this._isImmovable ? 0 : 2), this._body["SetAwake"](true)));
          }
          _IsImmovable() {
            return this._isImmovable;
          }
          _SetPreventRotate(t) {
            this._isEnabled && (t = !!t, this._preventRotation !== t && (this._preventRotation = t, this._body["SetFixedRotation"](this._preventRotation), this._body["SetAngularVelocity"](0), this._body["SetAwake"](true)));
          }
          _IsPreventRotate() {
            return this._preventRotation;
          }
          _SetBullet(t) {
            this._isEnabled && (t = !!t, this._isBullet !== t && (this._isBullet = t, this._body["SetBullet"](this._isBullet), this._body["SetAwake"](true)));
          }
          _IsBullet() {
            return this._isBullet;
          }
          _SetAwake(t) {
            this._isEnabled && this._body["SetAwake"](!!t);
          }
          _IsAwake() {
            return !!this._isEnabled && this._body["IsAwake"]();
          }
          _GetMass() {
            return this._isEnabled ? this._body["GetMass"]() / this._worldScale : 0;
          }
          _GetCenterOfMassX() {
            return this._isEnabled ? this._body["GetWorldCenter"]()["get_x"]() / this._worldScale : 0;
          }
          _GetCenterOfMassY() {
            return this._isEnabled ? this._body["GetWorldCenter"]()["get_y"]() / this._worldScale : 0;
          }
          _GetCenterOfMass() {
            if (!this._isEnabled) return [0, 0];
            const t = this._body["GetWorldCenter"](), e = this._worldScale;
            return [t["get_x"]() / e, t["get_y"]() / e];
          }
          _GetContactCount() {
            if (!this._isEnabled) return 0;
            let t = 0;
            for (let e = this._body["GetContactList"](); this._box2d["getPointer"](e); e = e["get_next"]()) {
              const i2 = e["get_contact"]();
              if (!i2) continue;
              t += i2["GetManifold"]()["get_pointCount"]();
            }
            return t;
          }
          _GetContactPositionAt(t) {
            if (t = Math.floor(t), !this._isEnabled) return [0, 0];
            let e = 0;
            for (let i2 = this._body["GetContactList"](); this._box2d["getPointer"](i2); i2 = i2["get_next"]()) {
              const s2 = i2["get_contact"]();
              if (!s2) continue;
              const n = s2["GetManifold"]()["get_pointCount"]();
              if (t >= e && t < e + n) {
                const i3 = t - e, n2 = this.GetBehavior().GetWorldManifold();
                s2["GetWorldManifold"](n2);
                const o2 = n2["get_points"](i3);
                return [o2["get_x"]() / this._worldScale, o2["get_y"]() / this._worldScale];
              }
              e += n;
            }
            return [0, 0];
          }
          GetScriptInterfaceClass() {
            return self.IPhysicsBehaviorInstance;
          }
        };
        const T = /* @__PURE__ */ new WeakMap();
        self.IPhysicsBehaviorInstance = class extends d2 {
          constructor() {
            super(), T.set(this, d2._GetInitInst().GetSdkInstance());
          }
          get isEnabled() {
            return T.get(this)._IsEnabled();
          }
          set isEnabled(t) {
            T.get(this)._SetEnabled(t);
          }
          applyForce(t, e, i2 = 0) {
            c2.RequireFiniteNumber(t), c2.RequireFiniteNumber(e), T.get(this)._ApplyForce(t, e, i2);
          }
          applyForceTowardPosition(t, e, i2, s2 = 0) {
            c2.RequireFiniteNumber(t), c2.RequireFiniteNumber(e), c2.RequireFiniteNumber(i2), T.get(this)._ApplyForceToward(t, e, i2, s2);
          }
          applyForceAtAngle(t, e, i2 = 0) {
            c2.RequireFiniteNumber(t), c2.RequireFiniteNumber(e), T.get(this)._ApplyForceAtAngle(t, e, i2);
          }
          applyImpulse(t, e, i2 = 0) {
            c2.RequireFiniteNumber(t), c2.RequireFiniteNumber(e), T.get(this)._ApplyImpulse(t, e, i2);
          }
          applyImpulseTowardPosition(t, e, i2, s2 = 0) {
            c2.RequireFiniteNumber(t), c2.RequireFiniteNumber(e), c2.RequireFiniteNumber(i2), T.get(this)._ApplyImpulseToward(t, e, i2, s2);
          }
          applyImpulseAtAngle(t, e, i2 = 0) {
            c2.RequireFiniteNumber(t), c2.RequireFiniteNumber(e), T.get(this)._ApplyImpulseAtAngle(t, e, i2);
          }
          applyTorque(t) {
            c2.RequireFiniteNumber(t), T.get(this)._ApplyTorque(t);
          }
          applyTorqueToAngle(t, e) {
            c2.RequireFiniteNumber(t), c2.RequireFiniteNumber(e), T.get(this)._ApplyTorqueToAngle(t, e);
          }
          applyTorqueToPosition(t, e, i2) {
            c2.RequireFiniteNumber(t), c2.RequireFiniteNumber(e), c2.RequireFiniteNumber(i2), T.get(this)._ApplyTorqueToPosition(t, e, i2);
          }
          set angularVelocity(t) {
            c2.RequireFiniteNumber(t), T.get(this)._SetAngularVelocity(t);
          }
          get angularVelocity() {
            return T.get(this)._GetAngularVelocity();
          }
          setVelocity(t, e) {
            c2.RequireFiniteNumber(t), c2.RequireFiniteNumber(e), T.get(this)._SetVelocity(t, e);
          }
          getVelocityX() {
            return T.get(this)._GetVelocityX();
          }
          getVelocityY() {
            return T.get(this)._GetVelocityY();
          }
          getVelocity() {
            return T.get(this)._GetVelocity();
          }
          teleport(t, e) {
            c2.RequireFiniteNumber(t), c2.RequireFiniteNumber(e), T.get(this)._Teleport(t, e);
          }
          set density(t) {
            c2.RequireFiniteNumber(t), T.get(this)._SetDensity(t);
          }
          get density() {
            return T.get(this)._GetDensity();
          }
          set friction(t) {
            c2.RequireFiniteNumber(t), T.get(this)._SetFriction(t);
          }
          get friction() {
            return T.get(this)._GetFriction();
          }
          set elasticity(t) {
            c2.RequireFiniteNumber(t), T.get(this)._SetElasticity(t);
          }
          get elasticity() {
            return T.get(this)._GetElasticity();
          }
          set linearDamping(t) {
            c2.RequireFiniteNumber(t), T.get(this)._SetLinearDamping(t);
          }
          get linearDamping() {
            return T.get(this)._GetLinearDamping();
          }
          set angularDamping(t) {
            c2.RequireFiniteNumber(t), T.get(this)._SetAngularDamping(t);
          }
          get angularDamping() {
            return T.get(this)._GetAngularDamping();
          }
          set isImmovable(t) {
            T.get(this)._SetImmovable(t);
          }
          get isImmovable() {
            return T.get(this)._IsImmovable();
          }
          set isPreventRotation(t) {
            T.get(this)._SetPreventRotate(t);
          }
          get isPreventRotation() {
            return T.get(this)._IsPreventRotate();
          }
          set isBullet(t) {
            T.get(this)._SetBullet(t);
          }
          get isBullet() {
            return T.get(this)._IsBullet();
          }
          get mass() {
            return T.get(this)._GetMass();
          }
          getCenterOfMassX() {
            return T.get(this)._GetCenterOfMassX();
          }
          getCenterOfMassY() {
            return T.get(this)._GetCenterOfMassY();
          }
          getCenterOfMass() {
            return T.get(this)._GetCenterOfMass();
          }
          getContactCount() {
            return T.get(this)._GetContactCount();
          }
          getContactX(t) {
            return c2.RequireFiniteNumber(t), T.get(this)._GetContactPositionAt(t)[0];
          }
          getContactY(t) {
            return c2.RequireFiniteNumber(t), T.get(this)._GetContactPositionAt(t)[1];
          }
          getContact(t) {
            return c2.RequireFiniteNumber(t), T.get(this)._GetContactPositionAt(t);
          }
          set isAwake(t) {
            T.get(this)._SetAwake(!!t);
          }
          get isAwake() {
            return T.get(this)._IsAwake();
          }
          get isSleeping() {
            return !T.get(this)._IsAwake();
          }
          createDistanceJoint(t, e, i2, s2, n) {
            c2.RequireFiniteNumber(s2), c2.RequireFiniteNumber(n);
            const o2 = UnwrapIWorldInstance2(this, e);
            T.get(this)._CreateDistanceJoint(t, o2, i2, s2, n);
          }
          createRevoluteJoint(t, e) {
            const i2 = UnwrapIWorldInstance2(this, e);
            T.get(this)._CreateRevoluteJoint(t, i2);
          }
          createLimitedRevoluteJoint(t, e, i2, s2) {
            c2.RequireFiniteNumber(i2), c2.RequireFiniteNumber(s2);
            const n = UnwrapIWorldInstance2(this, e);
            T.get(this)._CreateLimitedRevoluteJoint(t, n, i2, s2);
          }
          createPrismaticJoint(t, e, i2, s2, n, o2, r2, a2, l2) {
            const h = UnwrapIWorldInstance2(this, e);
            T.get(this)._CreatePrismaticJoint(t, h, i2, s2, n, o2, r2, a2, l2);
          }
          removeAllJoints() {
            T.get(this)._RemoveJoints();
          }
        };
      }
      {
        const x = self.C3;
        x.Behaviors.Physics.Cnds = { IsSleeping() {
          return !this._IsAwake();
        }, IsImmovable() {
          return this._IsImmovable();
        }, CompareVelocity(t, e, i2) {
          if (!this._isEnabled) return false;
          let s2 = 0;
          if (0 === t) s2 = this._GetVelocityX();
          else if (1 === t) s2 = this._GetVelocityY();
          else {
            const [t2, e2] = this._GetVelocity();
            s2 = Math.hypot(t2, e2);
          }
          return x.compare(s2, e, i2);
        }, CompareAngularVelocity(t, e) {
          if (!this._isEnabled) return false;
          const i2 = x.toDegrees(this._GetAngularVelocity());
          return x.compare(i2, t, e);
        }, CompareMass(t, e) {
          if (!this._isEnabled) return false;
          const i2 = this._GetMass();
          return x.compare(i2, t, e);
        }, IsEnabled() {
          return this._IsEnabled();
        } };
      }
      {
        const k = self.C3;
        k.Behaviors.Physics.Acts = { ApplyForce(t, e, i2) {
          this._ApplyForce(t, e, i2);
        }, ApplyForceToward(t, e, i2, s2) {
          this._ApplyForceToward(t, e, i2, s2);
        }, ApplyForceAtAngle(t, e, i2) {
          this._ApplyForceAtAngle(t, k.toRadians(e), i2);
        }, ApplyImpulse(t, e, i2) {
          this._ApplyImpulse(t, e, i2);
        }, ApplyImpulseToward(t, e, i2, s2) {
          this._ApplyImpulseToward(t, e, i2, s2);
        }, ApplyImpulseAtAngle(t, e, i2) {
          this._ApplyImpulseAtAngle(t, k.toRadians(e), i2);
        }, ApplyTorque(t) {
          this._ApplyTorque(k.toRadians(t));
        }, ApplyTorqueToAngle(t, e) {
          this._ApplyTorqueToAngle(k.toRadians(t), k.toRadians(e));
        }, ApplyTorqueToPosition(t, e, i2) {
          this._ApplyTorqueToPosition(k.toRadians(t), e, i2);
        }, SetAngularVelocity(t) {
          this._SetAngularVelocity(k.toRadians(t));
        }, CreateDistanceJoint(t, e, i2, s2, n) {
          if (!e) return;
          const o2 = e.GetFirstPicked(this._inst);
          this._CreateDistanceJoint(t, o2, i2, s2, n);
        }, CreateRevoluteJoint(t, e) {
          if (!e) return;
          const i2 = e.GetFirstPicked(this._inst);
          this._CreateRevoluteJoint(t, i2);
        }, CreateLimitedRevoluteJoint(t, e, i2, s2) {
          if (!e) return;
          const n = e.GetFirstPicked(this._inst);
          this._CreateLimitedRevoluteJoint(t, n, k.toRadians(i2), k.toRadians(s2));
        }, CreatePrismaticJoint(t, e, i2, s2, n, o2, r2, a2, l2) {
          if (!e) return;
          const h = e.GetFirstPicked(this._inst);
          this._CreatePrismaticJoint(t, h, k.toRadians(i2), s2, n, o2, r2, k.toRadians(a2), l2);
        }, RemoveJoints() {
          this._RemoveJoints();
        }, SetWorldGravity(t) {
          this.GetBehavior().SetGravity(t);
        }, SetSteppingMode(t) {
          this.GetBehavior().SetSteppingMode(t);
        }, SetIterations(t, e) {
          this.GetBehavior().SetIterations(t, e);
        }, SetVelocity(t, e) {
          this._SetVelocity(t, e);
        }, Teleport(t, e) {
          this._Teleport(t, e);
        }, SetDensity(t) {
          this._SetDensity(t);
        }, SetFriction(t) {
          this._SetFriction(t);
        }, SetElasticity(t) {
          this._SetElasticity(t);
        }, SetLinearDamping(t) {
          this._SetLinearDamping(t);
        }, SetAngularDamping(t) {
          this._SetAngularDamping(t);
        }, SetImmovable(t) {
          this._SetImmovable(t);
        }, EnableCollisions(t, e) {
          this.GetBehavior().SetCollisionsEnabled(this.GetObjectClass(), t, 0 !== e);
        }, SetPreventRotate(t) {
          this._SetPreventRotate(0 !== t);
        }, SetBullet(t) {
          this._SetBullet(0 !== t);
        }, SetAwake(t) {
          this._SetAwake(!!t);
        }, SetEnabled(t) {
          this._SetEnabled(0 !== t);
        } };
      }
      {
        const J = self.C3;
        J.Behaviors.Physics.Exps = { VelocityX() {
          return this._GetVelocityX();
        }, VelocityY() {
          return this._GetVelocityY();
        }, AngularVelocity() {
          return J.toDegrees(this._GetAngularVelocity());
        }, Mass() {
          return this._GetMass();
        }, CenterOfMassX() {
          return this._GetCenterOfMassX();
        }, CenterOfMassY() {
          return this._GetCenterOfMassY();
        }, Density() {
          return this._GetDensity();
        }, Friction() {
          return this._GetFriction();
        }, Elasticity() {
          return this._GetElasticity();
        }, LinearDamping() {
          return this._GetLinearDamping();
        }, AngularDamping() {
          return this._GetAngularDamping();
        }, ContactCount() {
          return this._GetContactCount();
        }, ContactXAt(t) {
          return this._GetContactPositionAt(t)[0];
        }, ContactYAt(t) {
          return this._GetContactPositionAt(t)[1];
        } };
      }
    }
    var SetObjectTypeCollisionsEnabled;
    var UnwrapIWorldInstance;
    {
      let CloneVec22 = function(e) {
        return GetVec2(e["get_x"](), e["get_y"]());
      }, SplitConvexPolysOver8Points2 = function(e) {
        const t = [];
        for (const r2 of e) r2.length <= 8 ? t.push(r2) : t.push.apply(t, SplitConvexPoly2(r2));
        return t;
      }, SplitConvexPoly2 = function(e) {
        const t = [];
        t.push(e.splice(0, 8));
        const r2 = t[0][0];
        let n = t[0][7];
        for (; e.length; ) {
          const a2 = e.splice(0, Math.min(e.length, 6));
          let o2 = a2.at(-1);
          a2.push(CloneVec22(r2)), a2.push(CloneVec22(n)), t.push(a2), n = o2;
        }
        return t;
      };
      CloneVec2 = CloneVec22, SplitConvexPolysOver8Points = SplitConvexPolysOver8Points2, SplitConvexPoly = SplitConvexPoly2;
      const C33 = self.C3, b2Separator = {};
      C33.Behaviors.Physics.Separator = b2Separator;
      const GetVec2 = C33.Behaviors.Physics.GetVec2, FreeVec2 = C33.Behaviors.Physics.FreeVec2;
      b2Separator.det = function(e, t, r2, n, a2, o2) {
        return e * n + r2 * o2 + a2 * t - t * r2 - n * a2 - o2 * e;
      }, b2Separator.hitRay = function(e, t, r2, n, a2, o2, s2, g) {
        const p = r2 - e, i2 = n - t, c2 = s2 - a2, h = g - o2, _ = (c2 * (o2 - t) - h * (a2 - e)) / (i2 * c2 - p * h), u = e + _ * p, l2 = t + _ * i2, y = b2Separator.isOnSegment(r2, n, e, t, u, l2), f2 = b2Separator.isOnSegment(u, l2, a2, o2, s2, g);
        return y && f2 ? GetVec2(u, l2) : null;
      }, b2Separator.isOnSegment = function(e, t, r2, n, a2, o2) {
        return (r2 + 0.1 >= e && e >= a2 - 0.1 || r2 - 0.1 <= e && e <= a2 + 0.1) && (n + 0.1 >= t && t >= o2 - 0.1 || n - 0.1 <= t && t <= o2 + 0.1) && b2Separator.isOnLine(e, t, r2, n, a2, o2);
      }, b2Separator.isOnLine = function(e, t, r2, n, a2, o2) {
        if (Math.abs(a2 - r2) > 0.1) {
          const s2 = (o2 - n) / (a2 - r2) * (e - r2) + n;
          return Math.abs(s2 - t) < 0.1;
        }
        return Math.abs(e - r2) < 0.1;
      }, b2Separator.pointsMatch = function(e, t, r2, n) {
        return Math.abs(r2 - e) < 0.1 && Math.abs(n - t) < 0.1;
      }, b2Separator.Separate = function(e, t) {
        if (3 === e.length) return [e.map((e2) => GetVec2(e2["get_x"](), e2["get_y"]()))];
        const r2 = b2Separator.calcShapes(e);
        let n = [];
        for (let e2 = 0, a2 = r2.length; e2 < a2; ++e2) {
          const a3 = r2[e2], o2 = [];
          let s2 = 0;
          for (let e3 = 0, t2 = a3.length; e3 < t2; ++e3) {
            const r3 = a3[e3], n2 = a3[(e3 + 1) % t2];
            s2 += r3["get_x"]() * n2["get_y"]() - r3["get_y"]() * n2["get_x"](), o2.push(GetVec2(r3["get_x"](), r3["get_y"]()));
          }
          if (s2 = Math.abs(s2 / 2), s2 >= 1e-3 * t) n.push(o2);
          else for (let e3 = 0, t2 = o2.length; e3 < t2; e3++) FreeVec2(o2[e3]);
        }
        return n = SplitConvexPolysOver8Points2(n), n;
      }, b2Separator.calcShapes = function(e) {
        let t, r2, n, a2, o2, s2, g, p = [], i2 = 0, c2 = 0, h = 0, _ = 0, u = 0, l2 = 0, y = 0, f2 = 0, S = 0, b = 0, x = 0, V = 0, C = 0, v = 0, M = 0, O = [], P = [], m = false, G = [], F = [], k = false;
        for (F.push(e); F.length; ) {
          for (p = F[0], c2 = p.length, m = true, i2 = 0; i2 < c2; i2++) if (S = i2, b = i2 < c2 - 1 ? i2 + 1 : i2 + 1 - c2, x = i2 < c2 - 2 ? i2 + 2 : i2 + 2 - c2, t = p[S], r2 = p[b], n = p[x], _ = b2Separator.det(t["get_x"](), t["get_y"](), r2["get_x"](), r2["get_y"](), n["get_x"](), n["get_y"]()), _ < 0) {
            for (m = false, f2 = 1e9, h = 0; h < c2; h++) h !== S && h !== b && (V = h, C = h < c2 - 1 ? h + 1 : 0, a2 = p[V], o2 = p[C], s2 = b2Separator.hitRay(t["get_x"](), t["get_y"](), r2["get_x"](), r2["get_y"](), a2["get_x"](), a2["get_y"](), o2["get_x"](), o2["get_y"]()), s2 && (l2 = r2["get_x"]() - s2["get_x"](), y = r2["get_y"]() - s2["get_y"](), u = l2 * l2 + y * y, u < f2 ? (M = V, v = C, g = s2, f2 = u) : FreeVec2(s2)));
            if (1e9 === f2) return [];
            for (O = [], P = [], V = M, C = v, a2 = p[V], o2 = p[C], k = false, b2Separator.pointsMatch(g["get_x"](), g["get_y"](), o2["get_x"](), o2["get_y"]()) || (O.push(g), k = true), b2Separator.pointsMatch(g["get_x"](), g["get_y"](), a2["get_x"](), a2["get_y"]()) || (P.push(g), k = true), k || FreeVec2(g), M = -1, v = S; ; ) {
              if (v === C) {
                if (M < 0 || M >= c2) return [];
                b2Separator.isOnSegment(o2["get_x"](), o2["get_y"](), p[M]["get_x"](), p[M]["get_y"](), t["get_x"](), t["get_y"]()) || O.push(p[v]);
                break;
              }
              O.push(p[v]), M = v, v - 1 < 0 ? v = c2 - 1 : v--;
            }
            for (O.reverse(), M = -1, v = b; ; ) {
              if (v === V) {
                if (M < 0 || M >= c2) return [];
                v !== V || b2Separator.isOnSegment(a2["get_x"](), a2["get_y"](), p[M]["get_x"](), p[M]["get_y"](), r2["get_x"](), r2["get_y"]()) || P.push(p[v]);
                break;
              }
              P.push(p[v]), M = v, v + 1 > c2 - 1 ? v = 0 : v++;
            }
            F.push(O, P), F.shift();
            break;
          }
          m && G.push(F.shift());
        }
        return G;
      };
    }
    var CloneVec2;
    var SplitConvexPolysOver8Points;
    var SplitConvexPoly;
    {
      {
        const e = self.C3;
        e.Behaviors.Rotate = class extends e.SDKBehaviorBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const e = self.C3;
        e.Behaviors.Rotate.Type = class extends e.SDKBehaviorTypeBase {
          constructor(e2) {
            super(e2);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const e = self.C3, t = self.C3X, s2 = self.IBehaviorInstance, a2 = 0, i2 = 1, n = 2;
        e.Behaviors.Rotate.Instance = class extends e.SDKBehaviorInstanceBase {
          constructor(t2, s3) {
            super(t2), this._speed = 0, this._acceleration = 0, this._isEnabled = true, s3 && (this._speed = e.toRadians(s3[a2]), this._acceleration = e.toRadians(s3[i2]), this._isEnabled = s3[n]), this._isEnabled && this._StartTicking();
          }
          Release() {
            super.Release();
          }
          _SetSpeed(e2) {
            this._speed = e2;
          }
          _GetSpeed() {
            return this._speed;
          }
          _SetAcceleration(e2) {
            this._acceleration = e2;
          }
          _GetAcceleration() {
            return this._acceleration;
          }
          SaveToJson() {
            return { "s": this._speed, "a": this._acceleration, "e": this._isEnabled };
          }
          LoadFromJson(e2) {
            this._speed = e2["s"], this._acceleration = e2["a"], this._SetEnabled(e2["e"]);
          }
          Tick() {
            if (!this._isEnabled) return;
            const e2 = this._runtime.GetDt(this._inst);
            if (0 !== e2 && (0 !== this._acceleration && (this._speed += this._acceleration * e2), 0 !== this._speed)) {
              const t2 = this._inst.GetWorldInfo();
              t2.SetAngle(t2.GetAngle() + this._speed * e2), t2.SetBboxChanged();
            }
          }
          GetPropertyValueByIndex(t2) {
            switch (t2) {
              case a2:
                return e.toDegrees(this._GetSpeed());
              case i2:
                return e.toDegrees(this._GetAcceleration());
              case n:
                return this._IsEnabled();
            }
          }
          SetPropertyValueByIndex(t2, s3) {
            switch (t2) {
              case a2:
                this._SetSpeed(e.toRadians(s3));
                break;
              case i2:
                this._SetAcceleration(e.toRadians(s3));
                break;
              case n:
                this._SetEnabled(s3);
            }
          }
          _SetEnabled(e2) {
            this._isEnabled = !!e2, this._isEnabled ? this._StartTicking() : this._StopTicking();
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          GetDebuggerProperties() {
            const t2 = "behaviors.rotate";
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t2 + ".properties.speed.name", value: e.toDegrees(this._GetSpeed()), onedit: (t3) => this._SetSpeed(e.toRadians(t3)) }, { name: t2 + ".properties.acceleration.name", value: e.toDegrees(this._GetAcceleration()), onedit: (t3) => this._SetAcceleration(e.toRadians(t3)) }, { name: t2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }] }];
          }
          GetScriptInterfaceClass() {
            return self.IRotateBehaviorInstance;
          }
        };
        const r2 = /* @__PURE__ */ new WeakMap();
        self.IRotateBehaviorInstance = class extends s2 {
          constructor() {
            super(), r2.set(this, s2._GetInitInst().GetSdkInstance());
          }
          set speed(e2) {
            t.RequireFiniteNumber(e2), r2.get(this)._SetSpeed(e2);
          }
          get speed() {
            return r2.get(this)._GetSpeed();
          }
          set acceleration(e2) {
            t.RequireFiniteNumber(e2), r2.get(this)._SetAcceleration(e2);
          }
          get acceleration() {
            return r2.get(this)._GetAcceleration();
          }
          get isEnabled() {
            return r2.get(this)._IsEnabled();
          }
          set isEnabled(e2) {
            r2.get(this)._SetEnabled(e2);
          }
        };
      }
      self.C3.Behaviors.Rotate.Cnds = { IsEnabled() {
        return this._IsEnabled();
      } };
      {
        const e = self.C3;
        e.Behaviors.Rotate.Acts = { SetSpeed(t) {
          this._SetSpeed(e.toRadians(t));
        }, SetAcceleration(t) {
          this._SetAcceleration(e.toRadians(t));
        }, SetEnabled(e2) {
          this._SetEnabled(e2);
        } };
      }
      {
        const e = self.C3;
        e.Behaviors.Rotate.Exps = { Speed() {
          return e.toDegrees(this._GetSpeed());
        }, Acceleration() {
          return e.toDegrees(this._GetAcceleration());
        } };
      }
    }
    {
      let unaryminus2 = function(n) {
        return typeof n === "number" ? -n : n;
      }, bothNumbers2 = function(a2, b) {
        return typeof a2 === "number" && typeof b === "number";
      }, add2 = function(l2, r2) {
        if (bothNumbers2(l2, r2))
          return l2 + r2;
        else
          return l2;
      }, subtract2 = function(l2, r2) {
        if (bothNumbers2(l2, r2))
          return l2 - r2;
        else
          return l2;
      }, multiply2 = function(l2, r2) {
        if (bothNumbers2(l2, r2))
          return l2 * r2;
        else
          return l2;
      }, divide2 = function(l2, r2) {
        if (bothNumbers2(l2, r2))
          return l2 / r2;
        else
          return l2;
      }, mod2 = function(l2, r2) {
        if (bothNumbers2(l2, r2))
          return l2 % r2;
        else
          return l2;
      }, pow2 = function(l2, r2) {
        if (bothNumbers2(l2, r2))
          return Math.pow(l2, r2);
        else
          return l2;
      }, and2 = function(l2, r2) {
        if (typeof l2 === "string" || typeof r2 === "string") {
          let lstr, rstr;
          if (typeof l2 === "number")
            lstr = (Math.round(l2 * 1e10) / 1e10).toString();
          else
            lstr = l2;
          if (typeof r2 === "number")
            rstr = (Math.round(r2 * 1e10) / 1e10).toString();
          else
            rstr = r2;
          return lstr + rstr;
        } else {
          return l2 && r2 ? 1 : 0;
        }
      }, or2 = function(l2, r2) {
        if (bothNumbers2(l2, r2))
          return l2 || r2 ? 1 : 0;
        else
          return l2;
      };
      unaryminus = unaryminus2, bothNumbers = bothNumbers2, add = add2, subtract = subtract2, multiply = multiply2, divide = divide2, mod = mod2, pow = pow2, and = and2, or = or2;
      const C33 = self.C3;
      self.C3_ExpressionFuncs = [
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => '{"c2dictionary":true,"data":' + v0.GetValue() + "}";
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0() + "_dev";
        },
        () => "Tutorial",
        () => "Events",
        () => "Battle",
        () => "Background",
        () => 100,
        () => "",
        () => 0,
        () => 0.8,
        () => 1,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("x", v0.GetValue());
        },
        () => "intro",
        () => "Debug",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => v0.GetValue();
        },
        () => "Short",
        (p) => {
          const n0 = p._GetNode(0);
          const n1 = p._GetNode(1);
          return () => n0.ExpObject() + n1.ExpObject() / 2 - 40;
        },
        () => 3,
        () => 270,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("Sound: ", v0.GetValue());
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("Music: ", v0.GetValue());
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => "ID: " + v0.GetValue();
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("Junk: ", v0.GetValue());
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0();
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const n1 = p._GetNode(1);
          const v2 = p._GetNode(2).GetVar();
          return () => f0(n1.ExpObject(), "\u041F\u0438\u0442\u043E\u043C\u0435\u0446", v2.GetValue());
        },
        (p) => {
          const n0 = p._GetNode(0);
          const n1 = p._GetNode(1);
          const n2 = p._GetNode(2);
          const n3 = p._GetNode(3);
          const n4 = p._GetNode(4);
          const n5 = p._GetNode(5);
          const n6 = p._GetNode(6);
          const n7 = p._GetNode(7);
          const n8 = p._GetNode(8);
          const n9 = p._GetNode(9);
          return () => and2(and2(and2(and2(and2(and2(and2(and2(and2(and2("N \n", n0.ExpObject(0, 0)) + "\n", n1.ExpObject(1, 0)) + "\n", n2.ExpObject(2, 0)) + "\n", n3.ExpObject(3, 0)) + "\n", n4.ExpObject(4, 0)) + "\n", n5.ExpObject(5, 0)) + "\n", n6.ExpObject(6, 0)) + "\n", n7.ExpObject(7, 0)) + "\n", n8.ExpObject(8, 0)) + "\n", n9.ExpObject(9, 0));
        },
        (p) => {
          const n0 = p._GetNode(0);
          const n1 = p._GetNode(1);
          const n2 = p._GetNode(2);
          const n3 = p._GetNode(3);
          const n4 = p._GetNode(4);
          return () => and2(and2(and2(and2(and2("R \n", n0.ExpObject(0, 0)) + "\n", n1.ExpObject(1, 0)) + "\n", n2.ExpObject(2, 0)) + "\n", n3.ExpObject(3, 0)) + "\n", n4.ExpObject(4, 0));
        },
        (p) => {
          const n0 = p._GetNode(0);
          const n1 = p._GetNode(1);
          const n2 = p._GetNode(2);
          return () => and2(and2(and2("L \n", n0.ExpObject(0, 0)) + "\n", n1.ExpObject(1, 0)) + "\n", n2.ExpObject(2, 0));
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          return () => and2("Current Event: " + v0.GetValue(), v1.GetValue());
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          return () => v0.GetValue() + v1.GetValue() + v2.GetValue() + v3.GetValue() + v4.GetValue();
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject();
        },
        (p) => {
          const n0 = p._GetNode(0);
          const v1 = p._GetNode(1).GetVar();
          return () => n0.ExpObject() * v1.GetValue();
        },
        (p) => {
          const n0 = p._GetNode(0);
          const n1 = p._GetNode(1);
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          return () => C33.lerp(n0.ExpObject(), n1.ExpObject() * v2.GetValue(), v3.GetValue());
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const n1 = p._GetNode(1);
          return () => f0(0) - Math.abs(n1.ExpObject()) / 2;
        },
        (p) => {
          const n0 = p._GetNode(0);
          const n1 = p._GetNode(1);
          const n2 = p._GetNode(2);
          return () => n0.ExpObject_InstExpr(n1.ExpObject() - 1) + Math.abs(n2.ExpObject());
        },
        () => -640,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() + 1135;
        },
        () => 51,
        () => -157548846713855,
        () => 11,
        () => 50,
        () => -717748980794367,
        () => 10,
        () => -717714117687295,
        () => "Rocks",
        () => 2,
        () => 6,
        () => 4,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => v0.GetValue() + 1;
        },
        () => "Dig",
        () => 284,
        () => 252,
        () => 7,
        () => 810,
        () => 247,
        () => 201,
        () => 193,
        () => 927,
        () => 187,
        () => "Junk",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0("left", "right");
        },
        () => 905,
        () => 1600,
        () => "left",
        () => 205,
        () => "right",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const f1 = p._GetNode(1).GetBoundMethod();
          return () => f0(f1(0, 10));
        },
        () => 5,
        () => 880,
        () => 1.5,
        () => 0.3,
        () => 0.2,
        () => "sound",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() + 30;
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() - 30;
        },
        () => "+3",
        () => "-3",
        () => 8,
        () => 9,
        () => "InteractiveObject",
        () => 0.5,
        () => "Default",
        () => "Normal",
        () => "Rare",
        () => "Legendary",
        () => "Mission",
        () => 539,
        () => 1818,
        () => 408,
        () => 1730,
        () => 540,
        () => 290,
        () => "Final",
        () => 541,
        () => 1711,
        () => 1712,
        () => 25,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() + 60;
        },
        () => "base",
        () => -10,
        () => "dig",
        () => "normal",
        () => "legend",
        () => "rare",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject(0, 0);
        },
        (p) => {
          const n0 = p._GetNode(0);
          const v1 = p._GetNode(1).GetVar();
          return () => n0.ExpObject(0, v1.GetValue());
        },
        () => 1110,
        () => 410,
        () => 1500,
        () => 40,
        () => 200,
        () => 300,
        () => 310,
        () => 400,
        () => "battle",
        () => "\u0420\u0430\u0441\u043A\u043E\u043B \u0432 \u0437\u0435\u043C\u043B\u0435 \u2013 \u043C\u0435\u0441\u0442\u043E \u0441\u043E\u043A\u0440\u043E\u0432\u0435\u043D\u043D\u044B\u0445 \u0441\u043E\u043A\u0440\u043E\u0432\u0438\u0449 \u0438 \u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u0435\u0439",
        () => "\u041F\u0440\u043E\u0431\u0438\u0442\u044C",
        () => 902,
        () => 210,
        () => "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C",
        (p) => {
          const n0 = p._GetNode(0);
          const f1 = p._GetNode(1).GetBoundMethod();
          const f2 = p._GetNode(2).GetBoundMethod();
          return () => n0.ExpObject(0, f1(f2(0, 4)));
        },
        () => "health",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject(1, 2);
        },
        () => "mission",
        () => 1047,
        () => "Events body",
        () => 0.08,
        () => 110,
        () => "Norm ",
        () => "HUD",
        () => 770,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() + 80;
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() - 20;
        },
        () => "+2",
        () => "\u041A\u0430\u0436\u0435\u0442\u0441\u044F, \u043F\u0440\u0438\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u043D\u0430 \u0445\u0432\u043E\u0441\u0442 \u043F\u0440\u0438\u043B\u0435\u0442\u0435\u043B\u043E!",
        () => 405,
        () => 515,
        () => "-5",
        () => "+5",
        () => "+1",
        () => "\u041F\u0440\u0438\u0433\u043E\u0442\u043E\u0432\u0438\u0442\u044C",
        () => "\u0421\u044A\u0435\u0441\u0442\u044C",
        () => 138,
        () => 1678,
        () => 73,
        () => 70,
        () => 182,
        () => 1640,
        () => "+7",
        () => 358,
        () => 636,
        () => 680,
        () => 857.692247,
        () => 1672.497945,
        () => 55.32703,
        () => 78.487182,
        () => 898,
        () => "\u041F\u0435\u0440\u0435\u043A\u0443\u0441\u0438\u0442\u044C \n\u043D\u0430 \u0445\u043E\u0434\u0443",
        () => "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C \u0440\u0430\u0431\u043E\u0442\u0430\u0442\u044C",
        () => "-10",
        () => 92,
        () => 858,
        () => 1673,
        () => "\u041F\u0440\u0438\u043A\u0440\u044B\u0442\u044C \n\u043B\u0438\u0446\u043E",
        () => "\u041F\u043E\u0432\u0435\u0440\u043D\u0443\u0442\u044C\u0441\u044F \u043A \u0432\u0435\u0442\u0440\u0443",
        () => 254,
        () => 1691,
        () => 298,
        () => 1649,
        () => 74.127643,
        () => 61.582965,
        () => "\u041F\u043E\u0442\u0435\u0440\u0435\u0442\u044C \n\u043E\u0431 \u043A\u0430\u043C\u0435\u043D\u044C",
        () => "Legend",
        () => 799,
        () => 1463,
        () => "+15",
        () => 15,
        () => "Norm",
        () => "+4",
        () => "-7",
        () => 12,
        () => 13,
        () => 14,
        () => 16,
        () => 17,
        () => 18,
        () => "Rare1",
        () => "\u0421\u044A\u0435\u0441\u0442\u044C \u043A\u043E\u0440\u0435\u043D\u044C",
        () => "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u043D\u0438\u0442\u0438",
        () => "+10",
        () => 747,
        () => 1684,
        () => 93.009236,
        () => 86.52022,
        () => 784,
        () => 1644,
        () => "\u041F\u043E\u0440\u044B\u0442\u044C\u0441\u044F",
        () => "\u0414\u0435\u0440\u0436\u0430\u0442\u044C\u0441\u044F \u043F\u043E\u0434\u0430\u043B\u044C\u0448\u0435",
        () => 72,
        () => 114,
        () => 1650,
        () => 280,
        () => 1688,
        () => 320,
        () => 1648,
        () => 425,
        () => 78.538084,
        () => 73.058683,
        () => 465,
        () => 1651,
        () => "\u0423\u043C\u044B\u0442\u044C\u0441\u044F \n\u0432 \u0432\u043E\u0434\u0435",
        () => "\u041F\u043E\u043F\u0440\u043E\u0431\u043E\u0432\u0430\u0442\u044C \n\u043D\u0430 \u0432\u043A\u0443\u0441",
        () => "Legend1",
        () => "\u0421\u0443\u0445\u0430\u0440\u0438",
        () => "\u041C\u044F\u0441\u043E",
        () => "+20",
        () => 20,
        () => 150,
        () => "Norm2",
        () => 19,
        () => 21,
        () => 22,
        () => "+6",
        () => 23,
        () => 24,
        () => 26,
        () => 27,
        () => "-15",
        () => 28,
        () => "Rare2",
        () => "\u0412\u0437\u044F\u0442\u044C \u0437\u043E\u043B\u043E\u0442\u043E",
        () => "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0442\u0440\u0430\u0432\u044B",
        () => 78.421137,
        () => 72.949895,
        () => "+8",
        () => "\u0417\u0430\u0431\u0440\u0430\u0442\u044C",
        () => "\u041F\u043E\u043B\u044E\u0431\u043E\u0432\u0430\u0442\u044C\u0441\u044F",
        () => "\u0423\u043C\u044B\u0442\u044C\u0441\u044F",
        () => "\u041D\u0430\u043F\u0438\u0442\u044C\u0441\u044F",
        () => "\u0420\u0430\u0437\u0431\u0438\u0440\u0430\u0442\u044C \u043F\u043E\u0440\u043E\u0434\u0443",
        () => "\u0420\u044B\u0442\u044C \u0433\u043B\u0443\u0431\u0436\u0435",
        () => 89.95824,
        () => 83.682084,
        () => "+12",
        () => "Legend2",
        () => "+30",
        () => 30,
        () => "Norm3",
        () => 29,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject(0, 31);
        },
        () => 31,
        () => 32,
        () => 33,
        () => "-20",
        () => 34,
        () => 35,
        () => 36,
        () => 37,
        () => 38,
        () => "Rare3",
        () => "\u0414\u043E\u0431\u044B\u0432\u0430\u0442\u044C\n\u0441\u0435\u0440\u0435\u0431\u0440\u043E",
        () => "\u0412\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C\n\u0441\u0438\u043B\u044B",
        () => "\u0421\u043E\u0433\u0440\u0435\u0442\u0443\u044E \u043F\u0438\u0449\u0443",
        () => "\u0418\u0441\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u044C \n\u043C\u0438\u043D\u0435\u0440\u0430\u043B\u044B",
        () => "\u0412\u0433\u0440\u044B\u0437\u0430\u0442\u044C\u0441\u044F \n\u0433\u043B\u0443\u0431\u0436\u0435",
        () => "\u0421\u043E\u0431\u0440\u0430\u0442\u044C \u0447\u0442\u043E \n\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E",
        () => "\u041E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C \n\u043A\u0430\u043C\u043D\u0438",
        () => "Legend3",
        () => "+50",
        () => -1,
        () => 340,
        () => "Event_5",
        () => "Event_15",
        () => 180,
        () => "{}",
        () => "CurrentMission",
        () => "Recipe",
        () => 250,
        () => "Event_25",
        () => 350,
        () => "Event_35",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0(1, 2);
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0(3, 4);
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0(1, 2, 3, 4);
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          const v5 = p._GetNode(5).GetVar();
          return () => f0(1.05 * v1.GetValue() + (v2.GetValue() + v3.GetValue() + v4.GetValue() + v5.GetValue()));
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          const v5 = p._GetNode(5).GetVar();
          return () => f0(1.2 * v1.GetValue() + (v2.GetValue() + v3.GetValue() + v4.GetValue() + v5.GetValue()));
        },
        () => "adventure_tutorial_completed",
        () => "base_tutorial_completed",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const f1 = p._GetNode(1).GetBoundMethod();
          return () => f0(f1(430, 500));
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const f1 = p._GetNode(1).GetBoundMethod();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          const v5 = p._GetNode(5).GetVar();
          return () => f0(f1(0.8 * 0.85 * (500 + 5 * (2 + v2.GetValue() * (v3.GetValue() - 1))), 1.1 * 0.85 * (500 + 5 * (2 + v4.GetValue() * (v5.GetValue() - 1)))));
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const f1 = p._GetNode(1).GetBoundMethod();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          const v5 = p._GetNode(5).GetVar();
          return () => f0(f1(0.8 * 0.9 * (500 + 5 * (2 + v2.GetValue() * (v3.GetValue() - 1))), 1.1 * 0.9 * (500 + 5 * (2 + v4.GetValue() * (v5.GetValue() - 1)))));
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const f1 = p._GetNode(1).GetBoundMethod();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          const v5 = p._GetNode(5).GetVar();
          return () => f0(f1(0.8 * 0.95 * (500 + 5 * (2 + v2.GetValue() * (v3.GetValue() - 1))), 1.1 * 0.95 * (500 + 5 * (2 + v4.GetValue() * (v5.GetValue() - 1)))));
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const f1 = p._GetNode(1).GetBoundMethod();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          const v5 = p._GetNode(5).GetVar();
          return () => f0(f1(0.8 * 1 * (500 + 5 * (2 + v2.GetValue() * (v3.GetValue() - 1))), 1.1 * 1 * (500 + 5 * (2 + v4.GetValue() * (v5.GetValue() - 1)))));
        },
        () => 1530,
        () => "+ 20",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          return () => f0("weekly_fighting_stats", v1.GetValue().toString());
        },
        () => "+ 10",
        () => "Battle_1",
        () => "Battle_2",
        () => "Battle_3",
        () => "Battle_4",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() - 150;
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() + 150;
        },
        () => "Enter",
        () => "Passed",
        () => "Choice buttons",
        () => "100 m",
        () => "200 m",
        () => "300 m",
        () => "400 m",
        () => "100 m2",
        () => 1.2,
        () => 0.7,
        () => "200 m2",
        () => 2.3,
        () => "300 m2",
        () => "400 m2",
        () => 1e3,
        () => 1e4,
        () => "Functions",
        () => 296,
        () => 161,
        () => 650,
        () => 418,
        () => 1660,
        () => 1.7,
        () => "Rewards",
        () => 1.3,
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0("Events");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() + 10;
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() + 280;
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2(v0.GetValue(), "/3");
        },
        () => "Pause",
        () => 640,
        () => "Battle_inside",
        () => 98,
        () => 0.9,
        () => 600,
        () => "Idle",
        () => 660,
        () => 800,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("enemy_", v0.GetValue());
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const n1 = p._GetNode(1);
          return () => f0(n1.ExpInstVar());
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("Idle", v0.GetValue());
        },
        () => 539.5,
        () => 1803,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpInstVar();
        },
        () => 578,
        () => "baseEnemyHp",
        () => 376,
        () => 1814,
        (p) => {
          const n0 = p._GetNode(0);
          const v1 = p._GetNode(1).GetVar();
          return () => and2(and2("[icon=", n0.ExpInstVar()) + "] ", v1.GetValue());
        },
        () => "Player",
        () => 0.1,
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          const v5 = p._GetNode(5).GetVar();
          const f6 = p._GetNode(6).GetBoundMethod();
          const v7 = p._GetNode(7).GetVar();
          const v8 = p._GetNode(8).GetVar();
          const v9 = p._GetNode(9).GetVar();
          const v10 = p._GetNode(10).GetVar();
          const v11 = p._GetNode(11).GetVar();
          return () => and2(and2(f0(v1.GetValue() * 0.9) + v2.GetValue() + v3.GetValue() + v4.GetValue() + v5.GetValue(), "-"), f6(v7.GetValue() * 1.2) + v8.GetValue() + v9.GetValue() + v10.GetValue() + v11.GetValue());
        },
        () => 60,
        () => 217,
        () => 1786,
        () => 850,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject(1) - 20;
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject(1);
        },
        () => 0.6,
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const f1 = p._GetNode(1).GetBoundMethod();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          return () => f0(f1(v2.GetValue() * 0.9, v3.GetValue() * 1.2));
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          return () => v0.GetValue() + v1.GetValue() + v2.GetValue() + v3.GetValue();
        },
        () => "Attack",
        () => 416,
        () => 164,
        () => 382,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("Hurt", v0.GetValue());
        },
        () => 697,
        () => 654,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() + 1e3;
        },
        () => "SpawnMovement",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() - 200;
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const n1 = p._GetNode(1);
          return () => and2(and2(-Math.round(v0.GetValue() / 10), " [icon="), n1.ExpInstVar()) + "]";
        },
        () => "Deadly",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => Math.round(v0.GetValue() / 10);
        },
        () => "Hungry",
        () => "Depressive",
        () => "Dirty",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0() * 0.16;
        },
        () => "Brightness",
        () => 170,
        () => 0.06,
        () => "GetHitMove",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() - 18;
        },
        () => "GetHitAngle",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() - 6;
        },
        () => 348,
        () => 714,
        () => "AttackMove",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() - 80;
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0(0.1, 0.3);
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("Attack", v0.GetValue());
        },
        () => 272,
        () => 706,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const f1 = p._GetNode(1).GetBoundMethod();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          const v5 = p._GetNode(5).GetVar();
          const v6 = p._GetNode(6).GetVar();
          const v7 = p._GetNode(7).GetVar();
          const f8 = p._GetNode(8).GetBoundMethod();
          const v9 = p._GetNode(9).GetVar();
          const v10 = p._GetNode(10).GetVar();
          const v11 = p._GetNode(11).GetVar();
          const v12 = p._GetNode(12).GetVar();
          const v13 = p._GetNode(13).GetVar();
          return () => and2(and2(v0.GetValue() - f1(v2.GetValue() / 100 * 10) + v3.GetValue() + v4.GetValue() + v5.GetValue() + v6.GetValue(), "-"), v7.GetValue() + f8(v9.GetValue() / 100 * 20) + v10.GetValue() + v11.GetValue() + v12.GetValue() + v13.GetValue());
        },
        () => 1466,
        () => 309.722561,
        () => "Inventory",
        () => 808,
        () => 242,
        () => 838,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject(2);
        },
        () => 392,
        () => 542,
        () => 692,
        () => 842,
        () => 241,
        () => 818,
        () => 391,
        () => 813,
        () => 688,
        () => 816,
        () => 841,
        () => 814,
        () => 504,
        () => 887,
        () => 355,
        () => 804,
        () => 655,
        () => "InvOpen",
        () => "InvClose",
        () => 151,
        () => 2008,
        () => 966,
        () => 285,
        () => 1011,
        () => 135.760359,
        () => 126.288706,
        () => 247.090852,
        () => 1084,
        () => 538,
        () => 1015,
        () => 123.312104,
        () => 114.708934,
        () => 505,
        () => 1017,
        () => 142.235913,
        () => 132.312478,
        () => 764,
        () => 403,
        () => 1301,
        () => 137.113015,
        () => 127.546991,
        () => 363.41817,
        () => 1368,
        () => 676,
        () => 110.967742,
        () => 103.225806,
        () => 638,
        () => 635,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          return () => v0.GetValue() + v1.GetValue() * 2 + v2.GetValue() * 3 + v3.GetValue() * 4 + v4.GetValue() * 5;
        },
        () => 2.5,
        () => "BlurVertical",
        () => 0.4,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("X", v0.GetValue());
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          const v3 = p._GetNode(3).GetVar();
          const v4 = p._GetNode(4).GetVar();
          const v5 = p._GetNode(5).GetVar();
          const v6 = p._GetNode(6).GetVar();
          return () => f0((v1.GetValue() + v2.GetValue() * 2 + v3.GetValue() * 3 + v4.GetValue() * 4 + v5.GetValue() * 5) * v6.GetValue());
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() - 130;
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() - 85;
        },
        () => "\u0417\u0430\u0431\u0440\u0430\u0442\u044C\n\u043D\u0430\u0433\u0440\u0430\u0434\u0443",
        () => "Send Data",
        () => "FinalRewardRecieved",
        () => "Cutscene",
        () => "RecieptRewardRecieved",
        () => "Second_digging_finish",
        () => "Base",
        () => "balance",
        () => "SubLevel",
        () => "weekly_mining_stats",
        () => "weekly_fighting_stats",
        () => "EventsID",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          return () => f0(v1.GetValue());
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2(v0.GetValue(), " \u043C");
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          return () => v0.GetValue() / v1.GetValue();
        },
        () => 0.04,
        () => 0.03,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          return () => (v0.GetValue() > -1 ? 1 : 0) ? v1.GetValue() : v2.GetValue();
        },
        () => 1055,
        () => 240,
        () => 538.5,
        () => 1289.5,
        () => 398,
        () => 204,
        () => 1800,
        () => 575,
        () => 666,
        () => 537,
        () => 1558,
        () => 359.6,
        () => 1035,
        () => 492,
        () => 1443,
        () => 198,
        () => 235,
        () => 1621,
        () => 49.3,
        () => "\u0428\u0430\u0445\u0442\u0430 \u0442\u0435\u0431\u0435 \u043F\u043E\u0434\u043C\u0438\u0433\u043D\u0443\u043B\u0430. \u041D\u0435 \u043E\u0431\u043B\u0430\u0436\u0430\u0439\u0441\u044F!",
        () => 312,
        () => 299,
        () => 662,
        () => 548,
        () => 325,
        () => 342,
        () => 791,
        () => "\u041E, \u043F\u043E\u0448\u043B\u0430 \u0436\u0430\u0440\u0438\u0448\u043A\u0430! \u0413\u043E\u0442\u043E\u0432\u044C \u043B\u0430\u043F\u044B!",
        () => 185,
        () => 177.7,
        () => 544,
        () => 1541,
        () => "\u0411\u0435\u0439 \u043D\u0435 \u0436\u0430\u043B\u0435\u044F \u043B\u0430\u043F \u2014 \u043E\u043D\u0438 \u0435\u0449\u0451 \u043E\u0442\u0440\u0430\u0441\u0442\u0443\u0442!",
        () => 744,
        () => 243,
        () => 577,
        () => 130,
        () => "\u041F\u043E\u043B\u0443\u0447\u0438\u043B \u043F\u043E \u0443\u0448\u0430\u043C? \u0411\u044B\u0432\u0430\u0435\u0442\u2026 \u0436\u0438\u0432\u043E\u0439 \u2014 \u0443\u0436\u0435 \u043F\u043E\u0431\u0435\u0434\u0430!",
        () => 464.666547,
        () => 271.16577,
        () => 1757.417115,
        () => 276.333274,
        () => 555,
        () => "\u0412 \u0448\u0430\u0445\u0442\u0435, \u043A\u0430\u043A \u0432 \u0436\u0438\u0437\u043D\u0438 \u2014 \u0432\u044B\u0431\u0438\u0440\u0430\u0439 \u043D\u0430\u0443\u0433\u0430\u0434!",
        () => 213.666547,
        () => 196.16577,
        () => 963,
        () => 846,
        () => 970,
        () => 618,
        () => 174.1,
        () => "\u041F\u0440\u043E\u0432\u0435\u0440\u044C \u043A\u0430\u0440\u043C\u0430\u043D\u044B\u2026 \u0432\u0434\u0440\u0443\u0433 \u0442\u0430\u043C \u0443\u0436\u0435 \u043D\u0430 \u043F\u0435\u043D\u0441\u0438\u044E \u043D\u0430\u043A\u043E\u043F\u0430\u043B!",
        () => 857,
        () => 1792,
        () => 227,
        () => 1788,
        () => "\u042F \u0431 \u043F\u0435\u0440\u0435\u0434 \u0442\u0430\u043A\u0438\u043C \u043C\u043E\u0440\u0434\u043E\u0432\u043E\u0440\u043E\u0442\u043E\u043C \u043F\u0435\u0440\u0435\u043A\u0443\u0441\u0438\u043B \u0447\u0435\u0433\u043E-\u0442\u043E \u0431\u043E\u0434\u0440\u044F\u0449\u0435\u0433\u043E...",
        () => 216,
        () => 245,
        () => 363,
        () => 906,
        (p) => {
          const n0 = p._GetNode(0);
          const n1 = p._GetNode(1);
          return () => n0.ExpObject() + n1.ExpObject() / 2;
        },
        () => 354.6,
        () => "\u0412\u0438\u0434\u0438\u0448\u044C \u0444\u0438\u0433\u043D\u044E? \u041D\u0430\u0436\u043C\u0438. \u0412\u0434\u0440\u0443\u0433 \u044D\u0442\u043E \u0431\u043E\u043D\u0443\u0441!",
        () => 262,
        () => 318,
        () => "\u042D\u0442\u043E \u043D\u0435 \u043C\u0430\u0445\u0430\u0447 \u2014 \u044D\u0442\u043E \u044D\u043A\u0437\u0430\u043C\u0435\u043D \u043D\u0430 \u0448\u0430\u0445\u0442\u0451\u0440\u0430!",
        () => 188,
        () => "\u0412\u043E\u0442 \u0442\u0435\u0431\u0435 \u0438 \u043D\u0430\u0445\u043E\u0434\u043A\u0430 \u2014 \u043F\u0440\u0438\u0433\u043E\u0434\u0438\u0442\u0441\u044F!",
        () => 260,
        () => 167,
        () => 797.5,
        () => 1480,
        () => 532,
        () => 1484,
        () => 96.2,
        () => "\u041E-\u043E-\u043E, \u043F\u0430\u0445\u043D\u0435\u0442 \u0433\u043B\u0443\u0431\u0438\u043D\u043E\u0439 \u0438 \u043F\u0440\u0438\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F\u043C\u0438!",
        () => 380,
        () => 104.5,
        () => 113,
        () => 648,
        () => "\u041F\u043E\u043C\u043D\u0438, \u0432\u043D\u0443\u0447\u0435\u043A: \u043A\u043E\u043F\u043D\u0443\u043B \u2014 \u0443\u0436\u0435 \u043F\u0440\u0438\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435!",
        () => 546,
        () => 1537,
        () => 179.1,
        () => "2BaffsUsed",
        () => "SettingsUI",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject(3);
        },
        () => "music",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const f1 = p._GetNode(1).GetBoundMethod();
          const v2 = p._GetNode(2).GetVar();
          const f3 = p._GetNode(3).GetBoundMethod();
          const v4 = p._GetNode(4).GetVar();
          const v5 = p._GetNode(5).GetVar();
          const f6 = p._GetNode(6).GetBoundMethod();
          const v7 = p._GetNode(7).GetVar();
          return () => f0(f1(v2.GetValue() - f3(v4.GetValue() / 100 * 10), v5.GetValue() + f6(v7.GetValue() / 100 * 20)));
        },
        () => "door",
        () => "Upgrade_window",
        () => "Sleep_panel",
        () => "Sound_options",
        () => "workshop",
        () => "Skill_window",
        () => "AutoFarm",
        () => "Top_rewards",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0("Player");
        },
        () => "idle",
        () => "<style>\n  .centered {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    max-width: 75vw;\n    max-height: 75vh;\n  }\n</style>\n<img class='centered' src= https://11da79cac89c194b2fce6412c3b04f11.cdn.bubble.io/f1751015545652x828619742100144900/happy.gif>",
        () => "<style>\n  .centered {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    max-width: 75vw;\n    max-height: 75vh;\n  }\n</style>\n<img class='centered' src= https://11da79cac89c194b2fce6412c3b04f11.cdn.bubble.io/f1751015563474x445988557283174500/idle.gif>",
        () => "<style>\n  .centered {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    max-width: 75vw;\n    max-height: 75vh;\n  }\n</style>\n<img class='centered' src= https://11da79cac89c194b2fce6412c3b04f11.cdn.bubble.io/f1751015578420x362754020729257860/sad.gif>",
        () => "\u041D\u0435\u0442 \u0438\u043C\u0435\u043D\u0438",
        (p) => {
          const n0 = p._GetNode(0);
          const f1 = p._GetNode(1).GetBoundMethod();
          const f2 = p._GetNode(2).GetBoundMethod();
          return () => n0.ExpObject(0, f1(f2(0, 8)));
        },
        () => 960,
        () => 294.5,
        () => 1450,
        () => -539.5,
        () => -594.5,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          return () => and2(and2(v0.GetValue(), "/"), v1.GetValue());
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          return () => C33.clamp(v0.GetValue(), 0, v1.GetValue());
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          return () => 192 * C33.clamp(v0.GetValue() / v1.GetValue(), 0, 1);
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          return () => 188 * C33.clamp(v0.GetValue() / v1.GetValue(), 0, 1);
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => "RecordID: " + v0.GetValue();
        },
        () => -645,
        () => "Shop",
        () => "Food",
        () => 691.284683,
        () => 495,
        () => 276.020841,
        () => 755.545713,
        () => 339.232144,
        () => 475.951462,
        () => 755.409763,
        () => 538.888301,
        () => 755.791512,
        () => 670.137137,
        () => 755.409737,
        () => 732.310482,
        () => 755.409694,
        () => 750,
        () => "Sleep",
        () => -20,
        () => 1753,
        () => "sleep",
        () => "<style>\n  .centered {\n    position: absolute;\n    top: 90%;\n    left: 30%;\n    transform: translate(-50%, -50%);\n    max-width: 75vw;\n    max-height: 75vh;\n  }\n</style>\n<img class='centered' src= https://11da79cac89c194b2fce6412c3b04f11.cdn.bubble.io/f1751015610152x351820336692927320/sleep_2.gif>",
        () => "Sleep_start",
        () => "Explosion",
        () => 543,
        () => 1156,
        () => 172.484782,
        () => "Sleep_finish",
        () => 311,
        () => 549,
        () => 224,
        () => 909,
        () => "\u041D\u0430\u043A\u043E\u043F\u0430\u043B\u0441\u044F, \u0442\u0435\u043F\u0435\u0440\u044C \u043C\u043E\u0436\u043D\u043E \u0438 \u043F\u043E\u0441\u043F\u0430\u0442\u044C.",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2(v0.GetValue(), "/\u0447");
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => v0.GetValue() + " \u0432\u0441\u0442\u0430\u0432\u0430\u0439, \u043D\u0430 \u0440\u0430\u0431\u043E\u0442\u0443 \u043F\u043E\u0440\u0430!";
        },
        () => 290.5,
        () => "Shower",
        () => "Shower_shop_open",
        () => -3,
        () => 500,
        () => "Aid",
        () => 730.284683,
        () => 308.020841,
        () => 506.951462,
        () => 701.137137,
        () => 202,
        () => 223.666547,
        () => 213.16577,
        () => 1243,
        () => 203,
        () => "heal",
        () => "eat",
        () => "wash",
        () => "Shower_shop_closed",
        () => "Food_shop_closed",
        () => "Heal_shop_closed",
        () => 206,
        () => 207,
        () => 1200,
        () => 2e3,
        () => 700,
        () => 1300,
        () => "Animation",
        () => "<style>\n  .centered {\n    position: absolute;\n    top: 40%;\n    left: 20%;\n    transform: translate(-50%, -50%);\n    max-width: 75vw;\n    max-height: 75vh;\n  }\n</style>\n<img class='centered' src= https://11da79cac89c194b2fce6412c3b04f11.cdn.bubble.io/f1751015556009x781498770890937300/heal.gif>",
        () => "scene",
        () => "<style>\n  .centered {\n    position: absolute;\n    top: 15%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    max-width: 75vw;\n    max-height: 75vh;\n  }\n</style>\n<img class='centered' src= https://11da79cac89c194b2fce6412c3b04f11.cdn.bubble.io/f1751015618310x969531098886919800/wash.gif>",
        () => "<style>\n  .centered {\n    position: absolute;\n    top: 90%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    max-width: 90vw;\n    max-height: 90vh;\n  }\n</style>\n<img class='centered' src= https://11da79cac89c194b2fce6412c3b04f11.cdn.bubble.io/f1751015533405x431480970016051600/eat.gif>",
        () => "<style>\n  .centered {\n    position: absolute;\n    top: 90%;\n    left: 30%;\n    transform: translate(-50%, -50%);\n    max-width: 75vw;\n    max-height: 75vh;\n  }\n</style>\n<img class='centered' src= https://11da79cac89c194b2fce6412c3b04f11.cdn.bubble.io/f1751015595239x486557357609789000/sleep_1.gif>",
        () => "death",
        () => "<style>\n  .centered {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    max-width: 70vw;\n    max-height: 70vh;\n  }\n</style>\n<img class='centered' src= https://11da79cac89c194b2fce6412c3b04f11.cdn.bubble.io/f1746631045907x642608350816679800/death%202.gif>",
        () => "Settings",
        () => "Workshop",
        () => "pickaxe",
        () => "bag",
        () => 402.460818,
        () => 703,
        () => 255,
        () => 484.214029,
        () => 256,
        () => 568.63972,
        () => 257,
        () => 652.752731,
        () => 401.152385,
        () => 261,
        () => 485.246033,
        () => 568.835415,
        () => 263,
        () => 653.497108,
        () => "Second_digging_start",
        () => "Debug1",
        () => "Bars",
        () => "Death",
        () => 1749,
        () => "<style>\n  .centered {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    max-width: 80vw;\n    max-height: 80vh;\n  }\n</style>\n<img class='centered' src= https://11da79cac89c194b2fce6412c3b04f11.cdn.bubble.io/f1746631045907x642608350816679800/death%202.gif>",
        () => "Door",
        () => -903,
        () => -878,
        () => -951,
        () => "TutorialBase",
        () => 420.666547,
        () => 451.16577,
        () => 243.5,
        () => 253,
        () => 786,
        () => 305,
        () => 239,
        () => 593,
        () => 358.8,
        () => 633,
        () => "\u0414\u0430 \u0442\u044B \u0435\u043B\u0435 \u0436\u0438\u0432\u043E\u0439 \u2014 \u043A\u0430\u043A \u044F \u043F\u043E\u0441\u043B\u0435 \u0441\u043C\u0435\u043D\u044B!",
        () => 203.666547,
        () => 204.16577,
        () => 120.5,
        () => 1755.5,
        () => 516,
        () => 137,
        () => 1502,
        () => 176,
        () => 349,
        () => "\u0421 \u0442\u0435\u0431\u044F \u0443\u0436\u0435 \u043F\u044B\u043B\u044C \u0441\u044B\u043F\u043B\u0435\u0442\u0441\u044F\u2026 \u0438\u0434\u0438 \u043C\u043E\u0439\u0441\u044F!",
        () => 211.666547,
        () => 285.16577,
        () => 338,
        () => 719.5,
        () => 335,
        () => 177,
        () => "\u0428\u0442\u0443\u0447\u043A\u0430 \u0438\u0437 \u0437\u0430\u043D\u0430\u0447\u043A\u0438... \u041D\u043E \u0434\u0430\u043B\u044C\u0448\u0435 - \u0437\u0430 \u043A\u0440\u043E\u0432\u043D\u043E \u0437\u0430\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u043D\u044B\u0435!",
        () => 201.744806,
        () => 192.273218,
        () => 772,
        () => 1752,
        () => 769,
        () => 1529,
        () => "\u042F \u043D\u0430 \u0433\u043E\u043B\u043E\u0434\u043D\u044B\u0439 \u0436\u0435\u043B\u0443\u0434\u043E\u043A \u0434\u0430\u0436\u0435 \u0440\u0443\u0433\u0430\u0442\u044C\u0441\u044F \u0445\u0443\u0436\u0435 \u0443\u043C\u0435\u044E!",
        () => 971,
        () => 1515,
        () => "\u0412 \u043C\u043E\u0438 \u0433\u043E\u0434\u044B \u044F \u0431\u044B \u0443\u0436\u0435 \u043F\u0435\u0440\u0435\u0432\u044F\u0437\u044B\u0432\u0430\u043B\u0441\u044F \u0442\u0443\u0430\u043B\u0435\u0442\u043A\u043E\u0439!",
        () => 127.953327,
        () => 125.462136,
        () => 994.395739,
        () => 1055.594459,
        () => 656,
        () => 948,
        () => 498,
        () => "\u041A\u043D\u043E\u043F\u043A\u0430 \u043F\u0440\u043E\u043A\u0430\u0447\u043A\u0438! \u0416\u043C\u0438 \u0438 \u043D\u0430\u0434\u0435\u0439\u0441\u044F!",
        () => 400.953327,
        () => 210.462136,
        () => 532.5,
        () => 1567.5,
        () => 187.744806,
        () => 185.273218,
        () => 315,
        () => 1751.5,
        () => 381.666547,
        () => 150.16577,
        () => 856,
        () => 302,
        () => 339,
        () => 1477,
        () => "\u0422\u044B \u0447\u0451 \u043A\u0430\u043A \u0432\u044B\u0436\u0430\u0442\u044B\u0439 \u043B\u0438\u043C\u043E\u043D, \u0430? \u0411\u0440\u043E\u0441\u0430\u0439 \u043A\u0438\u0440\u043A\u0443 \u2014 \u043F\u043E\u0440\u0430 \u043F\u0435\u0440\u0435\u0434\u043E\u0445\u043D\u0443\u0442\u044C.",
        () => 1494,
        () => "\u042D\u0445, \u0442\u043E\u043B\u044C\u043A\u043E \u0442\u0435\u0431\u044F \u0443\u043B\u043E\u0436\u0438\u043B \u2014 \u0430 \u0442\u0443\u0442 \u0437\u0430\u0432\u0430\u043B \u0441\u0440\u043E\u0447\u043D\u044B\u0439! \u041F\u043E\u0434\u044A\u0451\u043C, \u0431\u0430\u043D\u043A\u0443 \u0432 \u043B\u0430\u043F\u044B \u2014 \u0438 \u043A\u043E\u043F\u0430\u0442\u044C!",
        () => 260.744806,
        () => 288.273218,
        () => 545,
        () => 1740,
        () => "\u041D\u0443 \u0447\u0442\u043E, \u043B\u0430\u043F\u0430\u0441\u0442\u044B\u0439 \u2014 \u043F\u043E\u0440\u0430 \u0441\u043D\u043E\u0432\u0430 \u0448\u0430\u0445\u0442\u0451\u0440\u0438\u0442\u044C!",
        () => "ReciepHelp",
        () => 365,
        () => 393,
        () => 221,
        () => 251,
        () => "\u0425\u043E\u0447\u0435\u0448\u044C \u043A\u0438\u0440\u043A\u0443 \u043F\u043E\u043C\u043E\u0449\u043D\u0435\u0435? \u0422\u0440\u0438 \u0447\u0435\u0440\u0442\u0435\u0436\u0430 \u0432 \u0448\u0430\u0445\u0442\u0430\u0445 \u0438 \u043A\u0443\u0440\u0438\u0446\u0430 \u0432\u0441\u0451 \u0441\u0434\u0435\u043B\u0430\u0435\u0442.",
        () => "OfflineRewardMode",
        () => "\u0422\u0430\u043F\u0430\u043D\u0438 \u043F\u043E \u043C\u043D\u0435 3 \u0440\u0430\u0437\u0430",
        () => 90,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() + 200;
        },
        () => "0 \u0447",
        () => "last_exit",
        () => "Skill Window",
        () => 0.15,
        () => "spin_tick",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          return () => v0.GetValue() % v1.GetValue() + 1;
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          return () => C33.lerp(v0.GetValue(), v1.GetValue(), v2.GetValue() / 10);
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0(1, 2, 3, 4, 5, 6, 7, 8, 9);
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => v0.GetValue() % 9 + 1;
        },
        () => 807.659903,
        () => 1387.206441,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2(v0.GetValue(), "/10");
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => 570 / 10 * v0.GetValue();
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("\u0443\u0440.", v0.GetValue());
        },
        () => "\u043C\u0430\u043A\u0441.",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => 5 * v0.GetValue();
        },
        () => "hunger",
        () => "power",
        () => "purity",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => 1 * v0.GetValue();
        },
        () => "reward",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => 12 * v0.GetValue();
        },
        () => "debaff",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => -1 * v0.GetValue();
        },
        () => "energy",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => 2 * v0.GetValue();
        },
        () => "happiness",
        () => "TopRewards",
        () => 447,
        () => 1127,
        () => 1187,
        () => 461,
        () => 1060,
        () => 3e3,
        () => 4e3,
        () => 5e3,
        () => "PopUP",
        () => "\u042F \u043D\u0435 \u043C\u043E\u0433\u0443 \u044D\u0442\u043E \u0444\u0438\u043D\u0430\u043D\u0441\u0438\u0440\u043E\u0432\u0430\u0442\u044C!",
        () => 56,
        () => "\u042F \u0441\u0435\u0439\u0447\u0430\u0441 \u043D\u0435 \u0433\u043E\u0442\u043E\u0432, \u043A\u0430\u0436\u0435\u0442\u044C\u0441\u044F \u043C\u043D\u0435 \u043D\u0435 \u0445\u0432\u0430\u0442\u0430\u0435\u0442 \u043D\u0435\u043C\u043D\u043E\u0433\u043E \u0437\u0430\u0431\u043E\u0442\u044B",
        () => "\u0422\u044B \u0432\u044B\u0442\u0440\u0443\u0441\u0438\u043B \u0432\u0441\u0451, \u0447\u0442\u043E \u043C\u043E\u0433!",
        () => "\u0411\u0435\u0437 \u041B\u043E\u043A\u0435\u0440\u0430 \u0432\u0441\u0451 \u043F\u043E \u0440\u0430\u043D\u0434\u043E\u043C\u0443, \u0431\u043E\u0441\u0441. \u0425\u043E\u0447\u0435\u0448\u044C \u0432\u044B\u0431\u0440\u0430\u0442\u044C \u0441\u0430\u043C \u2014 \u0434\u043E\u0441\u0442\u0430\u043D\u044C \u041B\u043E\u043A\u0435\u0440.",
        () => "\u0411\u043E\u0441\u0441, \u044D\u0442\u0430 \u043F\u0440\u043E\u043A\u0430\u0447\u043A\u0430 \u0443\u0436\u0435 \u0432 \u043F\u043E\u0442\u043E\u043B\u043E\u043A \u0443\u043F\u0451\u0440\u043B\u0430\u0441\u044C. \u041B\u043E\u043A\u0435\u0440 \u0441\u044E\u0434\u0430 \u043D\u0435 \u0432\u043B\u0435\u0437\u0435\u0442!",
        () => "\u0429\u0430 \u0431\u044B \u0430\u0432\u0442\u043E\u043A\u043E\u043F\u0430\u0442\u044C \u0431\u0435\u0437 \u044D\u043D\u0435\u0440\u0433\u0438\u0438\u2026 \u044D\u0442\u043E \u043A\u0430\u043A \u043A\u0438\u0440\u043A\u043E\u0439 \u043C\u0430\u0445\u0430\u0442\u044C \u0432\u043E \u0441\u043D\u0435.",
        () => 38.56172,
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2("-", v0.GetValue());
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => 9 * f0();
        },
        () => 547.134121,
        () => 1153,
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          return () => f0(625 * v1.GetValue() * 0.7 * v2.GetValue());
        },
        () => "BlurHorizontal",
        () => "RadialBlur",
        () => "UI",
        () => "shadow",
        () => "Sound",
        () => "AirtableData",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0("new URLSearchParams(window.location.search).get('id')");
        },
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const n1 = p._GetNode(1);
          return () => v0.GetValue() + "&fields[]=" + n1.ExpObject();
        },
        () => "1001",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          const v2 = p._GetNode(2).GetVar();
          return () => f0(v1.GetValue(), "userid", v2.GetValue());
        },
        () => "Authorization",
        () => "Bearer pateWcDdq7UZIsk4b.31b097cb23563636a1ef69d099fe81d3832a1459f0d526f8aa2be703e490f8bb",
        () => "GetPlayerData",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          const v1 = p._GetNode(1).GetVar();
          return () => v0.GetValue() + v1.GetValue();
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const n1 = p._GetNode(1);
          return () => f0(n1.ExpObject("records.0.fields"));
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.id");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.base_tutorial_completed");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.adventure_tutorial_completed");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.aidShopLvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.washShopLvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.foodShopLvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.SubLevel");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.CurrentMission");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.Recipe");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.health");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.hunger");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.mood");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.purity");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.energy");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.is_sleeping");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.sound");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.music");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.is_dead");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.balance");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.name");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.health_buff_lvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.energy_buff_lvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.mood_buff_lvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.hunger_buff_lvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.purity_buff_lvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.hourly_offline_buff_lvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.pickaxe_power_buff_lvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.hourly_loss_stat_buff_lvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.sleep_boost_lvl");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.locker_ammount");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.locker_progress");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.offline_reward");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.health_max");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.energy_max");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.purity_max");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.hunger_max");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.mood_max");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.pickaxe_power");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.weekly_fighting_stats");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.weekly_mining_stats");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.weekly_purity_stats");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.energy_regeneration");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.weekly_fighting_place");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.weekly_mining_place");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.weekly_purity_place");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("records.0.fields.spin_cost");
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => and2(n0.ExpObject("records.0.fields.hours_offline"), " \u0447");
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          return () => f0(v1.GetValue(), "%2520", "%20");
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          return () => f0(v1.GetValue(), "%25", "%");
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          return () => f0(v1.GetValue(), "%20", " ");
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const v1 = p._GetNode(1).GetVar();
          return () => f0(v1.GetValue(), "%", "");
        },
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0(0.2, 1);
        },
        () => "Content-Type",
        () => "application/json",
        () => "PATCH_PlayerData",
        () => "https://api.airtable.com/v0/appKc6Om5FaUEODka/Pets",
        () => "PATCH",
        () => "System",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => and2(v0.GetValue(), " \u0443\u0440.");
        },
        () => 1.1,
        () => 71.721894,
        () => 167.310373,
        () => 262.242211,
        () => 1.4,
        () => 360.356122,
        () => 454.227269,
        () => 1.6,
        () => 548.098416,
        () => 639.848181,
        () => 1.8,
        () => 731.067601,
        () => 1.9,
        () => 828.651166,
        () => 412,
        () => 406,
        () => "FadeOut",
        () => "https://pub-095b5716defa4f779e2effb48ddf341a.r2.dev/cutscene/cutscene1.mp4",
        () => "SecondCutscene",
        () => "https://pub-095b5716defa4f779e2effb48ddf341a.r2.dev/cutscene/cutscene2.mp4",
        () => "https://pub-095b5716defa4f779e2effb48ddf341a.r2.dev/cutscene/cutscene_reciep1.mp4",
        () => "https://pub-095b5716defa4f779e2effb48ddf341a.r2.dev/cutscene/cutscene_reciep2.mp4",
        () => "ReplaceColor",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0(35, 19, 14);
        },
        () => "https://pub-095b5716defa4f779e2effb48ddf341a.r2.dev/cutscene/cutscene_reciep_final1.mp4",
        () => "https://pub-095b5716defa4f779e2effb48ddf341a.r2.dev/cutscene/cutscene_reciep_final2.mp4",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() + 2;
        },
        () => "https://pub-095b5716defa4f779e2effb48ddf341a.r2.dev/cutscene/cutscene_base_2.mp4",
        () => "First_Cuscene_seen",
        () => "Second_Cuscene_seen",
        () => "Opacity",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => "v. " + f0();
        },
        () => "Data_loading_start",
        () => "Data_loading_finish",
        () => "SendLoginEvent",
        () => "https://digging-fox-tg.ruslan-85d.workers.dev/",
        () => "POST",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0("new URLSearchParams(window.location.search).get('dev_mode')");
        },
        () => 48,
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => and2(Math.round(f0() * 100), "%");
        },
        (p) => {
          const n0 = p._GetNode(0);
          const n1 = p._GetNode(1);
          const f2 = p._GetNode(2).GetBoundMethod();
          return () => C33.lerp(n0.ExpObject(), n1.ExpInstVar(), f2());
        },
        () => 0.05,
        () => "Resourses_loading_finish",
        () => "DEV_GROUP",
        () => "Digging",
        () => "\u041F\u0438\u0442\u043E\u043C\u0435\u0446 \u043D\u0430\u0445\u043E\u0434\u0438\u0442 \u043A\u0430\u043C\u0435\u043D\u044C \u0441 \u0442\u0430\u0438\u043D\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u043C\u0438 \u0443\u0437\u043E\u0440\u0430\u043C\u0438. \u0415\u0433\u043E \u0441\u0432\u0435\u0447\u0435\u043D\u0438\u0435 \u043D\u0430\u043F\u043E\u043B\u043D\u044F\u0435\u0442 \u0440\u0430\u0434\u043E\u0441\u0442\u044C\u044E, \u043D\u043E \u0437\u0430\u0441\u0442\u0430\u0432\u043B\u044F\u0435\u0442 \u0437\u0430\u0434\u0435\u0440\u0436\u0430\u0442\u044C\u0441\u044F \u0434\u043E\u043B\u044C\u0448\u0435 \u0447\u0435\u043C \u043D\u0443\u0436\u043D\u043E."
      ];
    }
    var unaryminus;
    var bothNumbers;
    var add;
    var subtract;
    var multiply;
    var divide;
    var mod;
    var pow;
    var and;
    var or;
  }
});

// file-map:scripts/c3main.js
var import_c3runtime = __toESM(require_c3runtime());

// file-map:scripts/objRefTable.js
var C32 = self.C3;
self.C3_GetObjectRefTable = function() {
  return [
    C32.Plugins.AdvancedRandom,
    C32.Plugins.AJAX,
    C32.Plugins.Audio,
    C32.Plugins.Browser,
    C32.Plugins.Button,
    C32.Plugins.Json,
    C32.Plugins.Arr,
    C32.Plugins.Touch,
    C32.Plugins.LocalStorage,
    C32.Plugins.Date,
    C32.Plugins.video,
    C32.Behaviors.Timer,
    C32.Plugins.GameAnalytics,
    C32.Plugins.BinaryData,
    C32.Plugins.PlatformInfo,
    C32.Plugins.Dictionary,
    C32.Plugins.Keyboard,
    C32.Plugins.Sprite,
    C32.Behaviors.Bullet,
    C32.Plugins.Text,
    C32.Behaviors.destroy,
    C32.Behaviors.Tween,
    C32.Behaviors.Fade,
    C32.Behaviors.MoveTo,
    C32.Behaviors.Flash,
    C32.Plugins.TextBox,
    C32.Behaviors.Sin,
    C32.Behaviors.Pin,
    C32.Plugins.TiledBg,
    C32.Plugins.Particles,
    C32.Plugins.HTMLElement,
    C32.Behaviors.DragnDrop,
    C32.Behaviors.Physics,
    C32.Behaviors.Rotate,
    C32.Plugins.NinePatch,
    C32.Plugins.System.Acts.SetFunctionReturnValue,
    C32.JavaScriptInEvents.Es_dataextension_Event4_Act1,
    C32.JavaScriptInEvents.Es_dataextension_Event5_Act1,
    C32.JavaScriptInEvents.Es_dataextension_Event6_Act2,
    C32.Plugins.System.Cnds.OnLayoutStart,
    C32.Plugins.System.Cnds.CompareBoolVar,
    C32.JavaScriptInEvents.Es_telegram_Event4_Act1,
    C32.Plugins.System.Cnds.Else,
    C32.JavaScriptInEvents.Es_telegram_Event5_Act1,
    C32.JavaScriptInEvents.Es_telegram_Event6_Act2,
    C32.Plugins.System.Acts.SetBoolVar,
    C32.Plugins.GameAnalytics.Acts.configureBuild,
    C32.Plugins.System.Exps.projectversion,
    C32.Plugins.GameAnalytics.Acts.addAvailableResourceItemType,
    C32.Plugins.GameAnalytics.Acts.addAvailableResourceCurrency,
    C32.JavaScriptInEvents.Es_gameanalytics_Event5_Act9,
    C32.JavaScriptInEvents.Es_gameanalytics_Event5_Act10,
    C32.Plugins.GameAnalytics.Acts.initialize,
    C32.Plugins.System.Acts.WaitForPreviousActions,
    C32.JavaScriptInEvents.Es_gameanalytics_Event5_Act14,
    C32.JavaScriptInEvents.Es_gameanalytics_Event7_Act1,
    C32.Plugins.System.Cnds.IsGroupActive,
    C32.Plugins.Sprite.Acts.SetOpacity,
    C32.Behaviors.Tween.Acts.TweenOneProperty,
    C32.Plugins.System.Acts.SetObjectTimescale,
    C32.Plugins.Text.Acts.SetText,
    C32.Plugins.System.Acts.SetVar,
    C32.Plugins.Audio.Acts.Stop,
    C32.Plugins.System.Acts.SetLayerVisible,
    C32.Plugins.Sprite.Acts.SetAnimFrame,
    C32.Plugins.System.Cnds.IsPreview,
    C32.Plugins.System.Cnds.CompareVar,
    C32.Plugins.Sprite.Acts.SetSize,
    C32.Plugins.Text.Acts.SetVisible,
    C32.Plugins.Sprite.Acts.SetAnim,
    C32.Plugins.Sprite.Acts.SetY,
    C32.Plugins.Sprite.Exps.BBoxBottom,
    C32.Plugins.Sprite.Exps.Height,
    C32.Plugins.Sprite.Acts.Destroy,
    C32.Plugins.System.Cnds.EveryTick,
    C32.Behaviors.Bullet.Acts.SetAngleOfMotion,
    C32.Plugins.Sprite.Acts.MoveToTop,
    C32.Plugins.LocalStorage.Exps.ItemValue,
    C32.Plugins.System.Exps.replace,
    C32.Plugins.Text.Exps.Text,
    C32.Plugins.Arr.Exps.At,
    C32.Plugins.System.Cnds.Compare,
    C32.Plugins.Sprite.Exps.ImageHeight,
    C32.Plugins.Sprite.Acts.SetHeight,
    C32.Plugins.Sprite.Cnds.CompareY,
    C32.Plugins.System.Exps.viewporttop,
    C32.Plugins.Sprite.Exps.Y,
    C32.Plugins.Sprite.Exps.IID,
    C32.Plugins.Text.Acts.SetFontColor,
    C32.Plugins.Sprite.Cnds.OnCreated,
    C32.Plugins.Sprite.Cnds.CompareFrame,
    C32.Plugins.System.Cnds.TriggerOnce,
    C32.Plugins.Sprite.Cnds.IsAnimPlaying,
    C32.Plugins.System.Acts.CreateObject,
    C32.Plugins.Sprite.Acts.SetScale,
    C32.Behaviors.MoveTo.Acts.MoveToPosition,
    C32.Behaviors.Fade.Acts.StartFade,
    C32.Plugins.System.Exps.choose,
    C32.Plugins.System.Exps.int,
    C32.Plugins.System.Exps.random,
    C32.Plugins.Touch.Cnds.OnTapGestureObject,
    C32.Plugins.Sprite.Cnds.IsVisible,
    C32.Behaviors.Tween.Acts.TweenTwoProperties,
    C32.Plugins.System.Acts.Wait,
    C32.Plugins.System.Acts.AddVar,
    C32.Plugins.Sprite.Exps.X,
    C32.Plugins.Audio.Acts.Play,
    C32.Plugins.System.Acts.SubVar,
    C32.Plugins.GameAnalytics.Acts.addDesignEvent,
    C32.Plugins.Sprite.Acts.SetVisible,
    C32.Plugins.Sprite.Cnds.OnAnimFinished,
    C32.Plugins.Text.Acts.Destroy,
    C32.Plugins.AJAX.Acts.RequestFile,
    C32.Plugins.AdvancedRandom.Acts.CreateProbabilityTable,
    C32.Plugins.Sprite.Acts.SetPos,
    C32.Plugins.Text.Acts.SetPos,
    C32.Plugins.AdvancedRandom.Acts.AddProbabilityEntry,
    C32.Plugins.AdvancedRandom.Exps.Weighted,
    C32.Plugins.Arr.Cnds.ArrForEach,
    C32.Plugins.Arr.Acts.Pop,
    C32.Plugins.AJAX.Cnds.OnComplete,
    C32.Plugins.Arr.Acts.JSONLoad,
    C32.Plugins.AJAX.Exps.LastData,
    C32.Plugins.AdvancedRandom.Acts.RemoveProbabilityEntry,
    C32.Plugins.Sprite.Cnds.CompareInstanceVar,
    C32.Plugins.Sprite.Cnds.IsOnScreen,
    C32.Plugins.Sprite.Cnds.OnCollision,
    C32.Plugins.Sprite.Cnds.CompareOpacity,
    C32.Plugins.Text.Exps.X,
    C32.Plugins.Text.Exps.Y,
    C32.Plugins.Text.Cnds.CompareText,
    C32.Plugins.Json.Acts.Parse,
    C32.Plugins.Json.Acts.SetValue,
    C32.Plugins.Json.Exps.ToCompactString,
    C32.JavaScriptInEvents.Digging_sheet_Event414_Act2,
    C32.Plugins.GameAnalytics.Acts.addResourceEvent,
    C32.Behaviors.MoveTo.Acts.MoveToObject,
    C32.Behaviors.MoveTo.Acts.SetMovingAngle,
    C32.Plugins.Sprite.Acts.SetAngle,
    C32.Behaviors.MoveTo.Acts.SetMaxSpeed,
    C32.Behaviors.MoveTo.Acts.SetAcceleration,
    C32.Behaviors.MoveTo.Acts.SetDeceleration,
    C32.Plugins.Text.Acts.MoveToTop,
    C32.Plugins.System.Exps.viewportmidx,
    C32.Plugins.System.Exps.viewportmidy,
    C32.Behaviors.MoveTo.Cnds.OnArrived,
    C32.Plugins.Sprite.Acts.Spawn,
    C32.Behaviors.MoveTo.Acts.SetEnabled,
    C32.Behaviors.Bullet.Acts.SetEnabled,
    C32.Behaviors.Bullet.Acts.SetSpeed,
    C32.Plugins.Text.Acts.SetOpacity,
    C32.JavaScriptInEvents.Digging_sheet_Event614_Act1,
    C32.Plugins.System.Acts.LoadObjectTextures,
    C32.Plugins.Sprite.Acts.MoveToLayer,
    C32.Plugins.Sprite.Acts.SetInstanceVar,
    C32.Plugins.Sprite.Acts.AddChild,
    C32.Plugins.Audio.Cnds.IsTagPlaying,
    C32.Plugins.Sprite.Exps.ImagePointX,
    C32.Plugins.Sprite.Exps.ImagePointY,
    C32.JavaScriptInEvents.Digging_sheet_Event633_Act6,
    C32.Plugins.Sprite.Acts.SetBoolInstanceVar,
    C32.Plugins.System.Cnds.Repeat,
    C32.Plugins.System.Exps.loopindex,
    C32.Plugins.Sprite.Acts.SetEffectParam,
    C32.Plugins.Sprite.Exps.Angle,
    C32.Plugins.Sprite.Cnds.OnFrameChanged,
    C32.Plugins.Sprite.Cnds.IsBoolInstanceVarSet,
    C32.Plugins.System.Cnds.LayerVisible,
    C32.Behaviors.Pin.Acts.PinByImagePoint,
    C32.Plugins.Sprite.Acts.StopAnim,
    C32.Plugins.Text.Acts.TypewriterText,
    C32.Plugins.Text.Acts.SetEffectEnabled,
    C32.Behaviors.Sin.Acts.SetEnabled,
    C32.Plugins.System.Acts.LoadLayoutTextures,
    C32.Plugins.System.Acts.GoToLayoutByName,
    C32.Plugins.Arr.Acts.SetSize,
    C32.Plugins.AdvancedRandom.Acts.CreatePermutationTable,
    C32.Plugins.Arr.Acts.SetXY,
    C32.Plugins.AdvancedRandom.Exps.Permutation,
    C32.Plugins.Text.Cnds.CompareY,
    C32.Plugins.Text.Cnds.PickDistance,
    C32.Plugins.Text.Cnds.OnCreated,
    C32.Plugins.System.Acts.SetTimescale,
    C32.Plugins.Sprite.Acts.MoveToBottom,
    C32.JavaScriptInEvents.Digging_sheet_Event756_Act12,
    C32.JavaScriptInEvents.Digging_sheet_Event772_Act1,
    C32.Plugins.Text.Acts.SetY,
    C32.Plugins.System.Acts.GoToLayout,
    C32.Plugins.LocalStorage.Acts.SetItem,
    C32.Plugins.Keyboard.Cnds.IsKeyDown,
    C32.Plugins.Audio.Acts.StopAll,
    C32.Plugins.HTMLElement.Acts.SetPos,
    C32.Plugins.NinePatch.Acts.SetVisible,
    C32.Plugins.HTMLElement.Acts.SetContent,
    C32.Plugins.TiledBg.Acts.SetWidth,
    C32.Plugins.TiledBg.Acts.SetVisible,
    C32.Plugins.Sprite.Acts.SetX,
    C32.Plugins.Audio.Acts.SetVolume,
    C32.Behaviors.Rotate.Acts.SetEnabled,
    C32.Plugins.Touch.Cnds.IsTouchingObject,
    C32.Plugins.Touch.Cnds.OnTapGesture,
    C32.Plugins.Sprite.Exps.UID,
    C32.Plugins.Sprite.Cnds.PickByUID,
    C32.Behaviors.Timer.Acts.StartTimer,
    C32.Plugins.Sprite.Cnds.OnAnyAnimFinished,
    C32.Behaviors.Timer.Cnds.OnTimer,
    C32.Plugins.System.Cnds.Every,
    C32.JavaScriptInEvents.Base_sheet_Event337_Act6,
    C32.Plugins.Text.Acts.SetFontSize,
    C32.Plugins.HTMLElement.Exps.Y,
    C32.Plugins.HTMLElement.Exps.X,
    C32.Plugins.Particles.Acts.SetRate,
    C32.Plugins.Particles.Acts.SetAngle,
    C32.JavaScriptInEvents.Base_sheet_Event359,
    C32.Plugins.Browser.Acts.ConsoleLog,
    C32.Plugins.System.Cnds.PickByComparison,
    C32.Behaviors.Timer.Acts.StopTimer,
    C32.Plugins.NinePatch.Acts.SetWidth,
    C32.Plugins.NinePatch.Acts.SetHeight,
    C32.Plugins.Sprite.Acts.StartAnim,
    C32.Plugins.Sprite.Acts.SetAnimSpeed,
    C32.Plugins.System.Exps.dt,
    C32.Plugins.NinePatch.Cnds.CompareHeight,
    C32.Plugins.Audio.Acts.SetMuted,
    C32.JavaScriptInEvents.Es_general_Event19_Act1,
    C32.Plugins.Dictionary.Acts.JSONLoad,
    C32.Plugins.Browser.Exps.ExecJS,
    C32.Plugins.Dictionary.Cnds.ForEachKey,
    C32.Plugins.Dictionary.Exps.CurrentKey,
    C32.Plugins.AJAX.Acts.SetHeader,
    C32.Plugins.AJAX.Acts.Request,
    C32.Plugins.Json.Exps.GetAsCompactString,
    C32.Plugins.Json.Exps.Get,
    C32.JavaScriptInEvents.Es_general_Event30_Act51,
    C32.Plugins.AJAX.Cnds.OnError,
    C32.JavaScriptInEvents.Es_general_Event36_Act1,
    C32.JavaScriptInEvents.Es_general_Event38_Act1,
    C32.Plugins.AJAX.Acts.Post,
    C32.JavaScriptInEvents.Es_general_Event39_Act1,
    C32.Plugins.BinaryData.Acts.SetLength,
    C32.Plugins.video.Acts.SetSource2,
    C32.Plugins.AJAX.Acts.SetResponseBinary,
    C32.Plugins.video.Acts.SetEffectParam,
    C32.Plugins.System.Exps.rgbex255,
    C32.Plugins.System.Cnds.PickAll,
    C32.Plugins.video.Cnds.HasEnded,
    C32.Plugins.Touch.Cnds.OnTouchEnd,
    C32.Plugins.Text.Cnds.IsVisible,
    C32.Plugins.video.Acts.SetPlaybackTime,
    C32.Plugins.video.Exps.PlaybackTime,
    C32.Plugins.BinaryData.Cnds.CompareLength,
    C32.Plugins.BinaryData.Exps.GetURL,
    C32.Plugins.Button.Cnds.OnClicked,
    C32.Plugins.PlatformInfo.Cnds.IsOnMobile,
    C32.JavaScriptInEvents.Dataloader_sheet_Event3_Act1,
    C32.JavaScriptInEvents.Dataloader_sheet_Event8_Act1,
    C32.Plugins.NinePatch.Acts.SetInstanceVar,
    C32.Plugins.NinePatch.Exps.Width,
    C32.Plugins.NinePatch.Acts.SetBoolInstanceVar,
    C32.Plugins.System.Exps.loadingprogress,
    C32.Plugins.NinePatch.Cnds.IsBoolInstanceVarSet,
    C32.JavaScriptInEvents.Es_loading_Event6_Act1,
    C32.Plugins.System.Cnds.OnLoadFinished,
    C32.Plugins.System.Acts.SetGroupActive,
    C32.JavaScriptInEvents.Es_dev_Event5_Act1,
    C32.Plugins.Keyboard.Cnds.OnKey,
    C32.Plugins.Touch.Cnds.OnDoubleTapGesture,
    C32.Plugins.System.Exps.layoutname
  ];
};
self.C3_JsPropNameTable = [
  { AdvancedRandom: 0 },
  { AJAX: 0 },
  { Audio: 0 },
  { Browser: 0 },
  { Button: 0 },
  { JSON: 0 },
  { Legend_Array: 0 },
  { Norm_Array: 0 },
  { Rare_Array: 0 },
  { Touch: 0 },
  { LocalStorage: 0 },
  { Battle_Array: 0 },
  { Door_Array: 0 },
  { EventsLeft_Array: 0 },
  { NormRandom: 0 },
  { RareRandom: 0 },
  { LegendRandom: 0 },
  { Mission_Array: 0 },
  { Date: 0 },
  { Timer: 0 },
  { FoxNews: 0 },
  { GameAnalytics: 0 },
  { NextCutSceneBinaryData: 0 },
  { PlatformInfo: 0 },
  { PlayerDataDictionary: 0 },
  { Keyboard: 0 },
  { AirtablePatchFields: 0 },
  { BaseBackground: 0 },
  { Battle_BG: 0 },
  { Bullet: 0 },
  { Battle_icon: 0 },
  { block: 0 },
  { box1: 0 },
  { Button_continue: 0 },
  { Button_continue2: 0 },
  { Cooper: 0 },
  { Cooper_inv: 0 },
  { Copper_count: 0 },
  { DestroyOutsideLayout: 0 },
  { Tween: 0 },
  { crack: 0 },
  { DataSendText: 0 },
  { Debug: 0 },
  { debug_button: 0 },
  { debug_deep: 0 },
  { DecodedName: 0 },
  { \u0412\u0443\u0443\u0437: 0 },
  { Deep_txt: 0 },
  { type: 0 },
  { typeNumeric: 0 },
  { attackAvailable: 0 },
  { attackFrame: 0 },
  { Fade: 0 },
  { MoveTo: 0 },
  { Flash: 0 },
  { Enemy1: 0 },
  { EnterName: 0 },
  { EnterScore: 0 },
  { Event_line: 0 },
  { Event_stat_txt: 0 },
  { Event_txt: 0 },
  { EventButton1: 0 },
  { EventButton2: 0 },
  { Final_score: 0 },
  { Sine: 0 },
  { Final_Score2: 0 },
  { FinalButton: 0 },
  { food_btn: 0 },
  { Fox: 0 },
  { Frame: 0 },
  { Gold: 0 },
  { Gold_count: 0 },
  { Gold_inv: 0 },
  { ground1: 0 },
  { ground_rocks1: 0 },
  { ground_rocks2: 0 },
  { EnergyFrame: 0 },
  { Group4: 0 },
  { Happiness_baff_count: 0 },
  { Happiness_baff_txt: 0 },
  { Happiness_button: 0 },
  { header: 0 },
  { Help_button: 0 },
  { Help_close: 0 },
  { Help_panel: 0 },
  { Hunger_baff_count: 0 },
  { Hunger_baff_txt: 0 },
  { Hunger_button: 0 },
  { icon: 0 },
  { RecordID: 0 },
  { Pin: 0 },
  { Inv_close: 0 },
  { Inventory: 0 },
  { Inventory_frame: 0 },
  { Iron: 0 },
  { Iron_count: 0 },
  { Iron_inv: 0 },
  { NormTest: 0 },
  { junk: 0 },
  { junk2: 0 },
  { Lead: 0 },
  { Lead_count: 0 },
  { Lead_inv: 0 },
  { load32_: 0 },
  { maskBlendMode: 0 },
  { Middle_frame: 0 },
  { money_bar: 0 },
  { Monster_Power: 0 },
  { Music: 0 },
  { Name: 0 },
  { Pickaxe_Power: 0 },
  { ProgressBarDiggingFill: 0 },
  { ProgressBarDiggingPanel: 0 },
  { progress_bar_milestones1: 0 },
  { Resource_frame: 0 },
  { result_window: 0 },
  { rocks_tunnel_: 0 },
  { Shadow: 0 },
  { Silver: 0 },
  { Silver_count: 0 },
  { Silver_inv: 0 },
  { Small_frame: 0 },
  { Sound: 0 },
  { Sprite2: 0 },
  { take_reward_button: 0 },
  { TextRandom: 0 },
  { TiledBackground: 0 },
  { tool: 0 },
  { tunnel1: 0 },
  { tunnel2: 0 },
  { hearth_txt: 0 },
  { health_sprite: 0 },
  { health_sprite2: 0 },
  { health_sprite3: 0 },
  { PickAxe_Range_txt: 0 },
  { mood_txt: 0 },
  { Happiness_sprite: 0 },
  { Happiness_Sprite2: 0 },
  { Happiness_Sprite3: 0 },
  { hunger_txt: 0 },
  { Hunger_Sprite: 0 },
  { Hunger_Sprite2: 0 },
  { Hunger_Sprite3: 0 },
  { purity_txt: 0 },
  { Purity_Sprite: 0 },
  { Purity_Sprite2: 0 },
  { Purity_Sprite3: 0 },
  { dontxt: 0 },
  { sleep_debug: 0 },
  { AnimType: 0 },
  { junktest: 0 },
  { obj_health_icon: 0 },
  { obj_mood_icon: 0 },
  { obj_hunger_icon: 0 },
  { obj_purity_icon: 0 },
  { LocalName: 0 },
  { Tg_ID: 0 },
  { api_debug: 0 },
  { RareTest: 0 },
  { LegendTest: 0 },
  { CurrentEventTxt: 0 },
  { tap_object_txt: 0 },
  { ProbabStatEventTxt: 0 },
  { AttackSmokeFX: 0 },
  { Baff_effect: 0 },
  { Pickaxedisplay_txt: 0 },
  { progress_bar_milestones2: 0 },
  { progress_bar_milestones4: 0 },
  { progress_bar_milestones3: 0 },
  { BaseReturnBtn: 0 },
  { MultiplierPic: 0 },
  { MusicBtn: 0 },
  { RecipeCountFrame: 0 },
  { RecipeIcon: 0 },
  { SoundBtn: 0 },
  { Multiplier_txt: 0 },
  { DamageFXText: 0 },
  { aid_btn: 0 },
  { button_frame: 0 },
  { Down_panel: 0 },
  { energy_progress_bar: 0 },
  { settings_btn: 0 },
  { workshop_btn: 0 },
  { shower_btn: 0 },
  { sleep_btn: 0 },
  { mood_progress_bar_green: 0 },
  { stats_panel: 0 },
  { tool_btn: 0 },
  { purity_progress_bar_green: 0 },
  { health_progress_bar_green: 0 },
  { hunger_progress_green: 0 },
  { NoMoney_panel: 0 },
  { main_shadow: 0 },
  { money_count_txt: 0 },
  { music_box: 0 },
  { music_Check: 0 },
  { no_btn_lvlup: 0 },
  { no_btn_sleep: 0 },
  { no_btn_upgrade: 0 },
  { no_btn_workshop: 0 },
  { NoMoneyTxt: 0 },
  { options_panel: 0 },
  { Player_name_txt: 0 },
  { PlayerShadow: 0 },
  { purity_stat_txt: 0 },
  { revive_button: 0 },
  { shop_shadow: 0 },
  { shop_window: 0 },
  { sleep_panel: 0 },
  { SleepTxt: 0 },
  { Small_obj_1: 0 },
  { sound_box: 0 },
  { sound_Check: 0 },
  { Sound_txt: 0 },
  { Sprite4: 0 },
  { Stat_count: 0 },
  { taken_money_txt: 0 },
  { Tap_obj: 0 },
  { upgrade_btn: 0 },
  { Upgrade_price_txt: 0 },
  { workshop_bags_buy_btn: 0 },
  { workshop_bags_buy_check: 0 },
  { workshop_bags_price_txt: 0 },
  { workshop_bags_txt: 0 },
  { workshop_buy_panel: 0 },
  { workshop_buy_txt: 0 },
  { workshop_deep_buy_btn: 0 },
  { workshop_deep_txt: 0 },
  { workshop_header_txt: 0 },
  { workshop_main_panel: 0 },
  { workshop_pickaxe_buy_check: 0 },
  { workshop_pickaxe_price_txt: 0 },
  { workshop_Pickaxe_skin_txt: 0 },
  { workshop_pickxe_buy_btn: 0 },
  { workshop_shadow: 0 },
  { workshop_upgrade_price_txt: 0 },
  { yes_btn_lvlup: 0 },
  { yes_btn_sleep: 0 },
  { yes_btn_buy: 0 },
  { yes_btn_workshop: 0 },
  { "1_item_1added_stat_txt": 0 },
  { "1_item_2added_stat_txt": 0 },
  { "1_item_price_txt": 0 },
  { "1_item_stat_bonus_icon": 0 },
  { "1_slot_item": 0 },
  { "1_slot_item_count": 0 },
  { slot_buy_btn: 0 },
  { "2_item_1added_stat_txt": 0 },
  { "2_item_2added_stat_txt": 0 },
  { "2_slot_item": 0 },
  { "2_slot_item_count": 0 },
  { "3_item_1added_stat_txt": 0 },
  { "3_item_2added_stat_txt": 0 },
  { "3_slot_item": 0 },
  { "3_slot_item_count": 0 },
  { "4_slot_item": 0 },
  { "4_slot_item_count": 0 },
  { "5_slot_item": 0 },
  { "5_slot_item_count": 0 },
  { "6_slot_item": 0 },
  { "6_slot_item_count": 0 },
  { added_stat_txt1: 0 },
  { added_stat_txt2: 0 },
  { close_workshop: 0 },
  { debug_energy_btn: 0 },
  { debug_energy_btn_2: 0 },
  { debug_health_btn: 0 },
  { debug_health_btn2: 0 },
  { dont: 0 },
  { energy_count_txt: 0 },
  { energy_icon: 0 },
  { Explosion: 0 },
  { hapiness_stat_txt: 0 },
  { health_stat_txt: 0 },
  { hunger_stat_txt: 0 },
  { levelup_panel: 0 },
  { LvlupTxt: 0 },
  { "2_item_price_txt": 0 },
  { "3_item_price_txt": 0 },
  { mood_progress_bar_yellow: 0 },
  { mood_progress_bar_red: 0 },
  { purity_progress_yellow: 0 },
  { purity_progress_red: 0 },
  { health_progress_bar_yellow: 0 },
  { health_progress_red: 0 },
  { hunger_progress_yellow: 0 },
  { hunger_progress_red: 0 },
  { obj_health_icon_base: 0 },
  { obj_hunger_icon_base: 0 },
  { obj_mood_icon_base: 0 },
  { obj_purity_icon_base: 0 },
  { BlockScreen: 0 },
  { dino: 0 },
  { door_button: 0 },
  { doors: 0 },
  { DoorTxt: 0 },
  { upgrade_price_icon: 0 },
  { tutorail_shadow: 0 },
  { Coin: 0 },
  { CoinParticles: 0 },
  { pulsetime: 0 },
  { BaseReturnTxt: 0 },
  { Cutscene_txt: 0 },
  { Debug_Load_txt: 0 },
  { debugTxt: 0 },
  { debugTxt2: 0 },
  { HitExplosion1: 0 },
  { HitExplosion2: 0 },
  { LevelTxt: 0 },
  { Loading_animation: 0 },
  { LoadingText: 0 },
  { LoadingBg: 0 },
  { MisiionFrame: 0 },
  { MissionObject: 0 },
  { MissionTxt: 0 },
  { MissonIcon: 0 },
  { Multiplyer_txt: 0 },
  { DragDrop: 0 },
  { Physics: 0 },
  { NewFox: 0 },
  { StartScreenFox: 0 },
  { RecipeCount_txt: 0 },
  { Rotate: 0 },
  { redbull: 0 },
  { ShakeButton: 0 },
  { ShakeButtonReward: 0 },
  { ShakeRewardText: 0 },
  { ShakeRewardTimerTxt: 0 },
  { skip: 0 },
  { skip2: 0 },
  { TapFoxZone: 0 },
  { BonusCoin_txt: 0 },
  { Progress_bar_start_txt: 0 },
  { Locker_title_txt: 0 },
  { Locker_count_txt: 0 },
  { Type: 0 },
  { skill_current_baff_txt: 0 },
  { locker_progress_count_txt: 0 },
  { Skill_price_bnt_txt: 0 },
  { skill_level_txt: 0 },
  { Skill_window_title_txt: 0 },
  { AutoFarm_bnt: 0 },
  { BonusCoinIcon: 0 },
  { seq: 0 },
  { Card: 0 },
  { CardParticlesWin: 0 },
  { debaff_skill_icon: 0 },
  { energy_skill_icon: 0 },
  { happiness_skill_icon: 0 },
  { health_skill_icon: 0 },
  { hunger_skill_icon: 0 },
  { locker_count: 0 },
  { locker_fly_icon: 0 },
  { locker_icon: 0 },
  { locker_progress: 0 },
  { locker_progress_icon: 0 },
  { lvl: 0 },
  { power_skill_icon: 0 },
  { Progress_bar_2: 0 },
  { Progress_bar_start: 0 },
  { progress_bar_sublevel_fill: 0 },
  { progress_bar_sublevels: 0 },
  { purity_skill_icon: 0 },
  { Recipe_progress_icon: 0 },
  { reward_skill_icon: 0 },
  { skill_buy_btn: 0 },
  { skill_panel: 0 },
  { skill_progressbar_frame: 0 },
  { skill_window_cancel: 0 },
  { SkillBtn: 0 },
  { sleep_skill_icon: 0 },
  { Spin_arrows: 0 },
  { energy_regen_Txt: 0 },
  { TopRewards_txt_2: 0 },
  { TopRewards_txt_1: 0 },
  { TopRewards_btn_txt: 0 },
  { Autofarm_x_text: 0 },
  { Autofarm_reward_text: 0 },
  { Autofarm_mult_text: 0 },
  { Autofarm_energy_text: 0 },
  { Autofarm_take_text: 0 },
  { Autofarm_title_text: 0 },
  { StartScreenFoxText: 0 },
  { ProjectVersionText: 0 },
  { defaultWidth: 0 },
  { enable: 0 },
  { LoadingPanel9patch: 0 },
  { TutorialMask1: 0 },
  { TutorialMask2: 0 },
  { TutorialPopup: 0 },
  { TutorialTxt: 0 },
  { TutorialHand: 0 },
  { autofarm_buy_btn: 0 },
  { AutoFarm_frame: 0 },
  { autofarm_close: 0 },
  { autofarm_plus: 0 },
  { autofarm_minus: 0 },
  { TopReward_frame: 0 },
  { TopReward_btn: 0 },
  { TopRewardBadge: 0 },
  { coins_top_fly_icon: 0 },
  { locker_top_fly_icon: 0 },
  { tunnel_autofarm: 0 },
  { ground_autofarm: 0 },
  { autofarm_progress: 0 },
  { AutoChestIcon: 0 },
  { chest_btn_icon: 0 },
  { energy_btn_icon: 0 },
  { AutoChest_big_icon: 0 },
  { TempTestSizeFox: 0 },
  { MonsterPowerTypeIcons: 0 },
  { UIHealthPanel: 0 },
  { DarkGradientTexture: 0 },
  { DamageFXIcons: 0 },
  { CharacterShadow: 0 },
  { Sprite3: 0 },
  { ChestProgressBarIcon: 0 },
  { tunnel: 0 },
  { rocks: 0 },
  { JunkFam: 0 },
  { Event_fam: 0 },
  { Digging: 0 },
  { Event_stats: 0 },
  { Stat_txt: 0 },
  { EventUI: 0 },
  { Inventory_window: 0 },
  { Inventory_count_text: 0 },
  { Main_UI_buttons: 0 },
  { ProgressBar: 0 },
  { Shop_Window_Family: 0 },
  { Shop_window_txt_fam: 0 },
  { Slot_items: 0 },
  { Base_buttons: 0 },
  { Sleep_icons: 0 },
  { Sound_icons: 0 },
  { workshop_main_icons: 0 },
  { workshop_buy_btns: 0 },
  { workshop_txt: 0 },
  { TapIcons: 0 },
  { Price_txt: 0 },
  { Base_icons: 0 },
  { Additional_UI: 0 },
  { TutorialImages: 0 },
  { RecipePicsFam: 0 },
  { Skill_window_icons: 0 },
  { Skill_window_txt: 0 },
  { MainStatSprites: 0 },
  { AutoFarm_fam: 0 },
  { TopRewardsTxts: 0 },
  { AutoFarm_txt: 0 },
  { dataJson: 0 },
  { dictionaryJson: 0 },
  { value: 0 },
  { key: 0 },
  { TelegramSDKAvailable: 0 },
  { GameAnalyticsInitialized: 0 },
  { i_eventType: 0 },
  { i_eventValue: 0 },
  { AnimCount: 0 },
  { JunkAnimCount1: 0 },
  { JunkAnimCount2: 0 },
  { ItemAnimCount: 0 },
  { Deep: 0 },
  { DeepCompleted: 0 },
  { Chance: 0 },
  { pause: 0 },
  { EventStat: 0 },
  { Purity: 0 },
  { Hunger: 0 },
  { Happiness: 0 },
  { Health: 0 },
  { Choice: 0 },
  { ChoiceButton: 0 },
  { BattleButton: 0 },
  { InvButton: 0 },
  { DiggingTutorial: 0 },
  { BaseTutorial: 0 },
  { Reward1Y: 0 },
  { Reward2Y: 0 },
  { PickaxePower: 0 },
  { PickaxePowerUpgraded: 0 },
  { EnemyPower: 0 },
  { BattleReward: 0 },
  { Touched: 0 },
  { Happin_baff_count: 0 },
  { EventPush: 0 },
  { WinBattle: 0 },
  { Copper: 0 },
  { Score: 0 },
  { InventoryON: 0 },
  { GameOver: 0 },
  { name: 0 },
  { AttackLanding: 0 },
  { HelpWindow: 0 },
  { targetProgress: 0 },
  { progressSpeed: 0 },
  { maxDepth: 0 },
  { junkGO: 0 },
  { TapObject: 0 },
  { tempHappinessBaffi: 0 },
  { tempHungerBaffi: 0 },
  { EventCounter: 0 },
  { EventType: 0 },
  { EventID: 0 },
  { EventNormIndex: 0 },
  { EventRareIndex: 0 },
  { EventLegendIndex: 0 },
  { NormX: 0 },
  { NormCount: 0 },
  { RareX: 0 },
  { RareCount: 0 },
  { LegendX: 0 },
  { LegendCount: 0 },
  { NormDone: 0 },
  { RareDone: 0 },
  { LegendDone: 0 },
  { EventStart: 0 },
  { Tutorial: 0 },
  { TutorialStep: 0 },
  { TutorialPause: 0 },
  { JunkTutor1: 0 },
  { JunkTutor2: 0 },
  { InventoryTutorial: 0 },
  { InventoryAvailable: 0 },
  { BaffTutorTap: 0 },
  { TotalResources: 0 },
  { BaffTutor: 0 },
  { EnemyType: 0 },
  { LevelMultiplier: 0 },
  { CurrentMission: 0 },
  { MissionRecieved: 0 },
  { MissionPopup: 0 },
  { ReturnBaseWindow: 0 },
  { Recipe: 0 },
  { BattleWins: 0 },
  { ObjSide: 0 },
  { i_enemyType: 0 },
  { NextScene: 0 },
  { newTutorialStep: 0 },
  { EnemyHPmax: 0 },
  { EnemyHP: 0 },
  { shop_window_tap: 0 },
  { "1_item_price": 0 },
  { "2_item_price": 0 },
  { "3_item_price": 0 },
  { "1_item_count": 0 },
  { "2_item_count": 0 },
  { "3_item_count": 0 },
  { "4_item_count": 0 },
  { "5_item_count": 0 },
  { "6_item_count": 0 },
  { Current_money: 0 },
  { Upgrade_price: 0 },
  { Basket_money: 0 },
  { "1_Added_stat": 0 },
  { "2_Added_stat": 0 },
  { Energy: 0 },
  { maxEnergy: 0 },
  { maxHealth: 0 },
  { maxHunger: 0 },
  { maxPurity: 0 },
  { maxHappiness: 0 },
  { "1_item_1_stat": 0 },
  { "1_item_2_stat": 0 },
  { "2_item_1_stat": 0 },
  { "2_item_2_stat": 0 },
  { "3_item_1_stat": 0 },
  { "3_item_2_stat": 0 },
  { NoMoneyWarning: 0 },
  { AnimEnd: 0 },
  { Purchase: 0 },
  { tempHealthValue: 0 },
  { tempPurityValue: 0 },
  { tempHungerValue: 0 },
  { ActionAnim: 0 },
  { sleep_window: 0 },
  { Sleep: 0 },
  { Settings: 0 },
  { Workshop: 0 },
  { WorkshopUpgradeWindow: 0 },
  { workshop_pickaxe_price: 0 },
  { workshop_bags_price: 0 },
  { WorkshopUpgradePrice: 0 },
  { WorkshopUpgradeType: 0 },
  { Pickaxe_level: 0 },
  { Bags_level: 0 },
  { LvlUpgrade: 0 },
  { jsonBody: 0 },
  { music: 0 },
  { sound: 0 },
  { death: 0 },
  { NoPatience: 0 },
  { Start: 0 },
  { BlockClose: 0 },
  { AidShopLvl: 0 },
  { WashShopLvl: 0 },
  { FoodShopLvl: 0 },
  { WarningTXT: 0 },
  { BaseTutorialStep: 0 },
  { OpenedDoor: 0 },
  { WashShopTutor: 0 },
  { HealShopTutor: 0 },
  { FoodShopTutor: 0 },
  { SleepTutor: 0 },
  { SkillTutor: 0 },
  { CanBuyTutor: 0 },
  { FullBlock: 0 },
  { RedBull: 0 },
  { RecipeHelp: 0 },
  { OfflineRewardMode: 0 },
  { SkillUpgrade: 0 },
  { TopReward: 0 },
  { AutoFarm: 0 },
  { AutoFarmBtn: 0 },
  { AutoFarmRewardRecieved: 0 },
  { RewardClick: 0 },
  { NowISO: 0 },
  { OfflineReward: 0 },
  { SkillBtnPrice: 0 },
  { CurrentSpin: 0 },
  { Spin_State: 0 },
  { Spin_Delay: 0 },
  { Spin_MinDelay: 0 },
  { Spin_StartDelay: 0 },
  { Spin_StepsInLoop: 0 },
  { Spin_StepsSinceLoop: 0 },
  { Spin_LoopsAtMin: 0 },
  { Spin_LoopsTotal: 0 },
  { Spin_CurrentSeq: 0 },
  { Spin_PrevSeq: 0 },
  { Spin_TargetSeq: 0 },
  { Lockers: 0 },
  { SelectedSeq: 0 },
  { Locked: 0 },
  { LockerProgresBar: 0 },
  { SelectedPrevSeq: 0 },
  { MaxSkillLvl: 0 },
  { Lvl_Health: 0 },
  { Lvl_Hunger: 0 },
  { Lvl_Power: 0 },
  { Lvl_Energy: 0 },
  { Lvl_Happiness: 0 },
  { Lvl_Purity: 0 },
  { Lvl_StatDrop: 0 },
  { Lvl_Reward: 0 },
  { Lvl_Sleep: 0 },
  { Energy_regen: 0 },
  { OverallAddedSTATS: 0 },
  { weekly_mining_place: 0 },
  { weekly_fighting_place: 0 },
  { weekly_purity_place: 0 },
  { TopReward1: 0 },
  { TopReward2: 0 },
  { TopWindowOrder: 0 },
  { AutoRewardOption: 0 },
  { AutoRewardMultiplyer: 0 },
  { AutoRewardEnergyCost: 0 },
  { FoxSpeed: 0 },
  { FinalAutoReward: 0 },
  { SpinCost: 0 },
  { isOn: 0 },
  { skillSeq: 0 },
  { Order: 0 },
  { Badge: 0 },
  { Place: 0 },
  { ID: 0 },
  { API: 0 },
  { ActiveMainUI: 0 },
  { ActiveAdditionalUI: 0 },
  { DevMode: 0 },
  { Level: 0 },
  { AirtableLoaded: 0 },
  { playerDataJJON: 0 },
  { fieldsParameter: 0 },
  { keyIndex: 0 },
  { fields: 0 },
  { payload: 0 },
  { fieldsJSON: 0 },
  { CutsceneStep: 0 },
  { ImagesLoaded: 0 },
  { CombinedProgress: 0 }
];
self.InstanceType = {
  AdvancedRandom: class extends self.IInstance {
  },
  AJAX: class extends self.IInstance {
  },
  Audio: class extends self.IInstance {
  },
  Browser: class extends self.IInstance {
  },
  Button: class extends self.IButtonInstance {
  },
  JSON: class extends self.IJSONInstance {
  },
  Legend_Array: class extends self.IArrayInstance {
  },
  Norm_Array: class extends self.IArrayInstance {
  },
  Rare_Array: class extends self.IArrayInstance {
  },
  Touch: class extends self.IInstance {
  },
  LocalStorage: class extends self.IInstance {
  },
  Battle_Array: class extends self.IArrayInstance {
  },
  Door_Array: class extends self.IArrayInstance {
  },
  EventsLeft_Array: class extends self.IArrayInstance {
  },
  NormRandom: class extends self.IArrayInstance {
  },
  RareRandom: class extends self.IArrayInstance {
  },
  LegendRandom: class extends self.IArrayInstance {
  },
  Mission_Array: class extends self.IArrayInstance {
  },
  Date: class extends self.IInstance {
  },
  FoxNews: class extends self.IWorldInstance {
  },
  GameAnalytics: class extends self.IInstance {
  },
  NextCutSceneBinaryData: class extends self.IBinaryDataInstance {
  },
  PlatformInfo: class extends self.IInstance {
  },
  PlayerDataDictionary: class extends self.IDictionaryInstance {
  },
  Keyboard: class extends self.IInstance {
  },
  AirtablePatchFields: class extends self.IJSONInstance {
  },
  BaseBackground: class extends self.ISpriteInstance {
  },
  Battle_BG: class extends self.ISpriteInstance {
  },
  Battle_icon: class extends self.ISpriteInstance {
  },
  block: class extends self.ISpriteInstance {
  },
  box1: class extends self.ISpriteInstance {
  },
  Button_continue: class extends self.ITextInstance {
  },
  Button_continue2: class extends self.ITextInstance {
  },
  Cooper: class extends self.ISpriteInstance {
  },
  Cooper_inv: class extends self.ISpriteInstance {
  },
  Copper_count: class extends self.ITextInstance {
  },
  crack: class extends self.ISpriteInstance {
  },
  DataSendText: class extends self.ITextInstance {
  },
  Debug: class extends self.ITextInstance {
  },
  debug_button: class extends self.ISpriteInstance {
  },
  debug_deep: class extends self.ISpriteInstance {
  },
  DecodedName: class extends self.ITextInstance {
  },
  Deep_txt: class extends self.ITextInstance {
  },
  Enemy1: class extends self.ISpriteInstance {
  },
  EnterName: class extends self.ITextInputInstance {
  },
  EnterScore: class extends self.ITextInputInstance {
  },
  Event_line: class extends self.ISpriteInstance {
  },
  Event_stat_txt: class extends self.ITextInstance {
  },
  Event_txt: class extends self.ITextInstance {
  },
  EventButton1: class extends self.ISpriteInstance {
  },
  EventButton2: class extends self.ISpriteInstance {
  },
  Final_score: class extends self.ITextInstance {
  },
  Final_Score2: class extends self.ITextInstance {
  },
  FinalButton: class extends self.ITextInstance {
  },
  food_btn: class extends self.ISpriteInstance {
  },
  Fox: class extends self.ISpriteInstance {
  },
  Frame: class extends self.ISpriteInstance {
  },
  Gold: class extends self.ISpriteInstance {
  },
  Gold_count: class extends self.ITextInstance {
  },
  Gold_inv: class extends self.ISpriteInstance {
  },
  ground1: class extends self.ISpriteInstance {
  },
  ground_rocks1: class extends self.ISpriteInstance {
  },
  ground_rocks2: class extends self.ISpriteInstance {
  },
  EnergyFrame: class extends self.ISpriteInstance {
  },
  Group4: class extends self.ISpriteInstance {
  },
  Happiness_baff_count: class extends self.ITextInstance {
  },
  Happiness_baff_txt: class extends self.ITextInstance {
  },
  Happiness_button: class extends self.ISpriteInstance {
  },
  header: class extends self.ISpriteInstance {
  },
  Help_button: class extends self.ISpriteInstance {
  },
  Help_close: class extends self.ISpriteInstance {
  },
  Help_panel: class extends self.ISpriteInstance {
  },
  Hunger_baff_count: class extends self.ITextInstance {
  },
  Hunger_baff_txt: class extends self.ITextInstance {
  },
  Hunger_button: class extends self.ISpriteInstance {
  },
  icon: class extends self.ISpriteInstance {
  },
  RecordID: class extends self.ITextInstance {
  },
  Inv_close: class extends self.ISpriteInstance {
  },
  Inventory: class extends self.ISpriteInstance {
  },
  Inventory_frame: class extends self.ISpriteInstance {
  },
  Iron: class extends self.ISpriteInstance {
  },
  Iron_count: class extends self.ITextInstance {
  },
  Iron_inv: class extends self.ISpriteInstance {
  },
  NormTest: class extends self.ITextInstance {
  },
  junk: class extends self.ISpriteInstance {
  },
  junk2: class extends self.ISpriteInstance {
  },
  Lead: class extends self.ISpriteInstance {
  },
  Lead_count: class extends self.ITextInstance {
  },
  Lead_inv: class extends self.ISpriteInstance {
  },
  load32_: class extends self.ISpriteInstance {
  },
  maskBlendMode: class extends self.ISpriteInstance {
  },
  Middle_frame: class extends self.ISpriteInstance {
  },
  money_bar: class extends self.ISpriteInstance {
  },
  Monster_Power: class extends self.ITextInstance {
  },
  Music: class extends self.ITextInstance {
  },
  Name: class extends self.ITextInstance {
  },
  Pickaxe_Power: class extends self.ITextInstance {
  },
  ProgressBarDiggingFill: class extends self.ISpriteInstance {
  },
  ProgressBarDiggingPanel: class extends self.ISpriteInstance {
  },
  progress_bar_milestones1: class extends self.ISpriteInstance {
  },
  Resource_frame: class extends self.ISpriteInstance {
  },
  result_window: class extends self.ISpriteInstance {
  },
  rocks_tunnel_: class extends self.ISpriteInstance {
  },
  Shadow: class extends self.ISpriteInstance {
  },
  Silver: class extends self.ISpriteInstance {
  },
  Silver_count: class extends self.ITextInstance {
  },
  Silver_inv: class extends self.ISpriteInstance {
  },
  Small_frame: class extends self.ISpriteInstance {
  },
  Sound: class extends self.ITextInstance {
  },
  Sprite2: class extends self.ISpriteInstance {
  },
  take_reward_button: class extends self.ISpriteInstance {
  },
  TextRandom: class extends self.ITextInstance {
  },
  TiledBackground: class extends self.ITiledBackgroundInstance {
  },
  tool: class extends self.ISpriteInstance {
  },
  tunnel1: class extends self.ISpriteInstance {
  },
  tunnel2: class extends self.ISpriteInstance {
  },
  hearth_txt: class extends self.ITextInstance {
  },
  health_sprite: class extends self.ISpriteInstance {
  },
  health_sprite2: class extends self.ISpriteInstance {
  },
  health_sprite3: class extends self.ISpriteInstance {
  },
  PickAxe_Range_txt: class extends self.ITextInstance {
  },
  mood_txt: class extends self.ITextInstance {
  },
  Happiness_sprite: class extends self.ISpriteInstance {
  },
  Happiness_Sprite2: class extends self.ISpriteInstance {
  },
  Happiness_Sprite3: class extends self.ISpriteInstance {
  },
  hunger_txt: class extends self.ITextInstance {
  },
  Hunger_Sprite: class extends self.ISpriteInstance {
  },
  Hunger_Sprite2: class extends self.ISpriteInstance {
  },
  Hunger_Sprite3: class extends self.ISpriteInstance {
  },
  purity_txt: class extends self.ITextInstance {
  },
  Purity_Sprite: class extends self.ISpriteInstance {
  },
  Purity_Sprite2: class extends self.ISpriteInstance {
  },
  Purity_Sprite3: class extends self.ISpriteInstance {
  },
  dontxt: class extends self.ITextInstance {
  },
  sleep_debug: class extends self.ITextInstance {
  },
  AnimType: class extends self.ITextInstance {
  },
  junktest: class extends self.ITextInstance {
  },
  obj_health_icon: class extends self.ISpriteInstance {
  },
  obj_mood_icon: class extends self.ISpriteInstance {
  },
  obj_hunger_icon: class extends self.ISpriteInstance {
  },
  obj_purity_icon: class extends self.ISpriteInstance {
  },
  LocalName: class extends self.ITextInstance {
  },
  Tg_ID: class extends self.ITextInstance {
  },
  api_debug: class extends self.ITextInstance {
  },
  RareTest: class extends self.ITextInstance {
  },
  LegendTest: class extends self.ITextInstance {
  },
  CurrentEventTxt: class extends self.ITextInstance {
  },
  tap_object_txt: class extends self.ITextInstance {
  },
  ProbabStatEventTxt: class extends self.ITextInstance {
  },
  AttackSmokeFX: class extends self.ISpriteInstance {
  },
  Baff_effect: class extends self.ISpriteInstance {
  },
  Pickaxedisplay_txt: class extends self.ITextInstance {
  },
  progress_bar_milestones2: class extends self.ISpriteInstance {
  },
  progress_bar_milestones4: class extends self.ISpriteInstance {
  },
  progress_bar_milestones3: class extends self.ISpriteInstance {
  },
  BaseReturnBtn: class extends self.ISpriteInstance {
  },
  MultiplierPic: class extends self.ISpriteInstance {
  },
  MusicBtn: class extends self.ISpriteInstance {
  },
  RecipeCountFrame: class extends self.ISpriteInstance {
  },
  RecipeIcon: class extends self.ISpriteInstance {
  },
  SoundBtn: class extends self.ISpriteInstance {
  },
  Multiplier_txt: class extends self.ITextInstance {
  },
  DamageFXText: class extends self.ITextInstance {
  },
  aid_btn: class extends self.ISpriteInstance {
  },
  button_frame: class extends self.ISpriteInstance {
  },
  Down_panel: class extends self.ISpriteInstance {
  },
  energy_progress_bar: class extends self.ITiledBackgroundInstance {
  },
  settings_btn: class extends self.ISpriteInstance {
  },
  workshop_btn: class extends self.ISpriteInstance {
  },
  shower_btn: class extends self.ISpriteInstance {
  },
  sleep_btn: class extends self.ISpriteInstance {
  },
  mood_progress_bar_green: class extends self.ITiledBackgroundInstance {
  },
  stats_panel: class extends self.ISpriteInstance {
  },
  tool_btn: class extends self.ISpriteInstance {
  },
  purity_progress_bar_green: class extends self.ITiledBackgroundInstance {
  },
  health_progress_bar_green: class extends self.ITiledBackgroundInstance {
  },
  hunger_progress_green: class extends self.ITiledBackgroundInstance {
  },
  NoMoney_panel: class extends self.ISpriteInstance {
  },
  main_shadow: class extends self.ISpriteInstance {
  },
  money_count_txt: class extends self.ITextInstance {
  },
  music_box: class extends self.ISpriteInstance {
  },
  music_Check: class extends self.ISpriteInstance {
  },
  no_btn_lvlup: class extends self.ISpriteInstance {
  },
  no_btn_sleep: class extends self.ISpriteInstance {
  },
  no_btn_upgrade: class extends self.ISpriteInstance {
  },
  no_btn_workshop: class extends self.ISpriteInstance {
  },
  NoMoneyTxt: class extends self.ITextInstance {
  },
  options_panel: class extends self.ISpriteInstance {
  },
  Player_name_txt: class extends self.ITextInstance {
  },
  PlayerShadow: class extends self.ISpriteInstance {
  },
  purity_stat_txt: class extends self.ITextInstance {
  },
  revive_button: class extends self.ISpriteInstance {
  },
  shop_shadow: class extends self.ISpriteInstance {
  },
  shop_window: class extends self.ISpriteInstance {
  },
  sleep_panel: class extends self.ISpriteInstance {
  },
  SleepTxt: class extends self.ITextInstance {
  },
  Small_obj_1: class extends self.ISpriteInstance {
  },
  sound_box: class extends self.ISpriteInstance {
  },
  sound_Check: class extends self.ISpriteInstance {
  },
  Sound_txt: class extends self.ITextInstance {
  },
  Sprite4: class extends self.ISpriteInstance {
  },
  Stat_count: class extends self.ISpriteInstance {
  },
  taken_money_txt: class extends self.ITextInstance {
  },
  Tap_obj: class extends self.ISpriteInstance {
  },
  upgrade_btn: class extends self.ISpriteInstance {
  },
  Upgrade_price_txt: class extends self.ITextInstance {
  },
  workshop_bags_buy_btn: class extends self.ISpriteInstance {
  },
  workshop_bags_buy_check: class extends self.ISpriteInstance {
  },
  workshop_bags_price_txt: class extends self.ITextInstance {
  },
  workshop_bags_txt: class extends self.ITextInstance {
  },
  workshop_buy_panel: class extends self.ISpriteInstance {
  },
  workshop_buy_txt: class extends self.ITextInstance {
  },
  workshop_deep_buy_btn: class extends self.ISpriteInstance {
  },
  workshop_deep_txt: class extends self.ITextInstance {
  },
  workshop_header_txt: class extends self.ITextInstance {
  },
  workshop_main_panel: class extends self.ISpriteInstance {
  },
  workshop_pickaxe_buy_check: class extends self.ISpriteInstance {
  },
  workshop_pickaxe_price_txt: class extends self.ITextInstance {
  },
  workshop_Pickaxe_skin_txt: class extends self.ITextInstance {
  },
  workshop_pickxe_buy_btn: class extends self.ISpriteInstance {
  },
  workshop_shadow: class extends self.ISpriteInstance {
  },
  workshop_upgrade_price_txt: class extends self.ITextInstance {
  },
  yes_btn_lvlup: class extends self.ISpriteInstance {
  },
  yes_btn_sleep: class extends self.ISpriteInstance {
  },
  yes_btn_buy: class extends self.ISpriteInstance {
  },
  yes_btn_workshop: class extends self.ISpriteInstance {
  },
  _1_item_1added_stat_txt: class extends self.ITextInstance {
  },
  _1_item_2added_stat_txt: class extends self.ITextInstance {
  },
  _1_item_price_txt: class extends self.ITextInstance {
  },
  _1_item_stat_bonus_icon: class extends self.ISpriteInstance {
  },
  _1_slot_item: class extends self.ISpriteInstance {
  },
  _1_slot_item_count: class extends self.ITextInstance {
  },
  slot_buy_btn: class extends self.ISpriteInstance {
  },
  _2_item_1added_stat_txt: class extends self.ITextInstance {
  },
  _2_item_2added_stat_txt: class extends self.ITextInstance {
  },
  _2_slot_item: class extends self.ISpriteInstance {
  },
  _2_slot_item_count: class extends self.ITextInstance {
  },
  _3_item_1added_stat_txt: class extends self.ITextInstance {
  },
  _3_item_2added_stat_txt: class extends self.ITextInstance {
  },
  _3_slot_item: class extends self.ISpriteInstance {
  },
  _3_slot_item_count: class extends self.ITextInstance {
  },
  _4_slot_item: class extends self.ISpriteInstance {
  },
  _4_slot_item_count: class extends self.ITextInstance {
  },
  _5_slot_item: class extends self.ISpriteInstance {
  },
  _5_slot_item_count: class extends self.ITextInstance {
  },
  _6_slot_item: class extends self.ISpriteInstance {
  },
  _6_slot_item_count: class extends self.ITextInstance {
  },
  added_stat_txt1: class extends self.ITextInstance {
  },
  added_stat_txt2: class extends self.ITextInstance {
  },
  close_workshop: class extends self.ISpriteInstance {
  },
  debug_energy_btn: class extends self.ISpriteInstance {
  },
  debug_energy_btn_2: class extends self.ISpriteInstance {
  },
  debug_health_btn: class extends self.ISpriteInstance {
  },
  debug_health_btn2: class extends self.ISpriteInstance {
  },
  dont: class extends self.ISpriteInstance {
  },
  energy_count_txt: class extends self.ITextInstance {
  },
  energy_icon: class extends self.ISpriteInstance {
  },
  Explosion: class extends self.ISpriteInstance {
  },
  hapiness_stat_txt: class extends self.ITextInstance {
  },
  health_stat_txt: class extends self.ITextInstance {
  },
  hunger_stat_txt: class extends self.ITextInstance {
  },
  levelup_panel: class extends self.ISpriteInstance {
  },
  LvlupTxt: class extends self.ITextInstance {
  },
  _2_item_price_txt: class extends self.ITextInstance {
  },
  _3_item_price_txt: class extends self.ITextInstance {
  },
  mood_progress_bar_yellow: class extends self.ITiledBackgroundInstance {
  },
  mood_progress_bar_red: class extends self.ITiledBackgroundInstance {
  },
  purity_progress_yellow: class extends self.ITiledBackgroundInstance {
  },
  purity_progress_red: class extends self.ITiledBackgroundInstance {
  },
  health_progress_bar_yellow: class extends self.ITiledBackgroundInstance {
  },
  health_progress_red: class extends self.ITiledBackgroundInstance {
  },
  hunger_progress_yellow: class extends self.ITiledBackgroundInstance {
  },
  hunger_progress_red: class extends self.ITiledBackgroundInstance {
  },
  obj_health_icon_base: class extends self.ISpriteInstance {
  },
  obj_hunger_icon_base: class extends self.ISpriteInstance {
  },
  obj_mood_icon_base: class extends self.ISpriteInstance {
  },
  obj_purity_icon_base: class extends self.ISpriteInstance {
  },
  BlockScreen: class extends self.ISpriteInstance {
  },
  dino: class extends self.ISpriteInstance {
  },
  door_button: class extends self.ISpriteInstance {
  },
  doors: class extends self.ISpriteInstance {
  },
  DoorTxt: class extends self.ITextInstance {
  },
  upgrade_price_icon: class extends self.ISpriteInstance {
  },
  tutorail_shadow: class extends self.ISpriteInstance {
  },
  Coin: class extends self.ISpriteInstance {
  },
  CoinParticles: class extends self.IParticlesInstance {
  },
  BaseReturnTxt: class extends self.ITextInstance {
  },
  Cutscene_txt: class extends self.ITextInstance {
  },
  Debug_Load_txt: class extends self.ITextInstance {
  },
  debugTxt: class extends self.ITextInstance {
  },
  debugTxt2: class extends self.ITextInstance {
  },
  HitExplosion1: class extends self.ISpriteInstance {
  },
  HitExplosion2: class extends self.ISpriteInstance {
  },
  LevelTxt: class extends self.ITextInstance {
  },
  Loading_animation: class extends self.ISpriteInstance {
  },
  LoadingText: class extends self.ITextInstance {
  },
  LoadingBg: class extends self.ISpriteInstance {
  },
  MisiionFrame: class extends self.ISpriteInstance {
  },
  MissionObject: class extends self.ISpriteInstance {
  },
  MissionTxt: class extends self.ITextInstance {
  },
  MissonIcon: class extends self.ISpriteInstance {
  },
  Multiplyer_txt: class extends self.ITextInstance {
  },
  NewFox: class extends self.IHTMLElementInstance {
  },
  StartScreenFox: class extends self.ISpriteInstance {
  },
  RecipeCount_txt: class extends self.ITextInstance {
  },
  redbull: class extends self.ISpriteInstance {
  },
  ShakeButton: class extends self.ISpriteInstance {
  },
  ShakeButtonReward: class extends self.ISpriteInstance {
  },
  ShakeRewardText: class extends self.ITextInstance {
  },
  ShakeRewardTimerTxt: class extends self.ITextInstance {
  },
  skip: class extends self.IButtonInstance {
  },
  skip2: class extends self.IButtonInstance {
  },
  TapFoxZone: class extends self.ISpriteInstance {
  },
  BonusCoin_txt: class extends self.ITextInstance {
  },
  Progress_bar_start_txt: class extends self.ITextInstance {
  },
  Locker_title_txt: class extends self.ITextInstance {
  },
  Locker_count_txt: class extends self.ITextInstance {
  },
  skill_current_baff_txt: class extends self.ITextInstance {
  },
  locker_progress_count_txt: class extends self.ITextInstance {
  },
  Skill_price_bnt_txt: class extends self.ITextInstance {
  },
  skill_level_txt: class extends self.ITextInstance {
  },
  Skill_window_title_txt: class extends self.ITextInstance {
  },
  AutoFarm_bnt: class extends self.ISpriteInstance {
  },
  BonusCoinIcon: class extends self.ISpriteInstance {
  },
  Card: class extends self.ISpriteInstance {
  },
  CardParticlesWin: class extends self.IParticlesInstance {
  },
  debaff_skill_icon: class extends self.ISpriteInstance {
  },
  energy_skill_icon: class extends self.ISpriteInstance {
  },
  happiness_skill_icon: class extends self.ISpriteInstance {
  },
  health_skill_icon: class extends self.ISpriteInstance {
  },
  hunger_skill_icon: class extends self.ISpriteInstance {
  },
  locker_count: class extends self.ISpriteInstance {
  },
  locker_fly_icon: class extends self.ISpriteInstance {
  },
  locker_icon: class extends self.ISpriteInstance {
  },
  locker_progress: class extends self.IWorldInstance {
  },
  locker_progress_icon: class extends self.ISpriteInstance {
  },
  lvl: class extends self.ISpriteInstance {
  },
  power_skill_icon: class extends self.ISpriteInstance {
  },
  Progress_bar_2: class extends self.ISpriteInstance {
  },
  Progress_bar_start: class extends self.ISpriteInstance {
  },
  progress_bar_sublevel_fill: class extends self.IWorldInstance {
  },
  progress_bar_sublevels: class extends self.ISpriteInstance {
  },
  purity_skill_icon: class extends self.ISpriteInstance {
  },
  Recipe_progress_icon: class extends self.ISpriteInstance {
  },
  reward_skill_icon: class extends self.ISpriteInstance {
  },
  skill_buy_btn: class extends self.ISpriteInstance {
  },
  skill_panel: class extends self.ISpriteInstance {
  },
  skill_progressbar_frame: class extends self.ISpriteInstance {
  },
  skill_window_cancel: class extends self.ISpriteInstance {
  },
  SkillBtn: class extends self.ISpriteInstance {
  },
  sleep_skill_icon: class extends self.ISpriteInstance {
  },
  Spin_arrows: class extends self.ISpriteInstance {
  },
  energy_regen_Txt: class extends self.ITextInstance {
  },
  TopRewards_txt_2: class extends self.ITextInstance {
  },
  TopRewards_txt_1: class extends self.ITextInstance {
  },
  TopRewards_btn_txt: class extends self.ITextInstance {
  },
  Autofarm_x_text: class extends self.ITextInstance {
  },
  Autofarm_reward_text: class extends self.ITextInstance {
  },
  Autofarm_mult_text: class extends self.ITextInstance {
  },
  Autofarm_energy_text: class extends self.ITextInstance {
  },
  Autofarm_take_text: class extends self.ITextInstance {
  },
  Autofarm_title_text: class extends self.ITextInstance {
  },
  StartScreenFoxText: class extends self.ISpriteInstance {
  },
  ProjectVersionText: class extends self.ITextInstance {
  },
  LoadingPanel9patch: class extends self.IWorldInstance {
  },
  TutorialMask1: class extends self.ISpriteInstance {
  },
  TutorialMask2: class extends self.ISpriteInstance {
  },
  TutorialPopup: class extends self.ISpriteInstance {
  },
  TutorialTxt: class extends self.ITextInstance {
  },
  TutorialHand: class extends self.ISpriteInstance {
  },
  autofarm_buy_btn: class extends self.ISpriteInstance {
  },
  AutoFarm_frame: class extends self.ISpriteInstance {
  },
  autofarm_close: class extends self.ISpriteInstance {
  },
  autofarm_plus: class extends self.ISpriteInstance {
  },
  autofarm_minus: class extends self.ISpriteInstance {
  },
  TopReward_frame: class extends self.ISpriteInstance {
  },
  TopReward_btn: class extends self.ISpriteInstance {
  },
  TopRewardBadge: class extends self.ISpriteInstance {
  },
  coins_top_fly_icon: class extends self.ISpriteInstance {
  },
  locker_top_fly_icon: class extends self.ISpriteInstance {
  },
  tunnel_autofarm: class extends self.ISpriteInstance {
  },
  ground_autofarm: class extends self.ISpriteInstance {
  },
  autofarm_progress: class extends self.IWorldInstance {
  },
  AutoChestIcon: class extends self.ISpriteInstance {
  },
  chest_btn_icon: class extends self.ISpriteInstance {
  },
  energy_btn_icon: class extends self.ISpriteInstance {
  },
  AutoChest_big_icon: class extends self.ISpriteInstance {
  },
  TempTestSizeFox: class extends self.ISpriteInstance {
  },
  MonsterPowerTypeIcons: class extends self.ISpriteInstance {
  },
  UIHealthPanel: class extends self.ISpriteInstance {
  },
  DarkGradientTexture: class extends self.ISpriteInstance {
  },
  DamageFXIcons: class extends self.ISpriteInstance {
  },
  CharacterShadow: class extends self.ISpriteInstance {
  },
  Sprite3: class extends self.ISpriteInstance {
  },
  ChestProgressBarIcon: class extends self.ISpriteInstance {
  },
  tunnel: class extends self.ISpriteInstance {
  },
  rocks: class extends self.ISpriteInstance {
  },
  JunkFam: class extends self.ISpriteInstance {
  },
  Event_fam: class extends self.ITextInstance {
  },
  Digging: class extends self.ISpriteInstance {
  },
  Event_stats: class extends self.ISpriteInstance {
  },
  Stat_txt: class extends self.ITextInstance {
  },
  EventUI: class extends self.ISpriteInstance {
  },
  Inventory_window: class extends self.ISpriteInstance {
  },
  Inventory_count_text: class extends self.ITextInstance {
  },
  Main_UI_buttons: class extends self.ISpriteInstance {
  },
  ProgressBar: class extends self.ISpriteInstance {
  },
  Shop_Window_Family: class extends self.ISpriteInstance {
  },
  Shop_window_txt_fam: class extends self.ITextInstance {
  },
  Slot_items: class extends self.ISpriteInstance {
  },
  Base_buttons: class extends self.ISpriteInstance {
  },
  Sleep_icons: class extends self.ISpriteInstance {
  },
  Sound_icons: class extends self.ISpriteInstance {
  },
  workshop_main_icons: class extends self.ISpriteInstance {
  },
  workshop_buy_btns: class extends self.ISpriteInstance {
  },
  workshop_txt: class extends self.ITextInstance {
  },
  TapIcons: class extends self.ISpriteInstance {
  },
  Price_txt: class extends self.ITextInstance {
  },
  Base_icons: class extends self.ISpriteInstance {
  },
  Additional_UI: class extends self.ISpriteInstance {
  },
  TutorialImages: class extends self.ISpriteInstance {
  },
  RecipePicsFam: class extends self.ISpriteInstance {
  },
  Skill_window_icons: class extends self.ISpriteInstance {
  },
  Skill_window_txt: class extends self.ITextInstance {
  },
  MainStatSprites: class extends self.ISpriteInstance {
  },
  AutoFarm_fam: class extends self.ISpriteInstance {
  },
  TopRewardsTxts: class extends self.ITextInstance {
  },
  AutoFarm_txt: class extends self.ITextInstance {
  }
};

// file-map:scripts/project/Telegram/telegramAPI.js
function loadTelegramSDK(callback) {
  var script = document.createElement("script");
  script.src = "https://telegram.org/js/telegram-web-app.js";
  script.onload = function() {
    console.log("Telegram Web Apps SDK \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D \u0443\u0441\u043F\u0435\u0448\u043D\u043E");
    if (callback) callback();
  };
  document.head.appendChild(script);
}
function getTelegramUserInfo() {
  if (window.Telegram && window.Telegram.WebApp) {
    const tg = window.Telegram.WebApp;
    const user = tg.initDataUnsafe.user;
    if (user) {
      return {
        id: user.id,
        username: user.username || "",
        userFirstName: user.first_name || "",
        userLastName: user.last_name || ""
      };
    } else {
      console.log("\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0435.");
      return null;
    }
  } else {
    console.log("Telegram Web Apps SDK \u043D\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D \u0438\u043B\u0438 \u043F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u043D\u0435 \u0437\u0430\u043F\u0443\u0449\u0435\u043D\u043E \u0432\u043D\u0443\u0442\u0440\u0438 Telegram.");
    return null;
  }
}

// file-map:scripts/project/Data/playerData.js
var PLAYER_DATA = {
  "name": null,
  "is_dead": null,
  "is_sleeping": null,
  "balance": null,
  "health": null,
  "energy": null,
  "mood": null,
  "hunger": null,
  "purity": null,
  "SubLevel": null,
  "health_max": null,
  "energy_max": null,
  "mood_max": null,
  "hunger_max": null,
  "purity_max": null,
  "CurrentMission": null,
  "Recipe": null,
  "pickaxe_power": null,
  "energy_regeneration": null,
  "hours_offline": null,
  "offline_reward": null,
  "health_buff_lvl": null,
  "energy_buff_lvl": null,
  "mood_buff_lvl": null,
  "hunger_buff_lvl": null,
  "purity_buff_lvl": null,
  "pickaxe_power_buff_lvl": null,
  "sleep_boost_lvl": null,
  "hourly_offline_buff_lvl": null,
  "hourly_loss_stat_buff_lvl": null,
  "aidShopLvl": null,
  "washShopLvl": null,
  "foodShopLvl": null,
  "base_tutorial_completed": null,
  "adventure_tutorial_completed": null,
  "locker_ammount": null,
  "locker_progress": null,
  "spin_cost": null,
  "weekly_fighting_stats": null,
  "weekly_mining_stats": null,
  "weekly_purity_stats": null,
  "weekly_fighting_place": null,
  "weekly_mining_place": null,
  "weekly_purity_place": null,
  "music": null,
  "sound": null
};
var playerData_default = PLAYER_DATA;

// file-map:scripts/project/Data/enemiesData.js
var EnemyTypes = {
  Deadly: 0,
  Hungry: 1,
  Depressive: 2,
  Dirty: 3
};
var enemiesData_default = EnemyTypes;

// file-map:scripts/project/javaScriptInEvents.js
var scriptsInEvents = {
  async Es_dataextension_Event4_Act1(runtime, localVars) {
    const object = JSON.parse(localVars.dictionaryJson);
    const json = JSON.stringify(object.data);
    runtime.setReturnValue(json);
  },
  async Es_dataextension_Event5_Act1(runtime, localVars) {
    runtime.setReturnValue(localVars.value);
  },
  async Es_dataextension_Event6_Act2(runtime, localVars) {
    let object = {
      [localVars.key]: !Number.isNaN(Number(localVars.value)) ? Number(localVars.value) : localVars.value
    };
    runtime.setReturnValue(JSON.stringify(object));
  },
  async Es_telegram_Event4_Act1(runtime, localVars) {
    loadTelegramSDK(function() {
      runtime.callFunction("OnTWALoaded");
    });
  },
  async Es_telegram_Event5_Act1(runtime, localVars) {
    console.warn("Telegram Web Apps SDK \u0443\u0436\u0435 \u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D");
  },
  async Es_telegram_Event6_Act2(runtime, localVars) {
    let userTG = getTelegramUserInfo();
    if (userTG) {
      runtime.globalVars.ID = userTG.id;
    }
  },
  async Es_gameanalytics_Event5_Act9(runtime, localVars) {
    console.log("GA Initialize user id: ", runtime.globalVars.ID);
  },
  async Es_gameanalytics_Event5_Act10(runtime, localVars) {
    GameAnalytics && GameAnalytics("configureUserId", runtime.globalVars.ID);
    GameAnalytics && GameAnalytics("setExternalUserId", runtime.globalVars.ID);
  },
  async Es_gameanalytics_Event5_Act14(runtime, localVars) {
    console.log("GA Initialized");
  },
  async Es_gameanalytics_Event6_Act1(runtime, localVars) {
  },
  async Es_gameanalytics_Event7_Act1(runtime, localVars) {
    console.warn("GameAnalytics \u0443\u0436\u0435 \u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D");
  },
  async Es_general_Event19_Act1(runtime, localVars) {
    localVars.playerDataJJON = JSON.stringify(playerData_default);
  },
  async Es_general_Event30_Act51(runtime, localVars) {
    const params = new URLSearchParams(window.location.search);
    let rawName = params.get("name");
    if (rawName) {
      try {
        rawName = decodeURIComponent(rawName);
      } catch (e) {
        console.warn("Could not decode name, using raw value instead.");
      }
      runtime.globalVars.name = rawName;
    }
  },
  async Es_general_Event36_Act1(runtime, localVars) {
    const fields = {
      "health": runtime.globalVars.Health,
      "energy": runtime.globalVars.Energy,
      "mood": runtime.globalVars.Happiness,
      "hunger": runtime.globalVars.Hunger,
      "purity": runtime.globalVars.Purity,
      "balance": runtime.globalVars.Current_money,
      "is_sleeping": runtime.globalVars.Sleep,
      "is_dead": runtime.globalVars.death,
      "music": runtime.globalVars.music,
      "sound": runtime.globalVars.sound,
      "adventure_tutorial_completed": runtime.globalVars.DiggingTutorial,
      "base_tutorial_completed": runtime.globalVars.BaseTutorial,
      "aidShopLvl": runtime.globalVars.AidShopLvl,
      "washShopLvl": runtime.globalVars.WashShopLvl,
      "foodShopLvl": runtime.globalVars.FoodShopLvl,
      "SubLevel": runtime.globalVars.Level,
      "CurrentMission": runtime.globalVars.CurrentMission,
      "Recipe": runtime.globalVars.Recipe,
      "health_buff_lvl": runtime.globalVars.Lvl_Health,
      "energy_buff_lvl": runtime.globalVars.Lvl_Energy,
      "mood_buff_lvl": runtime.globalVars.Lvl_Happiness,
      "hunger_buff_lvl": runtime.globalVars.Lvl_Hunger,
      "purity_buff_lvl": runtime.globalVars.Lvl_Purity,
      "hourly_offline_buff_lvl": runtime.globalVars.Lvl_Reward,
      "pickaxe_power_buff_lvl": runtime.globalVars.Lvl_Power,
      "sleep_boost_lvl": runtime.globalVars.Lvl_Sleep,
      "hourly_loss_stat_buff_lvl": runtime.globalVars.Lvl_StatDrop,
      "locker_ammount": runtime.globalVars.Lockers,
      "locker_progress": runtime.globalVars.LockerProgresBar,
      "weekly_purity_stats": runtime.globalVars.OverallAddedSTATS,
      "weekly_fighting_place": runtime.globalVars.weekly_fighting_place,
      "weekly_mining_place": runtime.globalVars.weekly_mining_place,
      "weekly_purity_place": runtime.globalVars.weekly_purity_place,
      "weekly_mining_stats": runtime.globalVars.DeepCompleted
    };
    localVars.fields = JSON.stringify(fields);
  },
  async Es_general_Event38_Act1(runtime, localVars) {
    const payload = {
      "records": [
        {
          "id": runtime.globalVars.RecordID,
          "fields": JSON.parse(localVars.fieldsJSON)
        }
      ]
    };
    localVars.payload = JSON.stringify(payload);
  },
  async Es_general_Event39_Act1(runtime, localVars) {
    console.log("PatchToAirtable, fields: ", JSON.parse(localVars.fieldsJSON));
  },
  async Digging_sheet_Event414_Act2(runtime, localVars) {
    console.log("Event button clicked, current deep: ", runtime.globalVars.Deep);
  },
  async Digging_sheet_Event614_Act1(runtime, localVars) {
    runtime.setReturnValue(enemiesData_default[localVars.i_enemyType]);
  },
  async Digging_sheet_Event633_Act6(runtime, localVars) {
    console.log("PreparePlayerAttack");
  },
  async Digging_sheet_Event756_Act12(runtime, localVars) {
    console.log("Call Tutorial, step: ", runtime.globalVars.TutorialStep);
  },
  async Digging_sheet_Event772_Act1(runtime, localVars) {
    console.log("Event button tutorial step: ", runtime.globalVars.TutorialStep);
  },
  async Base_sheet_Event359(runtime, localVars) {
    runtime.globalVars.NowISO = (/* @__PURE__ */ new Date()).toISOString();
  },
  async Dataloader_sheet_Event3_Act1(runtime, localVars) {
    window.Telegram.WebApp.requestFullscreen();
  },
  async Dataloader_sheet_Event8_Act1(runtime, localVars) {
    const payload = {
      "id": parseInt(runtime.globalVars.ID)
    };
    localVars.payload = JSON.stringify(payload);
    console.log("---");
    console.log(JSON.stringify(payload));
  },
  async Es_loading_Event6_Act1(runtime, localVars) {
    window.Telegram.WebApp.expand();
  },
  async Es_dev_Event5_Act1(runtime, localVars) {
    console.log("PLAYER DATA CONST: ", playerData_default);
  },
  async Base_sheet_Event337_Act6(runtime, localVars) {
    console.log("Call Base Tutorial, step: ", runtime.globalVars.BaseTutorialStep);
  }
};
globalThis.C3.JavaScriptInEvents = scriptsInEvents;
/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 3.4.1

Copyright (c) 2015-2021, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
